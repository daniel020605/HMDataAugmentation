[
    {
        "id": 1,
        "pre": "Text('自定义拖出响应，拖拽video')\\n  .draggable(true)\\n  .onDragStart((event) => {\\n    // 处理拖出数据\\n    let video: unifiedDataChannel.Video = new unifiedDataChannel.Video();\\n    video.videoUri = '/resources/rawfile/01.mp4';\\n    let data: unifiedDataChannel.UnifiedData = new unifiedDataChannel.UnifiedData(video);\\n    (event as DragEvent).setData(data);\\n  })",
        "type": "Reference",
        "function_call": "draggable()",
        "function_name": null,
        "parent_text": "默认支持拖出能力的组件，如Search、Hyperlink等，在拖出时会使用组件的默认拖出响应。其中Search组件默认拖拽内容为选中的文字，Hyperlink组件默认拖拽内容为超链接地址。如果想自定义组件的拖拽内容，需要在组件的onDragStart()接口中将自定义数据封装成UnifiedData数据对象，通过DragEvent的setData()接口设置拖出数据。对于其他非默认组件或自定义组件，如果想实现其拖出功能，需要将组件的draggable()属性设置为true，并自定义组件的拖拽内容。以Text组件为例，示例代码如下： ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragstart\\\"' target='\\\"_blank\\\"'>默认支持拖出能力的组件</a>，如<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-search\\\"' target='\\\"_blank\\\"'>Search</a>、<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-hyperlink\\\"' target='\\\"_blank\\\"'>Hyperlink</a>等，在拖出时会使用组件的默认拖出响应。其中<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-search\\\"' target='\\\"_blank\\\"'>Search</a>组件默认拖拽内容为选中的文字，<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-hyperlink\\\"' target='\\\"_blank\\\"'>Hyperlink</a>组件默认拖拽内容为超链接地址。如果想自定义组件的拖拽内容，需要在组件的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragstart\\\"' target='\\\"_blank\\\"'>onDragStart()</a>接口中将自定义数据封装成<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-data-unifieddatachannel#unifieddata\\\"' target='\\\"_blank\\\"'>UnifiedData</a>数据对象，通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#dragevent7\\\"' target='\\\"_blank\\\"'>DragEvent</a>的setData()接口设置拖出数据。对于其他非默认组件或自定义组件，如果想实现其拖出功能，需要将组件的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-drag-drop#draggable\\\"' target='\\\"_blank\\\"'>draggable()</a>属性设置为true，并自定义组件的拖拽内容。以Text组件为例，示例代码如下： </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-drag-framework.html"
    },
    {
        "id": 2,
        "pre": "Text('自定义拖拽背板图')\\n  .draggable(true)\\n  .onDragStart(() => {\\n    // 返回自定义背板图\\n    let dragItemInfo: DragItemInfo = {\\n      pixelMap: this.pixelMap,\\n      builder: () => { this.pixelMapBuilder() },\\n      extraInfo: \\\"this is extraInfo\\\",\\n    };\\n    return dragItemInfo;\\n  })",
        "type": "Reference",
        "function_call": "onDragStart()",
        "function_name": null,
        "parent_text": "通过标准手势发起拖拽后，系统会默认将组件本身的截图作为拖拽移动中的背板图。如果想自定义拖拽背板图，需要在组件的onDragStart()接口中通过回调的CustomBuilder或DragItemInfo进行设置。以Text组件为例，示例代码如下： ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>通过标准手势发起拖拽后，系统会默认将组件本身的截图作为拖拽移动中的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-drag-event#拖拽背板图\\\"' target='\\\"_blank\\\"'>背板图</a>。如果想自定义拖拽背板图，需要在组件的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragstart\\\"' target='\\\"_blank\\\"'>onDragStart()</a>接口中通过回调的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-types#custombuilder8\\\"' target='\\\"_blank\\\"'>CustomBuilder</a>或<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#dragiteminfo说明\\\"' target='\\\"_blank\\\"'>DragItemInfo</a>进行设置。以Text组件为例，示例代码如下： </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-drag-framework.html"
    },
    {
        "id": 3,
        "pre": "Text(this.targetText)\\n  .allowDrop([uniformTypeDescriptor.UniformDataType.PLAIN_TEXT])\\n  .onDrop((event: DragEvent) => {\\n    // 处理拖入数据\\n    let records: Array<unifiedDataChannel.UnifiedRecord> = event.getData().getRecords();\\n    let plainText: unifiedDataChannel.PlainText = records[0] as unifiedDataChannel.PlainText;\\n    this.targetText = plainText.textContent;\\n   })",
        "type": "Reference",
        "function_call": "onDrop()",
        "function_name": "[h2]释放拖拽",
        "parent_text": "[h2]释放拖拽默认支持拖入能力的组件，如Search等，将目标拖入组件区域内会使用默认拖入响应。如果想自定义组件的拖入响应，需要将组件的allowDrop()属性设置为允许拖入的数据类型，并在其onDrop()接口中通过DragEvent的getData()接口获取拖入数据后，对数据内容进行相应处理。  可以在onDrop()中处理接收到的数据，例如将图片识别为文字以显示在只支持文字的组件上，详情见AI识别拖拽内容。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section91043366223\\\"'><a name='\\\"section91043366223\\\"'></a><a name='\\\"section91043366223\\\"'></a><h4>[h2]释放拖拽</h4><p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondragstart\\\"' target='\\\"_blank\\\"'>默认支持拖入能力的组件</a>，如<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-search\\\"' target='\\\"_blank\\\"'>Search</a>等，将目标拖入组件区域内会使用默认拖入响应。如果想自定义组件的拖入响应，需要将组件的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-drag-drop#allowdrop\\\"' target='\\\"_blank\\\"'>allowDrop()</a>属性设置为允许拖入的数据类型，并在其<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondrop\\\"' target='\\\"_blank\\\"'>onDrop()</a>接口中通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#dragevent7\\\"' target='\\\"_blank\\\"'>DragEvent</a>的getData()接口获取拖入数据后，对数据内容进行相应处理。</p>  <p>可以在<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-drag-drop#ondrop\\\"' target='\\\"_blank\\\"'>onDrop()</a>中处理接收到的数据，例如将图片识别为文字以显示在只支持文字的组件上，详情见<a href='\\\"#section4125035104613\\\"'>AI识别拖拽内容</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-drag-framework.html"
    },
    {
        "id": 4,
        "pre": "// src/main/ets/pages/background/Background.ets\\n@Builder\\npixelMapBuilder() {\\n  Column() {\\n    Text($r('app.string.background_content'))\\n      .fontSize('16fp')\\n      .fontColor(Color.Black)\\n      .margin({\\n        left: '16vp',\\n        right: '16vp',\\n        top: '8vp',\\n        bottom: '8vp'\\n      })\\n  }\\n  .backgroundColor(Color.White)\\n  .borderRadius(18)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "创建自定义组件。 ",
        "import_module": null,
        "parent": "<li>创建自定义组件。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-drag-framework.html"
    },
    {
        "id": 5,
        "pre": "// src/main/ets/pages/airecognition/AIRecognition.ets\\nColumn() {\\n  Text(this.textContent)\\n    // ...\\n}\\n.allowDrop([uniformTypeDescriptor.UniformDataType.IMAGE])",
        "type": "Reference",
        "function_call": "在拖拽释放区域的allowDrop()",
        "function_name": null,
        "parent_text": "在拖拽释放区域的allowDrop()接口中设置允许拖入的数据类型为uniformTypeDescriptor.UniformDataType.IMAGE。 ",
        "import_module": null,
        "parent": "<li>在拖拽释放区域的allowDrop()接口中设置允许拖入的数据类型为<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-data-uniformtypedescriptor#uniformdatatype\\\"' target='\\\"_blank\\\"'>uniformTypeDescriptor.UniformDataType.IMAGE</a>。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-drag-framework.html"
    },
    {
        "id": 6,
        "pre": "{\\n  \\\"module\\\": { \\n    // ...\\n    \\\"compressNativeLibs\\\": true // 标识libs库以压缩存储方式打包\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]配置so压缩选项",
        "parent_text": "[h2]配置so压缩选项当前DevEco Studio默认打包应用时不压缩so库文件，配置so压缩选项后，DevEco Studio会将so库文件以压缩形式打包到包中，从而减小应用包大小。 配置方法 修改应用模块配置文件module.json5中的compressNativeLibs字段，将值配置为true，重新编译、打包应用。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section15826132851819\\\"'><a name='\\\"section15826132851819\\\"'></a><a name='\\\"section15826132851819\\\"'></a><h4>[h2]配置so压缩选项</h4><p>当前DevEco Studio默认打包应用时不压缩so库文件，配置so压缩选项后，DevEco Studio会将so库文件以压缩形式打包到包中，从而减小应用包大小。</p> <p><strong>配置方法</strong></p> <p>修改应用模块配置文件module.json5中的compressNativeLibs字段，将值配置为true，重新编译、打包应用。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-decrease_pakage_size.html"
    },
    {
        "id": 7,
        "pre": "target_link_libraries(entry PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/thirdparty/xxx/${OHOS_ARCH}/lib/libxxx.a)",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "配置静态库链接。 ",
        "import_module": null,
        "parent": "<li>配置静态库链接。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lycium-adapts-to-harmonyos.html"
    },
    {
        "id": 8,
        "pre": "// TableAdaptiveExtensionIndex.ets\\nRow() {\\n  Column() {\\n    ForEach(ListDataConstants.INDICATOR_NAME_COLUMN, (item: string, index: number) => {\\n      // ...\\n    }, (item: string, index: number) => index + JSON.stringify(item))\\n  }\\n  .alignItems(HorizontalAlign.Start)\\n\\n  Blank()\\n\\n  Column() {\\n    ForEach(ListDataConstants.STOCK_INDEX_DATA1, (item: string, index: number) => {\\n      // ...\\n    }, (item: string, index: number) => index + JSON.stringify(item))\\n  }\\n  .width($r('app.float.stock_data_width'))\\n  .alignItems(HorizontalAlign.End)\\n\\n  Blank()\\n\\n  Column() {\\n    ForEach(ListDataConstants.STOCK_INDEX_DATA2, (item: string, index: number) => {\\n      // ...\\n    }, (item: string, index: number) => index + JSON.stringify(item))\\n  }\\n  .width($r('app.float.stock_data_width'))\\n  .alignItems(HorizontalAlign.End)\\n\\n  Blank()\\n\\n  Column() {\\n    ForEach(ListDataConstants.STOCK_INDEX_DATA3, (item: string, index: number) => {\\n      // ...\\n    }, (item: string, index: number) => index + JSON.stringify(item))\\n  }\\n  .width($r('app.float.stock_data_width'))\\n  .alignItems(HorizontalAlign.End)\\n}\\n.width(CommonConstants.FULL_WIDTH_PERCENT)\\n// ...",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "核心指标使用Blank组件作为数据各列的空白空间，同时给各列数据及表格整体设置固定宽度，可实现数据各列的空白空间自适应拉伸。 对不同列设置不同的alignItems，支持不同列设置不同对齐方式。  ",
        "import_module": null,
        "parent": "<li>核心指标<p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-blank\\\"' target='\\\"_blank\\\"'>Blank组件</a>作为数据各列的空白空间，同时给各列数据及表格整体设置固定宽度，可实现数据各列的空白空间自适应拉伸。</p> <p>对不同列设置不同的alignItems，支持不同列设置不同对齐方式。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-ticket-class.html"
    },
    {
        "id": 9,
        "pre": "// DoubleTabAdaptiveCenteringIndex.ets\\nRow() {\\n  Column() {\\n    List({\\n      space: new BreakpointType(CommonConstants.DOUBLE_TAB_PADDING_SM, CommonConstants.DOUBLE_TAB_PADDING_MD1,\\n        CommonConstants.DOUBLE_TAB_PADDING_LG1).getValue(this.breakPoint)\\n    }) {\\n      ForEach(ListDataConstants.STOCK_OPTIONS_LIST1, (item: string, index: number) => {\\n        ListItem() {\\n          Column() {\\n            Text(item)\\n              // ...\\n          }\\n        }\\n        // ...\\n      }, (item: string, index: number) => index + JSON.stringify(item))\\n\\n      ListItem() {\\n        Image($r('app.media.ic_public_more'))\\n          // ...\\n      }\\n      // ...\\n    }\\n    .scrollBar(BarState.Off)\\n    .listDirection(Axis.Horizontal)\\n  }\\n  .width($r('app.float.width_296'))\\n  // ...\\n}\\n// ...",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "股票双页签借助栅格布局监听断点变化，改变List组件下子组件的间隔宽度，同时给List组件设置固定宽度，当List组件下的tab内容超过设定宽度时隐藏部分tab，延伸显示更多。  ",
        "import_module": null,
        "parent": "<li>股票双页签<p>借助<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-grid-layout\\\"' target='\\\"_blank\\\"'>栅格布局</a>监听断点变化，改变<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list\\\"' target='\\\"_blank\\\"'>List组件</a>下子组件的间隔宽度，同时给List组件设置固定宽度，当List组件下的tab内容超过设定宽度时隐藏部分tab，延伸显示更多。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-ticket-class.html"
    },
    {
        "id": 10,
        "pre": "// the Load task\\nvoid AddLoads(int n) {\\n    if (!n) {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"invalid input.\\\");\\n        return;\\n    }\\n\\n    // set QoS level\\n    int ret = OH_QoS_SetThreadQoS(QoS_Level::QOS_BACKGROUND);\\n    if (ret) {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"set load thread QoS level failed.\\\");\\n        return;\\n    }\\n\\n    // bind cpu\\n    cpu_set_t mask;\\n    CPU_SET(*g_affinity, &mask);\\n    if (sched_setaffinity(0, sizeof(mask), &mask) != 0) {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"bind load thread failed\\\");\\n        return;\\n    }\\n    // Perform load calculation\\n    for (int i = 0; i < BOUND; i++) {\\n        for (int j = 0; j < BOUND; j++) {\\n            int x = (i + j) - n;\\n            printf(\\\"%d\\\", x);\\n        }\\n    }\\n    // reset load flag\\n    g_addLoad = false;\\n}",
        "type": "Reference",
        "function_call": "join()",
        "function_name": "场景示例",
        "parent_text": "场景示例下面是一个在高负载情况下，配置了不同QoS等级的两个关键线程完成相同计算任务所花时间的对比图，从界面的运行结果可以看到在高负载情况下，配置了高优先级的线程执行完计算所花的时间更少一些。  具体实现步骤如下： 1、实现负载线程所要完成的任务。  2、实现高、低QoS等级计算线程（关键线程）所要完成的计算任务（斐波那契数列计算）。先通过 OH_QoS_SetThreadQoS 接口设置当前线程的QoS等级，再执行 DoFib() 斐波那契数列计算。 // Perform Fibonacci sequence calculations\\nlong long DoFib(double n) {\\n    if (n == ONE) {\\n        return ONE;\\n    }\\n    if (n == TWO) {\\n        return TWO;\\n    }\\n    return DoFib(n - ONE) + DoFib(n - TWO);\\n}\\n\\nvoid SetQoS(QoS_Level level) {\\n    // set QoS level\\n    int ret = OH_QoS_SetThreadQoS(level);\\n    if (!ret) {\\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"set qos level success.\\\");\\n        //  query qos level\\n        QoS_Level queryLevel = QOS_DEFAULT;\\n        ret = OH_QoS_GetThreadQoS(&queryLevel);\\n        if (!ret) {\\n            OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"the qos level of current thread : %{public}d\\\",\\n                         queryLevel);\\n        } else {\\n            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"get qos level failed.\\\");\\n            return;\\n        }\\n    } else {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"get level qos failed!\\\");\\n        return;\\n    }\\n\\n    // bind cpu\\n    cpu_set_t mask;\\n    CPU_SET(*g_affinity, &mask);\\n    if (sched_setaffinity(0, sizeof(mask), &mask) != 0) {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"bind qos thread failed\\\");\\n        return;\\n    }\\n    auto startTime = std::chrono::system_clock::now();\\n    // Execute computational tasks\\n    long long res = DoFib(DEPTH);\\n    auto endTime = std::chrono::system_clock::now();\\n    g_durationTime = std::chrono::duration<double, std::milli>(endTime - startTime).count();\\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"calculate res is: %{public}llu\\\", res);\\n\\n    // Reset QoS level\\n    ret = OH_QoS_ResetThreadQoS();\\n    if (!ret) {\\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"reset qos level success.\\\");\\n    } else {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"reset qos level failed!\\\");\\n        return;\\n    }\\n\\n    // after reset QoS, query QoS again will fail\\n    QoS_Level queryLevelTwo;\\n    ret = OH_QoS_GetThreadQoS(&queryLevelTwo);\\n    if (!ret) {\\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"the qos level after: %{public}d\\\", queryLevelTwo);\\n        return;\\n    } else {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"query qos level failed after reset.\\\");\\n        return;\\n    }\\n} 3、然后分别将计算线程（关键线程）设置低、高QoS等级来对比两者在相同的高负载情况下完成相同层级的斐波那契数列计算所花时间。 给计算线程配置低QoS等级 static napi_value lowQoSCalculate(napi_env env, napi_callback_info info) {\\n    g_durationTime = 0;\\n    // Simulate system load\\n    if (!g_addLoad) {\\n        std::vector<std::thread> loadThreads;\\n        for (int i = 0; i < TASKS; i++) {\\n            // Activate threads to execute load tasks\\n            loadThreads.emplace_back(std::thread(AddLoads, TASKS));\\n            loadThreads[i].detach();\\n        }\\n        g_addLoad = true;\\n    }\\n\\n    // set QOS_BACKGROUND level\\n    QoS_Level level = QoS_Level::QOS_BACKGROUND;\\n    std::thread task(SetQoS, level);\\n    task.join();\\n\\n    // Return calculation time\\n    napi_value res;\\n    napi_create_double(env, g_durationTime, &res);\\n    return res;\\n} 计算线程（线程id：39260）设置低QoS等级trace图：  如上图所示，计算线程执行完计算任务耗时726.8毫秒。 给计算线程配置高QoS等级 static napi_value highQoSCalculate(napi_env env, napi_callback_info info) {\\n    g_durationTime = 0;\\n    // Simulate system load\\n    if (!g_addLoad) {\\n        std::vector<std::thread> loadThreads;\\n        for (int i = 0; i < TASKS; i++) {\\n            // Activate threads to execute load tasks\\n            loadThreads.emplace_back(std::thread(AddLoads, TASKS));\\n            loadThreads[i].detach();\\n        }\\n        g_addLoad = true;\\n    }\\n    // set QOS_USER_INTERACTIVE level\\n    QoS_Level level = QoS_Level::QOS_USER_INTERACTIVE;\\n    std::thread task(SetQoS, level);\\n    task.join();\\n\\n    // Return calculation time\\n    napi_value res;\\n    napi_create_double(env, g_durationTime, &res);\\n    return res;\\n} 计算线程（线程id：39204）设置高QoS等级trace图：  如上图所示，计算线程执行完计算任务耗时323.9毫秒。  该示例只在高负载压力下有效。 在低负载情况下，由于系统资源相对充足，即使不进行特别的优先级设置，大多数线程也能够得到足够的cpu时间来完成任务，因而效果并不明显。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section119mcpsimp\\\"'><a name='\\\"section119mcpsimp\\\"'></a><a name='\\\"section119mcpsimp\\\"'></a><h4>场景示例</h4><p>下面是一个在高负载情况下，配置了不同QoS等级的两个关键线程完成相同计算任务所花时间的对比图，从界面的运行结果可以看到在高负载情况下，配置了高优先级的线程执行完计算所花的时间更少一些。</p> <p><span><img originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161153.30563573907297595329037021242150:50001231000000:2800:54DF9C5B6D6409E2BE38CD3D3A318D25B6322B1E70FDA22926D1C390B106D828.gif\\\"'/></span></p> <p>具体实现步骤如下：</p> <p>1、实现负载线程所要完成的任务。</p>  <p>2、实现高、低QoS等级计算线程（关键线程）所要完成的计算任务（斐波那契数列计算）。先通过 <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/qos-guidelines\\\"' target='\\\"_blank\\\"'>OH_QoS_SetThreadQoS</a> 接口设置当前线程的QoS等级，再执行 DoFib() 斐波那契数列计算。</p> <pre class='\\\"screen\\\"'>// Perform Fibonacci sequence calculations\\nlong long DoFib(double n) {\\n    if (n == ONE) {\\n        return ONE;\\n    }\\n    if (n == TWO) {\\n        return TWO;\\n    }\\n    return DoFib(n - ONE) + DoFib(n - TWO);\\n}\\n\\nvoid SetQoS(QoS_Level level) {\\n    // set QoS level\\n    int ret = OH_QoS_SetThreadQoS(level);\\n    if (!ret) {\\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"set qos level success.\\\");\\n        //  query qos level\\n        QoS_Level queryLevel = QOS_DEFAULT;\\n        ret = OH_QoS_GetThreadQoS(&amp;queryLevel);\\n        if (!ret) {\\n            OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"the qos level of current thread : %{public}d\\\",\\n                         queryLevel);\\n        } else {\\n            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"get qos level failed.\\\");\\n            return;\\n        }\\n    } else {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"get level qos failed!\\\");\\n        return;\\n    }\\n\\n    // bind cpu\\n    cpu_set_t mask;\\n    CPU_SET(*g_affinity, &amp;mask);\\n    if (sched_setaffinity(0, sizeof(mask), &amp;mask) != 0) {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"bind qos thread failed\\\");\\n        return;\\n    }\\n    auto startTime = std::chrono::system_clock::now();\\n    // Execute computational tasks\\n    long long res = DoFib(DEPTH);\\n    auto endTime = std::chrono::system_clock::now();\\n    g_durationTime = std::chrono::duration&lt;double, std::milli&gt;(endTime - startTime).count();\\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"calculate res is: %{public}llu\\\", res);\\n\\n    // Reset QoS level\\n    ret = OH_QoS_ResetThreadQoS();\\n    if (!ret) {\\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"reset qos level success.\\\");\\n    } else {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"reset qos level failed!\\\");\\n        return;\\n    }\\n\\n    // after reset QoS, query QoS again will fail\\n    QoS_Level queryLevelTwo;\\n    ret = OH_QoS_GetThreadQoS(&amp;queryLevelTwo);\\n    if (!ret) {\\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"the qos level after: %{public}d\\\", queryLevelTwo);\\n        return;\\n    } else {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"QoS\\\", \\\"query qos level failed after reset.\\\");\\n        return;\\n    }\\n}</pre> <p>3、然后分别将计算线程（关键线程）设置低、高QoS等级来对比两者在相同的高负载情况下完成相同层级的斐波那契数列计算所花时间。</p> <ul><li><strong>给计算线程配置低QoS等级</strong></li></ul> <pre class='\\\"screen\\\"'>static napi_value lowQoSCalculate(napi_env env, napi_callback_info info) {\\n    g_durationTime = 0;\\n    // Simulate system load\\n    if (!g_addLoad) {\\n        std::vector&lt;std::thread&gt; loadThreads;\\n        for (int i = 0; i &lt; TASKS; i++) {\\n            // Activate threads to execute load tasks\\n            loadThreads.emplace_back(std::thread(AddLoads, TASKS));\\n            loadThreads[i].detach();\\n        }\\n        g_addLoad = true;\\n    }\\n\\n    // set QOS_BACKGROUND level\\n    QoS_Level level = QoS_Level::QOS_BACKGROUND;\\n    std::thread task(SetQoS, level);\\n    task.join();\\n\\n    // Return calculation time\\n    napi_value res;\\n    napi_create_double(env, g_durationTime, &amp;res);\\n    return res;\\n}</pre> <p>计算线程（线程id：39260）设置低QoS等级trace图：</p> <p><span><img height='\\\"132.66750000000002\\\"' originheight='\\\"321\\\"' originwidth='\\\"1263\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161153.92943286982990163072542160230922:50001231000000:2800:D54D77E44A87A14E6B810E49F1C628851272BDB6F3667693BA5F74A93E522686.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></p> <p>如上图所示，计算线程执行完计算任务耗时726.8毫秒。</p> <ul><li><strong>给计算线程配置高QoS等级</strong></li></ul> <pre class='\\\"screen\\\"'>static napi_value highQoSCalculate(napi_env env, napi_callback_info info) {\\n    g_durationTime = 0;\\n    // Simulate system load\\n    if (!g_addLoad) {\\n        std::vector&lt;std::thread&gt; loadThreads;\\n        for (int i = 0; i &lt; TASKS; i++) {\\n            // Activate threads to execute load tasks\\n            loadThreads.emplace_back(std::thread(AddLoads, TASKS));\\n            loadThreads[i].detach();\\n        }\\n        g_addLoad = true;\\n    }\\n    // set QOS_USER_INTERACTIVE level\\n    QoS_Level level = QoS_Level::QOS_USER_INTERACTIVE;\\n    std::thread task(SetQoS, level);\\n    task.join();\\n\\n    // Return calculation time\\n    napi_value res;\\n    napi_create_double(env, g_durationTime, &amp;res);\\n    return res;\\n}</pre> <p>计算线程（线程id：39204）设置高QoS等级trace图：</p> <p><span><img height='\\\"138.6525\\\"' originheight='\\\"275\\\"' originwidth='\\\"1036\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161153.17334616994691878857585166816817:50001231000000:2800:4BE5EC78D4AE04342A8D16E66BA7FA2463ADF8DBDFC9E0BD40E2422B0EAFD99A.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></p> <p>如上图所示，计算线程执行完计算任务耗时323.9毫秒。</p> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161153.91102915243845191174934165889705:50001231000000:2800:6A0BE950B755B36852A8A4EDDCD8BCFA91BE2E52157F0FCE860A1CED707806B3.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>该示例只在高负载压力下有效。</p> <p>在低负载情况下，由于系统资源相对充足，即使不进行特别的优先级设置，大多数线程也能够得到足够的cpu时间来完成任务，因而效果并不明显。</p> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-thread-priority-setting.html"
    },
    {
        "id": 11,
        "pre": "{\\n  \\\"module\\\": {\\n    // ...\\n    \\\"abilities\\\": [\\n      {\\n        \\\"name\\\": \\\"EntryAbility\\\",\\n        // ...\\n        \\\"orientation\\\": \\\"portrait\\\"\\n      }\\n    ]\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]配置module.json5的orientation字段",
        "parent_text": "[h2]配置module.json5的orientation字段此字段配置的是应用启动时的窗口显示状态，对于开屏时就需要以默认的横屏或者竖屏方式显示，需要在此字段进行相应的配置：  其支持的参数可以参考module.json5配置项中orientation字段相关配置的orientation字段说明： 根据应用默认的旋转行为进行相应的配置： 如果应用是竖屏应用，建议配置portrait为默认旋转策略。如果应用是横屏应用，例如游戏类应用，进入游戏时，默认就是横屏，此时有两种情况：一、仅支持横屏，建议配置landscape为默认旋转策略。 二、支持在横屏和反向横屏中切换，建议设置为auto_rotation_landscape。 如果应用为可旋转应用，建议应用配置auto_rotation_restricted为默认旋转策略。如果一个应用，在直板机和折叠机折叠态是竖屏应用，在平板和折叠机展开态默认是可旋转应用，推荐配置follow_desktop为默认旋转策略。  对于需要通过控制中心进行旋转锁定控制的，可以选择字段后方带有restricted字段的旋转策略，此字段表示旋转行为受到控制中心按钮控制，开关打开情况下，不随设备方向旋转，关闭情况下，则会发生跟随设备旋转。  以如下文件管理应用为例，在系统关闭了旋转锁定后，应用的页面都会随着手机旋转而发生展示上的切换，而打开时则不会发生旋转行为，此时就需要配置为auto_rotation_restricted。 图2 应用随系统旋转切换横竖屏 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1188593118171\\\"'><a name='\\\"section1188593118171\\\"'></a><a name='\\\"section1188593118171\\\"'></a><h4>[h2]配置module.json5的orientation字段</h4><p>此字段配置的是应用启动时的窗口显示状态，对于开屏时就需要以默认的横屏或者竖屏方式显示，需要在此字段进行相应的配置：</p>  <p>其支持的参数可以参考module.json5配置项中<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/module-configuration-file#abilities标签\\\"' target='\\\"_blank\\\"'>orientation字段相关配置</a>的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#orientation9\\\"' target='\\\"_blank\\\"'>orientation字段</a>说明：</p> <p>根据应用默认的旋转行为进行相应的配置：</p> <ul><li>如果应用是竖屏应用，建议配置portrait为默认旋转策略。</li><li>如果应用是横屏应用，例如游戏类应用，进入游戏时，默认就是横屏，此时有两种情况：<p>一、仅支持横屏，建议配置landscape为默认旋转策略。</p> <p>二、支持在横屏和反向横屏中切换，建议设置为auto_rotation_landscape。</p> </li><li>如果应用为可旋转应用，建议应用配置auto_rotation_restricted为默认旋转策略。</li><li>如果一个应用，在直板机和折叠机折叠态是竖屏应用，在平板和折叠机展开态默认是可旋转应用，推荐配置follow_desktop为默认旋转策略。</li></ul> <div class='\\\"notice\\\"'><span class='\\\"noticetitle\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161121.54314861039182049910664973681681:50001231000000:2800:CFA6832C5F5387F314CFAA76BEBA4515E3DEBF30109EADC26CC5FCCE9D715BC0.png\\\"'/> </span><div class='\\\"noticebody\\\"'><p>对于需要通过控制中心进行旋转锁定控制的，可以选择字段后方带有restricted字段的旋转策略，此字段表示旋转行为受到控制中心按钮控制，开关打开情况下，不随设备方向旋转，关闭情况下，则会发生跟随设备旋转。</p> </div></div> <p>以如下文件管理应用为例，在系统关闭了旋转锁定后，应用的页面都会随着手机旋转而发生展示上的切换，而打开时则不会发生旋转行为，此时就需要配置为auto_rotation_restricted。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图2 </b>应用随系统旋转切换横竖屏</span><br/><span><img height='\\\"294.2625\\\"' originheight='\\\"2160\\\"' originwidth='\\\"3840\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161121.79176597097331106266511798164378:50001231000000:2800:3BBC77737DA41C77EC25DC702C84041F79D09788CC84D0A1BDCCFD0551805BAE.jpg\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-landscape-and-portrait-development.html"
    },
    {
        "id": 12,
        "pre": "setOrientation(orientation: number) {\\n  this.windowClass.setPreferredOrientation(orientation).then(() => {\\n    console.info('setWindowOrientation: ' + orientation + ' Succeeded.');\\n  }).catch((err: BusinessError) => {\\n    console.info('setWindowOrientation: ' + orientation + ' Failed. Cause: ' + JSON.stringify(err));\\n  });\\n}",
        "type": "Reference",
        "function_call": "getFoldStatus()",
        "function_name": "[h2]设置窗口的旋转策略",
        "parent_text": "[h2]设置窗口的旋转策略首先需要对应用启动时的旋转策略进行设置，具体可以参考配置module.json5的Orientation字段，这里我们以实现了一多开发为例，满足直板机和平板设备不同的策略，设置为follow_desktop，这个字段主要解决在不同设备上默认旋转策略不同的问题。 在具体需要实现横竖屏切换的页面上，例如视频播放页面支持横屏，但是首页的内容是支持仅竖屏的，那么就需要在进入对应的页面时，采用window窗口提供的设置窗口方向的能力，通过setPreferredOrientation将窗口显示的方向修改为横屏、竖屏的状态。在使用时，需根据应用自身的旋转策略选择相应的参数，可以封装如下方法，进行旋转策略的设置。 具体如下：通过getContext拿到对应的UIAbilityContext，并通过context拿到对应的windowStage实例，然后通过windowStage.getMainWindowSync同步方法拿到对应的窗口实例win，然后调用setPreferredOrientation方法设置窗口方向。  以视频播放为例，不仅需要可以通过系统控制横竖屏，也支持用户在系统锁定旋转的情况下，手动设置横屏状态，即需要满足以下条件： 1、应用跟随传感器旋转。 2、受到控制中心的旋转锁定按钮控制。 3、支持用户使用应用时，在页面中临时调用设置方向能力，如点击全屏按钮进行切换。 要实现以上效果，可以使用窗口的能力设置orientation的枚举类型进行相应的旋转，由于要提供临时设置方向的能力，用户在手动点击全屏按钮时，相当于需要手动触发横竖屏切换，如果此时关闭了旋转锁定，那么窗口需要能够跟随传感器一起发生旋转，所以可以使用以下枚举中的能力，临时调用旋转，并让其后续也能支持跟随传感器。 表1 orientation部分参数列举orientation枚举值  枚举数值  效果描述    USER_ROTATION_PORTRAIT  13  调用时临时旋转到竖屏，之后跟随传感器自动旋转，受控制中心的旋转开关控制，且可旋转方向受系统判定。   USER_ROTATION_LANDSCAPE  14  调用时临时旋转到横屏，之后跟随传感器自动旋转，受控制中心的旋转开关控制，且可旋转方向受系统判定。     然后来分析旋转方向：对于视频播放的应用，一般旋转方向不会旋转到反向竖屏（由UX需求决定），即只旋转到竖屏、横屏和反向横屏。并且用户在使用时，点击切换按钮时，根据用户习惯，一般默认是旋转到横屏状态，然后支持跟随传感器旋转到反向横屏。 图4 窗口旋转状态示意图 在需要用户点击的地方，需要根据进入全屏和退出全屏分别执行相应的逻辑，需要使用的方向状态如下： 设置为横屏时，对应窗口方向为横屏状态：this.setOrientation(window.Orientation.USER_ROTATION_LANDSCAPE)，例如进入播放页时，进行竖屏 -> 横屏切换; Image($r('app.media.icon_zoom_in'))\\n  // ...\\n  .onClick(() => {\\n    if (display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_EXPANDED || display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_HALF_FOLDED) {\\n      this.isLandscape = true;\\n    } else {\\n      this.setOrientation(window.Orientation.USER_ROTATION_LANDSCAPE);\\n    }\\n  }) 设置为竖屏时，对应窗口方向为竖屏状态：this.setOrientation(window.Orientation.USER_ROTATION_PORTRAIT)，例如在返回竖屏状态时，进行横屏 -> 竖屏切换; Image($r('app.media.icon_back'))\\n  // ...\\n  .onClick(() => {\\n    // ...\\n      this.setOrientation(window.Orientation.USER_ROTATION_PORTRAIT);\\n      // ...\\n  })  需要注意的是，由于setPreferredOrientation方法调用改变的是窗口的显示方向，所以如果在进入视频播放页时，手动调用了旋转到横屏，那么在退出时也需要手动调用该接口，使窗口回到之前的竖屏状态。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section58861731201715\\\"'><a name='\\\"section58861731201715\\\"'></a><a name='\\\"section58861731201715\\\"'></a><h4>[h2]设置窗口的旋转策略</h4><p>首先需要对应用启动时的旋转策略进行设置，具体可以参考<a href='\\\"#section1188593118171\\\"'>配置module.json5的Orientation字段</a>，这里我们以实现了一多开发为例，满足直板机和平板设备不同的策略，设置为follow_desktop，这个字段主要解决在不同设备上默认旋转策略不同的问题。</p> <p>在具体需要实现横竖屏切换的页面上，例如视频播放页面支持横屏，但是首页的内容是支持仅竖屏的，那么就需要在进入对应的页面时，采用window窗口提供的设置窗口方向的能力，通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#setpreferredorientation9-1\\\"' target='\\\"_blank\\\"'>setPreferredOrientation</a>将窗口显示的方向修改为横屏、竖屏的状态。在使用时，需根据应用自身的旋转策略选择相应的参数，可以封装如下方法，进行旋转策略的设置。</p> <p>具体如下：通过getContext拿到对应的UIAbilityContext，并通过context拿到对应的windowStage实例，然后通过windowStage.getMainWindowSync同步方法拿到对应的窗口实例win，然后调用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#setpreferredorientation9-1\\\"' target='\\\"_blank\\\"'>setPreferredOrientation</a>方法设置窗口方向。</p>  <p>以视频播放为例，不仅需要可以通过系统控制横竖屏，也支持用户在系统锁定旋转的情况下，手动设置横屏状态，即需要满足以下条件：</p> <p><strong>1、应用跟随传感器旋转。</strong></p> <p><strong>2、受到控制中心的旋转锁定按钮控制。</strong></p> <p><strong>3、支持用户使用应用时，在页面中临时调用设置方向能力，如点击全屏按钮进行切换。</strong></p> <p>要实现以上效果，可以使用窗口的能力设置orientation的枚举类型进行相应的旋转，由于要提供临时设置方向的能力，用户在手动点击全屏按钮时，相当于需要手动触发横竖屏切换，如果此时关闭了旋转锁定，那么窗口需要能够跟随传感器一起发生旋转，所以可以使用以下枚举中的能力，临时调用旋转，并让其后续也能支持跟随传感器。</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表1 </b>orientation部分参数列举</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.6.11.2.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"30.093009300930092%\\\"'><p>orientation枚举值</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.6.11.2.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"6.840684068406841%\\\"'><p>枚举数值</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.6.11.2.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"63.06630663066307%\\\"'><p>效果描述</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"30.093009300930092%\\\"'><p>USER_ROTATION_PORTRAIT</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.840684068406841%\\\"'><p>13</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"63.06630663066307%\\\"'><p>调用时临时旋转到竖屏，之后跟随传感器自动旋转，受控制中心的旋转开关控制，且可旋转方向受系统判定。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"30.093009300930092%\\\"'><p>USER_ROTATION_LANDSCAPE</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.840684068406841%\\\"'><p>14</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"63.06630663066307%\\\"'><p>调用时临时旋转到横屏，之后跟随传感器自动旋转，受控制中心的旋转开关控制，且可旋转方向受系统判定。</p> </td> </tr> </tbody></table> </div> <p>然后来分析旋转方向：对于视频播放的应用，一般旋转方向不会旋转到反向竖屏（由UX需求决定），即只旋转到竖屏、横屏和反向横屏。并且用户在使用时，点击切换按钮时，根据用户习惯，一般默认是旋转到横屏状态，然后支持跟随传感器旋转到反向横屏。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图4 </b>窗口旋转状态示意图</span><br/><span><img height='\\\"322.875854\\\"' originheight='\\\"703\\\"' originwidth='\\\"1552\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161121.72375245960181294558527447133857:50001231000000:2800:6606D3F9BB84AA9901BE5A28FEA6EC492DC11935FB4F157295D24FB715242FC2.png\\\"' title='\\\"点击放大\\\"' width='\\\"703.2375000000001\\\"'/></span></div> <p>在需要用户点击的地方，需要根据进入全屏和退出全屏分别执行相应的逻辑，需要使用的方向状态如下：</p> <p>设置为横屏时，对应窗口方向为横屏状态：this.setOrientation(window.Orientation.USER_ROTATION_LANDSCAPE)，例如进入播放页时，进行竖屏 -&gt; 横屏切换;</p> <pre class='\\\"screen\\\"'>Image($r('app.media.icon_zoom_in'))\\n  // ...\\n  .onClick(() =&gt; {\\n    if (display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_EXPANDED || display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_HALF_FOLDED) {\\n      this.isLandscape = true;\\n    } else {\\n      this.setOrientation(window.Orientation.USER_ROTATION_LANDSCAPE);\\n    }\\n  })</pre> <p>设置为竖屏时，对应窗口方向为竖屏状态：this.setOrientation(window.Orientation.USER_ROTATION_PORTRAIT)，例如在返回竖屏状态时，进行横屏 -&gt; 竖屏切换;</p> <pre class='\\\"screen\\\"'>Image($r('app.media.icon_back'))\\n  // ...\\n  .onClick(() =&gt; {\\n    // ...\\n      this.setOrientation(window.Orientation.USER_ROTATION_PORTRAIT);\\n      // ...\\n  })</pre> <div class='\\\"caution\\\"'><span class='\\\"cautiontitle\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161121.76030054997166420984914215328560:50001231000000:2800:7D4C04592EF9E05BE8D0401B2451818A5BB592FDEC2537BDFCB95208DE7DCC25.png\\\"'/> </span><div class='\\\"cautionbody\\\"'><p>需要注意的是，由于setPreferredOrientation方法调用改变的是窗口的显示方向，所以如果在进入视频播放页时，手动调用了旋转到横屏，那么在退出时也需要手动调用该接口，使窗口回到之前的竖屏状态。</p> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-landscape-and-portrait-development.html"
    },
    {
        "id": 13,
        "pre": "Image(this.isVideoLock ? $r('app.media.icon_lock') : $r('app.media.icon_lock_open'))\\n  // ...\\n  .onClick(() => {\\n    this.isVideoLock = !this.isVideoLock;\\n    // ...\\n    if (this.isVideoLock) {\\n      this.setOrientation(window.Orientation.AUTO_ROTATION_LANDSCAPE);\\n    } else {\\n      this.setOrientation(window.Orientation.AUTO_ROTATION_UNSPECIFIED);\\n    }\\n  })",
        "type": "Reference",
        "function_call": "getFoldStatus()",
        "function_name": "[h2]锁定屏幕功能",
        "parent_text": "[h2]锁定屏幕功能部分视频应用支持屏幕锁定功能，在全屏状态下，实现对功能按钮的隐藏，并临时锁定屏幕的旋转，避免用户误触其他操作按钮。屏幕锁定后，应用可以在横屏和反向横屏之间翻转，不可由横屏旋转为竖屏，解锁后，如果当前屏幕处于竖屏，则应该恢复到竖屏显示。 图7 屏幕锁定功能 针对上述功能可以考虑如下实现： 1、判断当前控制中心的开关状态，如果是已经锁定情况下，则不需要进行额外处理 2、锁定时设置旋转策略为AUTO_ROTATION_LANDSCAPE，即支持横屏和反向横屏旋转，不受控制中心控制 3、解锁时需要回到支持三向旋转，即支持横屏、竖屏、反向横屏，并受到控制中心控制 可以由上述推断功能实现得到如下代码：  对于需要在折叠屏状态下对旋转逻辑进行单独处理的情况，可以封装如下方法isExpandedOrHalfFolded方法，来判断当前设备是否为折叠屏展开态，处于折叠屏展开态情况下，不会触发旋转逻辑。 isExpandedOrHalfFolded(): boolean {\\n  return display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_EXPANDED ||\\n    display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_HALF_FOLDED;\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section102502044185919\\\"'><a name='\\\"section102502044185919\\\"'></a><a name='\\\"section102502044185919\\\"'></a><h4>[h2]锁定屏幕功能</h4><p>部分视频应用支持屏幕锁定功能，在全屏状态下，实现对功能按钮的隐藏，并临时锁定屏幕的旋转，避免用户误触其他操作按钮。屏幕锁定后，应用可以在横屏和反向横屏之间翻转，不可由横屏旋转为竖屏，解锁后，如果当前屏幕处于竖屏，则应该恢复到竖屏显示。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图7 </b>屏幕锁定功能</span><br/><span><img height='\\\"170.17057400000002\\\"' originheight='\\\"279\\\"' originwidth='\\\"1336\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161121.80244983787264337776112493376028:50001231000000:2800:D08E44373A3060CB9FD7B5FE4E0D6C5362072259F90700C46B85D19BB78D600E.png\\\"' title='\\\"点击放大\\\"' width='\\\"814.9575000000001\\\"'/></span></div> <p>针对上述功能可以考虑如下实现：</p> <p>1、判断当前控制中心的开关状态，如果是已经锁定情况下，则不需要进行额外处理</p> <p>2、锁定时设置旋转策略为AUTO_ROTATION_LANDSCAPE，即支持横屏和反向横屏旋转，不受控制中心控制</p> <p>3、解锁时需要回到支持三向旋转，即支持横屏、竖屏、反向横屏，并受到控制中心控制</p> <p>可以由上述推断功能实现得到如下代码：</p>  <p>对于需要在折叠屏状态下对旋转逻辑进行单独处理的情况，可以封装如下方法isExpandedOrHalfFolded方法，来判断当前设备是否为折叠屏展开态，处于折叠屏展开态情况下，不会触发旋转逻辑。</p> <pre class='\\\"screen\\\"'>isExpandedOrHalfFolded(): boolean {\\n  return display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_EXPANDED ||\\n    display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_HALF_FOLDED;\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-landscape-and-portrait-development.html"
    },
    {
        "id": 14,
        "pre": "@Component({ freezeWhenInactive: true })  // 添加自定义组件冻结功能\\nstruct VideoDetailView {\\n  build() {\\n    Scroll() {\\n      // ... 详情内容\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "nfunction ImageItem(imageSrc:ResourceStr)",
        "function_name": "性能优化",
        "parent_text": "性能优化由于在窗口旋转时，屏幕的尺寸会发生变化，界面会发生重新布局，为了提高横竖屏切换时的流畅度，需要进行相应的性能优化。 使用自定义组件冻结 旋转时，由于整窗一起旋转，会导致页面重新布局，但是实际上需要展示的可能只有播放内容，对于其他的组件可以使用自定义组件冻结功能，避免由于旋转导致的UI更新操作。例如视频播放底下的详情内容，可能是单独的组件。  对图片使用autoResize 如果当前旋转页面存在一些图片，未经合理的裁剪，图片过大，可以对图片设置autoResize属性，使图片裁剪到合适的大小进行绘制。该属性的作用是将组件显示区域作为绘制的图源尺寸，可以减少内存占用，例如原图是1920*1080，但是显示区域是200*100，则在解码时会降低采样编码到200*100尺寸。 @Builder\\nfunction ImageItem(imageSrc:ResourceStr) {\\n  Stack({}) {\\n    Image(imageSrc)\\n      .width('100%')\\n      .height('100%')\\n      .autoResize(true)  // 对图片使用auto_resize属性\\n      .borderRadius(8)\\n      .objectFit(ImageFit.Fill)\\n      .backgroundColor('#1AFFFFFF')\\n  }\\n} 排查一些耗时操作 排查当前页面是否存在一些冗余的OnAreaChange事件、blur模糊或者一些线性变化linearGradient的属性，这些都比较耗时，可以根据是否必须使用来决定是否进行优化。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1189243111172\\\"'><a name='\\\"section1189243111172\\\"'></a><a name='\\\"section1189243111172\\\"'></a><h4>性能优化</h4><p>由于在窗口旋转时，屏幕的尺寸会发生变化，界面会发生重新布局，为了提高横竖屏切换时的流畅度，需要进行相应的性能优化。</p> <p><strong>使用自定义组件冻结</strong></p> <p>旋转时，由于整窗一起旋转，会导致页面重新布局，但是实际上需要展示的可能只有播放内容，对于其他的组件可以使用自定义组件冻结功能，避免由于旋转导致的UI更新操作。例如视频播放底下的详情内容，可能是单独的组件。</p>  <p><strong>对图片使用autoResize</strong></p> <p>如果当前旋转页面存在一些图片，未经合理的裁剪，图片过大，可以对图片设置autoResize属性，使图片裁剪到合适的大小进行绘制。该属性的作用是将组件显示区域作为绘制的图源尺寸，可以减少内存占用，例如原图是1920*1080，但是显示区域是200*100，则在解码时会降低采样编码到200*100尺寸。</p> <pre class='\\\"screen\\\"'>@Builder\\nfunction ImageItem(imageSrc:ResourceStr) {\\n  Stack({}) {\\n    Image(imageSrc)\\n      .width('100%')\\n      .height('100%')\\n      .autoResize(true)  // 对图片使用auto_resize属性\\n      .borderRadius(8)\\n      .objectFit(ImageFit.Fill)\\n      .backgroundColor('#1AFFFFFF')\\n  }\\n}</pre> <p><strong>排查一些耗时操作</strong></p> <p>排查当前页面是否存在一些冗余的OnAreaChange事件、blur模糊或者一些线性变化linearGradient的属性，这些都比较耗时，可以根据是否必须使用来决定是否进行优化。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-landscape-and-portrait-development.html"
    },
    {
        "id": 15,
        "pre": "@Component\\nstruct TabsView {\\n  @State isLayoutFullScreen:boolean = false;\\n\\n  build() {\\n    Tabs() {\\n      // ... 省略布局内容\\n    }\\n    .barHeight(this.isLayoutFullScreen ? 0 : 50) // 通过用户是否需要点击进入全屏，隐藏Tabs标签栏的高度，可以实现隐藏\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]Tabs栏中的视频横屏播放，无法隐藏Tabs栏",
        "parent_text": "[h2]Tabs栏中的视频横屏播放，无法隐藏Tabs栏对于首页中有部分视频可以直接播放，并且不会跳转至详情页播放的，需要支持直接在首页发生旋转，当前可以通过设置XComponent的宽高实现，但是会发现即使全屏后，Tabs栏并不会消失。而是会一起发生旋转并存在于页面上。解决方案如下： 进入全屏时，隐藏Tabs，退出全屏时，展示Tabs栏。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section2892203111714\\\"'><a name='\\\"section2892203111714\\\"'></a><a name='\\\"section2892203111714\\\"'></a><h4>[h2]<strong>Tabs栏中的视频横屏播放，无法隐藏Tabs栏</strong></h4><p>对于首页中有部分视频可以直接播放，并且不会跳转至详情页播放的，需要支持直接在首页发生旋转，当前可以通过设置XComponent的宽高实现，但是会发现即使全屏后，Tabs栏并不会消失。而是会一起发生旋转并存在于页面上。解决方案如下：</p> <p>进入全屏时，隐藏Tabs，退出全屏时，展示Tabs栏。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-landscape-and-portrait-development.html"
    },
    {
        "id": 16,
        "pre": "// features/shopping/src/main/ets/views/Index.ets\\nTabs({ barPosition: BarPosition.End }) {\\n  // ...\\n}\\n.backgroundColor('#F1F3F5')\\n.expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "方案一：使用expandSafeArea属性扩展背景组件安全区域。给设置背景色的组件设置expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])，使背景色延伸到状态栏和导航条。由于expandSafeArea属性不影响子组件的布局，所以Tabs组件内的内容默认在安全区域布局，避让状态栏和导航条。  ",
        "import_module": null,
        "parent": "<li>方案一：使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea\\\"' target='\\\"_blank\\\"'>expandSafeArea</a>属性扩展背景组件安全区域。<p>给设置背景色的组件设置expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])，使背景色延伸到状态栏和导航条。由于<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea\\\"' target='\\\"_blank\\\"'>expandSafeArea</a>属性不影响子组件的布局，所以Tabs组件内的内容默认在安全区域布局，避让状态栏和导航条。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-immersive.html"
    },
    {
        "id": 17,
        "pre": "// features/shopping/src/main/ets/views/detail/Banner.ets\\nSwiper(this.swiperController) {\\n  ForEach(BANNER_IMAGES, (image: Resource) => {\\n    Image(image)\\n      .width('100%')\\n      .height('100%')\\n      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])\\n  }, (image: Resource) => JSON.stringify(image))\\n}\\n.clip(false)",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]开发步骤",
        "parent_text": "[h2]开发步骤设置图片expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])，扩展图片上方的安全区域。由于expandSafeArea属性不影响兄弟组件的布局，顶部的按钮区域默认避让状态栏。设置Swiper组件的clip属性为false，不裁剪内部组件。在设置expandSafeArea属性的组件的父组件是滚动类容器时，需配合clip属性使用。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section86747120174\\\"'><a name='\\\"section86747120174\\\"'></a><a name='\\\"section86747120174\\\"'></a><h4>[h2]开发步骤</h4><ol><li>设置图片expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])，扩展图片上方的安全区域。由于<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea\\\"' target='\\\"_blank\\\"'>expandSafeArea</a>属性不影响兄弟组件的布局，顶部的按钮区域默认避让状态栏。</li><li>设置Swiper组件的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sharp-clipping#clip12\\\"' target='\\\"_blank\\\"'>clip</a>属性为false，不裁剪内部组件。在设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area#expandsafearea\\\"' target='\\\"_blank\\\"'>expandSafeArea</a>属性的组件的父组件是滚动类容器时，需配合<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-sharp-clipping#clip12\\\"' target='\\\"_blank\\\"'>clip</a>属性使用。</li></ol>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-immersive.html"
    },
    {
        "id": 18,
        "pre": "// features/shopping/src/main/ets/views/detail/FaqList.ets\\nList() {\\n  // ...\\n}\\n.layoutWeight(1)\\n.scrollBar(BarState.Off)\\n.expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "设置列表组件ListexpandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])，扩展列表底部到安全区域。此时List组件显示区域扩大，滚动时列表内容可在导航条区域显示。 ",
        "import_module": null,
        "parent": "<li>设置列表组件ListexpandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])，扩展列表底部到安全区域。此时List组件显示区域扩大，滚动时列表内容可在导航条区域显示。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-immersive.html"
    },
    {
        "id": 19,
        "pre": "// products/default/src/main/ets/pages/VideoPlayer.ets\\nonShown() {\\n  this.windowClass.setWindowLayoutFullScreen(true);\\n  this.windowClass.setWindowSystemBarEnable([]);\\n}\\n\\nonHidden() {\\n  this.windowClass.setWindowLayoutFullScreen(false);\\n  this.windowClass.setWindowSystemBarEnable(['status', 'navigation']);\\n}\\n\\nbuild() {\\n  NavDestination() {\\n    Column() {\\n      Video({ src: $rawfile('video.mp4') })\\n        // ...\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n  .hideTitleBar(true)\\n  .onShown(() => this.onShown())\\n  .onHidden(() => this.onHidden())\\n}",
        "type": "Reference",
        "function_call": "setWindowSystemBarEnable()",
        "function_name": "[h2]开发步骤",
        "parent_text": "[h2]开发步骤在页面显示或隐藏时，使用Window.setWindowLayoutFullScreen()方法设置窗口是否为全屏模式，使用Window.setWindowSystemBarEnable()方法设置状态栏和导航条显隐。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section813019373176\\\"'><a name='\\\"section813019373176\\\"'></a><a name='\\\"section813019373176\\\"'></a><h4>[h2]开发步骤</h4><p>在页面显示或隐藏时，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#setwindowlayoutfullscreen9\\\"' target='\\\"_blank\\\"'>Window.setWindowLayoutFullScreen()</a>方法设置窗口是否为全屏模式，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#setwindowsystembarenable9\\\"' target='\\\"_blank\\\"'>Window.setWindowSystemBarEnable()</a>方法设置状态栏和导航条显隐。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-immersive.html"
    },
    {
        "id": 20,
        "pre": "// products/default/src/main/ets/pages/MiniGame.ets\\nturnOnImmersive() {\\n  this.windowClass.setWindowLayoutFullScreen(true);\\n  this.windowClass.setWindowSystemBarEnable([]);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "设置全屏并隐藏状态栏和导航栏。 ",
        "import_module": null,
        "parent": "<li>设置全屏并隐藏状态栏和导航栏。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-immersive.html"
    },
    {
        "id": 21,
        "pre": "// entry/src/main/ets/pages/ForEachListPage\\n@Entry\\n@Component\\nexport struct ForEachListPage {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      Header()\\n      List({ space: Constants.SPACE_16 }) {\\n        ForEach(this.articleList, (item: LearningResource) => {\\n          ListItem() {\\n            ArticleCardView({\\n              articleItem: item,\\n              isLiked: this.isLiked(item.id),\\n              isCollected: this.isCollected(item.id)\\n            })\\n          }\\n        }, (item: LearningResource) => item.id)\\n      }\\n      .width(Constants.FULL_SCREEN)\\n      .height(Constants.FULL_SCREEN)\\n      .margin({ left: 10, right: 10 })\\n      .layoutWeight(1)\\n    }\\n    .backgroundColor($r('app.color.text_background'))\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "对比案例1：使用ForEach对List列表进行加载 ",
        "import_module": null,
        "parent": "<li>对比案例1：使用ForEach对List列表进行加载 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-best-practices-long-list.html"
    },
    {
        "id": 22,
        "pre": "// entry/src/main/ets/pages/LazyForEachListPage\\n@Entry\\n@Component\\nexport struct LazyForEachListPage {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      Header()\\n      List({ space: Constants.SPACE_16 }) {\\n        if (this.data !== null) {\\n          // 使用懒加载\\n          LazyForEach(this.data, (item: LearningResource) => {\\n            ListItem() {\\n              ArticleCardView({\\n                articleItem: item,\\n                isLiked: this.isLiked(item.id),\\n                isCollected: this.isCollected(item.id)\\n              })\\n            }\\n          }, (item: LearningResource) => item.id)\\n        }\\n      }\\n      .width(Constants.FULL_SCREEN)\\n      .height(Constants.FULL_SCREEN)\\n      .margin({ left: 10, right: 10 })\\n      .layoutWeight(1)\\n      // 使用cachedCount\\n      .cachedCount(3);\\n    }\\n    .backgroundColor($r('app.color.text_background'))\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]场景案例",
        "parent_text": "[h2]场景案例在LazyForEach上添加缓存列表项后的关键代码如下所示：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section18672196153710\\\"'><a name='\\\"section18672196153710\\\"'></a><a name='\\\"section18672196153710\\\"'></a><h4>[h2]场景案例</h4><p>在LazyForEach上添加缓存列表项后的关键代码如下所示：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-best-practices-long-list.html"
    },
    {
        "id": 23,
        "pre": "import { SongInfoItem } from '../model/LearningResource';\\nimport { HashMap } from '@kit.ArkTS';\\nimport { fileIo } from '@kit.CoreFileKit';\\nimport { IDataSourcePrefetching } from '@kit.ArkUI';\\nimport { rcp } from '@kit.RemoteCommunicationKit';\\n\\nlet PREFETCH_ENABLED: boolean = false;\\nconst CANCEL_CODE: number = 1007900992;\\nconst IMADE_UNAVAILABLE = $r('app.media.startIcon');\\n\\nexport default class DataSourcePrefetching implements IDataSourcePrefetching {\\n  private dataArray: Array<SongInfoItem>;\\n  private listeners: DataChangeListener[] = [];\\n  private readonly requestsInFlight: HashMap<number, rcp.Request> = new HashMap();\\n  private readonly session: rcp.Session = rcp.createSession();\\n  private readonly cachePath = getContext().getApplicationContext().cacheDir;\\n\\n  constructor(dataArray: Array<SongInfoItem>) {\\n    this.dataArray = dataArray;\\n  }\\n\\n  async prefetch(index: number): Promise<void> {\\n    PREFETCH_ENABLED = true;\\n    if (this.requestsInFlight.hasKey(index)) {\\n      throw new Error('Already being prefetched')\\n    }\\n    const item = this.dataArray[index];\\n    if (item.cachedImage) {\\n      return;\\n    }\\n    // 数据请求\\n    const request = new rcp.Request(item.albumUrl, 'GET');\\n    // 缓存网络请求对象，便于在需要取消请求的时候进行处理\\n    this.requestsInFlight.set(index, request);\\n    try {\\n      // 发送http请求获得响应\\n      const response = await this.session.fetch(request);\\n      if (response.statusCode !== 200 || !response.body) {\\n        throw new Error('Bad response');\\n      }\\n      // 将加载的数据信息存储到缓存文件中\\n      item.cachedImage = await this.cache(item.songId, response.body);\\n      // 删除指定元素\\n      this.requestsInFlight.remove(index);\\n    } catch (err) {\\n      if (err.code !== CANCEL_CODE) {\\n        item.cachedImage = IMADE_UNAVAILABLE;\\n        // 移除有异常的网络请求任务\\n        this.requestsInFlight.remove(index);\\n      }\\n      throw err as Error;\\n    }\\n  }\\n\\n  cancel(index: number) {\\n    if (this.requestsInFlight.hasKey(index)) {\\n      // 返回MAP对象指定元素\\n      const request = this.requestsInFlight.get(index);\\n      // 取消数据请求\\n      this.session.cancel(request);\\n      // 移除被取消的网络请求对象\\n      this.requestsInFlight.remove(index);\\n    }\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "ListItem()",
        "function_name": "[h2]场景案例",
        "parent_text": "[h2]场景案例实现DataSourcePrefetchingRCP类，继承IDataSourcePrefetching接口，并实现prefetch和cancel方法，如下代码所示  在应用列表界面，首先创建DataSourcePrefetchingRCP、BasicPrefetcher对象，然后在List的onScrollIndex回调中调用BasicPrefetcher的visibleAreaChanged方法，传入List的可见区域起始坐标。至此完成代码的优化。 import { SongInfoItem } from '../model/LearningResource';\\nimport DataSourcePrefetching from '../model/ArticleListData';\\nimport { ObservedArray } from '../utils/ObservedArray';\\nimport { ReusableArticleCardView } from '../components/ReusableArticleCardView';\\nimport Constants from '../constants/Constants';\\nimport PageViewModel from '../components/PageViewModel';\\nimport { BasicPrefetcher } from '@kit.ArkUI';\\n\\n@Entry\\n@Component\\nexport struct LazyForEachListPage {\\n  @State collectedIds: ObservedArray<string> = ['1', '2', '3', '4', '5', '6'];\\n  @State likedIds: ObservedArray<string> = ['1', '2', '3', '4', '5', '6'];\\n  @State isListReachEnd: boolean = false;\\n  // 创建DataSourcePrefetching对象，具备任务预取、取消能力的数据源\\n  private readonly dataSource = new DataSourcePrefetching(PageViewModel.getItems());\\n  // 创建BasicPrefetcher对象，默认的动态预取算法实现\\n  private readonly prefetcher = new BasicPrefetcher(this.dataSource);\\n\\n  build() {\\n    Column() {\\n      Header()\\n      List({ space: Constants.SPACE_16 }) {\\n        LazyForEach(this.dataSource, (item: SongInfoItem) => {\\n          ListItem() {\\n            ReusableArticleCardView({ articleItem: item })\\n          }\\n          .reuseId('article')\\n        })\\n      }\\n      .cachedCount(5)\\n      .onScrollIndex((start: number, end: number) => {\\n        // 列表滚动触发visibleAreaChanged，实时更新预取范围，触发调用prefetch、cancel接口\\n        this.prefetcher.visibleAreaChanged(start, end)\\n      })\\n      .width(Constants.FULL_SCREEN)\\n      .height(Constants.FULL_SCREEN)\\n      .padding({ left: 10, right: 10 })\\n      .layoutWeight(1)\\n    }\\n    .backgroundColor($r('app.color.text_background'))\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1536105332\\\"'><a name='\\\"section1536105332\\\"'></a><a name='\\\"section1536105332\\\"'></a><h4>[h2]场景案例</h4><p>实现DataSourcePrefetchingRCP类，继承IDataSourcePrefetching接口，并实现prefetch和cancel方法，如下代码所示</p>  <p>在应用列表界面，首先创建DataSourcePrefetchingRCP、BasicPrefetcher对象，然后在List的onScrollIndex回调中调用BasicPrefetcher的visibleAreaChanged方法，传入List的可见区域起始坐标。至此完成代码的优化。</p> <pre class='\\\"screen\\\"'>import { SongInfoItem } from '../model/LearningResource';\\nimport DataSourcePrefetching from '../model/ArticleListData';\\nimport { ObservedArray } from '../utils/ObservedArray';\\nimport { ReusableArticleCardView } from '../components/ReusableArticleCardView';\\nimport Constants from '../constants/Constants';\\nimport PageViewModel from '../components/PageViewModel';\\nimport { BasicPrefetcher } from '@kit.ArkUI';\\n\\n@Entry\\n@Component\\nexport struct LazyForEachListPage {\\n  @State collectedIds: ObservedArray&lt;string&gt; = ['1', '2', '3', '4', '5', '6'];\\n  @State likedIds: ObservedArray&lt;string&gt; = ['1', '2', '3', '4', '5', '6'];\\n  @State isListReachEnd: boolean = false;\\n  // 创建DataSourcePrefetching对象，具备任务预取、取消能力的数据源\\n  private readonly dataSource = new DataSourcePrefetching(PageViewModel.getItems());\\n  // 创建BasicPrefetcher对象，默认的动态预取算法实现\\n  private readonly prefetcher = new BasicPrefetcher(this.dataSource);\\n\\n  build() {\\n    Column() {\\n      Header()\\n      List({ space: Constants.SPACE_16 }) {\\n        LazyForEach(this.dataSource, (item: SongInfoItem) =&gt; {\\n          ListItem() {\\n            ReusableArticleCardView({ articleItem: item })\\n          }\\n          .reuseId('article')\\n        })\\n      }\\n      .cachedCount(5)\\n      .onScrollIndex((start: number, end: number) =&gt; {\\n        // 列表滚动触发visibleAreaChanged，实时更新预取范围，触发调用prefetch、cancel接口\\n        this.prefetcher.visibleAreaChanged(start, end)\\n      })\\n      .width(Constants.FULL_SCREEN)\\n      .height(Constants.FULL_SCREEN)\\n      .padding({ left: 10, right: 10 })\\n      .layoutWeight(1)\\n    }\\n    .backgroundColor($r('app.color.text_background'))\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-best-practices-long-list.html"
    },
    {
        "id": 24,
        "pre": "@Component\\n@Reusable\\nexport struct ReusableArticleCardView {\\n  @Prop articleItem: LearningResource = new LearningResource();\\n  @Prop isCollected: boolean = false;\\n  @Prop isLiked: boolean = false;\\n  onCollected?: () => void;\\n  onLiked?: () => void;\\n\\n  aboutToReuse(params: Record<string, Object>): void {\\n    this.onCollected = params.onCollected as () => void;\\n    this.onLiked = params.onLiked as () => void;\\n  }\\n\\n  build() {\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "ListItem()",
        "function_name": "[h2]场景案例",
        "parent_text": "[h2]场景案例下面的代码片段是在缓存列表项的基础上增加的组件复用的相关代码，组件复用需要首先在复用的组件上添加@Reusable注解，然后实现aboutToReuse方法，关键代码如下：   无需对@Prop修饰的变量进行赋值，因为这些变量是由父组件传递给子组件的。如果在子组件中重新赋值这些变量，会导致重用的组件的内容重新触发状态刷新，从而降低组件的复用性能。相反，只需要在aboutToReuse方法中对onCollected和onLiked这两个函数进行重新赋值即可。  最后，还需要去设置可复用组件的reuseId，关键代码如下所示： // entry/src/main/ets/pages/LazyForEachListPage\\n@Entry\\n@Component\\nexport struct LazyForEachListPage {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      Header()\\n      List({ space: Constants.SPACE_16 }) {\\n        if (this.data !== null) {\\n          // 使用懒加载\\n          LazyForEach(this.data, (item: LearningResource) => {\\n            ListItem() {\\n              // 使用组件复用\\n              ReusableArticleCardView({\\n                articleItem: item,\\n                isLiked: this.isLiked(item.id),\\n                isCollected: this.isCollected(item.id)\\n              })\\n            }\\n            // 如果只有一个复用的组件，可以不用设置reuseId\\n            .reuseId('article')\\n          }, (item: LearningResource) => item.id)\\n        }\\n      }\\n      .width(Constants.FULL_SCREEN)\\n      .height(Constants.FULL_SCREEN)\\n      .margin({ left: 10, right: 10 })\\n      .layoutWeight(1)\\n      // 使用cachedCount\\n      .cachedCount(3);\\n    }\\n    .backgroundColor($r('app.color.text_background'))\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section19482174122811\\\"'><a name='\\\"section19482174122811\\\"'></a><a name='\\\"section19482174122811\\\"'></a><h4>[h2]场景案例</h4><p>下面的代码片段是在缓存列表项的基础上增加的组件复用的相关代码，组件复用需要首先在复用的组件上添加<span rgb(128,128,0);\\\"=\"\" style='\\\"color:'>@Reusable</span>注解，然后实现aboutToReuse方法，关键代码如下：</p>  <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161214.86447949553260381812344779084603:50001231000000:2800:C75C9CEC7430EDB80EE2A892FCE868501B6F89090C4AE578D722F0C1814950F1.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>无需对@Prop修饰的变量进行赋值，因为这些变量是由父组件传递给子组件的。如果在子组件中重新赋值这些变量，会导致重用的组件的内容重新触发状态刷新，从而降低组件的复用性能。相反，只需要在aboutToReuse方法中对onCollected和onLiked这两个函数进行重新赋值即可。</p> </div></div> <p>最后，还需要去设置可复用组件的reuseId，关键代码如下所示：</p> <pre class='\\\"screen\\\"'>// entry/src/main/ets/pages/LazyForEachListPage\\n@Entry\\n@Component\\nexport struct LazyForEachListPage {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      Header()\\n      List({ space: Constants.SPACE_16 }) {\\n        if (this.data !== null) {\\n          // 使用懒加载\\n          LazyForEach(this.data, (item: LearningResource) =&gt; {\\n            ListItem() {\\n              // 使用组件复用\\n              ReusableArticleCardView({\\n                articleItem: item,\\n                isLiked: this.isLiked(item.id),\\n                isCollected: this.isCollected(item.id)\\n              })\\n            }\\n            // 如果只有一个复用的组件，可以不用设置reuseId\\n            .reuseId('article')\\n          }, (item: LearningResource) =&gt; item.id)\\n        }\\n      }\\n      .width(Constants.FULL_SCREEN)\\n      .height(Constants.FULL_SCREEN)\\n      .margin({ left: 10, right: 10 })\\n      .layoutWeight(1)\\n      // 使用cachedCount\\n      .cachedCount(3);\\n    }\\n    .backgroundColor($r('app.color.text_background'))\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-best-practices-long-list.html"
    },
    {
        "id": 25,
        "pre": "@Component\\nexport struct ArticleCardView {\\n  build() {\\n    Row() {                  // 线性布局，第1层\\n      Column() {             // 线性布局，第2层\\n        Column() {\\n          Text()\\n          Text()\\n        }\\n        Row() {              // 线性布局，第3层\\n          Row(){             // 线性布局，第4层\\n            Image()          // 线性布局，第5层\\n            Text()\\n          }\\n          Row(){\\n            Image()\\n            Text()\\n          }\\n          Row(){\\n            Image()\\n            Text()\\n          }\\n        }\\n      }\\n      Image()\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "对比案例1：线性布局，最大嵌套层级为5层 ",
        "import_module": null,
        "parent": "<li>对比案例1：线性布局，最大嵌套层级为5层 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-best-practices-long-list.html"
    },
    {
        "id": 26,
        "pre": "// entry/src/main/ets/pages/BottomTab.ets\\nbuild() {\\n  Tabs({\\n    barPosition: BarPosition.End,\\n    controller: this.tabsController\\n  }) {\\n    this.tabContentBuilder($r('app.string.message'),\\n      Constants.TAB_INDEX_ZERO, $r('app.media.activeMessage'), $r('app.media.message'))\\n    this.tabContentBuilder($r('app.string.people'),\\n      Constants.TAB_INDEX_ONE, $r('app.media.activePeople'), $r('app.media.people'))\\n    this.tabContentBuilder($r('app.string.activity'),\\n      Constants.TAB_INDEX_TWO, $r('app.media.activeStar'), $r('app.media.star'))\\n  }\\n  .width('100%')\\n  .backgroundColor('#F3F4F5')\\n  .barHeight(52)\\n  .barMode(BarMode.Fixed)\\n  .onAnimationStart((index: number, targetIndex: number) => {\\n    hilog.info(0x0000, 'index', index.toString());\\n    this.currentIndex = targetIndex;\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用Tabs组件，设置barPosition为BarPosition.End控制导航条底部展示。Tabs组件嵌套tabContentBuilder自定义组件。 ",
        "import_module": null,
        "parent": "<li><span>使用Tabs组件，设置barPosition为BarPosition.End控制导航条底部展示。</span><span>Tabs组件嵌套</span><span>tabContentBuilder自定义组件</span>。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 27,
        "pre": "// entry/src/main/ets/pages/RudderStyleTab.ets\\nTabs({ barPosition: BarPosition.End, controller: this.controller }) {\\n  ForEach(this.tabArray, (item: BottomTabModel, index: number) => {\\n    if (index === Constants.TAB_INDEX_TWO) {\\n      TabContent()\\n      .backgroundColor(Color.White)\\n    } else {\\n      TabContent() {\\n        Row() {\\n          Text(item.title)\\n            .fontSize(30)\\n        }\\n        .height(300)\\n        .width('100%')\\n        .justifyContent(FlexAlign.Center)\\n      }\\n      .backgroundColor(Color.White)\\n    }\\n  }, (item: BottomTabModel, index: number) => JSON.stringify(item) + index)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用Tabs组件，设置barPosition为BarPosition.End控制导航条底部展示。Tabs组件嵌套TabContent组件实现内容区。 ",
        "import_module": null,
        "parent": "<li><span>使用Tabs组件，设置barPosition为BarPosition.End</span><span>控制导航条底部展示</span><span>。</span><span>Tabs组件嵌套</span><span>TabContent组件实现内容区。</span> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 28,
        "pre": "// entry/src/main/ets/pages/LeftTab.ets\\nStack({ alignContent: Alignment.TopStart }) {\\n  // 导航条文字\\n  Row() {\\n    ForEach(this.tabArray, (item: number, index: number) => {\\n      this.tab('页签 ' + item, item, index);\\n    })\\n    Blank()\\n    Text('+')\\n      .width(24)\\n      .height(24)\\n      .fontSize(24)\\n      .textAlign(TextAlign.Center)\\n      .margin({ right: 24 })\\n  }\\n  .justifyContent(FlexAlign.Start)\\n  .width('100%')\\n\\n  // 导航条下划线\\n  Column()\\n    .width(this.indicatorWidth)\\n    .height(1.5)\\n    .backgroundColor('#0A59F7')\\n    .borderRadius(1)\\n    .margin({ left: this.indicatorLeftMargin, top: 35 })\\n}\\n.height(56)\\n.margin({ left: this.tabLeftOffset })",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "Stack组件中嵌套Row组件和Column组件，实现导航条文字和下划线两部分。 ",
        "import_module": null,
        "parent": "<li><span>Stack组件中嵌套Row组件和Column组件，实现导航条文字和下划线两部分</span>。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 29,
        "pre": "// src/main/ets/pages/SlideAndMoreTab.ets\\nRow() {\\n  List({ initialIndex: 0, scroller: this.listScroller }) {\\n    ForEach(this.tabArray, (item: TabItem, index: number) => {\\n      this.Tab(item.name, index)\\n    }, (item: TabItem, index: number) => JSON.stringify(item) + index)\\n  }\\n  .listDirection(Axis.Horizontal)\\n  .height(30)\\n  .scrollBar(BarState.Off)\\n  .width('85%')\\n  .friction(0.6)\\n  .onWillScroll((xOffset: number) => {\\n    this.indicatorLeftMargin -= xOffset;\\n  })\\n\\n  Image($r('app.media.more'))\\n    .width(20)\\n    .height(15)\\n    .margin({ left: 16 })\\n}\\n.height(52)\\n.width('100%')",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]可滑动居左对齐样式",
        "parent_text": "[h2]可滑动居左对齐样式可滑动导航样式在居左对齐基础上增加滑动功能，适合页签数较多场景。  实现方式与居左对齐样式相同，唯一区别在于导航布局中嵌套List组件实现可滑动效果。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1749323710379\\\"'><a name='\\\"section1749323710379\\\"'></a><a name='\\\"section1749323710379\\\"'></a><h4>[h2]可滑动居左对齐样式</h4><p>可滑动导航样式在居左对齐基础上增加滑动功能，适合页签数较多场景。</p> <p><span><img height='\\\"568.9873\\\"' originheight='\\\"2338\\\"' originwidth='\\\"1093\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161127.37847057014808092087124599331429:50001231000000:2800:CBD49AC3F2EACCC47BB67EBA399B93C0A53C76992D7E720695AC5EBA5C65AA03.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>实现方式与居左对齐样式相同，唯一区别在于导航布局中嵌套List组件实现可滑动效果。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 30,
        "pre": "// entry/src/main/ets/pages/UnderlineTab.ets\\nTabs({ barPosition: BarPosition.Start }) {\\n  ForEach(this.tabArray.slice(0, 4), (item: TabItem) => {\\n    TabContent() {\\n      Row() {\\n        Text(item.name)\\n          .height(300)\\n          .fontSize(30)\\n      }\\n      .width('100%')\\n      .justifyContent(FlexAlign.Center)\\n      .height('100%')\\n    }.tabBar(this.tabBuilder(item.id, item.name))\\n  }, (item: TabItem, index: number) => JSON.stringify(item) + index)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用Tabs组件，设置barPosition为BarPosition.Start控制导航条顶部展示。通过tabBar属性和Builder装饰器实现导航。 ",
        "import_module": null,
        "parent": "<li><span>使用Tabs组件，设置barPosition为BarPosition.Start</span><span>控制导航条顶部展示</span><span>。通过tabBar属性和Builder装饰器实现导航。</span> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 31,
        "pre": "// src/main/ets/pages/BackgroundLightTab.ets\\nTabs({ barPosition: BarPosition.Start, controller: this.controller }) {\\n  ForEach(this.tabArray.slice(0, 6),\\n    (item: TabItem) => {\\n      TabContent() {\\n        Row() {\\n          Text(item.name)\\n            .height(300)\\n            .fontSize(30)\\n        }\\n        .width('100%')\\n        .justifyContent(FlexAlign.Center)\\n      }\\n      .backgroundColor(Color.White)\\n    }, (item: TabItem, index: number) => JSON.stringify(item) + index)\\n}\\n.width('100%')",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用Tabs组件，设置barPosition为BarPosition.Start控制导航条顶部展示。通过自定义布局实现导航背景高亮样式。 ",
        "import_module": null,
        "parent": "<li><span>使用Tabs组件，设置barPosition为BarPosition.Start</span><span>控制导航条顶部展示</span><span>。通过自定义布局</span>实现导航背景高亮样式。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 32,
        "pre": "// entry/src/main/ets/pages/WordTab.ets\\nTabs({ barPosition: BarPosition.Start }) {\\n  ForEach(this.tabArray.slice(0, 4), (item: TabItem) => {\\n    TabContent() {\\n      Row() {\\n        Text(item.name)\\n          .height(300)\\n          .fontSize(30)\\n      }\\n      .width('100%')\\n      .justifyContent(FlexAlign.Center)\\n      .height('100%')\\n    }.tabBar(this.tabBuilder(item.id, item.name))\\n  }, (item: TabItem, index: number) => JSON.stringify(item) + index)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用Tabs组件，设置barPosition为BarPosition.Start。通过tabBar属性和Builder装饰器实现导航。 ",
        "import_module": null,
        "parent": "<li><span>使用Tabs组件，设置barPosition为BarPosition.Start。通过tabBar属性和Builder装饰器实现导航。</span> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 33,
        "pre": "// src/main/ets/pages/DoubleNestingTabOne.ets\\n@Builder\\nsubTabBuilder(tabName: string | Resource, tabIndex: number) {\\n  Row() {\\n    Text(tabName)\\n      .fontSize(16)\\n      .fontColor(tabIndex === this.focusIndex ? '#0A59F7' : '#E6000000')\\n      .id(tabIndex.toString())\\n  }\\n  .justifyContent(FlexAlign.Center)\\n  .padding({ left: 12, right: 12 })\\n  .height(30)\\n  .onClick(() => {\\n    this.subController.changeIndex(tabIndex);\\n    this.focusIndex = tabIndex;\\n  })\\n}\\n\\n// src/main/ets/pages/DoubleNestingTabOne.ets\\nTabContent() {\\n  Column() {\\n    Column() {\\n      Row() {\\n        List({ initialIndex: Constants.TAB_INDEX_ZERO, scroller: this.listScroller }) {\\n          ForEach(this.tabArray, (item: TabItem, index: number) => {\\n            this.subTabBuilder(item.name, index)\\n          }, (item: TabItem, index: number) => JSON.stringify(item) + index)\\n        }\\n        .listDirection(Axis.Horizontal)\\n        .height(30)\\n        .scrollBar(BarState.Off)\\n        .width('85%')\\n        .friction(0.6)\\n\\n        Image($r('app.media.more'))\\n          .width(20)\\n          .height(15)\\n          .margin({ left: 16 })\\n      }\\n      .height(25)\\n      .width('100%')\\n    }\\n    .alignItems(HorizontalAlign.Center)\\n    .width('100%')\\n    .padding({ left: 4 })\\n\\n    // src/main/ets/pages/DoubleNestingTabOne.ets\\n    Tabs({ barPosition: BarPosition.Start, controller: this.subController }) {\\n      // ...\\n    }\\n    .barHeight(0)\\n    .animationDuration(Constants.ANIMATION_DURATION)\\n    .onAnimationStart((index: number, targetIndex: number) => {\\n      hilog.info(0x0000, 'index', index.toString());\\n      this.focusIndex = targetIndex;\\n      this.listScroller.scrollToIndex(targetIndex, true, ScrollAlign.CENTER);\\n    })\\n  }\\n}\\n.tabBar(this.tabBuilder(Constants.TAB_INDEX_ZERO, this.topTabData[Constants.TAB_INDEX_ZERO]))",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]双层嵌套式",
        "parent_text": "[h2]双层嵌套式双层嵌套样式拥有两层导航，外层嵌套内层，与单层导航相比可以容纳更多页签。  外层导航通过在TabContent组件设置tabBar属性，其中TabContent中嵌套List和子级Tabs。List组件嵌套subTabBuilder自定义组件实现内层导航。子级Tabs组件嵌套TabContent组件实现内容区。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section14821142112717\\\"'><a name='\\\"section14821142112717\\\"'></a><a name='\\\"section14821142112717\\\"'></a><h4>[h2]双层嵌套式</h4><p>双层嵌套样式拥有两层导航，外层嵌套内层，与单层导航相比可以容纳更多页签。</p> <p><span><img height='\\\"566.3273\\\"' originheight='\\\"1056\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161128.56856010335231977826614931946096:50001231000000:2800:4CE00027DBC0DA2D483261757B5721DDE44C02432357E78F8EC936C31927186C.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>外层导航通过在<span>TabContent</span>组件设置<span>tabBar属性，其中</span><span>TabContent中嵌套List和子级Tabs。</span><span>List组件嵌套</span>subTabBuilder自定义组件<span>实现内层导航</span><span>。</span><span>子级Tabs组件嵌套</span><span>TabContent</span><span>组件实现内容区。</span></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 34,
        "pre": "// src/main/ets/pages/SideTab.ets\\n// 左侧导航布局\\nList({ scroller: this.classifyScroller }) {\\n  ForEach(this.ClassifyArray, (item: ClassifyModel, index?: number) => {\\n    ListItem() {\\n      ClassifyItem({\\n        classifyName: item.classifyName,\\n        isSelected: this.currentClassify === index,\\n        onClickAction: () => {\\n          if (index !== undefined) {\\n            this.classifyChangeAction(index, true);\\n          }\\n        }\\n      })\\n    }\\n  }, (item: ClassifyModel, index: number) => JSON.stringify(item) + index)\\n}\\n.height('110%')\\n.width('27.8%')\\n.backgroundColor('#F1F3F5')\\n.scrollBar(BarState.Off)\\n.margin({ top: 74 })\\n\\n// 右侧内容区域\\nColumn() {\\n  ForEach(this.ClassifyArray, (item: ClassifyModel, index: number) => {\\n    Text(this.currentClassify === index ? item.classifyName : '')\\n      .fontSize(30)\\n  },(item: ClassifyModel, index: number) => JSON.stringify(item) + index)\\n}\\n.width('72.2%')",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]基础侧边导航",
        "parent_text": "[h2]基础侧边导航属于侧边导航类，通过List去实现左侧导航条区域。  基础侧边导航使用左右布局：左侧通过List组件与ListItem组件实现导航布局，右侧实现导航内容区。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1147605715467\\\"'><a name='\\\"section1147605715467\\\"'></a><a name='\\\"section1147605715467\\\"'></a><h4>[h2]基础侧边导航</h4><p>属于侧边导航类，通过List去实现左侧导航条区域。</p> <p><span><img height='\\\"566.3273\\\"' originheight='\\\"1056\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161128.13516388570556194622154870971833:50001231000000:2800:0D057AD0357341B555231643B92FCD047F78602C632C16946640D9ECBF8EC1E1.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p><span>基础侧边导航使用左右布局：左侧通过List组件与ListItem组件实现导航布局，右侧实现导航内容区。</span></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 35,
        "pre": "// src/main/ets/pages/DrawerTab.ets\\nSideBarContainer(SideBarContainerType.Overlay) {\\n  // 左侧导航区域\\n  Column() {\\n    // ...\\n  }\\n  .height('100%')\\n  .padding({ top: 104 })\\n  .backgroundColor('#E9EAEC')\\n  // src/main/ets/pages/DrawerTab.ets\\n  // 右侧内容区域\\n  Column() {\\n    // ...\\n  }\\n  .onClick(() => {\\n    animateTo({\\n      duration: Constants.ANIMATION_DURATION,\\n      curve: Curve.EaseOut,\\n      playMode: PlayMode.Normal,\\n    }, () => {\\n      this.show = false;\\n    })\\n  })\\n  .width('100%')\\n  .height('110%')\\n  .backgroundColor(this.show ? '#c1c2c4' : '')\\n}\\n.showSideBar(this.show)\\n.controlButton({\\n  left: 16,\\n  top: 48,\\n  height: 40,\\n  width: 40,\\n  icons: {\\n    shown: $r('app.media.changeBack'),\\n    hidden: $r('app.media.change'),\\n    switching: $r('app.media.change')\\n  }\\n})\\n.onChange((value: boolean) => {\\n  this.show = value;\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用SideBarContainer组件实现侧边导航，并且通过设置该组件的showSideBar控制显示隐藏。在SideBarContainer实现左侧导航样式和右侧内容区。controlButton属性控制侧边导航按钮位置。 ",
        "import_module": null,
        "parent": "<li><span>使用</span><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer#示例\\\"' target='\\\"_blank\\\"'>SideBarContainer组件</a><span>实现侧边导航，并且通过设置该组件的</span>showSideBar控制显示隐藏。<span>在SideBarContainer实现左侧导航样式和右侧内容区。</span>controlButton属性控制侧边导航按钮位置。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-tab-practice.html"
    },
    {
        "id": 36,
        "pre": "import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';",
        "type": "Import",
        "function_call": null,
        "function_name": null,
        "parent_text": "新建一个ArkTS应用工程，编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，导入依赖模块： ",
        "import_module": "import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';",
        "parent": "<li><span>新建一个ArkTS应用工程，编辑工程中的“entry &gt; src &gt; main &gt; ets &gt; entryability &gt; EntryAbility.ets”文件，导入依赖模块：</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-stability-operate-app-event.html"
    },
    {
        "id": 37,
        "pre": "@Component\\nstruct ButtonWithWaterRipples {\\n  @Link isListening: boolean;\\n  @State immediatelyOpacity: number = 0.5;\\n  @State immediatelyScale: Scale = { x: 1, y: 1 };\\n  @State delayOpacity: number = 0.5;\\n  @State delayScale: Scale = { x: 1, y: 1 };\\n  private readonly BUTTON_SIZE: number = 120;\\n  private readonly BUTTON_CLICK_SCALE: number = 0.8;\\n  private readonly ANIMATION_DURATION: number = 1300;\\n\\n  @Styles\\n  ripplesStyle() {\\n    .width(this.BUTTON_SIZE * this.BUTTON_CLICK_SCALE)\\n    .height(this.BUTTON_SIZE * this.BUTTON_CLICK_SCALE)\\n    .borderRadius(this.BUTTON_SIZE * this.BUTTON_CLICK_SCALE / 2)\\n    .backgroundColor(Color.Red)\\n  }\\n\\n  build() {\\n    Stack() {\\n      Stack()\\n        .ripplesStyle()\\n        .opacity(this.immediatelyOpacity)\\n        .scale(this.immediatelyScale)\\n      Stack()\\n        .ripplesStyle()\\n        .opacity(this.delayOpacity)\\n        .scale(this.delayScale)\\n      Button() {\\n        Image($r('app.media.ic_public_music_filled'))\\n          .width($r('app.float.water_ripples_width'))\\n          .fillColor(Color.White)\\n      }\\n      .clickEffect({ level: ClickEffectLevel.HEAVY, scale: this.BUTTON_CLICK_SCALE })\\n      .backgroundColor($r('app.color.music_icon'))\\n      .type(ButtonType.Circle)\\n      .width(this.BUTTON_SIZE)\\n      .height(this.BUTTON_SIZE)\\n      .zIndex(1)\\n      // ...\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "getTitleScaleOptions()",
        "function_name": "[h2]动画实践案例",
        "parent_text": "[h2]动画实践案例使用显式动画实现特征动效 场景描述 在本场景中，圆形按钮上会依次出现多个水波状圆环，这些圆环从中心向外进行扩散，进而凸显功能，实现效果如图所示。 图7 使用显式动画实现水波纹动效 实现原理 水波圆环以圆形按钮为中心，将多个圆形图层逐渐向外扩展放大，每个圆形图层的动画开始时间稍微错开，进而形成多个水波圆环依次扩散的效果。其动效实现步骤如下。 实现圆形图层，以圆形图层作为水波圆环的基础形状，并设置相关背景属性。通过显示动画animateTo实现圆形图层放大的动效，并设置延迟时间。 开发步骤 实现圆形图层，通过Stack将圆形图层与Button组件进行重叠。  实现圆形图层的放大动效，并设置延迟时间。 Button() {\\n  Image($r('app.media.ic_public_music_filled'))\\n    .width($r('app.float.water_ripples_width'))\\n    .fillColor(Color.White)\\n}\\n.clickEffect({ level: ClickEffectLevel.HEAVY, scale: this.BUTTON_CLICK_SCALE })\\n.backgroundColor($r('app.color.music_icon'))\\n.type(ButtonType.Circle)\\n.width(this.BUTTON_SIZE)\\n.height(this.BUTTON_SIZE)\\n.zIndex(1)\\n.onClick(() => {\\n  this.isListening = !this.isListening;\\n  if (this.isListening) {\\n    animateTo({\\n      duration: this.ANIMATION_DURATION,\\n      iterations: CommonConstants.ITERATIONS,\\n      curve: Curve.EaseInOut\\n    }, () => {\\n      this.immediatelyOpacity = CommonConstants.COMMON_NUMBER_0;\\n      this.immediatelyScale = {\\n        x: CommonConstants.COMMON_NUMBER_6,\\n        y: CommonConstants.COMMON_NUMBER_6\\n      };\\n    })\\n    animateTo({\\n      duration: this.ANIMATION_DURATION,\\n      iterations: CommonConstants.ITERATIONS,\\n      curve: Curve.EaseInOut,\\n      delay: CommonConstants.DELAY_200\\n    }, () => {\\n      this.delayOpacity = CommonConstants.COMMON_NUMBER_0;\\n      this.delayScale = {\\n        x: CommonConstants.COMMON_NUMBER_6,\\n        y: CommonConstants.COMMON_NUMBER_6\\n      };\\n    })\\n  } else {\\n    // Break the animation by modifying the variable with a closure of duration 0.\\n    animateTo({ duration: CommonConstants.COMMON_NUMBER_0 }, () => {\\n      this.immediatelyOpacity = CommonConstants.COMMON_NUMBER;\\n      this.delayOpacity = CommonConstants.COMMON_NUMBER;\\n      this.immediatelyScale = {\\n        x: CommonConstants.COMMON_NUMBER_1,\\n        y: CommonConstants.COMMON_NUMBER_1\\n      };\\n      this.delayScale = {\\n        x: CommonConstants.COMMON_NUMBER_1,\\n        y: CommonConstants.COMMON_NUMBER_1\\n      };\\n    })\\n  }\\n}) 使用关键帧动画实现微动效 场景描述 如图所示，在本场景中，在登录页面前需要勾选相关的协议，如果未勾选相关协议，提示框将会通过左右移动进行提示。 图8 使用关键帧动画实现左右移动提示 实现原理 提示框左右移动提醒是将提示框进行左移，然后再进行右移，如此往复循环多次。其动效可以分为提示框左移和提示框右移两段，可以使用keyframeAnimateTo接口实现分段的动画效果，实现步骤如下所示。 根据需要实现的动画效果，将动画拆分成若干个关键帧，即将动画进行分段，如本案例中将动画分成提示框左移和提示框右移两段。根据不同的关键帧设置关键帧状态，即设置该段关键帧动画的持续时间、动画曲线和闭包函数等。设置动画触发条件，使用通用事件点击、出现等，选择对应需求的触发方式。。 开发步骤 通过keyframeAnimateTo来设置关键帧动画。 startAnimation() {\\n  if (!this.uiContext) {\\n    return;\\n  }\\n  this.translateX = CONFIGURATION.POSITION_ZERO;\\n  this.uiContext.keyframeAnimateTo({ iterations: CONFIGURATION.PLAYBACK_COUNT }, [\\n    {\\n      duration: CONFIGURATION.ANIMATION_TIME,\\n      event: () => {\\n        this.translateX = CONFIGURATION.TRANSLATE_OFFSET_X;\\n      }\\n    },\\n    {\\n      duration: CONFIGURATION.ANIMATION_TIME,\\n      event: () => {\\n        this.translateX = CONFIGURATION.POSITION_ZERO;\\n      }\\n    }\\n  ]);\\n} 设置onClick事件，通过onClick事件调用关键帧动画。 Button($r('app.string.login_in'))\\n  .type(ButtonType.Normal)\\n  .borderRadius($r('app.integer.comm_border_radius'))\\n  .fontColor($r('app.color.ohos_id_color_background'))\\n  .fontSize($r('app.integer.login_button_font_size'))\\n  .width(Constants.LAYOUT_MAX_PERCENT)\\n  .onClick(() => {\\n    if (!this.confirm) {\\n      this.startVibrate();\\n      this.startAnimation();\\n    } else {\\n      promptAction.showToast({\\n        message: $r('app.string.login_text')\\n      });\\n    }\\n  }) 使用属性动画实现手势动效 场景描述 在本场景中，页面主要分为标题和列表两个部分，当向下滑动列表时，标题会跟随下滑手势扩展显示详细信息，其实现效果如下所示。 图9 使用属性动画实现手势动效 实现原理 在实现下拉缩放详情中，主要包含了两个部分，分别是列表下拉的手势和下拉后标题和列表的动画，详细实现步骤如下。 处理手势事件：通过onTouch事件记录当前的触摸点，判断当前的手势是否为向上或向下滑动。通过属性动画animation实现标题缩放的效果：当列表向上或向下滑动时，改变列表的高度，并通过属性动画进行平滑过度，从而实现标题区域缩放的效果。实现标题内容的平移：在标题区域进行缩放的同时，标题的内容也会同步进行平移，从而实现标题部分整体缩放的效果。 开发步骤 实现手势事件方法。当手指按下时，触发TouchType.Down事件记录当前触碰的位置。手指按压态在屏幕上移动时，可以通过当前的位置与初始位置进行比较，判断手势是否为向上或向下滑动，进而变更列表的高度。 handleTouchEvent(event: TouchEvent): void {\\n  switch (event.type) {\\n    case TouchType.Down:\\n      this.downY = event.touches[0].y;\\n      this.lastMoveY = event.touches[0].y;\\n      this.isMoving = true;\\n      this.duration = Constants.ANIMATE_DURATION_DRAG;\\n      break;\\n\\n    case TouchType.Move:\\n      const delta = event.touches[0].y - this.lastMoveY;\\n      this.offsetY = event.touches[0].y - this.downY;\\n      if (delta < 0) {\\n        this.heightValue = Constants.AREA_HEIGHT_BEFORE;\\n        this.isExpanded = false;\\n        this.atStart = false;\\n      }\\n      if (delta > 0 && this.atStart) {\\n        this.animateToThrottle(() => {\\n          this.heightValue = Constants.AREA_HEIGHT_AFTER;\\n          this.isExpanded = true;\\n        }, 1000);\\n      }\\n      this.lastMoveY = event.touches[0].y;\\n      break;\\n\\n    case TouchType.Cancel:\\n      this.isMoving = false;\\n      this.duration = Constants.ANIMATE_DURATION_BACK;\\n      break;\\n    default:\\n      break;\\n  }\\n} 为列表设置触摸事件onTouch和属性动画，实现标题区域缩放的效果。 Column() {\\n  List({ space: Constants.SEARCH_MEMO_SPACE }) {\\n    ListItem() {\\n      Search({ placeholder: $r('app.string.search_placeholder') })\\n        .width(Constants.LAYOUT_MAX_PERCENT)\\n        .height(Constants.LAYOUT_EIGHT_PERCENT)\\n        .backgroundColor(Color.White)\\n        .enableKeyboardOnFocus(false)\\n    }\\n\\n    LazyForEach(this.memoData, (item: MemoInfo) => {\\n      ListItem() {\\n        MemoItem({ memoItem: item })\\n      }\\n    }, (item: MemoInfo) => JSON.stringify(item))\\n  }\\n  .scrollBar(BarState.Off)\\n  .margin({ left: $r('app.float.layout_10'), right: $r('app.float.layout_10') })\\n  .width(Constants.LAYOUT_NINETY_PERCENT)\\n  .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])\\n  .onReachStart(() => {\\n    this.atStart = true;\\n  })\\n}\\n.width(Constants.LAYOUT_MAX_PERCENT)\\n.height(this.heightValue)\\n.animation({ duration: this.duration, curve: Curve.FastOutLinearIn })\\n.onTouch((event: TouchEvent) => this.handleTouchEvent(event)) 通过animation属性动画实现标题内容平移，从而达到标题整体缩放的效果。 Column() {\\n  Row() {\\n    Text(!this.isExpanded ? $r('app.string.memo_title') : '')\\n      .fontSize($r('app.float.init_title_font_size'))\\n    Blank()\\n    Image($r('app.media.is_public_add'))\\n      .width($r('app.float.menu_pic_layout'))\\n      .height($r('app.float.menu_pic_layout'))\\n    Image($r('app.media.ic_public_more'))\\n      .width($r('app.float.menu_pic_layout'))\\n      .height($r('app.float.menu_pic_layout'))\\n      .margin({ left: $r('app.float.layout_8') })\\n  }\\n  .width(Constants.LAYOUT_MAX_PERCENT)\\n  .padding($r('app.float.layout_25'))\\n  .margin({ top: $r('app.float.layout_10') })\\n  .alignItems(VerticalAlign.Center)\\n  .translate(this.getMenuTranslateOptions())\\n  .animation({ duration: this.duration, curve: Curve.FastOutLinearIn })\\n\\n  Column() {\\n    Text($r('app.string.memo_title'))\\n      .fontSize($r('app.float.expanded_title_font_size'))\\n    Text($r('app.string.memo_counts'))\\n      .fontSize($r('app.float.memo_counts_font_size'))\\n      .fontColor(Color.Grey)\\n  }\\n  .width(Constants.LAYOUT_MAX_PERCENT)\\n  .padding({ left: $r('app.float.layout_25') })\\n  .margin({ top: $r('app.float.layout_10') })\\n  .alignItems(HorizontalAlign.Start)\\n  .translate(this.getTitleTranslateOptions())\\n  .scale(this.getTitleScaleOptions())\\n  .animation({ duration: this.duration, curve: Curve.FastOutLinearIn })\\n  .transition({ type: TransitionType.Insert, translate: { y: Constants.TRANSLATE_Y } })\\n  .visibility(this.isExpanded ? Visibility.Visible : Visibility.Hidden)\\n}\\n.height(Constants.LAYOUT_MAX_PERCENT)\\n.width(Constants.LAYOUT_MAX_PERCENT) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section640141219361\\\"'><a name='\\\"section640141219361\\\"'></a><a name='\\\"section640141219361\\\"'></a><h4>[h2]动画实践案例</h4><p><strong>使用显式动画实现特征动效</strong></p> <ul><li>场景描述</li></ul> <p>在本场景中，圆形按钮上会依次出现多个水波状圆环，这些圆环从中心向外进行扩散，进而凸显功能，实现效果如图所示。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图7 </b>使用显式动画实现水波纹动效</span><br/><span><img height='\\\"550.354\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.38817086858873992942907309784996:50001231000000:2800:9FDA6821E16F4027676AA5256829D822BC643496F9146D228FF4B24E223232F0.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <ul><li>实现原理</li></ul> <p>水波圆环以圆形按钮为中心，将多个圆形图层逐渐向外扩展放大，每个圆形图层的动画开始时间稍微错开，进而形成多个水波圆环依次扩散的效果。其动效实现步骤如下。</p> <ol><li><span>实现圆形图层，以圆形图层作为水波圆环的基础形状，并设置相关背景属性。</span></li><li><span>通过显示动画animateTo实现圆形图层放大的动效，并设置延迟时间。</span></li></ol> <ul><li>开发步骤</li></ul> <p>实现圆形图层，通过Stack将圆形图层与Button组件进行重叠。</p>  <p>实现圆形图层的放大动效，并设置延迟时间。</p> <pre class='\\\"screen\\\"'>Button() {\\n  Image($r('app.media.ic_public_music_filled'))\\n    .width($r('app.float.water_ripples_width'))\\n    .fillColor(Color.White)\\n}\\n.clickEffect({ level: ClickEffectLevel.HEAVY, scale: this.BUTTON_CLICK_SCALE })\\n.backgroundColor($r('app.color.music_icon'))\\n.type(ButtonType.Circle)\\n.width(this.BUTTON_SIZE)\\n.height(this.BUTTON_SIZE)\\n.zIndex(1)\\n.onClick(() =&gt; {\\n  this.isListening = !this.isListening;\\n  if (this.isListening) {\\n    animateTo({\\n      duration: this.ANIMATION_DURATION,\\n      iterations: CommonConstants.ITERATIONS,\\n      curve: Curve.EaseInOut\\n    }, () =&gt; {\\n      this.immediatelyOpacity = CommonConstants.COMMON_NUMBER_0;\\n      this.immediatelyScale = {\\n        x: CommonConstants.COMMON_NUMBER_6,\\n        y: CommonConstants.COMMON_NUMBER_6\\n      };\\n    })\\n    animateTo({\\n      duration: this.ANIMATION_DURATION,\\n      iterations: CommonConstants.ITERATIONS,\\n      curve: Curve.EaseInOut,\\n      delay: CommonConstants.DELAY_200\\n    }, () =&gt; {\\n      this.delayOpacity = CommonConstants.COMMON_NUMBER_0;\\n      this.delayScale = {\\n        x: CommonConstants.COMMON_NUMBER_6,\\n        y: CommonConstants.COMMON_NUMBER_6\\n      };\\n    })\\n  } else {\\n    // Break the animation by modifying the variable with a closure of duration 0.\\n    animateTo({ duration: CommonConstants.COMMON_NUMBER_0 }, () =&gt; {\\n      this.immediatelyOpacity = CommonConstants.COMMON_NUMBER;\\n      this.delayOpacity = CommonConstants.COMMON_NUMBER;\\n      this.immediatelyScale = {\\n        x: CommonConstants.COMMON_NUMBER_1,\\n        y: CommonConstants.COMMON_NUMBER_1\\n      };\\n      this.delayScale = {\\n        x: CommonConstants.COMMON_NUMBER_1,\\n        y: CommonConstants.COMMON_NUMBER_1\\n      };\\n    })\\n  }\\n})</pre> <p><strong>使用关键帧动画实现微动效</strong></p> <ul><li>场景描述</li></ul> <p>如图所示，在本场景中，在登录页面前需要勾选相关的协议，如果未勾选相关协议，提示框将会通过左右移动进行提示。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图8 </b>使用关键帧动画实现左右移动提示</span><br/><span><img height='\\\"550.354\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.21218723372348251131677118930709:50001231000000:2800:3F85F9C3F5ADCC504DB48734AC3F3CB0FA7DFD4A336CC4F746B468B128347496.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <ul><li>实现原理</li></ul> <p>提示框左右移动提醒是将提示框进行左移，然后再进行右移，如此往复循环多次。其动效可以分为提示框左移和提示框右移两段，可以使用keyframeAnimateTo接口实现分段的动画效果，实现步骤如下所示。</p> <ol><li><span>根据需要实现的动画效果，将动画拆分成若干个关键帧，即将动画进行分段，如本案例中将动画分成提示框左移和提示框右移两段。</span></li><li><span>根据不同的关键帧设置关键帧状态，即设置该段关键帧动画的持续时间、动画曲线和闭包函数等。</span></li><li><span>设置动画触发条件，使用通用事件点击、出现等，选择对应需求的触发方式。。</span></li></ol> <ul><li>开发步骤</li></ul> <p>通过keyframeAnimateTo来设置关键帧动画。</p> <pre class='\\\"screen\\\"'>startAnimation() {\\n  if (!this.uiContext) {\\n    return;\\n  }\\n  this.translateX = CONFIGURATION.POSITION_ZERO;\\n  this.uiContext.keyframeAnimateTo({ iterations: CONFIGURATION.PLAYBACK_COUNT }, [\\n    {\\n      duration: CONFIGURATION.ANIMATION_TIME,\\n      event: () =&gt; {\\n        this.translateX = CONFIGURATION.TRANSLATE_OFFSET_X;\\n      }\\n    },\\n    {\\n      duration: CONFIGURATION.ANIMATION_TIME,\\n      event: () =&gt; {\\n        this.translateX = CONFIGURATION.POSITION_ZERO;\\n      }\\n    }\\n  ]);\\n}</pre> <p>设置onClick事件，通过onClick事件调用关键帧动画。</p> <pre class='\\\"screen\\\"'>Button($r('app.string.login_in'))\\n  .type(ButtonType.Normal)\\n  .borderRadius($r('app.integer.comm_border_radius'))\\n  .fontColor($r('app.color.ohos_id_color_background'))\\n  .fontSize($r('app.integer.login_button_font_size'))\\n  .width(Constants.LAYOUT_MAX_PERCENT)\\n  .onClick(() =&gt; {\\n    if (!this.confirm) {\\n      this.startVibrate();\\n      this.startAnimation();\\n    } else {\\n      promptAction.showToast({\\n        message: $r('app.string.login_text')\\n      });\\n    }\\n  })</pre> <p><strong>使用属性动画实现手势动效</strong></p> <ul><li>场景描述</li></ul> <p>在本场景中，页面主要分为标题和列表两个部分，当向下滑动列表时，标题会跟随下滑手势扩展显示详细信息，其实现效果如下所示。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图9 </b>使用属性动画实现手势动效</span><br/><span><img height='\\\"550.354\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.08869734339858389103335033620774:50001231000000:2800:EFDCE367338DEA111F373B546E4BEA0F30DCE6520B2524E489EBC6761AC60E73.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <ul><li>实现原理</li></ul> <p>在实现下拉缩放详情中，主要包含了两个部分，分别是列表下拉的手势和下拉后标题和列表的动画，详细实现步骤如下。</p> <ol><li><span>处理手势事件：通过onTouch事件记录当前的触摸点，判断当前的手势是否为向上或向下滑动。</span></li><li><span>通过属性动画animation实现标题缩放的效果：当列表向上或向下滑动时，改变列表的高度，并通过属性动画进行平滑过度，从而实现标题区域缩放的效果。</span></li><li><span>实现标题内容的平移：在标题区域进行缩放的同时，标题的内容也会同步进行平移，从而实现标题部分整体缩放的效果。</span></li></ol> <ul><li>开发步骤</li></ul> <p>实现手势事件方法。当手指按下时，触发TouchType.Down事件记录当前触碰的位置。手指按压态在屏幕上移动时，可以通过当前的位置与初始位置进行比较，判断手势是否为向上或向下滑动，进而变更列表的高度。</p> <pre class='\\\"screen\\\"'>handleTouchEvent(event: TouchEvent): void {\\n  switch (event.type) {\\n    case TouchType.Down:\\n      this.downY = event.touches[0].y;\\n      this.lastMoveY = event.touches[0].y;\\n      this.isMoving = true;\\n      this.duration = Constants.ANIMATE_DURATION_DRAG;\\n      break;\\n\\n    case TouchType.Move:\\n      const delta = event.touches[0].y - this.lastMoveY;\\n      this.offsetY = event.touches[0].y - this.downY;\\n      if (delta &lt; 0) {\\n        this.heightValue = Constants.AREA_HEIGHT_BEFORE;\\n        this.isExpanded = false;\\n        this.atStart = false;\\n      }\\n      if (delta &gt; 0 &amp;&amp; this.atStart) {\\n        this.animateToThrottle(() =&gt; {\\n          this.heightValue = Constants.AREA_HEIGHT_AFTER;\\n          this.isExpanded = true;\\n        }, 1000);\\n      }\\n      this.lastMoveY = event.touches[0].y;\\n      break;\\n\\n    case TouchType.Cancel:\\n      this.isMoving = false;\\n      this.duration = Constants.ANIMATE_DURATION_BACK;\\n      break;\\n    default:\\n      break;\\n  }\\n}</pre> <p>为列表设置触摸事件onTouch和属性动画，实现标题区域缩放的效果。</p> <pre class='\\\"screen\\\"'>Column() {\\n  List({ space: Constants.SEARCH_MEMO_SPACE }) {\\n    ListItem() {\\n      Search({ placeholder: $r('app.string.search_placeholder') })\\n        .width(Constants.LAYOUT_MAX_PERCENT)\\n        .height(Constants.LAYOUT_EIGHT_PERCENT)\\n        .backgroundColor(Color.White)\\n        .enableKeyboardOnFocus(false)\\n    }\\n\\n    LazyForEach(this.memoData, (item: MemoInfo) =&gt; {\\n      ListItem() {\\n        MemoItem({ memoItem: item })\\n      }\\n    }, (item: MemoInfo) =&gt; JSON.stringify(item))\\n  }\\n  .scrollBar(BarState.Off)\\n  .margin({ left: $r('app.float.layout_10'), right: $r('app.float.layout_10') })\\n  .width(Constants.LAYOUT_NINETY_PERCENT)\\n  .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])\\n  .onReachStart(() =&gt; {\\n    this.atStart = true;\\n  })\\n}\\n.width(Constants.LAYOUT_MAX_PERCENT)\\n.height(this.heightValue)\\n.animation({ duration: this.duration, curve: Curve.FastOutLinearIn })\\n.onTouch((event: TouchEvent) =&gt; this.handleTouchEvent(event))</pre> <p>通过animation属性动画实现标题内容平移，从而达到标题整体缩放的效果。</p> <pre class='\\\"screen\\\"'>Column() {\\n  Row() {\\n    Text(!this.isExpanded ? $r('app.string.memo_title') : '')\\n      .fontSize($r('app.float.init_title_font_size'))\\n    Blank()\\n    Image($r('app.media.is_public_add'))\\n      .width($r('app.float.menu_pic_layout'))\\n      .height($r('app.float.menu_pic_layout'))\\n    Image($r('app.media.ic_public_more'))\\n      .width($r('app.float.menu_pic_layout'))\\n      .height($r('app.float.menu_pic_layout'))\\n      .margin({ left: $r('app.float.layout_8') })\\n  }\\n  .width(Constants.LAYOUT_MAX_PERCENT)\\n  .padding($r('app.float.layout_25'))\\n  .margin({ top: $r('app.float.layout_10') })\\n  .alignItems(VerticalAlign.Center)\\n  .translate(this.getMenuTranslateOptions())\\n  .animation({ duration: this.duration, curve: Curve.FastOutLinearIn })\\n\\n  Column() {\\n    Text($r('app.string.memo_title'))\\n      .fontSize($r('app.float.expanded_title_font_size'))\\n    Text($r('app.string.memo_counts'))\\n      .fontSize($r('app.float.memo_counts_font_size'))\\n      .fontColor(Color.Grey)\\n  }\\n  .width(Constants.LAYOUT_MAX_PERCENT)\\n  .padding({ left: $r('app.float.layout_25') })\\n  .margin({ top: $r('app.float.layout_10') })\\n  .alignItems(HorizontalAlign.Start)\\n  .translate(this.getTitleTranslateOptions())\\n  .scale(this.getTitleScaleOptions())\\n  .animation({ duration: this.duration, curve: Curve.FastOutLinearIn })\\n  .transition({ type: TransitionType.Insert, translate: { y: Constants.TRANSLATE_Y } })\\n  .visibility(this.isExpanded ? Visibility.Visible : Visibility.Hidden)\\n}\\n.height(Constants.LAYOUT_MAX_PERCENT)\\n.width(Constants.LAYOUT_MAX_PERCENT)</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-fair-use-animation.html"
    },
    {
        "id": 38,
        "pre": "@Entry\\n@Component\\nstruct CustomAnimationExample {\\n  @State widthSize: number = 80\\n  @State heightSize: number = 40\\n  @State flag: boolean = true\\n  // 自定义动画函数\\n  computeSize() {\\n    let duration = 2000\\n    // 设定循环周期\\n    let period = 1\\n    let widthSizeEnd = 0\\n    let heightSizeEnd = 0\\n    if (this.flag) {\\n      widthSizeEnd = 50\\n      heightSizeEnd = 25\\n    } else {\\n      widthSizeEnd = 80\\n      heightSizeEnd = 40\\n    }\\n    // 计算循环次数\\n    let doTimes = duration / period\\n    // 计算每次循环变化量\\n    let deltaHeight = (heightSizeEnd - this.heightSize) / doTimes\\n    let deltaWeight = (widthSizeEnd - this.widthSize) / doTimes\\n    // 循环，组件每个周期增加一部分宽高\\n    for (let i = 1; i <= doTimes; i++) {\\n      let t = period * (i);\\n      setTimeout(() => {\\n        this.heightSize = this.heightSize + deltaHeight\\n        this.widthSize = this.widthSize + deltaWeight\\n      }, t)\\n    }\\n    this.flag = !this.flag\\n  }\\n\\n  build() {\\n    Column() {\\n      Button()\\n        .width(this.widthSize)\\n        .height(this.heightSize)\\n      // 其他相似布局\\n      …\\n      Button('click me')\\n        .onClick(() => {\\n          let delay = 500\\n          // 调用自定义函数\\n          setTimeout(() => {\\n            this.computeSize()\\n          }, delay)\\n        })\\n        .width('50%').height('15%').backgroundColor(0x317aff)\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}",
        "type": "Reference",
        "function_call": "Button()",
        "function_name": "[h2]使用系统提供的动画接口",
        "parent_text": "[h2]使用系统提供的动画接口一般而言，在HarmonyOS应用开发中，动画设计实现可以通过自定义动画或系统提供的动画接口两种方式来实现。 方式一，自定义动画：自定义动画是指通过编写自定义的动画逻辑和计算过程来实现特定的动画效果。开发人员可以根据应用的需求和设计要求，使用自定义的动画算法和逻辑来创建独特的动画效果。自定义动画的优势在于可以实现非常个性化的动画效果，并且能够完全控制动画的每一个细节，但需要开发人员具备一定的动画算法和计算能力。 方式二，系统动画接口：系统动画接口是指通过使用系统提供的动画框架和接口来实现动画效果。在移动应用开发中，通常会使用属性动画来实现各种动画效果。通过可动画属性改变引起UI上产生的连续视觉效果，即为属性动画。属性动画是最基础易懂的动画，ArkUI提供两种属性动画接口animateTo和animation驱动组件属性按照动画曲线等动画参数进行连续的变化，产生属性动画。使用系统提供的动画接口可以简化动画的实现过程，并且能够充分利用系统优化的动画计算和渲染能力，从而提高动画的性能和流畅度。  场景设计 针对同一界面多个按钮同时缩放的场景（如下图所示），分别用自定义动画、属性动画、显式动画实现。 图10 同一界面多个按钮同时缩放示意图 自定义动画 播放动画时，系统需要在一个刷新周期内完成动画变化曲线的计算，完成组件布局绘制等操作。使用了自定义动画，动画曲线计算过程很容易引起UI线程高负载，易导致丢帧。 使用自定义动画实现按键缩放，具体实现代码如下：  系统动画接口 系统提供的动画接口，只需设置曲线类型、终点位置、时长等信息，就能够满足常用的动画功能，减少UI主线程的负载。 使用属性动画实现按键缩放，具体实现代码如下： @Entry\\n@Component\\nstruct PropertyAnimateToExample {\\n  @State widthSize: number = 80;\\n  @State heightSize: number = 40;\\n  @State flag: boolean = true;\\n\\n  build() {\\n    Column() {\\n      Button()\\n        .width(this.widthSize)\\n        .height(this.heightSize)\\n        // 对Button组件的宽高属性进行动画配置\\n        .animation({\\n          duration: 2000, // 动画时长\\n          curve: Curve.Linear, // 动画曲线\\n          delay: 500, // 动画延迟\\n          iterations: 1, // 播放次数\\n          playMode: PlayMode.Normal // 动画模式\\n        }) \\n      // 其他相似布局\\n      …\\n      Button('click me')\\n        .onClick((event?: ClickEvent | undefined) => {\\n          if (this.flag) {\\n            this.widthSize = 50\\n            this.heightSize = 25\\n          } else {\\n            this.widthSize = 80\\n            this.heightSize = 40\\n          }\\n          this.flag = !this.flag\\n        })\\n        .width('50%').height('15%').backgroundColor(0x317aff)\\n    }.width('100%').margin({ top: 5 })\\n  }\\n} 使用显式动画实现按键缩放，具体实现代码如下： @Entry\\n@Component\\nstruct ExplicitAnimateToExample {\\n  @State widthSize: number = 80;\\n  @State heightSize: number = 40;\\n  @State flag: boolean = true;\\n\\n  build() {\\n    Column() {\\n      Button()\\n        .width(this.widthSize)\\n        .height(this.heightSize)\\n      // 其他相似布局\\n      …\\n      Button('click me')\\n        .onClick((event?: ClickEvent | undefined) => {\\n          // 对Button组件的宽高属性进行动画配置\\n          if (this.flag) {\\n            animateTo({\\n              duration: 2000, // 动画时长\\n              curve: Curve.Linear, // 动画曲线\\n              delay: 500, // 动画延迟\\n              iterations: 1, // 播放次数\\n              playMode: PlayMode.Normal // 动画模式\\n            }, () => {\\n              this.widthSize = 50;\\n              this.heightSize = 25;\\n            })\\n          } else {\\n            animateTo({\\n              duration: 2000, // 动画时长\\n              curve: Curve.Linear, // 动画曲线\\n              delay: 500, // 动画延迟\\n              iterations: 1, // 播放次数\\n              playMode: PlayMode.Normal // 动画模式\\n            }, () => {\\n              this.widthSize = 80;\\n              this.heightSize = 40;\\n            })\\n          }\\n          this.flag = !this.flag;\\n        })\\n        .width('50%').height('15%').backgroundColor(0x317aff)\\n    }.width('100%').margin({ top: 5 })\\n  }\\n} 性能分析 使用IDE的Profiler工具检测下述指标，得到的数据如下所示： 表1 自定义动画、属性动画、显式动画实现相同场景的指标对比   自定义动画  属性动画  显式动画    丢帧率（%）  9.2%  0%  0%   最大连续丢帧数（帧）  7  0  0   平均1s大卡顿次数（次/s）  1.50  0  0     分析结论： 1）使用自定义动画实现计算量较大的动画时，丢帧率高达9.2%，最大连续丢失7帧，平均每秒发生大卡顿1.5次。 2）使用系统动画接口实现相同效果时，属性动画接口和显式动画接口都能够达到0丢帧。 这一结果表明，系统动画接口内部实现对开发者是透明的，已经进行了尽可能的性能优化，避免开发者使用自定义动画时产生不必要的性能劣化。自定义动画适合实现个性化的、复杂的动画效果，而系统提供的动画接口则适合实现常见的动画效果并且能够获得更好的性能表现。因此，在动画能够使用系统接口实现的情况下，开发者应尽量使用系统接口实现，保持动画的流畅性和稳定性，提升应用的性能表现。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section897161681719\\\"'><a name='\\\"section897161681719\\\"'></a><a name='\\\"section897161681719\\\"'></a><h4>[h2]使用系统提供的动画接口</h4><p>一般而言，在HarmonyOS应用开发中，动画设计实现可以通过自定义动画或系统提供的动画接口两种方式来实现。</p> <ul><li>方式一，自定义动画：<p>自定义动画是指通过编写自定义的动画逻辑和计算过程来实现特定的动画效果。开发人员可以根据应用的需求和设计要求，使用自定义的动画算法和逻辑来创建独特的动画效果。自定义动画的优势在于可以实现非常个性化的动画效果，并且能够完全控制动画的每一个细节，但需要开发人员具备一定的动画算法和计算能力。</p> </li><li>方式二，系统动画接口：<p>系统动画接口是指通过使用系统提供的动画框架和接口来实现动画效果。在移动应用开发中，通常会使用属性动画来实现各种动画效果。通过可动画属性改变引起UI上产生的连续视觉效果，即为属性动画。属性动画是最基础易懂的动画，ArkUI提供两种属性动画接口<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-explicit-animation\\\"' target='\\\"_blank\\\"'>animateTo</a>和<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty\\\"' target='\\\"_blank\\\"'>animation</a>驱动组件属性按照动画曲线等动画参数进行连续的变化，产生属性动画。使用系统提供的动画接口可以简化动画的实现过程，并且能够充分利用系统优化的动画计算和渲染能力，从而提高动画的性能和流畅度。</p> </li></ul> <p><strong>场景设计</strong></p> <p>针对同一界面多个按钮同时缩放的场景（如下图所示），分别用自定义动画、属性动画、显式动画实现。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图10 </b>同一界面多个按钮同时缩放示意图</span><br/><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.03915888789505877783254546655653:50001231000000:2800:4B82EE144F5746A665B11866F87F1CAC8D99480537992B23B18EC615C9700A4D.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p><strong>自定义动画</strong></p> <p>播放动画时，系统需要在一个刷新周期内完成动画变化曲线的计算，完成组件布局绘制等操作。使用了自定义动画，动画曲线计算过程很容易引起UI线程高负载，易导致丢帧。</p> <p>使用自定义动画实现按键缩放，具体实现代码如下：</p>  <p><strong>系统动画接口</strong></p> <p>系统提供的动画接口，只需设置曲线类型、终点位置、时长等信息，就能够满足常用的动画功能，减少UI主线程的负载。</p> <ul><li>使用属性动画实现按键缩放，具体实现代码如下：</li></ul> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct PropertyAnimateToExample {\\n  @State widthSize: number = 80;\\n  @State heightSize: number = 40;\\n  @State flag: boolean = true;\\n\\n  build() {\\n    Column() {\\n      Button()\\n        .width(this.widthSize)\\n        .height(this.heightSize)\\n        // 对Button组件的宽高属性进行动画配置\\n        .animation({\\n          duration: 2000, // 动画时长\\n          curve: Curve.Linear, // 动画曲线\\n          delay: 500, // 动画延迟\\n          iterations: 1, // 播放次数\\n          playMode: PlayMode.Normal // 动画模式\\n        }) \\n      // 其他相似布局\\n      …\\n      Button('click me')\\n        .onClick((event?: ClickEvent | undefined) =&gt; {\\n          if (this.flag) {\\n            this.widthSize = 50\\n            this.heightSize = 25\\n          } else {\\n            this.widthSize = 80\\n            this.heightSize = 40\\n          }\\n          this.flag = !this.flag\\n        })\\n        .width('50%').height('15%').backgroundColor(0x317aff)\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}</pre> <ul><li>使用显式动画实现按键缩放，具体实现代码如下：</li></ul> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct ExplicitAnimateToExample {\\n  @State widthSize: number = 80;\\n  @State heightSize: number = 40;\\n  @State flag: boolean = true;\\n\\n  build() {\\n    Column() {\\n      Button()\\n        .width(this.widthSize)\\n        .height(this.heightSize)\\n      // 其他相似布局\\n      …\\n      Button('click me')\\n        .onClick((event?: ClickEvent | undefined) =&gt; {\\n          // 对Button组件的宽高属性进行动画配置\\n          if (this.flag) {\\n            animateTo({\\n              duration: 2000, // 动画时长\\n              curve: Curve.Linear, // 动画曲线\\n              delay: 500, // 动画延迟\\n              iterations: 1, // 播放次数\\n              playMode: PlayMode.Normal // 动画模式\\n            }, () =&gt; {\\n              this.widthSize = 50;\\n              this.heightSize = 25;\\n            })\\n          } else {\\n            animateTo({\\n              duration: 2000, // 动画时长\\n              curve: Curve.Linear, // 动画曲线\\n              delay: 500, // 动画延迟\\n              iterations: 1, // 播放次数\\n              playMode: PlayMode.Normal // 动画模式\\n            }, () =&gt; {\\n              this.widthSize = 80;\\n              this.heightSize = 40;\\n            })\\n          }\\n          this.flag = !this.flag;\\n        })\\n        .width('50%').height('15%').backgroundColor(0x317aff)\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}</pre> <p><strong>性能分析</strong></p> <p>使用<span>IDE</span>的Profiler工具检测下述指标，得到的数据如下所示：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表1 </b><strong>自定义动画、属性动画、显式动画实现相同场景</strong><strong>的指标对比</strong></caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.13.19.2.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"22.24%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.13.19.2.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"24.23%\\\"'><p>自定义动画</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.13.19.2.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"26.1%\\\"'><p>属性动画</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.13.19.2.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"27.43%\\\"'><p>显式动画</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.24%\\\"'><p>丢帧率（%）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"24.23%\\\"'><p>9.2%</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.1%\\\"'><p>0%</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.43%\\\"'><p>0%</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.24%\\\"'><p>最大连续丢帧数（帧）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"24.23%\\\"'><p>7</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.1%\\\"'><p>0</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.43%\\\"'><p>0</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.24%\\\"'><p>平均1s大卡顿次数（次/s）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"24.23%\\\"'><p>1.50</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.1%\\\"'><p>0</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.43%\\\"'><p>0</p> </td> </tr> </tbody></table> </div> <p>分析结论：</p> <p>1）使用自定义动画实现计算量较大的动画时，丢帧率高达9.2%，最大连续丢失7帧，平均每秒发生大卡顿1.5次。</p> <p>2）使用系统动画接口实现相同效果时，属性动画接口和显式动画接口都能够达到0丢帧。</p> <p>这一结果表明，系统动画接口内部实现对开发者是透明的，已经进行了尽可能的性能优化，避免开发者使用自定义动画时产生不必要的性能劣化。自定义动画适合实现个性化的、复杂的动画效果，而系统提供的动画接口则适合实现常见的动画效果并且能够获得更好的性能表现。因此，在动画能够使用系统接口实现的情况下，开发者应尽量使用系统接口实现，保持动画的流畅性和稳定性，提升应用的性能表现。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-fair-use-animation.html"
    },
    {
        "id": 39,
        "pre": "@Entry\\n@Component\\nstruct Index {\\n  @State imageWidth: number = 60;\\n  @State imageHeight: number = 60;\\n  @State xPosition: number = 0;\\n  @State yPosition: number = 0;\\n\\n  build() {\\n    Column(){\\n      Image($r('app.media.sample'))\\n        .width(this.imageWidth)\\n        .height(this.imageHeight)\\n        .position({x: this.xPosition, y: this.yPosition})\\n      // 其他相似布局\\n      …\\n      Button(\\\"布局属性\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() => {\\n          let doTimes = 10;\\n          // 按播放次数循环播放动画\\n          for (let i = 0; i < doTimes; i++) {\\n            // 间隔播放位置、宽高变化\\n            if (i % 2 == 0){\\n              setTimeout(() => {\\n                animateTo({ duration:1000 }, () => {\\n                  this.imageWidth = 120;\\n                  this.imageHeight = 120;\\n                  this.xPosition = 15;\\n                  this.yPosition = 15;\\n                })\\n              }, 1000 * i)\\n            } else {\\n              setTimeout(() => {\\n                animateTo({ duration: 1000 }, () => {\\n                  this.imageWidth = 60;\\n                  this.imageHeight = 60;\\n                  this.xPosition = 0;\\n                  this.yPosition = 0;\\n                })\\n              }, 1000 * i)\\n            }\\n          }\\n        })\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]使用图形变换属性变化组件",
        "parent_text": "[h2]使用图形变换属性变化组件在应用开发中，改动组件的布局显示可以通过改动布局属性、改动图形变换属性两种方式来实现。 方式一，改动布局属性常见的布局属性包括位置、大小、内边距、外边距、对齐方式、权重等。当这些布局属性发生改变时，界面将重新布局以适应新的属性值。 方式二，改动图形变换属性图形变换属性是指对组件布局结果的变换操作，如平移、旋转、缩放等操作。通过改变这些图形变换属性，可以实现对组件布局完成后，在界面上的位置和形态进行动态变换。  布局属性和图形变换属性的可替换关系如下表所示： 表2 图形变换属性  布局属性    rotate  /   translate  position、offset   scale  width、height、Size   transform  /      表格中的对应关系仅供参考，开发者可以自行发掘更多的替代关系。  场景设计 针对同一界面多个图片同时缩放并位移的场景（如下图所示），分别通过改变布局属性、改变图形变换属性实现。 图11 同一界面多个图片同时缩放并位移示意图 改变布局属性 布局属性发生变化时，系统需要重新计算组件的位置和大小，然后进行重新布局。这个过程需要消耗大量的计算资源和时间，尤其是在界面中包含大量组件或者复杂布局时，性能开销会更加明显。 通过组件的width、height、position属性来改变组件大小和位置，具体代码实现如下：  改变图形变换属性 图形变换只是对组件的显示效果进行变换，而不会改变其在布局中的位置和大小，因此不会触发重新布局的计算过程。这使得使用图形变换属性来实现动画效果时，能够提升界面的流畅性和性能表现。 通过组件的scale、translate属性来改变组件大小和位置，具体代码实现如下： @Entry\\n@Component\\nstruct Index {\\n  @State imageScaleX: number = 1;\\n  @State imageScaleY: number = 1;\\n  @State imageTranslateX: number = 0;\\n  @State imageTranslateY: number = 0;\\n  build() {\\n    Column() {\\n      Image($r('app.media.like'))\\n        .scale({ x: this.imageScaleX, y: this.imageScaleY, centerX: 0, centerY: 0 })\\n        .translate({ x: this.imageTranslateX, y: this.imageTranslateY })\\n      // 其他相似布局\\n      …\\n      Button(\\\"图形变换属性\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() => {\\n          let doTimes = 10;\\n          // 按播放次数循环播放动画\\n          for (let i = 0; i < doTimes; i++) {\\n            if (i % 2 == 0) {\\n              setTimeout(() => {\\n                animateTo({ duration: 1000 }, () => {\\n                  this.imageScaleX = 2;\\n                  this.imageScaleY = 2;\\n                  this.imageTranslateX = 15;\\n                  this.imageTranslateY = 15;\\n                })\\n              }, 1000 * i)\\n            } else {\\n              setTimeout(() => {\\n                animateTo({ duration: 1000 }, () => {\\n                  this.imageScaleX = 1;\\n                  this.imageScaleY = 1;\\n                  this.imageTranslateX = 0;\\n                  this.imageTranslateY = 0;\\n                })\\n              }, 1000 * i)\\n            }\\n          }\\n        })\\n    }.width('100%').margin({ top: 5 })\\n  }\\n} 性能分析 使用IDE的Profiler工具检测下述指标，得到的数据如下所示： 表3 改变布局属性、改变图形变换属性实现相同场景的指标对比   改变布局属性  改变图形变换属性    丢帧率（%）  8.1%  3.7%   最大连续丢帧数（帧）  8  2   平均1s大卡顿次数（次/s）  0.48  0     分析结论： 1）使用布局属性改变图片大小和位置时，丢帧率为8.1%，最多连续丢失8帧，平均每秒发生大卡顿0.48次。 2）使用图形变化属性改变图片大小和位置时，丢帧率降到了3.7%，最多连续丢失2帧，在相同时长内没有发生大卡顿。 这一结果表明，使用图形变化属性改变图片大小和位置时，能够显著降低丢帧率和大卡顿的发生频率。界面布局是非常耗时的操作，因此频繁地改动布局属性会导致界面性能下降，出现卡顿现象，影响用户体验。因此，在动画能够使用图形变化属性实现的情况下，开发者应尽量使用图形变化属性实现，保持动画的流畅性和稳定性，提升应用的性能表现。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1723931117204\\\"'><a name='\\\"section1723931117204\\\"'></a><a name='\\\"section1723931117204\\\"'></a><h4>[h2]使用图形变换属性变化组件</h4><p>在应用开发中，改动组件的布局显示可以通过改动布局属性、改动图形变换属性两种方式来实现。</p> <ul><li>方式一，改动布局属性<p>常见的布局属性包括位置、大小、内边距、外边距、对齐方式、权重等。当这些布局属性发生改变时，界面将重新布局以适应新的属性值。</p> </li><li>方式二，改动图形变换属性<p>图形变换属性是指对组件布局结果的变换操作，如平移、旋转、缩放等操作。通过改变这些图形变换属性，可以实现对组件布局完成后，在界面上的位置和形态进行动态变换。</p> </li></ul> <p>布局属性和图形变换属性的可替换关系如下表所示：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表2 </b></caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.14.5.2.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>图形变换属性</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.14.5.2.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>布局属性</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>rotate</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>/</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>translate</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>position、offset</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>scale</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>width、height、Size</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>transform</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>/</p> </td> </tr> </tbody></table> </div> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.87501828874033683552908525425817:50001231000000:2800:AF075053ABA992CF6778868E5B6E3B9290CFC256851F776A6472CB127C1F67C4.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>表格中的对应关系仅供参考，开发者可以自行发掘更多的替代关系。</p> </div></div> <p><strong>场景设计</strong></p> <p>针对同一界面多个图片同时缩放并位移的场景（如下图所示），分别通过改变布局属性、改变图形变换属性实现。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图11 </b>同一界面多个图片同时缩放并位移示意图</span><br/><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.92248451193609199577521442645034:50001231000000:2800:5E0E07D7580B617A2AEA5453C5913D70A626DA1F26DBF07DF524673261C4D2C1.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p><strong>改变布局属性</strong></p> <p>布局属性发生变化时，系统需要重新计算组件的位置和大小，然后进行重新布局。这个过程需要消耗大量的计算资源和时间，尤其是在界面中包含大量组件或者复杂布局时，性能开销会更加明显。</p> <p>通过组件的width、height、position属性来改变组件大小和位置，具体代码实现如下：</p>  <p><strong>改变图形变换属性</strong></p> <p>图形变换只是对组件的显示效果进行变换，而不会改变其在布局中的位置和大小，因此不会触发重新布局的计算过程。这使得使用图形变换属性来实现动画效果时，能够提升界面的流畅性和性能表现。</p> <p>通过组件的scale、translate属性来改变组件大小和位置，具体代码实现如下：</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct Index {\\n  @State imageScaleX: number = 1;\\n  @State imageScaleY: number = 1;\\n  @State imageTranslateX: number = 0;\\n  @State imageTranslateY: number = 0;\\n  build() {\\n    Column() {\\n      Image($r('app.media.like'))\\n        .scale({ x: this.imageScaleX, y: this.imageScaleY, centerX: 0, centerY: 0 })\\n        .translate({ x: this.imageTranslateX, y: this.imageTranslateY })\\n      // 其他相似布局\\n      …\\n      Button(\\\"图形变换属性\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() =&gt; {\\n          let doTimes = 10;\\n          // 按播放次数循环播放动画\\n          for (let i = 0; i &lt; doTimes; i++) {\\n            if (i % 2 == 0) {\\n              setTimeout(() =&gt; {\\n                animateTo({ duration: 1000 }, () =&gt; {\\n                  this.imageScaleX = 2;\\n                  this.imageScaleY = 2;\\n                  this.imageTranslateX = 15;\\n                  this.imageTranslateY = 15;\\n                })\\n              }, 1000 * i)\\n            } else {\\n              setTimeout(() =&gt; {\\n                animateTo({ duration: 1000 }, () =&gt; {\\n                  this.imageScaleX = 1;\\n                  this.imageScaleY = 1;\\n                  this.imageTranslateX = 0;\\n                  this.imageTranslateY = 0;\\n                })\\n              }, 1000 * i)\\n            }\\n          }\\n        })\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}</pre> <p><strong>性能分析</strong></p> <p>使用<span>IDE</span>的Profiler工具检测下述指标，得到的数据如下所示：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表3 </b><strong>改变布局属性、改变图形变换属性实现</strong><strong>相同场景</strong><strong>的指标对比</strong></caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.14.20.2.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"26.810000000000002%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.14.20.2.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"33.56%\\\"'><p>改变布局属性</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.14.20.2.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"39.629999999999995%\\\"'><p>改变图形变换属性</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.810000000000002%\\\"'><p>丢帧率（%）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.56%\\\"'><p>8.1%</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"39.629999999999995%\\\"'><p>3.7%</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.810000000000002%\\\"'><p>最大连续丢帧数（帧）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.56%\\\"'><p>8</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"39.629999999999995%\\\"'><p>2</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.810000000000002%\\\"'><p>平均1s大卡顿次数（次/s）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.56%\\\"'><p>0.48</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"39.629999999999995%\\\"'><p>0</p> </td> </tr> </tbody></table> </div> <p>分析结论：</p> <p>1）使用布局属性改变图片大小和位置时，丢帧率为8.1%，最多连续丢失8帧，平均每秒发生大卡顿0.48次。</p> <p>2）使用图形变化属性改变图片大小和位置时，丢帧率降到了3.7%，最多连续丢失2帧，在相同时长内没有发生大卡顿。</p> <p>这一结果表明，使用图形变化属性改变图片大小和位置时，能够显著降低丢帧率和大卡顿的发生频率。界面布局是非常耗时的操作，因此频繁地改动布局属性会导致界面性能下降，出现卡顿现象，影响用户体验。因此，在动画能够使用图形变化属性实现的情况下，开发者应尽量使用图形变化属性实现，保持动画的流畅性和稳定性，提升应用的性能表现。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-fair-use-animation.html"
    },
    {
        "id": 40,
        "pre": "@Entry\\n@Component\\nstruct MyComponent {\\n  @State w:number = 150\\n  @State h:number = 2\\n  @State brightNum:number = 1.5\\n  @State color:Color = Color.Red\\n  // 动画闭包1，设置宽度变化\\n  func1() {\\n    animateTo({curve: Curve.Sharp, duration: 1000}, () => {\\n      this.w = (this.w === 80 ? 150 : 80);\\n    });\\n  }\\n  // 动画闭包2，设置颜色变化\\n  func2() {\\n    animateTo({curve: Curve.Sharp, duration: 1000}, () => {\\n      this.color = (this.color === Color.Yellow ? Color.Red : Color.Yellow);\\n    });\\n  }\\n  // 动画闭包3，设置高度变化\\n  func3() {\\n    animateTo({curve: Curve.Sharp, duration: 1000}, () => {\\n      this.h = (this.h === 2 ? 5 : 2);\\n    });\\n  }\\n  // 动画闭包4，设置高光变化\\n  func4() {\\n    animateTo({curve: Curve.Sharp, duration: 1000}, () => {\\n      this.brightNum= (this.brightNum=== 1.5 ? 1 : 1.5);\\n    });\\n  }\\n  build() {\\n    Column() {\\n      Row()\\n        .width(this.w)\\n        .backgroundColor(this.color)\\n        .height(this.h)\\n        .brightness(this.brightNum)\\n      // 其他相似布局\\n      …\\n      Button(\\\"click nFunc\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() => {\\n          let doTimes = 10;\\n            // 按播放次数循环播放动画\\n            for (let i = 0; i < doTimes; i++) {\\n              setTimeout(() => {\\n                this.func1();\\n                this.func2();\\n                this.func3();\\n                this.func4();\\n              }, 1000 * i)\\n            }\\n        })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "func()",
        "function_name": "[h2]参数相同时使用同一个animateTo",
        "parent_text": "[h2]参数相同时使用同一个animateTo每次调用animateTo方法，都会触发一次属性变化，这意味着在每次动画执行时都需要进行动画前后的对比，以确定属性的变化情况。当多次连续调用animateTo时，会增加额外的布局计算和绘制开销，从而降低性能表现。特别是当这些animateTo操作针对同一个组件的属性时，会导致该组件更新的次数增加，进一步影响性能。 在实际开发中，如果多个属性需要以相同的动画参数进行变化，推荐将它们放到同一个动画闭包中执行。通过将多个属性的动画操作合并到同一个动画闭包中，可以减少对组件的多次更新，避免重复的布局计算和绘制操作，提升动画效果的性能。 除了性能方面的优势，将多个属性的动画操作合并到同一个动画闭包中还有助于提高代码的可读性和维护性。通过集中管理相关联的属性变化，可以使代码结构更加清晰，便于后续的维护和修改。 场景设计 针对多个相同组件同时修改多个属性的场景（如下图所示），分别使用多个animateTo闭包和一个animateTo闭包实现。 图12 多个相同组件同时修改多个属性示意图 代码实现 将相同动画参数的状态变量更新放在不同的动画闭包中，具体代码实现如下：  将相同动画参数的动画合并在一个动画闭包中，具体代码实现如下： @Entry\\n@Component\\nstruct MyComponent {\\n  @State w:number = 150\\n  @State h:number = 2\\n  @State brightNum:number = 1.5\\n  @State color:Color = Color.Red\\n  // 统一动画闭包，同时设置四个属性变化\\n  func() {\\n    animateTo({curve: Curve.Sharp, duration: 1000}, () => {\\n      this.w = (this.w === 80 ? 150 : 80);\\n      this.color = (this.color === Color.Yellow ? Color.Red : Color.Yellow);\\n      this.h = (this.h === 2 ? 5 : 2);\\n      this.brightNum= (this.brightNum=== 1.5 ? 1 : 1.5);\\n    });\\n  }\\n build() {\\n    Column() {\\n      Row()\\n        .width(this.w)\\n        .backgroundColor(this.color)\\n        .height(this.h)\\n        .brightness(this.brightNum)\\n      // 其他相似布局\\n      …\\n      Button(\\\"click oneFunc\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() => {\\n          let doTimes = 10;\\n          // 按播放次数循环播放动画\\n          for (let i = 0; i < doTimes; i++) {\\n            setTimeout(() => {\\n              this.func();\\n            }, 1000 * i)\\n          }\\n        })\\n    }\\n  }\\n} 性能分析 使用IDE的Profiler工具检测下述指标，得到的数据如下所示： 表4 使用多个animateTo闭包和一个animateTo闭包实现相同场景的指标对比   多个animateTo闭包  一个animateTo闭包    丢帧率（%）  9.6%  4.0%   最大连续丢帧数（帧）  9  4   平均1s大卡顿次数（次/s）  1.01  0.24     分析结论： 1）将四个属性变化动画分别放在四个animateTo动画闭包中，丢帧率为9.6%，最多连续丢失9帧，平均每秒发生大卡顿1.01次。 2）将四个属性变化动画合入一个animateTo动画闭包中，丢帧率降到了4.0%，最多连续丢失4帧，平均每秒发生大卡顿0.24次。 这一结果表明，将多个属性变化动画合并到同一个animateTo动画闭包中能够显著降低丢帧率和大卡顿的发生频率。合并动画操作可以减少不必要的布局计算和绘制开销，从而提升动画的流畅性和性能表现，有助于优化动画效果的性能。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1150051943714\\\"'><a name='\\\"section1150051943714\\\"'></a><a name='\\\"section1150051943714\\\"'></a><h4>[h2]参数相同时使用同一个animateTo</h4><p>每次调用animateTo方法，都会触发一次属性变化，这意味着在每次动画执行时都需要进行动画前后的对比，以确定属性的变化情况。当多次连续调用animateTo时，会增加额外的布局计算和绘制开销，从而降低性能表现。特别是当这些animateTo操作针对同一个组件的属性时，会导致该组件更新的次数增加，进一步影响性能。</p> <p>在实际开发中，如果多个属性需要以相同的动画参数进行变化，推荐将它们放到同一个动画闭包中执行。通过将多个属性的动画操作合并到同一个动画闭包中，可以减少对组件的多次更新，避免重复的布局计算和绘制操作，提升动画效果的性能。</p> <p>除了性能方面的优势，将多个属性的动画操作合并到同一个动画闭包中还有助于提高代码的可读性和维护性。通过集中管理相关联的属性变化，可以使代码结构更加清晰，便于后续的维护和修改。</p> <p><strong>场景设计</strong></p> <p>针对多个相同组件同时修改多个属性的场景（如下图所示），分别使用多个animateTo闭包和一个animateTo闭包实现。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图12 </b>多个相同组件同时修改多个属性示意图</span><br/><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.28124150149753400622895410281525:50001231000000:2800:C5A61D878CC9F316FB976F7053E3ABBCD4E6D2689DF74F7DB4A1005486637E50.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p><strong>代码实现</strong></p> <ul><li>将相同动画参数的状态变量更新放在不同的动画闭包中，具体代码实现如下：</li></ul>  <ul><li>将相同动画参数的动画合并在一个动画闭包中，具体代码实现如下：</li></ul> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct MyComponent {\\n  @State w:number = 150\\n  @State h:number = 2\\n  @State brightNum:number = 1.5\\n  @State color:Color = Color.Red\\n  // 统一动画闭包，同时设置四个属性变化\\n  func() {\\n    animateTo({curve: Curve.Sharp, duration: 1000}, () =&gt; {\\n      this.w = (this.w === 80 ? 150 : 80);\\n      this.color = (this.color === Color.Yellow ? Color.Red : Color.Yellow);\\n      this.h = (this.h === 2 ? 5 : 2);\\n      this.brightNum= (this.brightNum=== 1.5 ? 1 : 1.5);\\n    });\\n  }\\n build() {\\n    Column() {\\n      Row()\\n        .width(this.w)\\n        .backgroundColor(this.color)\\n        .height(this.h)\\n        .brightness(this.brightNum)\\n      // 其他相似布局\\n      …\\n      Button(\\\"click oneFunc\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() =&gt; {\\n          let doTimes = 10;\\n          // 按播放次数循环播放动画\\n          for (let i = 0; i &lt; doTimes; i++) {\\n            setTimeout(() =&gt; {\\n              this.func();\\n            }, 1000 * i)\\n          }\\n        })\\n    }\\n  }\\n}</pre> <p><strong>性能分析</strong></p> <p>使用<span>IDE</span>的Profiler工具检测下述指标，得到的数据如下所示：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表4 </b><strong>使用多个animateTo闭包和一个animateTo闭包实现</strong><strong>相同场景</strong><strong>的指标对比</strong></caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.15.2.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"26.810000000000002%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.15.2.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"33.56%\\\"'><p>多个animateTo闭包</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.15.2.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"39.629999999999995%\\\"'><p>一个animateTo闭包</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.810000000000002%\\\"'><p>丢帧率（%）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.56%\\\"'><p>9.6%</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"39.629999999999995%\\\"'><p>4.0%</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.810000000000002%\\\"'><p>最大连续丢帧数（帧）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.56%\\\"'><p>9</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"39.629999999999995%\\\"'><p>4</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.810000000000002%\\\"'><p>平均1s大卡顿次数（次/s）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.56%\\\"'><p>1.01</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"39.629999999999995%\\\"'><p>0.24</p> </td> </tr> </tbody></table> </div> <p>分析结论：</p> <p>1）将四个属性变化动画分别放在四个animateTo动画闭包中，丢帧率为9.6%，最多连续丢失9帧，平均每秒发生大卡顿1.01次。</p> <p>2）将四个属性变化动画合入一个animateTo动画闭包中，丢帧率降到了4.0%，最多连续丢失4帧，平均每秒发生大卡顿0.24次。</p> <p>这一结果表明，将多个属性变化动画合并到同一个animateTo动画闭包中能够显著降低丢帧率和大卡顿的发生频率。合并动画操作可以减少不必要的布局计算和绘制开销，从而提升动画的流畅性和性能表现，有助于优化动画效果的性能。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-fair-use-animation.html"
    },
    {
        "id": 41,
        "pre": "@Entry\\n@Component\\nstruct MyComponent {\\n  @State w: number = 100\\n  @State h: number = 2\\n  @State color: Color = Color.Red\\n  build() {\\n    Column() {\\n      Row()\\n        .width(this.w)\\n        .backgroundColor(this.color)\\n        .height(this.h)\\n      // 其他相似布局\\n      …\\n      Button(\\\"click1\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() => {\\n          let doTimes = 5;\\n          for (let i = 0; i < doTimes; i++) {\\n            setTimeout(() => {\\n              this.w = 80\\n              // h是非动画属性\\n              this.h = 4\\n              animateTo({ curve: Curve.Sharp, duration: 1000 }, () => {\\n                this.w = (this.w === 80 ? 150 : 80);\\n              });\\n              // 在两个animateTo之间更新状态变量\\n              this.color = Color.Yellow\\n              animateTo({ curve: Curve.Linear, duration: 2000 }, () => {\\n                this.color = (this.color === Color.Yellow ? Color.Red : Color.Yellow);\\n              });\\n            }, 2000 * i)\\n          }\\n        })\\n     }\\n  }\\n}",
        "type": "Reference",
        "function_call": "Row()",
        "function_name": "[h2]多次animateTo时统一更新状态变量",
        "parent_text": "[h2]多次animateTo时统一更新状态变量使用animateTo方法执行动画时，会对执行动画闭包前后的状态进行对比，然后只对差异部分进行动画处理。 在动画执行过程中，脏节点是指在界面上需要进行重新绘制的区域。如果状态发生了变化，ArkUI会跟踪这些变化，并在动画闭包执行前进行状态对比，相关的脏节点会被标记为需要刷新，以便在动画闭包执行前对这些脏节点进行重新绘制。这样，只有发生变化的部分才会被纳入动画处理，而不需要重新绘制整个界面。 这种差异对比的方式能够显著减少不必要的绘制操作，提高动画的性能和流畅度。 场景设计 针对多个相同组件修改多个属性进行动画的场景（如下图所示），分别使用在多个animateTo之间更新状态变量、在animateTo之前显式指定属性初值、在animateTo之前使用原始状态实现。 图13 多个相同组件修改多个属性示意图 在多个animateTo之间更新状态变量 如果多个animateTo之间存在状态更新，会导致执行下一个animateTo之前又存在需要更新的脏节点，可能造成冗余更新，其动画更新流程如下图所示： 图14 多个animateTo之间更新状态变量更新流程 在第一个animateTo前，重新设置了w属性，所以Row组件需要更新一次。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件又需要更新一次并对比产生宽高动画。第二个animateTo前，重新设置了color属性，所以Row组件又需要更新一次。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了4次属性。 此外还更改了与动画无关的状态h，如果不需要改变无关状态，则不应改变造成冗余更新。 其具体代码实现如下：  统一更新状态变量 在animateTo之前显式指定属性初值 在animateTo之前显式的指定所有需要动画的属性初值，统一更新到节点中，然后再做动画，其动画更新流程如下图所示： 图15 animateTo之前显式指定属性初值更新流程 在第一个animateTo之前，重新设置了w和color属性，所以Row需要更新一次。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件需要更新一次并对比产生宽高动画。在第二个animateTo之前，由于没有执行额外的语句，不存在需要更新的脏状态变量和脏节点，无需更新。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了3次属性。 其具体代码实现如下： @Entry\\n@Component\\nstruct MyComponent {\\n  @State w: number = 100\\n  @State h: number = 2\\n  @State color: Color = Color.Red\\n  build() {\\n    Column() {\\n      Row()\\n        .width(this.w)\\n        .backgroundColor(this.color)\\n        .height(this.h)\\n      // 其他相似布局\\n      …\\n      Button(\\\"click2\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() => {\\n          let doTimes = 5;\\n          for (let i = 0; i < doTimes; i++) {\\n            setTimeout(() => {\\n              // 在动画之前显式的指定所有需要动画的属性初值\\n              this.w = 80\\n              this.color = Color.Yellow\\n              // 动画1，修改宽度\\n              animateTo({ curve: Curve.Sharp, duration: 1000 }, () => {\\n                this.w = (this.w === 80 ? 150 : 80);\\n              });\\n              // 动画2，修改颜色\\n              animateTo({ curve: Curve.Linear, duration: 2000 }, () => {\\n                this.color = (this.color === Color.Yellow ? Color.Red : Color.Yellow);\\n              });\\n              // 动画完成后刷新非动画属性\\n              this.h = 5\\n            }, 2000 * i)\\n          }\\n        })\\n     }\\n  }\\n} 在animateTo之前使用原始状态 在animateTo之前使用原始状态，让动画从原始状态过渡到指定状态，其动画更新流程如下图所示： 图16 animateTo之前使用原始状态更新流程 在第一个animateTo之前，不存在需要更新的脏状态变量和脏节点，无需更新。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件需要更新一次并对比产生宽高动画。在第二个animateTo之前，由于也没有执行额外的语句，不存在需要更新的脏状态变量和脏节点，无需更新。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了2次属性。 其具体代码实现如下： @Entry\\n@Component\\nstruct MyComponent {\\n  //原始状态\\n  @State w: number = 80\\n  @State h: number = 5\\n  @State color: Color = Color.Yellow\\n  build() {\\n    Column() {\\n      Row()\\n        .width(this.w)\\n        .backgroundColor(this.color)\\n        .height(this.h)\\n      // 其他相似布局\\n      …\\n      Button(\\\"click3\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() => {\\n          let doTimes = 5;\\n          for (let i = 0; i < doTimes; i++) {\\n            // 直接使用原始状态实现动画\\n            setTimeout(() => {\\n              animateTo({ curve: Curve.Sharp, duration: 1000 }, () => {\\n                this.w = (this.w === 80 ? 150 : 80);\\n              });\\n              animateTo({ curve: Curve.Linear, duration: 2000 }, () => {\\n                this.color = (this.color === Color.Yellow ? Color.Red : Color.Yellow);\\n              });\\n            }, 2000 * i)\\n          }\\n        })\\n     }\\n  }\\n} 性能分析 使用IDE的Profiler工具检测下述指标，得到的数据如下所示： 表5 状态变量更新位置不同的指标对比   在多个animateTo之间更新状态变量  在animateTo之前显式指定属性初值  在animateTo之前使用原始状态    丢帧率（%）  9.1%  5.4%  3.5%   最大连续丢帧数（帧）  15  10  5   平均1s大卡顿次数（次/s）  0.67  0.23  0.10     分析结论： 1）在多个animateTo之间更新状态变量时，丢帧率高达9.1%，最大连续丢失15帧，平均每秒发生大卡顿0.67次。 2）在animateTo之前显式指定属性初值时，丢帧率降到了5.4%，最多连续丢失10帧，平均每秒发生大卡顿0.23次。 3）在animateTo之前使用原始状态时，丢帧率降到了3.5%，最多连续丢失5帧，平均每秒发生大卡顿0.10次。 在进行属性变化动画时，显式指定属性初值或者使用原始状态作为动画的起始状态能够显著降低丢帧率和大卡顿的发生频率。因此，在进行动画操作时，合理管理状态变量的更新和初始值设定对于优化动画效果的性能至关重要，开发者应根据需要，尽可能地避免在多个animateTo之间更新状态变量，从而提升动画的流畅性和性能表现。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section2396161284213\\\"'><a name='\\\"section2396161284213\\\"'></a><a name='\\\"section2396161284213\\\"'></a><h4>[h2]多次animateTo时统一更新状态变量</h4><p>使用animateTo方法执行动画时，会对执行动画闭包前后的状态进行对比，然后只对差异部分进行动画处理。</p> <p>在动画执行过程中，脏节点是指在界面上需要进行重新绘制的区域。如果状态发生了变化，ArkUI会跟踪这些变化，并在动画闭包执行前进行状态对比，相关的脏节点会被标记为需要刷新，以便在动画闭包执行前对这些脏节点进行重新绘制。这样，只有发生变化的部分才会被纳入动画处理，而不需要重新绘制整个界面。</p> <p>这种差异对比的方式能够显著减少不必要的绘制操作，提高动画的性能和流畅度。</p> <p><strong>场景设计</strong></p> <p>针对多个相同组件修改多个属性进行动画的场景（如下图所示），分别使用在多个animateTo之间更新状态变量、在animateTo之前显式指定属性初值、在animateTo之前使用原始状态实现。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图13 </b>多个相同组件修改多个属性示意图</span><br/><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.34899418487307144047381312779237:50001231000000:2800:518E2B1837FEF3388A8770A19A68BAA96759A7B5C216744E1CA35E8C29E42343.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p><strong>在多个animateTo之间更新状态变量</strong></p> <p>如果多个animateTo之间存在状态更新，会导致执行下一个animateTo之前又存在需要更新的脏节点，可能造成冗余更新，其动画更新流程如下图所示：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图14 </b>多个animateTo之间更新状态变量更新流程</span><br/><span><img height='\\\"70.948185\\\"' originheight='\\\"116\\\"' originwidth='\\\"1552\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161110.70804351354416140958307394110884:50001231000000:2800:CF97C4E5397A584B18F029A7A2B0E21909298233790828F951458B8375FF7FD5.png\\\"' title='\\\"点击放大\\\"' width='\\\"949.5162600000001\\\"'/></span></div> <p>在第一个animateTo前，重新设置了w属性，所以Row组件需要更新一次。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件又需要更新一次并对比产生宽高动画。第二个animateTo前，重新设置了color属性，所以Row组件又需要更新一次。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了4次属性。</p> <p>此外还更改了与动画无关的状态h，如果不需要改变无关状态，则不应改变造成冗余更新。</p> <p>其具体代码实现如下：</p>  <p><strong>统一更新状态变量</strong></p> <ul><li>在animateTo之前显式指定属性初值</li></ul> <p>在animateTo之前显式的指定所有需要动画的属性初值，统一更新到节点中，然后再做动画，其动画更新流程如下图所示：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图15 </b>animateTo之前显式指定属性初值更新流程</span><br/><span><img height='\\\"75.479362\\\"' originheight='\\\"116\\\"' originwidth='\\\"1240\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161111.65254233015935952931098169849460:50001231000000:2800:6795F3C4A96BD89ADD86046649F0EB26154756D8187E78295341B7B67F6386B9.png\\\"' title='\\\"点击放大\\\"' width='\\\"806.9775000000001\\\"'/></span></div> <p>在第一个animateTo之前，重新设置了w和color属性，所以Row需要更新一次。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件需要更新一次并对比产生宽高动画。在第二个animateTo之前，由于没有执行额外的语句，不存在需要更新的脏状态变量和脏节点，无需更新。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了3次属性。</p> <p>其具体代码实现如下：</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct MyComponent {\\n  @State w: number = 100\\n  @State h: number = 2\\n  @State color: Color = Color.Red\\n  build() {\\n    Column() {\\n      Row()\\n        .width(this.w)\\n        .backgroundColor(this.color)\\n        .height(this.h)\\n      // 其他相似布局\\n      …\\n      Button(\\\"click2\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() =&gt; {\\n          let doTimes = 5;\\n          for (let i = 0; i &lt; doTimes; i++) {\\n            setTimeout(() =&gt; {\\n              // 在动画之前显式的指定所有需要动画的属性初值\\n              this.w = 80\\n              this.color = Color.Yellow\\n              // 动画1，修改宽度\\n              animateTo({ curve: Curve.Sharp, duration: 1000 }, () =&gt; {\\n                this.w = (this.w === 80 ? 150 : 80);\\n              });\\n              // 动画2，修改颜色\\n              animateTo({ curve: Curve.Linear, duration: 2000 }, () =&gt; {\\n                this.color = (this.color === Color.Yellow ? Color.Red : Color.Yellow);\\n              });\\n              // 动画完成后刷新非动画属性\\n              this.h = 5\\n            }, 2000 * i)\\n          }\\n        })\\n     }\\n  }\\n}</pre> <ul><li>在animateTo之前使用原始状态</li></ul> <p>在animateTo之前使用原始状态，让动画从原始状态过渡到指定状态，其动画更新流程如下图所示：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图16 </b>animateTo之前使用原始状态更新流程</span><br/><span><img height='\\\"82.7925\\\"' originheight='\\\"148\\\"' originwidth='\\\"928\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161111.45036443702533090452894560636576:50001231000000:2800:54F1F127E7482AAFBEF303385AA4972AEA4B40CDAA9D8BCE0E88C253D474C89B.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></div> <p>在第一个animateTo之前，不存在需要更新的脏状态变量和脏节点，无需更新。在第一个animateTo的动画闭包中，改变了w属性，所以Row组件需要更新一次并对比产生宽高动画。在第二个animateTo之前，由于也没有执行额外的语句，不存在需要更新的脏状态变量和脏节点，无需更新。在第二个animateTo的动画闭包中，改变了color属性，所以Row组件再更新一次并产生了背景色动画。Row组件总共更新了2次属性。</p> <p>其具体代码实现如下：</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct MyComponent {\\n  //原始状态\\n  @State w: number = 80\\n  @State h: number = 5\\n  @State color: Color = Color.Yellow\\n  build() {\\n    Column() {\\n      Row()\\n        .width(this.w)\\n        .backgroundColor(this.color)\\n        .height(this.h)\\n      // 其他相似布局\\n      …\\n      Button(\\\"click3\\\")\\n        // 按键属性设置\\n        …\\n        .onClick(() =&gt; {\\n          let doTimes = 5;\\n          for (let i = 0; i &lt; doTimes; i++) {\\n            // 直接使用原始状态实现动画\\n            setTimeout(() =&gt; {\\n              animateTo({ curve: Curve.Sharp, duration: 1000 }, () =&gt; {\\n                this.w = (this.w === 80 ? 150 : 80);\\n              });\\n              animateTo({ curve: Curve.Linear, duration: 2000 }, () =&gt; {\\n                this.color = (this.color === Color.Yellow ? Color.Red : Color.Yellow);\\n              });\\n            }, 2000 * i)\\n          }\\n        })\\n     }\\n  }\\n}</pre> <p><strong>性能分析</strong></p> <p>使用<span>IDE</span>的Profiler工具检测下述指标，得到的数据如下所示：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表5 </b><strong>状态变量更新位置不同的指标对比</strong></caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.16.30.2.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"20.86%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.16.30.2.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"22.21%\\\"'><p>在多个animateTo之间更新状态变量</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.16.30.2.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"26.1%\\\"'><p>在animateTo之前显式指定属性初值</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.16.30.2.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"30.830000000000002%\\\"'><p>在animateTo之前使用原始状态</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"20.86%\\\"'><p>丢帧率（%）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.21%\\\"'><p>9.1%</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.1%\\\"'><p>5.4%</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"30.830000000000002%\\\"'><p>3.5%</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"20.86%\\\"'><p>最大连续丢帧数（帧）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.21%\\\"'><p>15</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.1%\\\"'><p>10</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"30.830000000000002%\\\"'><p>5</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"20.86%\\\"'><p>平均1s大卡顿次数（次/s）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.21%\\\"'><p>0.67</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.1%\\\"'><p>0.23</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"30.830000000000002%\\\"'><p>0.10</p> </td> </tr> </tbody></table> </div> <p>分析结论：</p> <p>1）在多个animateTo之间更新状态变量时，丢帧率高达9.1%，最大连续丢失15帧，平均每秒发生大卡顿0.67次。</p> <p>2）在animateTo之前显式指定属性初值时，丢帧率降到了5.4%，最多连续丢失10帧，平均每秒发生大卡顿0.23次。</p> <p>3）在animateTo之前使用原始状态时，丢帧率降到了3.5%，最多连续丢失5帧，平均每秒发生大卡顿0.10次。</p> <p>在进行属性变化动画时，显式指定属性初值或者使用原始状态作为动画的起始状态能够显著降低丢帧率和大卡顿的发生频率。因此，在进行动画操作时，合理管理状态变量的更新和初始值设定对于优化动画效果的性能至关重要，开发者应根据需要，尽可能地避免在多个animateTo之间更新状态变量，从而提升动画的流畅性和性能表现。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-fair-use-animation.html"
    },
    {
        "id": 42,
        "pre": "// IconItem.ets\\n@Component\\nexport  struct IconItem {\\n  @StorageLink('renderGroupFlag') renderGroupFlag: boolean = false;\\n  image: string | Resource = '';\\n  text: string | Resource = '';\\n\\n  build() {\\n    Flex({\\n      direction: FlexDirection.Column,\\n      justifyContent: FlexAlign.Center,\\n      alignContent: FlexAlign.Center\\n    }) {\\n      Image(this.image)\\n        .height(20)\\n        .width(20)\\n        .objectFit(ImageFit.Contain)\\n        .margin({ left: 15 })\\n\\n      Text(this.text)\\n        .fontSize(10)\\n        .fontColor(\\\"#182431\\\")\\n        .margin({ top: 5 })\\n        .width(50)\\n        .opacity(0.8)\\n        .textAlign(TextAlign.Center)\\n    }\\n    .backgroundColor('#e3e3e3')\\n    .width(50)\\n    .height(50)\\n    .borderRadius(25)\\n    // 在IconItem内调用renderGroup，false为关闭，true为开启\\n    .renderGroup(this.renderGroupFlag)\\n  }\\n}",
        "type": "Reference",
        "function_call": "GridCol()",
        "function_name": "[h2]使用renderGroup",
        "parent_text": "[h2]使用renderGrouprenderGroup是组件通用方法，它代表了渲染绘制的一个组合。其核心功能就是标记组件，在绘制阶段将组件和其子组件的绘制结果进行合并并缓存，以达到复用的效果，从而降低绘制负载。 首次绘制组件时，若组件被标记为启用renderGroup状态，将对组件和其子组件进行离屏绘制，将绘制结果进行缓存。此后当需要重新绘制组件时，就会优先使用缓存而不必重新绘制，从而降低绘制负载，优化渲染性能。组件渲染流程图如下所示： 图17 组件渲染流程图 在进行缓存更新时，需要满足以下三个条件： 组件在当前组件树上。组件renderGroup被标记为true。组件内容被标脏。 在进行缓存清理时，需要满足以下任意条件： 组件不存在于组件树上。组件renderGroup被标记为false。 具体缓存管理流程图如下所示：   为了能使renderGroup功能生效，组件存在以下约束。 组件内容固定不变：父组件和其子组件各属性保持固定，不发生变化。如果父组件内容不是固定的，也就是说其子组件中上存在某些属性变化或者样式变化的组件，此时如果使用renderGroup，那么缓存的利用率将大大下降，并且有可能需要不断执行缓存更新逻辑，在这种情况下，不仅不能优化卡顿效果，甚至还可能使卡顿恶化。例如：文本内容使用双向绑定的动态数据；图片资源使用gif格式；使用video组件播放视频。子组件无动效：由父组件统一应用动效，其子组件均无动效。如果子组件上也应用动效，那么子组件相对父组件就不再是静止的，每一帧都有可能需要更新缓存，更新逻辑同样需要消耗系统资源。  场景设计 此案例在同一个页面下使用了固定的图片和文本内容，并且每个组件统一使用旋转和缩放的动效，并且重复使用了60个这样的组件。 图18 renderGroup案例实现图 代码实现 实现页面中需要使用的组件，并设置renderGroup属性，用@StorageLink修饰绑定renderGroupFlag标识。renderGroup属性的设置要满足父组件统一应用动效，子组件无动效，所以，动效在父组件上统一实现，未在IconItem上设置动效。在Flex组件中，Image和Text都无动效设置，所以在最外层Flex上设置renderGroup属性即可。 具体代码如下所示：  实现展示的页面，将控制renderGroup的标识renderGroupFlag通过APPStorage进行存储。 // Index.ets\\nimport { IconItem } from './IconItem'\\n\\n// IconItem相关数据\\nclass IconItemSource {\\n  image: string | Resource = ''\\n  text: string | Resource = ''\\n\\n  constructor(image: string | Resource = '', text: string | Resource = '') {\\n    this.image = image;\\n    this.text = text;\\n  }\\n}\\n\\n@Entry\\n@Component\\nstruct Index {\\n  // renderGroup接口是否开启\\n  @State renderGroupFlag: boolean = false;\\n  private iconItemSourceList: IconItemSource[] = [];\\n\\n  aboutToAppear() {\\n    // 遍历添加60个IconItem的数据\\n    for (let index = 0; index < 20; index++) {\\n      const numStart: number = index * 3;\\n      // 此处循环使用三张图片资源\\n      this.iconItemSourceList.push(\\n        new IconItemSource($r('app.media.album'), `item${numStart + 1}`),\\n        new IconItemSource($r('app.media.applet'), `item${numStart + 2}`),\\n        new IconItemSource($r('app.media.cards'), `item${numStart + 3}`),\\n      );\\n    }\\n  }\\n\\n  build() {\\n    Column() {\\n      Row() {\\n        Row() {\\n          Text('场景示例')\\n            .fontSize(24)\\n            .lineHeight(24)\\n            .fontColor(Color.Black)\\n            .fontWeight(FontWeight.Bold)\\n            .margin({ left: 30 })\\n        }\\n\\n        // 动态切换renderGroup功能\\n        Stack({ alignContent: Alignment.End }) {\\n          Button(this.renderGroupFlag ? 'renderGroup已开启' : 'renderGroup已关闭', {\\n            type: ButtonType.Normal,\\n            stateEffect: true\\n          })\\n            .fontSize(12)\\n            .borderRadius(8)\\n            .backgroundColor(0x317aff)\\n            .width(150)\\n            .height(30)\\n            .margin({ right: 30 })\\n            .onClick(() => {\\n              this.renderGroupFlag = !this.renderGroupFlag;\\n              AppStorage.setOrCreate('renderGroupFlag', this.renderGroupFlag)\\n            })\\n        }\\n      }\\n      .height(56)\\n      .width('100%')\\n      .backgroundColor(Color.White)\\n      .justifyContent(FlexAlign.SpaceBetween)\\n\\n      // IconItem放置在grid内\\n      GridRow({\\n        columns: 6,\\n        gutter: { x: 0, y: 0 },\\n        breakpoints: { value: [\\\"400vp\\\", \\\"600vp\\\", \\\"800vp\\\"],\\n          reference: BreakpointsReference.WindowSize },\\n        direction: GridRowDirection.Row\\n      }) {\\n        ForEach(this.iconItemSourceList, (item: IconItemSource) => {\\n          GridCol() {\\n            IconItem({ image: item.image, text: item.text })\\n              .transition(\\n                TransitionEffect.scale({ x: 0.5, y: 0.5 })\\n                  .animation({duration: 3000, curve: Curve.FastOutSlowIn, iterations: -1 })\\n                  .combine(TransitionEffect.rotate({ z: 1, angle: 360 })\\n                    .animation({ duration: 3000, curve: Curve.Linear, iterations: -1 }))\\n              )\\n          }\\n          .height(70)\\n          .width('25%')\\n        })\\n      }\\n      .width(\\\"100%\\\")\\n      .height(\\\"100%\\\")\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .alignItems(HorizontalAlign.Center)\\n  }\\n} 性能分析 使用IDE的Profiler工具检测下述指标，得到的数据如下所示： 表6 未开启renderGroup、开启renderGroup相同场景的指标对比   未开启renderGroup  开启renderGroup    丢帧率（%）  52.3%  0%   最大连续丢帧数（帧）  36  0   平均1s大卡顿次数（次/s）  2.3  0     分析结论： 1）未开启renderGroup时，在render_service侧的丢帧率为52.3%，最多连续丢失36帧，平均每秒发生大卡顿2.3次。 2）开启renderGroup时，既没有发生卡顿，也没有发生丢帧的情况，其丢帧率为0%。 这一结果表明，在满足上述的约束后，使用renderGroup时，能够显著降低丢帧率、最大连续丢帧数和平均1s大卡顿次数。因此，在单一页面上存在大量应用动效的组件，且组件和其子组件各属性保持固定、组件统一应用动效时，开发者可以使用renderGroup来提升应用的性能，保证应用及动画的流畅性。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1223162922415\\\"'><a name='\\\"section1223162922415\\\"'></a><a name='\\\"section1223162922415\\\"'></a><h4>[h2]使用renderGroup</h4><p>renderGroup是组件通用方法，它代表了渲染绘制的一个组合。其核心功能就是标记组件，在绘制阶段将组件和其子组件的绘制结果进行合并并缓存，以达到复用的效果，从而降低绘制负载。</p> <p>首次绘制组件时，若组件被标记为启用renderGroup状态，将对组件和其子组件进行离屏绘制，将绘制结果进行缓存。此后当需要重新绘制组件时，就会优先使用缓存而不必重新绘制，从而降低绘制负载，优化渲染性能。组件渲染流程图如下所示：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图17 </b>组件渲染流程图</span><br/><span><img height='\\\"243.39000000000001\\\"' originheight='\\\"624\\\"' originwidth='\\\"1339\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161111.92096449793215143736275238628133:50001231000000:2800:E5ABFA8D403C076D1EAA02679B30C6BFD48BFC1A51F7CD7BB2493055F93E4CC3.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></div> <p>在进行缓存更新时，需要满足以下三个条件：</p> <ul><li>组件在当前组件树上。</li><li>组件renderGroup被标记为true。</li><li>组件内容被标脏。</li></ul> <p>在进行缓存清理时，需要满足以下任意条件：</p> <ul><li>组件不存在于组件树上。</li><li>组件renderGroup被标记为false。</li></ul> <p>具体缓存管理流程图如下所示：</p> <p><span><img height='\\\"169.57500000000002\\\"' originheight='\\\"467\\\"' originwidth='\\\"1442\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161111.67004944126293317519915809979707:50001231000000:2800:14B54193F6CFECC4F8DED8168F1C608F95AF82B30AFD6E3C3747E749AE80470C.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></p> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161111.70927614354350065404630515768672:50001231000000:2800:ACF621AFABC384DD506ADAE558FEB0440760FD074CB99908EAF3CA12EF908864.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>为了能使renderGroup功能生效，组件存在以下约束。</p> <ul><li>组件内容固定不变：父组件和其子组件各属性保持固定，不发生变化。如果父组件内容不是固定的，也就是说其子组件中上存在某些属性变化或者样式变化的组件，此时如果使用renderGroup，那么缓存的利用率将大大下降，并且有可能需要不断执行缓存更新逻辑，在这种情况下，不仅不能优化卡顿效果，甚至还可能使卡顿恶化。例如：文本内容使用双向绑定的动态数据；图片资源使用gif格式；使用video组件播放视频。</li><li>子组件无动效：由父组件统一应用动效，其子组件均无动效。如果子组件上也应用动效，那么子组件相对父组件就不再是静止的，每一帧都有可能需要更新缓存，更新逻辑同样需要消耗系统资源。</li></ul> </div></div> <p><strong>场景设计</strong></p> <p>此案例在同一个页面下使用了固定的图片和文本内容，并且每个组件统一使用旋转和缩放的动效，并且重复使用了60个这样的组件。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图18 </b>renderGroup案例实现图</span><br/><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161111.43350355365109414272026604989636:50001231000000:2800:7F922CE161E537C9108EB34AD4CCAC2734E764EDFC931279229309E779C746AA.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p><strong>代码实现</strong></p> <p>实现页面中需要使用的组件，并设置renderGroup属性，用@StorageLink修饰绑定renderGroupFlag标识。renderGroup属性的设置要满足父组件统一应用动效，子组件无动效，所以，动效在父组件上统一实现，未在IconItem上设置动效。在Flex组件中，Image和Text都无动效设置，所以在最外层Flex上设置renderGroup属性即可。</p> <p>具体代码如下所示：</p>  <p>实现展示的页面，将控制renderGroup的标识renderGroupFlag通过APPStorage进行存储。</p> <pre class='\\\"screen\\\"'>// Index.ets\\nimport { IconItem } from './IconItem'\\n\\n// IconItem相关数据\\nclass IconItemSource {\\n  image: string | Resource = ''\\n  text: string | Resource = ''\\n\\n  constructor(image: string | Resource = '', text: string | Resource = '') {\\n    this.image = image;\\n    this.text = text;\\n  }\\n}\\n\\n@Entry\\n@Component\\nstruct Index {\\n  // renderGroup接口是否开启\\n  @State renderGroupFlag: boolean = false;\\n  private iconItemSourceList: IconItemSource[] = [];\\n\\n  aboutToAppear() {\\n    // 遍历添加60个IconItem的数据\\n    for (let index = 0; index &lt; 20; index++) {\\n      const numStart: number = index * 3;\\n      // 此处循环使用三张图片资源\\n      this.iconItemSourceList.push(\\n        new IconItemSource($r('app.media.album'), `item${numStart + 1}`),\\n        new IconItemSource($r('app.media.applet'), `item${numStart + 2}`),\\n        new IconItemSource($r('app.media.cards'), `item${numStart + 3}`),\\n      );\\n    }\\n  }\\n\\n  build() {\\n    Column() {\\n      Row() {\\n        Row() {\\n          Text('场景示例')\\n            .fontSize(24)\\n            .lineHeight(24)\\n            .fontColor(Color.Black)\\n            .fontWeight(FontWeight.Bold)\\n            .margin({ left: 30 })\\n        }\\n\\n        // 动态切换renderGroup功能\\n        Stack({ alignContent: Alignment.End }) {\\n          Button(this.renderGroupFlag ? 'renderGroup已开启' : 'renderGroup已关闭', {\\n            type: ButtonType.Normal,\\n            stateEffect: true\\n          })\\n            .fontSize(12)\\n            .borderRadius(8)\\n            .backgroundColor(0x317aff)\\n            .width(150)\\n            .height(30)\\n            .margin({ right: 30 })\\n            .onClick(() =&gt; {\\n              this.renderGroupFlag = !this.renderGroupFlag;\\n              AppStorage.setOrCreate('renderGroupFlag', this.renderGroupFlag)\\n            })\\n        }\\n      }\\n      .height(56)\\n      .width('100%')\\n      .backgroundColor(Color.White)\\n      .justifyContent(FlexAlign.SpaceBetween)\\n\\n      // IconItem放置在grid内\\n      GridRow({\\n        columns: 6,\\n        gutter: { x: 0, y: 0 },\\n        breakpoints: { value: [\\\"400vp\\\", \\\"600vp\\\", \\\"800vp\\\"],\\n          reference: BreakpointsReference.WindowSize },\\n        direction: GridRowDirection.Row\\n      }) {\\n        ForEach(this.iconItemSourceList, (item: IconItemSource) =&gt; {\\n          GridCol() {\\n            IconItem({ image: item.image, text: item.text })\\n              .transition(\\n                TransitionEffect.scale({ x: 0.5, y: 0.5 })\\n                  .animation({duration: 3000, curve: Curve.FastOutSlowIn, iterations: -1 })\\n                  .combine(TransitionEffect.rotate({ z: 1, angle: 360 })\\n                    .animation({ duration: 3000, curve: Curve.Linear, iterations: -1 }))\\n              )\\n          }\\n          .height(70)\\n          .width('25%')\\n        })\\n      }\\n      .width(\\\"100%\\\")\\n      .height(\\\"100%\\\")\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .alignItems(HorizontalAlign.Center)\\n  }\\n}</pre> <p><strong>性能分析</strong></p> <p>使用<span>IDE</span>的Profiler工具检测下述指标，得到的数据如下所示：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表6 </b>未开启renderGroup、开启renderGroup相同场景的指标对比</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.23.2.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.23.2.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>未开启renderGroup</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.23.2.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>开启renderGroup</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>丢帧率（%）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>52.3%</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>0%</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>最大连续丢帧数（帧）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>36</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>0</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>平均1s大卡顿次数（次/s）</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>2.3</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>0</p> </td> </tr> </tbody></table> </div> <p>分析结论：</p> <p>1）未开启renderGroup时，在render_service侧的丢帧率为52.3%，最多连续丢失36帧，平均每秒发生大卡顿2.3次。</p> <p>2）开启renderGroup时，既没有发生卡顿，也没有发生丢帧的情况，其丢帧率为0%。</p> <p>这一结果表明，在满足上述的约束后，使用renderGroup时，能够显著降低丢帧率、最大连续丢帧数和平均1s大卡顿次数。因此，在单一页面上存在大量应用动效的组件，且组件和其子组件各属性保持固定、组件统一应用动效时，开发者可以使用renderGroup来提升应用的性能，保证应用及动画的流畅性。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-fair-use-animation.html"
    },
    {
        "id": 43,
        "pre": "vec2 baseCoord = ve2(0.0);\\nvec2 offset[4] = {...};\\nfloat weight[4] = {...};\\nvec4 color = vec4(0.0);\\nfor (int i = 0; i < 4; i++) {\\n    color += weight[i] * texture(texSampler, baseCoord + offset[i]);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在shader中如果需要用同一个sampler对同一个纹理多次采样的结果进行加权处理（比如模糊处理）并且权值和坐标是都mediump，建议可以使用base采样坐标加多组偏移的方式进行采样，并且用一层for循环进行多次采样加权操作。base采样坐标、偏移值和加权值需要是uniform，例如编译时常量或者来自uniform buffer（循环次数为编译时常量，最大为64）。 ",
        "import_module": null,
        "parent": "<li>在shader中如果需要用同一个sampler对同一个纹理多次采样的结果进行加权处理（比如模糊处理）并且权值和坐标是都mediump，建议可以使用base采样坐标加多组偏移的方式进行采样，并且用一层for循环进行多次采样加权操作。base采样坐标、偏移值和加权值需要是uniform，例如编译时常量或者来自uniform buffer（循环次数为编译时常量，最大为64）。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-maleoon-gpu-best-practices.html"
    },
    {
        "id": 44,
        "pre": "struct unity_ Type {\\n    vec4 vecArrA[4];\\n    vec4 vecArrB[4];\\n};\\nlayout(std140) uniform UnityInstancing_PerDraw0 {\\n    unity_Type unity_Array[32];\\n};\\nvoid main() {\\n    u_xlati0 = gl_InstanceID + unity_BaseInstanceID;\\n    u_xlati0 = u_xlati0 << 2;\\n    u_xlat1.yw = (-_mhyWorldOffset.zx) + unity_Array[u_xlati0 / 4].vecArrA[3].zx;\\n}",
        "type": "Reference",
        "function_call": "nvoid main()",
        "function_name": "[h2]Vertex shading",
        "parent_text": "[h2]Vertex shading1. 精度 为了规避Vertex shader计算位置信息的偏差导致后续shader stage误差放大，Maleoon GPU上vertex shader精度统一按照highp实现。 【推荐】 建议使用highp设置。 2. InstanceID InstanceID经常会参与uniform buffer索引值的计算，此种情况下，Maleoon GPU会根据是否能有效减小load mem的次数从而开启Single InstanceID优化。此优化可以保证每组任务运行时InstanceID一致，从而每组任务load mem只用执行first thread一次load即可拿到整组对应数据。进一步，如果此shader所有uniform不超过1024 bytes大小，此uniform buffer可以完全放在constant register里面，即可通过Maleoon GPU特有的relative constant register代替此load mem操作，性能最优。 【推荐】 InstanceID参与uniform buffer索引值计算时，uniform buffer中尽量精简只保留有效数据。条件允许下，InstanceID每个实例可以多画一些点，性能收益更大。InstanceID参与uniform buffer索引值计算时，尽量不要在复杂的嵌套之内。 【示例】 原始shader：  推荐shader： struct unity_ Type {\\n    vec4 vecArrA[4];\\n};\\nlayout(std140) uniform UnityInstancing_PerDraw0 {\\n    unity_Type unity_Array[32];\\n};\\nvoid main() {\\n    u_xlati0 = gl_InstanceID + unity_BaseInstanceID;\\n    u_xlati0 = u_xlati0 << 2;\\n    u_xlat1.yw = (-_mhyWorldOffset.zx) + unity_Array[u_xlati0 / 4].vecArrA[3].zx;\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1568394383311\\\"'><a name='\\\"section1568394383311\\\"'></a><a name='\\\"section1568394383311\\\"'></a><h4>[h2]Vertex shading</h4><p><strong>1. 精度</strong></p> <p>为了规避Vertex shader计算位置信息的偏差导致后续shader stage误差放大，Maleoon GPU上vertex shader精度统一按照highp实现。</p> <p><strong>【推荐】</strong></p> <p>建议使用highp设置。</p> <p><strong>2. InstanceID</strong></p> <p>InstanceID经常会参与uniform buffer索引值的计算，此种情况下，Maleoon GPU会根据是否能有效减小load mem的次数从而开启Single InstanceID优化。此优化可以保证每组任务运行时InstanceID一致，从而每组任务load mem只用执行first thread一次load即可拿到整组对应数据。进一步，如果此shader所有uniform不超过1024 bytes大小，此uniform buffer可以完全放在constant register里面，即可通过Maleoon GPU特有的relative constant register代替此load mem操作，性能最优。</p> <p><strong>【推荐】</strong></p> <ul><li>InstanceID参与uniform buffer索引值计算时，uniform buffer中尽量精简只保留有效数据。</li><li>条件允许下，InstanceID每个实例可以多画一些点，性能收益更大。</li><li>InstanceID参与uniform buffer索引值计算时，尽量不要在复杂的嵌套之内。</li></ul> <p><strong>【示例】</strong></p> <p>原始shader：</p>  <p>推荐shader：</p> <pre class='\\\"screen\\\"'>struct unity_ Type {\\n    vec4 vecArrA[4];\\n};\\nlayout(std140) uniform UnityInstancing_PerDraw0 {\\n    unity_Type unity_Array[32];\\n};\\nvoid main() {\\n    u_xlati0 = gl_InstanceID + unity_BaseInstanceID;\\n    u_xlati0 = u_xlati0 &lt;&lt; 2;\\n    u_xlat1.yw = (-_mhyWorldOffset.zx) + unity_Array[u_xlati0 / 4].vecArrA[3].zx;\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-maleoon-gpu-best-practices.html"
    },
    {
        "id": 45,
        "pre": "// Vertex shader\\n#version 300 es\\nin vec4 in_position;\\nin vec2 in_coord;\\nout vec2 texCoord; \\nvoid main() {\\n    gl_Position = in_position;\\n    texCoord = in_coord;\\n}\\n\\n// Fragment shader\\n#version 300 es\\nprecision highp int;\\nprecision highp float;\\nin vec2 texCoord;\\nuniform vec2 texOffset;\\nlayout(location = 0) out highp vec4 fragColor0;\\nlayout(location = 0) uniform highp sampler2D sampler0;\\nvoid main() {\\n    vec2 coord = texCoord + texOffset;\\n    fragColor0 = texture(sampler0, coord);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "原始shader： ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>原始shader： </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-maleoon-gpu-best-practices.html"
    },
    {
        "id": 46,
        "pre": "struct FCocTileSample {\\n    vec4 Fgd;\\n};\\nvoid main() {\\n    uint u12 = 0u;\\n    FCocTileSample t10[3];\\n    while (u12 < 3u) {\\n        t10[int(u12)].Fgd = a;\\n        u12++;\\n    }\\n}",
        "type": "Reference",
        "function_call": "nvoid main()",
        "function_name": "[h2]内存访问向量化",
        "parent_text": "[h2]内存访问向量化Maleoon GPU在内存访问操作上使用向量化是更加高效的行为，向量化的内存访问可以减少访问cycle和带宽。 【推荐】 推荐shader写法：  【不推荐】 原始shader写法： struct FCocTileSample {\\n    float FgdMinCoc;\\n    float FgdMaxCoc;\\n    float BgdMinCoc;\\n    float BgdMaxCoc;\\n};\\nvoid main() {\\n    uint u12 = 0u;\\n    FCocTileSample t10[3];\\n    while (u12 < 3u) {\\n        t10[int(u12)].FgdMinCoc = a;\\n        t10[int(u12)].FgdMaxCoc = b;\\n        t10[int(u12)].BgdMinCoc = c;\\n        t10[int(u12)].BgdMaxCoc = d;\\n        u12++;\\n    }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section892433810014\\\"'><a name='\\\"section892433810014\\\"'></a><a name='\\\"section892433810014\\\"'></a><h4>[h2]内存访问向量化</h4><p>Maleoon GPU在内存访问操作上使用向量化是更加高效的行为，向量化的内存访问可以减少访问cycle和带宽。</p> <p><strong>【推荐】</strong></p> <p>推荐shader写法：</p>  <p><strong>【不推荐】</strong></p> <p>原始shader写法：</p> <pre class='\\\"screen\\\"'>struct FCocTileSample {\\n    float FgdMinCoc;\\n    float FgdMaxCoc;\\n    float BgdMinCoc;\\n    float BgdMaxCoc;\\n};\\nvoid main() {\\n    uint u12 = 0u;\\n    FCocTileSample t10[3];\\n    while (u12 &lt; 3u) {\\n        t10[int(u12)].FgdMinCoc = a;\\n        t10[int(u12)].FgdMaxCoc = b;\\n        t10[int(u12)].BgdMinCoc = c;\\n        t10[int(u12)].BgdMaxCoc = d;\\n        u12++;\\n    }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-maleoon-gpu-best-practices.html"
    },
    {
        "id": 47,
        "pre": "if (_61.x) {\\n    vec3 _513 = (-_37.xyz) * _462._m0[_440 / 8]._m0.www + _462._m0[_440 / 8]._m0.xyz;\\n    _179.x = _516 + _462._m0[_440 / 8]._m3.w;\\n    _516 *= _462._m0[_440 / 8]._m2.x;\\n    _516 *= _462._m0[_440 / 8]._m3.w;\\n    _559 = dot(_462._m0[_440 / 8]._m3.xyz, _71.xyz);\\n    _559 = (_559 * _462._m0[_440 / 8]._m2.z) + _462._m0[_440 / 8]._m2.w;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]Uniform Relative Indexing",
        "parent_text": "[h2]Uniform Relative IndexingMaleoon GPU对于Uniform relative indexing的一般做法为将动态索引的完整uniform buffer放在mem中，再通过运行时计算出来的index从mem中load出对应的uniform value。 【推荐】 从mem中load数据开销较大，因此避免非必要的uniform dynamic indexing写法。如果有必要，可以通过向量化操作拉长整个变量的生命周期，减少load mem的次数。 【示例】 原始shader写法：  推荐shader写法： if (_61.x) {\\n    vec4 ldubo_mo = _462._m0[_440 / 8]._m0.xyzw;\\n    vec4 ldubo_m2 = _462._m0[_440 / 8]._m2.xyzw;\\n    vec4 ldubo_m3 = _462._m0[_440 / 8]._m3.xyzw;\\n    vec3 _513 = (-_37.xyz) * ldubo_mo.www + ldubo_mo.xyz;\\n    _179.x = _516 + ldubo_m3.w;\\n    _516 *= ldubo_m2.x;\\n    _516 *= ldubo_m3.w;\\n    _559 = dot(ldubo_m3.xyz, _71.xyz);\\n    _559 = (_559 * ldubo_m2.z) + ldubo_m2.w;\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1025117311226\\\"'><a name='\\\"section1025117311226\\\"'></a><a name='\\\"section1025117311226\\\"'></a><h4>[h2]Uniform Relative Indexing</h4><p>Maleoon GPU对于Uniform relative indexing的一般做法为将动态索引的完整uniform buffer放在mem中，再通过运行时计算出来的index从mem中load出对应的uniform value。</p> <p><strong>【推荐】</strong></p> <ul><li>从mem中load数据开销较大，因此避免非必要的uniform dynamic indexing写法。</li><li>如果有必要，可以通过向量化操作拉长整个变量的生命周期，减少load mem的次数。</li></ul> <p><strong>【示例】</strong></p> <p>原始shader写法：</p>  <p>推荐shader写法：</p> <pre class='\\\"screen\\\"'>if (_61.x) {\\n    vec4 ldubo_mo = _462._m0[_440 / 8]._m0.xyzw;\\n    vec4 ldubo_m2 = _462._m0[_440 / 8]._m2.xyzw;\\n    vec4 ldubo_m3 = _462._m0[_440 / 8]._m3.xyzw;\\n    vec3 _513 = (-_37.xyz) * ldubo_mo.www + ldubo_mo.xyz;\\n    _179.x = _516 + ldubo_m3.w;\\n    _516 *= ldubo_m2.x;\\n    _516 *= ldubo_m3.w;\\n    _559 = dot(ldubo_m3.xyz, _71.xyz);\\n    _559 = (_559 * ldubo_m2.z) + ldubo_m2.w;\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-maleoon-gpu-best-practices.html"
    },
    {
        "id": 48,
        "pre": "vec4 UniformArrayDynamicIndex(int i) {\\n    if (i <= 0) return UArray[0]; \\n    else if (i == 1) return UArray[1];\\n    else if (i == 2) return UArray[2]; \\n    else if (i == 3) return UArray[3];\\n    else if (i == 4) return UArray[4]; \\n    else if (i == 5) return UArray[5];\\n    else if (i == 6) return UArray[6]; \\n    else if (i == 7) return UArray[7];\\n    else if (i == 8) return UArray[8]; \\n    else if (i == 9) return UArray[9];\\n    else if (i == 10) return UArray[10]; \\n    else if (i == 11) return UArray[11];\\n    else if (i == 12) return UArray[12]; \\n    else if (i == 13) return UArray[13];\\n    else if (i == 14) return UArray[14]; \\n    else if (i == 15) return UArray[15];\\n    else if (i == 16) return UArray[16]; \\n    else if (i == 17) return UArray[17];\\n    else if (i == 18) return UArray[18]; \\n    else if (i == 19) return UArray[19];\\n    else if (i == 20) return UArray[20]; \\n    else if (i == 21) return UArray[21];\\n    else if (i == 22) return UArray[22]; \\n    else if (i == 23) return UArray[23];\\n    else if (i == 24) return UArray[24]; \\n    else if (i == 25) return UArray[25];\\n    else if (i == 26) return UArray[26]; \\n    else if (i == 27) return UArray[27];\\n    else if (i == 28) return UArray[28]; \\n    else if (i == 29) return UArray[29];\\n    else if (i == 30) return UArray[30]; \\n    else if (i == 31) return UArray[31];\\n    return UArray[0];\\n}",
        "type": "Reference",
        "function_call": "mix()",
        "function_name": "[h2]Branch",
        "parent_text": "[h2]Branch分支（branching）在GPU上代价较大，原因如下： 分支使得一个warp内的线程会出现分叉，同一时刻可能只有一部分线程是active的，线程利用率降低。Maleoon GPU是大核结构（SIMD32/SIMD64），分支越多性能，利用率会越低。GPU硬件上需要额外的硬件单元记录branch和branch合并时的信息，这些资源是有限的，过多的branch可能导致warp并发度降低。分支给编译器优化带来更多可变因子，而图形渲染大部分是在线编译，需要平衡优化效果和编译时间。uniform branch相比普通的branch，可以避免分叉的产生，但还是会有其它的影响。开发过程中还是要尽可能避免使用branch。 【推荐】 尽量减少复杂的分支结构，减少嵌套深度， 嵌套深度尽量控制在8层以内。可以使用min()、max()、clamp()、mix()，三目运算符等方式减少简单的分支跳转。如果冗余计算的代价不大，可以去掉分支结构保留冗余计算。使用宏常量代替uniform变量。Vulkan使用push constant代替uniform变量。 【不推荐】 有些shader为了兼容性，会把memory的relative indexing改成if-else或者switch-case，这种太多分支操作写法对GPU不友好，导致性能很差。Maleoon GPU是支持所有memory类型的relative indexing，并且有些场景编译器还能优化，所以请保留relative indexing。 【示例】 原始shader写法：  推荐shader写法： vec4 UniformArrayDynamicIndex(int i) {\\n    if (i <0 || i > 31)\\n        i = 0;\\n    return UArray[i];\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section4771204420210\\\"'><a name='\\\"section4771204420210\\\"'></a><a name='\\\"section4771204420210\\\"'></a><h4>[h2]Branch</h4><p>分支（branching）在GPU上代价较大，原因如下：</p> <ul><li>分支使得一个warp内的线程会出现分叉，同一时刻可能只有一部分线程是active的，线程利用率降低。Maleoon GPU是大核结构（SIMD32/SIMD64），分支越多性能，利用率会越低。</li><li>GPU硬件上需要额外的硬件单元记录branch和branch合并时的信息，这些资源是有限的，过多的branch可能导致warp并发度降低。</li><li>分支给编译器优化带来更多可变因子，而图形渲染大部分是在线编译，需要平衡优化效果和编译时间。</li><li>uniform branch相比普通的branch，可以避免分叉的产生，但还是会有其它的影响。开发过程中还是要尽可能避免使用branch。</li></ul> <p><strong>【推荐】</strong></p> <ul><li>尽量减少复杂的分支结构，减少嵌套深度， 嵌套深度尽量控制在8层以内。</li><li>可以使用min()、max()、clamp()、mix()，三目运算符等方式减少简单的分支跳转。</li><li>如果冗余计算的代价不大，可以去掉分支结构保留冗余计算。</li><li>使用宏常量代替uniform变量。</li><li>Vulkan使用push constant代替uniform变量。</li></ul> <p><strong>【不推荐】</strong></p> <p>有些shader为了兼容性，会把memory的relative indexing改成if-else或者switch-case，这种太多分支操作写法对GPU不友好，导致性能很差。Maleoon GPU是支持所有memory类型的relative indexing，并且有些场景编译器还能优化，所以请保留relative indexing。</p> <p><strong>【示例】</strong></p> <p>原始shader写法：</p>  <p>推荐shader写法：</p> <pre class='\\\"screen\\\"'>vec4 UniformArrayDynamicIndex(int i) {\\n    if (i &lt;0 || i &gt; 31)\\n        i = 0;\\n    return UArray[i];\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-maleoon-gpu-best-practices.html"
    },
    {
        "id": 49,
        "pre": "for (i = 0; i < 2 ; i++) {\\n}",
        "type": "Import",
        "function_call": null,
        "function_name": "[h2]Loop",
        "parent_text": "[h2]LoopLoop运行过程中，会产生较多的分叉，且会有大量的分支指令，性能在GPU上较差。 【推荐】 如果一定要使用loop，建议使用如下的for循环： for循环的循环次数优先使用常量，uniform变量次之。简化for循环的条件，使得for循环的起始值、step值都是常量或者常量表达式。 推荐shader：  【不推荐】 原始shader： i = 0;\\nfor (;;) {\\n    if (((i * 2 ) + 1 >=4)) {\\n        break;\\n    }\\n    i++;\\n} ",
        "import_module": "for (i = 0; i < 2 ; i++) {\\n}",
        "parent": "<div class='\\\"section\\\"' id='\\\"section862734835\\\"'><a name='\\\"section862734835\\\"'></a><a name='\\\"section862734835\\\"'></a><h4>[h2]Loop</h4><p>Loop运行过程中，会产生较多的分叉，且会有大量的分支指令，性能在GPU上较差。</p> <p><strong>【推荐】</strong></p> <p>如果一定要使用loop，建议使用如下的for循环：</p> <ul><li>for循环的循环次数优先使用常量，uniform变量次之。</li><li>简化for循环的条件，使得for循环的起始值、step值都是常量或者常量表达式。</li></ul> <p>推荐shader：</p>  <p><strong>【不推荐】</strong></p> <p>原始shader：</p> <pre class='\\\"screen\\\"'>i = 0;\\nfor (;;) {\\n    if (((i * 2 ) + 1 &gt;=4)) {\\n        break;\\n    }\\n    i++;\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-maleoon-gpu-best-practices.html"
    },
    {
        "id": 50,
        "pre": "Video({\\n  src: $rawfile('video1.mp4'),\\n  previewUri: $r('app.media.img_preview'),\\n})\\n  .loop(true)\\n  .width(Constants.FULL_PERCENT)\\n  .height(Constants.FULL_PERCENT)\\n  .onStart(() => {\\n    this.brightnessViewModel.setWindowKeepScreenState(true);\\n  })\\n  .onPause(() => {\\n    this.brightnessViewModel.setWindowKeepScreenState(false);\\n  })",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]开发步骤",
        "parent_text": "[h2]开发步骤1.视频播放时保持屏幕常亮，暂停或退出页面，取消屏幕常亮  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1389752815227\\\"'><a name='\\\"section1389752815227\\\"'></a><a name='\\\"section1389752815227\\\"'></a><h4>[h2]开发步骤</h4><p>1.视频播放时保持屏幕常亮，暂停或退出页面，取消屏幕常亮</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-page-brightness-settings.html"
    },
    {
        "id": 51,
        "pre": "// entry/src/main/syscap.json\\n{\\n  \\\"devices\\\": {\\n    \\\"general\\\": [\\n      \\\"2in1\\\"\\n    ]\\n  },\\n  \\\"development\\\": {\\n    \\\"addedSysCaps\\\": [\\n      \\\"SystemCapability.Window.SessionManager\\\"\\n    ]\\n  }\\n}",
        "type": "Reference",
        "function_call": "为使用setWindowMask()",
        "function_name": null,
        "parent_text": "为使用setWindowMask()等接口，需要额外配置syscap.json文件，在模块/src/main目录下，创建syscap.json文件，填入以下内容： ",
        "import_module": null,
        "parent": "<li><span>为使用setWindowMask()等接口，需要额外<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/syscap#pcid导入\\\"' target='\\\"_blank\\\"'>配置syscap.json文件</a>，在模块/src/main目录下，创建syscap.json文件，填入以下内容：</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-2in1-window-shape.html"
    },
    {
        "id": 52,
        "pre": "@Builder\\nprivate getListView() {\\n  List({\\n    space: 12, scroller: this.scroller\\n  }) {\\n    // 使用懒加载组件渲染数据\\n    ForEach(this.newsData, (item: NewsData) => {\\n      ListItem() {\\n        newsItem({\\n          newsTitle: item.newsTitle,\\n          newsContent: item.newsContent,\\n          newsTime: item.newsTime,\\n          img: item.img\\n        })\\n      }\\n      .backgroundColor(Color.White)\\n      .borderRadius(16)\\n    });\\n  }\\n  .width('100%')\\n  .height('100%')\\n  .padding({\\n    left: 16,\\n    right: 16\\n  })\\n  .backgroundColor('#F1F3F5')\\n  // 必须设置列表为滑动到边缘无效果，否则无法触发pullToRefresh组件的上滑下拉方法。\\n  .edgeEffect(EdgeEffect.None)\\n}",
        "type": "Reference",
        "function_call": "ListItem()",
        "function_name": "[h2]刷新过程中，ForEach键值生成函数未设置导致的闪屏问题",
        "parent_text": "[h2]刷新过程中，ForEach键值生成函数未设置导致的闪屏问题问题现象 下拉刷新时，应用产生卡顿，出现闪屏问题。   可能原因 ForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: Object, index: number) => { return index + '__' + JSON.stringify(item); }。可参考键值生成规则。 在使用ForEach的过程中，若对于键值生成规则的理解不够充分，可能会出现错误的使用方式。错误使用一方面会导致功能层面问题，例如渲染结果非预期，另一方面会导致性能层面问题，例如渲染性能降低。 解决措施 在ForEach第三个参数中定义自定义键值的生成规则，即(item: NewsData, index?: number) => item.id，这样可以在渲染时降低重复组件的渲染开销，从而消除闪屏问题。可参考ForEach组件使用建议。 @Builder\\nprivate getListView() {\\n  List({\\n    space: 12, scroller: this.scroller\\n  }) {\\n    // 使用懒加载组件渲染数据\\n    ForEach(this.newsData, (item: NewsData) => {\\n      ListItem() {\\n        newsItem({\\n          newsTitle: item.newsTitle,\\n          newsContent: item.newsContent,\\n          newsTime: item.newsTime,\\n          img: item.img\\n        })\\n      }\\n      .backgroundColor(Color.White)\\n      .borderRadius(16)\\n    }, (item: NewsData) => item.newsId);\\n  }\\n  .width('100%')\\n  .height('100%')\\n  .padding({\\n    left: 16,\\n    right: 16\\n  })\\n  .backgroundColor('#F1F3F5')\\n  // 必须设置列表为滑动到边缘无效果，否则无法触发pullToRefresh组件的上滑下拉方法。\\n  .edgeEffect(EdgeEffect.None)\\n} 运行效果如下图所示。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section6978161018718\\\"'><a name='\\\"section6978161018718\\\"'></a><a name='\\\"section6978161018718\\\"'></a><h4>[h2]刷新过程中，ForEach键值生成函数未设置导致的闪屏问题</h4><p><strong>问题现象</strong></p> <p>下拉刷新时，应用产生卡顿，出现闪屏问题。</p> <p><span><img height='\\\"532.7767200000001\\\"' originheight='\\\"1080\\\"' originwidth='\\\"523\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161219.63034105525236763842435965029838:50001231000000:2800:A4F24E52E9BF30917BF0C709DF3890B36B4660A86AC731D0A9D89A4247E473FC.gif\\\"' title='\\\"点击放大\\\"' width='\\\"270.886021\\\"'/></span></p>  <p><strong><span rgb(73,73,73);\\\"=\"\" style='\\\"color:'>可能原因</span></strong></p> <p>ForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: Object, index: number) =&gt; { return index + '__' + JSON.stringify(item); }。可参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach#键值生成规则\\\"' target='\\\"_blank\\\"'>键值生成规则</a>。</p> <p>在使用ForEach的过程中，若对于键值生成规则的理解不够充分，可能会出现错误的使用方式。错误使用一方面会导致功能层面问题，例如渲染结果非预期，另一方面会导致性能层面问题，例如渲染性能降低。</p> <p><strong><span rgb(73,73,73);\\\"=\"\" style='\\\"color:'>解决措施</span></strong></p> <p>在ForEach第三个参数中定义自定义键值的生成规则，即(item: NewsData, index?: number) =&gt; item.id，这样可以在渲染时降低重复组件的渲染开销，从而消除闪屏问题。可参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach#使用建议\\\"' target='\\\"_blank\\\"'>ForEach组件使用建议</a>。</p> <pre class='\\\"screen\\\"'>@Builder\\nprivate getListView() {\\n  List({\\n    space: 12, scroller: this.scroller\\n  }) {\\n    // 使用懒加载组件渲染数据\\n    ForEach(this.newsData, (item: NewsData) =&gt; {\\n      ListItem() {\\n        newsItem({\\n          newsTitle: item.newsTitle,\\n          newsContent: item.newsContent,\\n          newsTime: item.newsTime,\\n          img: item.img\\n        })\\n      }\\n      .backgroundColor(Color.White)\\n      .borderRadius(16)\\n    }, (item: NewsData) =&gt; item.newsId);\\n  }\\n  .width('100%')\\n  .height('100%')\\n  .padding({\\n    left: 16,\\n    right: 16\\n  })\\n  .backgroundColor('#F1F3F5')\\n  // 必须设置列表为滑动到边缘无效果，否则无法触发pullToRefresh组件的上滑下拉方法。\\n  .edgeEffect(EdgeEffect.None)\\n}</pre> <p>运行效果如下图所示。</p> <p><span><img height='\\\"520.6072200000001\\\"' originheight='\\\"1080\\\"' originwidth='\\\"523\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161219.35947379366521772557810304388473:50001231000000:2800:096F11BF38EB73031A7316C8D348EAB2234AB759118DF27F3C524F9261BE343A.gif\\\"' title='\\\"点击放大\\\"' width='\\\"269.591266\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-screen-flicker-solution.html"
    },
    {
        "id": 53,
        "pre": "List() {\\n  ForEach(this.arrayTitle, (title: Title, index: number) => {\\n    ListItem() {\\n      TitleView({\\n        title: title, clickListener: () => {\\n          if (title.isSelected) {\\n            return;\\n          }\\n          // 点击标题时，Swiper组件跳转到对应的页面\\n          this.swiperController.changeIndex(index, true);\\n          // 设置标题为选中状态\\n          this.arrayTitle[index].isSelected = true;\\n          this.arrayTitle[this.selectIndex].isSelected = false;\\n          this.selectIndex = index;\\n        }\\n      })\\n        // ...\\n    }\\n  })\\n}\\n.height(30)\\n.listDirection(Axis.Horizontal)\\n\\nSwiper(this.swiperController) {\\n  // 使用LazyForEach，使Swiper页面按需加载，而不是一次全部创建\\n  LazyForEach(this.array, (item: string, index: number) => {\\n    // 常规复用代码，可按需注释运行TabComp({ index: index })\\n    // 自定义组件复用池代码\\n    // TabNode({ index: index })\\n  }, (title: string) => title)\\n}\\n.loop(false)\\n.onChange((index: number) => {\\n  // Swiper滑动切换页面时，改变标题栏的选中状态\\n  if (this.selectIndex !== index) {\\n    this.arrayTitle[index].isSelected = true;\\n    this.arrayTitle[this.selectIndex].isSelected = false;\\n    this.selectIndex = index;\\n  }\\n})\\n.cachedCount(0) // 此处设置cachedCount为0，便于性能对比，实际开发中可按需设置",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用List+Swiper实现Tabs页面切换。 ",
        "import_module": null,
        "parent": "<li>使用List+Swiper实现Tabs页面切换。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-global-custom-component-reuse.html"
    },
    {
        "id": 54,
        "pre": "List() {\\n  ForEach(this.arrayTitle, (title: Title, index: number) => {\\n    ListItem() {\\n      TitleView({\\n        title: title, clickListener: () => {\\n          if (title.isSelected) {\\n            return;\\n          }\\n          // 点击标题时，Swiper组件跳转到对应的页面\\n          this.swiperController.changeIndex(index, true);\\n          // 设置标题为选中状态\\n          this.arrayTitle[index].isSelected = true;\\n          this.arrayTitle[this.selectIndex].isSelected = false;\\n          this.selectIndex = index;\\n        }\\n      })\\n        // ...\\n    }\\n  })\\n}\\n.height(30)\\n.listDirection(Axis.Horizontal)\\n\\nSwiper(this.swiperController) {\\n  // 使用LazyForEach，使Swiper页面按需加载，而不是一次全部创建\\n  LazyForEach(this.array, (item: string, index: number) => {\\n    // 常规复用代码，可按需注释运行\\n    // TabComp({ index: index })\\n    // 自定义组件复用池代码\\n    TabNode({ index: index })\\n  }, (title: string) => title)\\n}\\n.loop(false)\\n.onChange((index: number) => {\\n  // Swiper滑动切换页面时，改变标题栏的选中状态\\n  if (this.selectIndex !== index) {\\n    this.arrayTitle[index].isSelected = true;\\n    this.arrayTitle[this.selectIndex].isSelected = false;\\n    this.selectIndex = index;\\n  }\\n})\\n.cachedCount(0) // 此处设置cachedCount为0，便于性能对比，实际开发中可按需设置",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用List+Swiper实现Tabs页面切换。 ",
        "import_module": null,
        "parent": "<li>使用List+Swiper实现Tabs页面切换。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-global-custom-component-reuse.html"
    },
    {
        "id": 55,
        "pre": "export class IdleCallback extends FrameCallback {\\n  private uiContext: UIContext;\\n  // 已经创建的子组件数量\\n  private todoCount: number = 0;\\n  private viewItems: ViewItem[] = [];\\n\\n  /**\\n   * @param context 上下文对象，用于将帧回调传递到下一帧\\n   * @param preBuildData 预创建组件的数据列表，用于确认预创建组件的数量和相关信息，可根据业务需求自行修改或设置固定值\\n   */\\n  constructor(context: UIContext, preBuildData: ViewItem[]) {\\n    super();\\n    this.uiContext = context;\\n    this.viewItems = preBuildData;\\n  }",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "继承抽象类FrameCallback，实现帧回调类，在构造器中传入预创建的数据，并实现onIdle接口。 ",
        "import_module": null,
        "parent": "<li>继承抽象类FrameCallback，实现帧回调类，在构造器中传入预创建的数据，并实现onIdle接口。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-global-custom-component-reuse.html"
    },
    {
        "id": 56,
        "pre": "List() {\\n  // ...\\n}.cachedCount(3)",
        "type": "Import",
        "function_call": null,
        "function_name": "[h2]长列表加载",
        "parent_text": "[h2]长列表加载长列表作为应用开发中最常见的开发场景之一，通常会包含成千上万个列表项，在此场景下，直接使用循环渲染ForEach一次性加载所有的列表项，会导致渲染时间过长，影响用户体验。而使用数据懒加载LazyForEach替换循环渲染ForEach，可以按需加载列表项，从而提升列表性能。数据懒加载的示例代码可以参考LazyForEach。 虽然，按需加载列表项可以优化长列表性能，但在快速滑动长列表的场景下，可能会来不及加载需要显示的列表项，导致出现白块的现象，从而影响用户体验。而在ArkUI中，List容器提供了cachedCount属性，LazyForEach可以结合cachedCount属性一起使用，能够避免白块的现象。cachedCount可以设置列表中ListItem/ListItemGroup的预加载数量，并且只在LazyForEach中生效，即cachedCount只能与LazyForEach一起使用。除了List容器，其他容器Grid、Swiper以及WaterFlow也都包含cachedCount属性。cachedCount的使用方法如下所示。  此外，HarmonyOS应用框架提供了组件复用能力，可以结合LazyForEach一起使用，进一步优化长列表的性能。组件复用会把组件树上将要移除的组件进行回收，回收的组件会进入到一个回收缓存区。后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。关于组件复用的详细原理可以参考组件复用。针对长列表加载的性能优化，可以参考优化长列表加载慢丢帧问题。 ",
        "import_module": "List() {\\n  // ...\\n}.cachedCount(3)",
        "parent": "<div class='\\\"section\\\"' id='\\\"section1847219719551\\\"'><a name='\\\"section1847219719551\\\"'></a><a name='\\\"section1847219719551\\\"'></a><h4>[h2]长列表加载</h4><p>长列表作为应用开发中最常见的开发场景之一，通常会包含成千上万个列表项，在此场景下，直接使用循环渲染ForEach一次性加载所有的列表项，会导致渲染时间过长，影响用户体验。而使用数据懒加载LazyForEach替换循环渲染ForEach，可以按需加载列表项，从而提升列表性能。数据懒加载的示例代码可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach\\\"' target='\\\"_blank\\\"'>LazyForEach</a>。</p> <p>虽然，按需加载列表项可以优化长列表性能，但在快速滑动长列表的场景下，可能会来不及加载需要显示的列表项，导致出现白块的现象，从而影响用户体验。而在ArkUI中，List容器提供了cachedCount属性，LazyForEach可以结合cachedCount属性一起使用，能够避免白块的现象。cachedCount可以设置列表中ListItem/ListItemGroup的预加载数量，并且只在LazyForEach中生效，即cachedCount只能与LazyForEach一起使用。除了List容器，其他容器Grid、Swiper以及WaterFlow也都包含cachedCount属性。cachedCount的使用方法如下所示。</p>  <p>此外，HarmonyOS应用框架提供了组件复用能力，可以结合LazyForEach一起使用，进一步优化长列表的性能。组件复用会把组件树上将要移除的组件进行回收，回收的组件会进入到一个回收缓存区。后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。关于组件复用的详细原理可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse\\\"'>组件复用</a>。针对长列表加载的性能优化，可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list\\\"' target='\\\"_blank\\\"'>优化长列表加载慢丢帧问题</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lazyforeach-optimization.html"
    },
    {
        "id": 57,
        "pre": "LazyForEach(this.data, (lazyForEachItem: string) => {\\n  ListItem() {\\n    Row() {\\n      Text(lazyForEachItem).fontSize(50)\\n    }.margin({ left: 10, right: 10 })\\n  }.onAppear(() => {\\n    // 通过onAppear记录组件创建的次数\\n    console.info(\\\"appear:\\\" + lazyForEachItem)\\n  })\\n}, (item: string) => {\\n  // 在键值生成函数keyGenerator中打印键值\\n  console.info(\\\"key:\\\" + item)\\n  return item;\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "通过日志观察键值、子组件创建的情况，参考如下所示。开发者需要留意日志中是否出现相同的键值、子组件出现的次数与实际不符等情况。 ",
        "import_module": "List() {\\n  // ...\\n}.cachedCount(3)",
        "parent": "<li>通过日志观察键值、子组件创建的情况，参考如下所示。开发者需要留意日志中是否出现相同的键值、子组件出现的次数与实际不符等情况。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lazyforeach-optimization.html"
    },
    {
        "id": 58,
        "pre": "@Entry\\n@Component\\nstruct Index {\\n  private data: MyDataSource = new MyDataSource();\\n\\n  aboutToAppear() {\\n    for (let i = 0; i <= 30; i++) {\\n      this.data.pushData(`Hello ${i}`)\\n    }\\n  }\\n\\n  build() {\\n    List({ space: 3 }) {\\n      LazyForEach(this.data, (lazyForEachItem: string) => {\\n        ListItem() {\\n          Column() {\\n            ForEach(this.data.getAllData(), (forEachItem: string) => {\\n              ListItem() {\\n                Row() {\\n                  Text(lazyForEachItem + forEachItem).fontSize(50)\\n                    .onAppear(() => {\\n                      console.info(\\\"appear:\\\" + lazyForEachItem)\\n                    })\\n                }.margin({ left: 10, right: 10 })\\n              }\\n            }, (item: string) => item)\\n          }\\n        }\\n      }, (item: string) => item)\\n    }.cachedCount(5)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]ListItem过于复杂导致丢帧",
        "parent_text": "[h2]ListItem过于复杂导致丢帧当使用LazyForEach时，如果子组件ListItem过于复杂，在子组件创建时，将产生大量的布局计算耗时，最终导致该帧丢帧。关键代码如下所示。  ",
        "import_module": "List() {\\n  // ...\\n}.cachedCount(3)",
        "parent": "<div class='\\\"section\\\"' id='\\\"section1086542617280\\\"'><a name='\\\"section1086542617280\\\"'></a><a name='\\\"section1086542617280\\\"'></a><h4>[h2]ListItem过于复杂导致丢帧</h4><p>当使用LazyForEach时，如果子组件ListItem过于复杂，在子组件创建时，将产生大量的布局计算耗时，最终导致该帧丢帧。关键代码如下所示。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lazyforeach-optimization.html"
    },
    {
        "id": 59,
        "pre": "@Entry\\n@Component\\nstruct Index {\\n  private data: MyDataSource = new MyDataSource();\\n  private scroller: Scroller = new Scroller();\\n\\n  aboutToAppear() {\\n    for (let i = 0; i <= 30; i++) {\\n      this.data.pushData(`Hello ${i}`)\\n    }\\n  }\\n\\n  build() {\\n    Column() {\\n      Grid(this.scroller) {\\n        LazyForEach(this.data, (lazyForEachItem: string) => {\\n          GridItem() {\\n            Text(lazyForEachItem)\\n              .fontSize(50)\\n              .width('100%')\\n          }\\n          .onAppear(() => {\\n            console.info(\\\"appear:\\\" + lazyForEachItem)\\n          })\\n        }, (item: string) => {\\n          return item;\\n        })\\n      }\\n      .columnsTemplate('1fr')\\n      .enableScrollInteraction(true)\\n      .width('100%')\\n      .height(800)\\n      .cachedCount(5)\\n    }\\n    .width('100%')\\n    .height(700)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]GridItem未设置高度导致按需加载失效",
        "parent_text": "[h2]GridItem未设置高度导致按需加载失效当使用Grid容器时，如果GridItem没有设置高度，会加载所有子组件，设置了GridItem的宽高，会加载Grid显示区域内的子组件。参考案例代码如下：  ",
        "import_module": "List() {\\n  // ...\\n}.cachedCount(3)",
        "parent": "<div class='\\\"section\\\"' id='\\\"section1995835515112\\\"'><a name='\\\"section1995835515112\\\"'></a><a name='\\\"section1995835515112\\\"'></a><h4>[h2]GridItem未设置高度导致按需加载失效</h4><p>当使用Grid容器时，如果GridItem没有设置高度，会加载所有子组件，设置了GridItem的宽高，会加载Grid显示区域内的子组件。参考案例代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lazyforeach-optimization.html"
    },
    {
        "id": 60,
        "pre": "@Observed\\nclass Translate {\\n  translateX: number = 20;\\n}\\n@Entry\\n@Component\\nstruct MyComponent {\\n  @State translateObj: Translate = new Translate(); // 变量translateObj没有关联任何UI组件，不应该定义为状态变量\\n  @State buttonMsg: string = 'I am button'; // 变量buttonMsg没有关联任何UI组件，不应该定义为状态变量\\n  build() {\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]避免不必要的状态变量的使用",
        "parent_text": "[h2]避免不必要的状态变量的使用删除冗余的状态变量标记 状态变量的管理有一定的开销，应在合理场景使用，普通的变量用状态变量标记可能会导致性能劣化。 反例1  以上示例中变量translateObj，buttonMsg没有关联任何UI组件，没有关联任何UI组件的状态变量不应该定义为状态变量，否则读写状态变量都会影响性能。 反例2 @Observed\\nclass Translate {\\n  translateX: number = 20;\\n}\\n@Entry\\n@Component\\nstruct MyComponent {\\n  @State translateObj: Translate = new Translate();\\n  @State buttonMsg: string = 'I am button';\\n  build() {\\n    Column() {\\n      Button(this.buttonMsg) // 这里只是读取变量buttonMsg的值，没有任何写的操作\\n    }\\n  }\\n} 以上示例中变量buttonMsg仅有读取操作，没有修改过，没有修改过的状态变量不应该定义为状态变量，否则读状态变量会影响性能。 正例 @Observed\\nclass Translate {\\n  translateX: number = 20;\\n}\\n\\n@Entry\\n@Component\\nstruct UnnecessaryState1 {\\n  @State translateObj: Translate = new Translate(); // 同时存在读写操作，并关联了Button组件，推荐使用状态变量\\n  buttonMsg = 'I am button'; // 仅读取变量buttonMsg的值，没有任何写的操作，直接使用一般变量即可\\n\\n  build() {\\n    Column() {\\n      Button(this.buttonMsg)\\n        .onClick(() => {\\n          animateTo({\\n            duration: 50\\n          }, () => {\\n            this.translateObj.translateX = (this.translateObj.translateX + 50) % 150; // 点击时给变量translateObj重新赋值\\n          })\\n        })\\n    }\\n    .translate({\\n      x: this.translateObj.translateX // 读取translateObj中的值\\n    })\\n  }\\n} 在代码中，buttonMsg变量因仅用于读取操作而被定义为普通成员变量，而translateObj变量则因需要根据用户事件改变其x值以驱动动画效果，故被定义为状态变量，并实时更新UI以显示动画。 建议使用临时变量替换状态变量 状态变量发生变化时，ArkUI会查询依赖该状态变量的组件并执行依赖该状态变量的组件的更新方法，完成组件渲染的行为。通过使用临时变量的计算代替直接操作状态变量，可以使ArkUI仅在最后一次状态变量变更时查询并渲染组件，减少不必要的行为，从而提高应用性能。状态变量行为可参考@State装饰器：组件内状态。 反例 @Entry\\n@Component\\nstruct Index {\\n  @State message: string = '';\\n\\n  // 定义改变状态变量的方法（多次修改状态变量）\\n  appendMsg(newMsg: string) {\\n    this.message += newMsg;\\n    this.message += ';';\\n    this.message += '<br/>';\\n  }\\n\\n  build() {\\n    Column() {\\n      Button('点击打印日志')\\n        .onClick(() => {\\n          this.appendMsg('操作状态变量'); // 调用封装的改变状态变量的方法\\n        })\\n        .width('90%')\\n        .backgroundColor(Color.Blue)\\n        .fontColor(Color.White)\\n        .margin({ top: 10})\\n    }\\n    .justifyContent(FlexAlign.Start)\\n    .alignItems(HorizontalAlign.Center)\\n    .margin({  top: 15 })\\n  }\\n} 正例 @Entry\\n@Component\\nstruct UnnecessaryState2 {\\n  @State message: string = '';\\n\\n  // 定义改变状态变量的方法（方法执行过程中操作中间变量，状态变量只修改一次）\\n  appendMsg(newMsg: string) {\\n    let message = this.message;\\n    message += newMsg;\\n    message += ';';\\n    message += '<br/>';\\n    this.message = message;\\n  }\\n\\n  build() {\\n    Column() {\\n      Button('点击打印日志')\\n        .onClick(() => {\\n          this.appendMsg('操作临时变量'); // 调用封装的改变状态变量的方法\\n        })\\n        .width('90%')\\n        .backgroundColor(Color.Blue)\\n        .fontColor(Color.White)\\n        .margin({ top: 10 })\\n    }\\n    .justifyContent(FlexAlign.Start)\\n    .alignItems(HorizontalAlign.Center)\\n    .margin({ top: 15 })\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section2674939304\\\"'><a name='\\\"section2674939304\\\"'></a><a name='\\\"section2674939304\\\"'></a><h4>[h2]避免不必要的状态变量的使用</h4><p><strong>删除冗余的状态变量标记</strong></p> <p>状态变量的管理有一定的开销，应在合理场景使用，普通的变量用状态变量标记可能会导致性能劣化。</p> <p>反例1</p>  <p>以上示例中变量translateObj，buttonMsg没有关联任何UI组件，没有关联任何UI组件的状态变量不应该定义为状态变量，否则读写状态变量都会影响性能。</p> <p>反例2</p> <pre class='\\\"screen\\\"'>@Observed\\nclass Translate {\\n  translateX: number = 20;\\n}\\n@Entry\\n@Component\\nstruct MyComponent {\\n  @State translateObj: Translate = new Translate();\\n  @State buttonMsg: string = 'I am button';\\n  build() {\\n    Column() {\\n      Button(this.buttonMsg) // 这里只是读取变量buttonMsg的值，没有任何写的操作\\n    }\\n  }\\n}</pre> <p>以上示例中变量buttonMsg仅有读取操作，没有修改过，没有修改过的状态变量不应该定义为状态变量，否则读状态变量会影响性能。</p> <p>正例</p> <pre class='\\\"screen\\\"'>@Observed\\nclass Translate {\\n  translateX: number = 20;\\n}\\n\\n@Entry\\n@Component\\nstruct UnnecessaryState1 {\\n  @State translateObj: Translate = new Translate(); // 同时存在读写操作，并关联了Button组件，推荐使用状态变量\\n  buttonMsg = 'I am button'; // 仅读取变量buttonMsg的值，没有任何写的操作，直接使用一般变量即可\\n\\n  build() {\\n    Column() {\\n      Button(this.buttonMsg)\\n        .onClick(() =&gt; {\\n          animateTo({\\n            duration: 50\\n          }, () =&gt; {\\n            this.translateObj.translateX = (this.translateObj.translateX + 50) % 150; // 点击时给变量translateObj重新赋值\\n          })\\n        })\\n    }\\n    .translate({\\n      x: this.translateObj.translateX // 读取translateObj中的值\\n    })\\n  }\\n}</pre> <p>在代码中，buttonMsg变量因仅用于读取操作而被定义为普通成员变量，而translateObj变量则因需要根据用户事件改变其x值以驱动动画效果，故被定义为状态变量，并实时更新UI以显示动画。</p> <p><strong>建议使用临时变量替换状态变量</strong></p> <p>状态变量发生变化时，ArkUI会查询依赖该状态变量的组件并执行依赖该状态变量的组件的更新方法，完成组件渲染的行为。通过使用临时变量的计算代替直接操作状态变量，可以使ArkUI仅在最后一次状态变量变更时查询并渲染组件，减少不必要的行为，从而提高应用性能。状态变量行为可参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-state\\\"' target='\\\"_blank\\\"'>@State装饰器：组件内状态</a>。</p> <p>反例</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct Index {\\n  <strong>@State message: string = '';</strong>\\n\\n  // 定义改变状态变量的方法（多次修改状态变量）\\n  appendMsg(newMsg: string) {\\n    this.message += newMsg;\\n    this.message += ';';\\n    this.message += '&lt;br/&gt;';\\n  }\\n\\n  build() {\\n    Column() {\\n      Button('点击打印日志')\\n        .onClick(() =&gt; {\\n          this.appendMsg('操作状态变量'); // 调用封装的改变状态变量的方法\\n        })\\n        .width('90%')\\n        .backgroundColor(Color.Blue)\\n        .fontColor(Color.White)\\n        .margin({ top: 10})\\n    }\\n    .justifyContent(FlexAlign.Start)\\n    .alignItems(HorizontalAlign.Center)\\n    .margin({  top: 15 })\\n  }\\n}</pre> <p>正例</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct UnnecessaryState2 {\\n  @State message: string = '';\\n\\n  // 定义改变状态变量的方法（方法执行过程中操作中间变量，状态变量只修改一次）\\n  appendMsg(newMsg: string) {\\n    let message = this.message;\\n    message += newMsg;\\n    message += ';';\\n    message += '&lt;br/&gt;';\\n    this.message = message;\\n  }\\n\\n  build() {\\n    Column() {\\n      Button('点击打印日志')\\n        .onClick(() =&gt; {\\n          this.appendMsg('操作临时变量'); // 调用封装的改变状态变量的方法\\n        })\\n        .width('90%')\\n        .backgroundColor(Color.Blue)\\n        .fontColor(Color.White)\\n        .margin({ top: 10 })\\n    }\\n    .justifyContent(FlexAlign.Start)\\n    .alignItems(HorizontalAlign.Center)\\n    .margin({ top: 15 })\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-status-management.html"
    },
    {
        "id": 61,
        "pre": "// 用户信息UserData的数据结构\\nexport interface UserData {\\n  id: string;\\n  username: string;\\n  description: string;\\n    // ...\\n}\\n\\n// 在业务类中获取服务端用户信息\\ngetUserData(): void {\\n  this.userAccountRepository.getUserData().then((data: UserData) => {\\n    // 1.将用户信息数据存储到AppStorage中\\n    AppStorage.setOrCreate('userData', data);\\n  })\\n}\\n\\n// “我的”模块顶部展示用户信息的视图组件\\n@Component\\nstruct UserInfoView {\\n  // 2.在UI中使用@StorageLink装饰器接收AppStorage中存储的用户信息\\n  @StorageLink('userData') userData: UserData | null = null;\\n\\n  build() {\\n    Column() {\\n      Row({ space: Constants.MIDDLE_SPACE }) {\\n        // ...\\n        Column() {\\n          // 3.展示用户信息userData中的用户名\\n          Text(this.userData? this.userData.username : $r('app.string.default_login'))\\n            // ...\\n        }\\n      }\\n      // ...\\n    }\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "当前项目中已经使用AppStorage存储用户信息UserData，UserData的数据结构和“UserInfoView”组件使用UserData状态展示用户信息的代码如下： ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>当前项目中已经使用AppStorage存储用户信息UserData，UserData的数据结构和“UserInfoView”组件使用UserData状态展示用户信息的代码如下： </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-status-management.html"
    },
    {
        "id": 62,
        "pre": "@Component\\nexport struct DiscoverView {\\n  // 1.获取跳转逻辑相关的共享状态\\n  @Consume('appPathStack') appPathStack: NavPathStack;\\n  @Consume('discoverPathStack') discoverPathStack: NavPathStack;\\n  @StorageProp('currentBreakpoint') currentBreakpoint: string = BreakpointTypeEnum.MD;\\n\\n  // 5.将3个组件的跳转处理逻辑集中在父组件上\\n  jumpDetail(item: LearningResource): void {\\n    if (this.currentBreakpoint === BreakpointTypeEnum.LG) {\\n      this.discoverPathStack.pushPathByName('articleDetail', item);  \\n    } else {\\n      this.appPathStack.pushPathByName('articleDetail', item);\\n    }\\n  }\\n\\n  build() {\\n    // ...\\n    ListItem() {\\n      BannerView({\\n        swiperData: this.discoverModel.swiperData,\\n        // 2.顶部轮播图组件传入父组件的逻辑处理函数\\n        handleClick: (item: LearningResource) => this.jumpDetail(item)\\n      })\\n    }\\n\\n    ListItem() {\\n      Column({ space: CommonConstants.SPACE_12 }) {\\n        HotFeedsView({\\n          hotFeedList: this.hotFeedList,\\n          showMore: () => this.jumpList(),   \\n          // 3.资讯列表组件传入父组件的逻辑处理函数\\n          handleClick: (item: LearningResource) => this.jumpDetail(item)\\n        })\\n        TechArticlesView({\\n          articlesDataSource: this.articlesDataSource,\\n          // 4.技术文章组件传入父组件的逻辑处理函数\\n          handleClick: (item: LearningResource) => this.jumpDetail(item)\\n        })\\n      }\\n    }\\n  }\\n}\\n\\n@Component\\nstruct BannerView {\\n  @Prop swiperData: LearningResource[] = [];\\n  private swiperController: SwiperController = new SwiperController();\\n  // 6.轮播图组件接收父组件传入的逻辑处理函数\\n  handleClick: (item: LearningResource) => void = () => {};\\n\\n  build() {\\n    Swiper(this.swiperController) {\\n      ForEach(this.swiperData, (item: LearningResource) => {\\n        Row() {\\n          Image(item.bannerSrc)\\n            .width(CommonConstants.FULL_PERCENT)\\n            .height(CommonConstants.FULL_PERCENT)\\n            .borderRadius($r('app.float.lg_border_radius'))\\n            //  7.点击图片时，调用接收的函数处理逻辑\\n            .onClick(() => this.handleClick(item))\\n        }\\n        // ...\\n      }, (item: LearningResource) => item.id)\\n    }\\n  // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "上述的三个组件共享全局路由信息，当发生界面点击交互时，三个组件的逻辑均为根据设备信息修改路由状态实现跳转到详情页。将三个组件处理跳转的逻辑集中到父组件上处理。实现代码如下： ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>上述的三个组件共享全局路由信息，当发生界面点击交互时，三个组件的逻辑均为根据设备信息修改路由状态实现跳转到详情页。将三个组件处理跳转的逻辑集中到父组件上处理。实现代码如下： </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-status-management.html"
    },
    {
        "id": 63,
        "pre": "@Entry\\n@Component\\nstruct Index {\\n  @State currentIndex: number = 0; // 当前选中的列表项下标\\n  private listData: string[] = [];\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i < 10; i++) {\\n      this.listData.push(`组件 ${i}`);\\n    }\\n  }\\n\\n  build() {\\n    Row() {\\n      Column() {\\n        List() {\\n          ForEach(this.listData, (item: string, index: number) => {\\n            ListItem() {\\n              ListItemComponent({ item: item, index: index, currentIndex: this.currentIndex })\\n            }\\n          })\\n        }\\n        .alignListItem(ListItemAlign.Center)\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}\\n\\n@Component\\nstruct ListItemComponent {\\n  @Prop item: string;\\n  @Prop index: number; // 列表项的下标\\n  @Link currentIndex: number;\\n  private sizeFont: number = 50;\\n\\n  isRender(): number {\\n    console.info(`ListItemComponent ${this.index} Text is rendered`);\\n    return this.sizeFont;\\n  }\\n\\n  build() {\\n    Column() {\\n      Text(this.item)\\n        .fontSize(this.isRender())// 根据当前列表项下标index与currentIndex的差值来动态设置文本的颜色\\n        .fontColor(Math.abs(this.index - this.currentIndex) <= 1 ? Color.Red : Color.Blue)\\n        .onClick(() => {\\n          this.currentIndex = this.index;\\n        })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "isRender()",
        "function_name": "[h2]使用 @Watch 装饰器监听数据源",
        "parent_text": "[h2]使用 @Watch 装饰器监听数据源在组件中使用@Watch装饰器监听数据源，当数据变化时执行业务逻辑，确保只有满足条件的组件进行刷新。 反例 在下面的示例代码中，多个组件直接关联同一个数据源，但是未使用@Watch装饰器和Emitter事件驱动更新，导致了冗余的组件刷新。  上述示例中，每个ListItemComponent组件点击Text后会将当前点击的列表项下标index赋值给currentIndex，@Link装饰的状态变量currentIndex变化后，父组件Index和所有ListItemComponent组件中的Index值都会同步发生改变。然后，在所有ListItemComponent组件中，根据列表项下标index与currentIndex的差值的绝对值是否小于等于1来决定Text的颜色，如果满足条件，则文本显示为红色，否则显示为蓝色，下面是运行效果图。  可以看到每次点击后即使其中部分Text组件的颜色并没有发生改变，所有的Text组件也都会刷新。这是由于ListItemComponent组件中的Text组件直接关联了currentIndex，而不是根据currentIndex计算得到的颜色。 针对上述父子组件层级关系的场景，推荐使用状态装饰器@Watch监听数据源。当数据源改变时，在@Watch的监听回调中执行业务逻辑。组件关联回调的处理结果，而不是直接关联数据源。 正例 下面是对上述示例的优化，展示如何通过@Watch装饰器实现精准刷新。 @Entry\\n@Component\\nstruct UseWatchListener {\\n  @State currentIndex: number = 0; // 当前选中的列表项下标\\n  private listData: string[] = [];\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i < 10; i++) {\\n      this.listData.push(`组件 ${i}`);\\n    }\\n  }\\n\\n  build() {\\n    Row() {\\n      Column() {\\n        List() {\\n          ForEach(this.listData, (item: string, index: number) => {\\n            ListItem() {\\n              ListItemComponent({ item: item, index: index, currentIndex: this.currentIndex })\\n            }\\n          })\\n        }\\n        .height('100%')\\n        .width('100%')\\n        .alignListItem(ListItemAlign.Center)\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}\\n\\n@Component\\nstruct ListItemComponent {\\n  @Prop item: string;\\n  @Prop index: number; // 列表项的下标\\n  @Link @Watch('onCurrentIndexUpdate') currentIndex: number;\\n  @State color: Color = Math.abs(this.index - this.currentIndex) <= 1 ? Color.Red : Color.Blue;\\n\\n  isRender(): number {\\n    console.info(`ListItemComponent ${this.index} Text is rendered`);\\n    return 50;\\n  }\\n\\n  onCurrentIndexUpdate() {\\n    // 根据当前列表项下标index与currentIndex的差值来动态修改color的值\\n    this.color = Math.abs(this.index - this.currentIndex) <= 1 ? Color.Red : Color.Blue;\\n  }\\n\\n  build() {\\n    Column() {\\n      Text(this.item)\\n        .fontSize(this.isRender())\\n        .fontColor(this.color)\\n        .onClick(() => {\\n          this.currentIndex = this.index;\\n        })\\n    }\\n  }\\n} 上述代码中，ListItemComponent组件中的状态变量currentIndex使用@Watch装饰，Text组件直接关联新的状态变量color。当currentIndex发生变化时，会触发onCurrentIndexUpdate方法，在其中将表达式的运算结果赋值给状态变量color。只有color的值发生变化时，Text组件才会重新渲染，运行效果图如下：  被依赖的数据源仅在父子或兄弟关系的组件中传递时，可以参考上述示例，使用@State/@Link/@Watch装饰器进行状态管理，实现组件的精准刷新。 当组件关系层级较多但都归属于同一个确定的组件树时，推荐使用@Provide/@Consume传递数据，使用@Watch装饰器监听数据变化，在监听回调中执行业务逻辑。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section117631443131915\\\"'><a name='\\\"section117631443131915\\\"'></a><a name='\\\"section117631443131915\\\"'></a><h4>[h2]使用 @Watch 装饰器监听数据源</h4><p>在组件中使用@Watch装饰器监听数据源，当数据变化时执行业务逻辑，确保只有满足条件的组件进行刷新。</p> <p><strong>反例</strong></p> <p>在下面的示例代码中，多个组件直接关联同一个数据源，但是未使用@Watch装饰器和Emitter事件驱动更新，导致了冗余的组件刷新。</p>  <p>上述示例中，每个ListItemComponent组件点击Text后会将当前点击的列表项下标index赋值给currentIndex，@Link装饰的状态变量currentIndex变化后，父组件Index和所有ListItemComponent组件中的Index值都会同步发生改变。然后，在所有ListItemComponent组件中，根据列表项下标index与currentIndex的差值的绝对值是否小于等于1来决定Text的颜色，如果满足条件，则文本显示为红色，否则显示为蓝色，下面是运行效果图。</p> <p><span><img height='\\\"352.1175\\\"' originheight='\\\"724\\\"' originwidth='\\\"1076\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161109.73776618621768307843680083649483:50001231000000:2800:51140A00B9EEADF7936CB48AAE8178209AD3F03BA89B26A30945242338D83458.gif\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></p> <p>可以看到每次点击后即使其中部分Text组件的颜色并没有发生改变，所有的Text组件也都会刷新。这是由于ListItemComponent组件中的Text组件直接关联了currentIndex，而不是根据currentIndex计算得到的颜色。</p> <p>针对上述父子组件层级关系的场景，推荐使用状态装饰器@Watch监听数据源。当数据源改变时，在@Watch的监听回调中执行业务逻辑。组件关联回调的处理结果，而不是直接关联数据源。</p> <p><strong>正例</strong></p> <p>下面是对上述示例的优化，展示如何通过@Watch装饰器实现精准刷新。</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct UseWatchListener {\\n  @State currentIndex: number = 0; // 当前选中的列表项下标\\n  private listData: string[] = [];\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i &lt; 10; i++) {\\n      this.listData.push(`组件 ${i}`);\\n    }\\n  }\\n\\n  build() {\\n    Row() {\\n      Column() {\\n        List() {\\n          ForEach(this.listData, (item: string, index: number) =&gt; {\\n            ListItem() {\\n              ListItemComponent({ item: item, index: index, currentIndex: this.currentIndex })\\n            }\\n          })\\n        }\\n        .height('100%')\\n        .width('100%')\\n        .alignListItem(ListItemAlign.Center)\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}\\n\\n@Component\\nstruct ListItemComponent {\\n  @Prop item: string;\\n  @Prop index: number; // 列表项的下标\\n  @Link @Watch('onCurrentIndexUpdate') currentIndex: number;\\n  @State color: Color = Math.abs(this.index - this.currentIndex) &lt;= 1 ? Color.Red : Color.Blue;\\n\\n  isRender(): number {\\n    console.info(`ListItemComponent ${this.index} Text is rendered`);\\n    return 50;\\n  }\\n\\n  onCurrentIndexUpdate() {\\n    // 根据当前列表项下标index与currentIndex的差值来动态修改color的值\\n    this.color = Math.abs(this.index - this.currentIndex) &lt;= 1 ? Color.Red : Color.Blue;\\n  }\\n\\n  build() {\\n    Column() {\\n      Text(this.item)\\n        .fontSize(this.isRender())\\n        .fontColor(this.color)\\n        .onClick(() =&gt; {\\n          this.currentIndex = this.index;\\n        })\\n    }\\n  }\\n}</pre> <p>上述代码中，ListItemComponent组件中的状态变量currentIndex使用@Watch装饰，Text组件直接关联新的状态变量color。当currentIndex发生变化时，会触发onCurrentIndexUpdate方法，在其中将表达式的运算结果赋值给状态变量color。只有color的值发生变化时，Text组件才会重新渲染，运行效果图如下：</p> <p><span><img height='\\\"353.115\\\"' originheight='\\\"722\\\"' originwidth='\\\"1069\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161109.04159374314320075800237994444811:50001231000000:2800:D88936722153E7B28EE484B8D0465F586FEF0E0B1EF3C6BD6A6ACEC516953721.gif\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></p> <p>被依赖的数据源仅在父子或兄弟关系的组件中传递时，可以参考上述示例，使用@State/@Link/@Watch装饰器进行状态管理，实现组件的精准刷新。</p> <p>当组件关系层级较多但都归属于同一个确定的组件树时，推荐使用@Provide/@Consume传递数据，使用@Watch装饰器监听数据变化，在监听回调中执行业务逻辑。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-status-management.html"
    },
    {
        "id": 64,
        "pre": "import { ButtonComponent } from '../components/ButtonComponent';\\nimport { ListItemComponent } from '../components/ListItemComponent';\\n\\n@Entry\\n@Component\\nstruct UseEmitterPublish {\\n  listData: string[] = ['A', 'B', 'C', 'D', 'E', 'F'];\\n\\n  build() {\\n    Column() {\\n      Row() {\\n        Column() {\\n          ButtonComponent()\\n        }\\n      }\\n\\n      Column() {\\n        Column() {\\n          List() {\\n            ForEach(this.listData, (item: string, index: number) => {\\n              ListItemComponent({ myItem: item, index: index })\\n            })\\n          }\\n          .height('100%')\\n          .width('100%')\\n          .alignListItem(ListItemAlign.Center)\\n        }\\n      }\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]使用自定义事件发布订阅",
        "parent_text": "[h2]使用自定义事件发布订阅当组件关系复杂或跨越层级过多时，推荐使用EventHub或者Emitter自定义事件发布订阅的方式。当数据源改变时发布事件，依赖该数据源的组件通过订阅事件来获取数据源的改变，完成业务逻辑的处理，从而实现组件的精准刷新。 下面通过部分示例代码介绍使用方式，ButtonComponent组件作为交互组件触发数据变更，ListItemComponent组件接收数据做相应的UI刷新。  由于ButtonComponent组件和ListItemComponent组件的组件关系较为复杂，因此在ButtonComponent组件中的Button回调中，可以使用emitter.emit发送事件，在ListItemComponent组件中订阅事件。在事件触发的回调中接收数据value，通过业务逻辑决定是否修改状态变量color，从而实现精准控制ListItemComponent组件中Text的刷新。 import { emitter } from '@kit.BasicServicesKit';\\n\\nconst CHANGE_COLOR_EVENT_ID = 1;\\n\\n@Component\\nexport struct ButtonComponent {\\n  value: number = 2;\\n\\n  build() {\\n    Button(`下标是${this.value}的倍数的组件文字变为红色`)\\n      .onClick(() => {\\n        let event: emitter.InnerEvent = {\\n          eventId: CHANGE_COLOR_EVENT_ID,\\n          priority: emitter.EventPriority.LOW\\n        };\\n        let eventData: emitter.EventData = {\\n          data: {\\n            value: this.value\\n          }\\n        };\\n        // 发送eventId为CHANGE_COLOR_EVENT_ID的事件，事件内容为eventData\\n        emitter.emit(event, eventData);\\n        this.value++;\\n      })\\n\\n  }\\n} import { emitter } from '@kit.BasicServicesKit';\\n\\nconst CHANGE_COLOR_EVENT_ID = 1;\\n\\n@Component\\nexport struct ListItemComponent {\\n  @State color: Color = Color.Black;\\n  @Prop index: number;\\n  @Prop myItem: string;\\n\\n  aboutToAppear(): void {\\n    let event: emitter.InnerEvent = {\\n      eventId: CHANGE_COLOR_EVENT_ID\\n    };\\n    // 收到eventId为CHANGE_COLOR_EVENT_ID的事件后执行该回调\\n    let callback = (eventData: emitter.EventData): void => {\\n      if (eventData.data?.value !== 0 && this.index % eventData.data?.value === 0) {\\n        this.color = Color.Red;\\n      }\\n    };\\n    // 订阅eventId为CHANGE_COLOR_EVENT_ID的事件\\n    emitter.on(event, callback);\\n  }\\n\\n  build() {\\n    Column() {\\n      Text(this.myItem)\\n        .fontSize(50)\\n        .fontColor(this.color)\\n    }\\n  }\\n}  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section26916161205\\\"'><a name='\\\"section26916161205\\\"'></a><a name='\\\"section26916161205\\\"'></a><h4>[h2]使用自定义事件发布订阅</h4><p>当组件关系复杂或跨越层级过多时，推荐使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-eventhub\\\"' target='\\\"_blank\\\"'>EventHub</a>或者<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-emitter\\\"' target='\\\"_blank\\\"'>Emitter</a>自定义事件发布订阅的方式。当数据源改变时发布事件，依赖该数据源的组件通过订阅事件来获取数据源的改变，完成业务逻辑的处理，从而实现组件的精准刷新。</p> <p>下面通过部分示例代码介绍使用方式，ButtonComponent组件作为交互组件触发数据变更，ListItemComponent组件接收数据做相应的UI刷新。</p>  <p>由于ButtonComponent组件和ListItemComponent组件的组件关系较为复杂，因此在ButtonComponent组件中的Button回调中，可以使用emitter.emit发送事件，在ListItemComponent组件中订阅事件。在事件触发的回调中接收数据value，通过业务逻辑决定是否修改状态变量color，从而实现精准控制ListItemComponent组件中Text的刷新。</p> <pre class='\\\"screen\\\"'>import { emitter } from '@kit.BasicServicesKit';\\n\\nconst CHANGE_COLOR_EVENT_ID = 1;\\n\\n@Component\\nexport struct ButtonComponent {\\n  value: number = 2;\\n\\n  build() {\\n    Button(`下标是${this.value}的倍数的组件文字变为红色`)\\n      .onClick(() =&gt; {\\n        let event: emitter.InnerEvent = {\\n          eventId: CHANGE_COLOR_EVENT_ID,\\n          priority: emitter.EventPriority.LOW\\n        };\\n        let eventData: emitter.EventData = {\\n          data: {\\n            value: this.value\\n          }\\n        };\\n        // 发送eventId为CHANGE_COLOR_EVENT_ID的事件，事件内容为eventData\\n        emitter.emit(event, eventData);\\n        this.value++;\\n      })\\n\\n  }\\n}</pre> <pre class='\\\"screen\\\"'>import { emitter } from '@kit.BasicServicesKit';\\n\\nconst CHANGE_COLOR_EVENT_ID = 1;\\n\\n@Component\\nexport struct ListItemComponent {\\n  @State color: Color = Color.Black;\\n  @Prop index: number;\\n  @Prop myItem: string;\\n\\n  aboutToAppear(): void {\\n    let event: emitter.InnerEvent = {\\n      eventId: CHANGE_COLOR_EVENT_ID\\n    };\\n    // 收到eventId为CHANGE_COLOR_EVENT_ID的事件后执行该回调\\n    let callback = (eventData: emitter.EventData): void =&gt; {\\n      if (eventData.data?.value !== 0 &amp;&amp; this.index % eventData.data?.value === 0) {\\n        this.color = Color.Red;\\n      }\\n    };\\n    // 订阅eventId为CHANGE_COLOR_EVENT_ID的事件\\n    emitter.on(event, callback);\\n  }\\n\\n  build() {\\n    Column() {\\n      Text(this.myItem)\\n        .fontSize(50)\\n        .fontColor(this.color)\\n    }\\n  }\\n}</pre> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-status-management.html"
    },
    {
        "id": 65,
        "pre": "int main(int argc, char **argv) {\\n  int stack_array[99];\\n  stack_array[1] = 0;\\n  return stack_array[argc + 100];  // BOOM\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]地址越界问题的日志分析",
        "parent_text": "[h2]地址越界问题的日志分析对于地址越界问题的日志分析，由于日志落盘与cppcrash日志相似，具体参考CppCrash问题排查方法，详细的步骤为： 1）获取HWAsan检测工具，检测到的地址越界问题日志； 2）获取符号表，定位行号（use栈、free栈）； 3）结合应用代码逻辑分析代码的内存操作；  地址越界问题代码示例： 以地址越界问题类型栈缓存区溢出（stack-buffer-overflow）为例，该类型是指程序读、写的栈内存超出预期范围，程序运行异常、崩溃，具体影响如下 1）对于越界读的场景时，读取到无效数据并且使用时，程序运行出现异常； 2）对于越界写的场景时，出现对有效数据的覆盖，甚至覆盖支撑问题定位的信息（例如，栈帧信息）； 地址越界问题类型的示例代码如下，  地址越界问题日志分析 开启HWAsan检测，上报的地址越界问题日志如下， ==27137==ERROR: HWAddressSanitizer: tag-mismatch on address 0x007fdfd21014 at pc 0x005578a3dad0\\nREAD of size 4 at 0x007fdfd21014 tags: c6/00 (ptr/mem) in thread T0\\n    #0 0x5578a3dad0  (/data/local/tmp/test.out+0x1ad0)\\n    #1 0x7fbd30c574  (/lib/ld-musl-aarch64.so.1+0xa0574) (BuildId: 8504e35ee1068ac2f54be5cafe869af6)\\n    #2 0x5578a3d8b4  (/data/local/tmp/test.out+0x18b4)\\nCause: stack tag-mismatch\\nAddress 0x007fdfd21014 is located in stack of thread T0\\nThread: T0 0x007600002000 stack: [0x007fdf522000,0x007fdfd22000) sz: 8388608 tls: [0x007fbd45c200,0x007fbd45c8f8)\\nPreviously allocated frames:\\n  record_addr:0x7fbd21c630 record:0x2102005578a3da1c  (/data/local/tmp/test.out+0x1a1c)\\nMemory tags around the buggy address (one tag corresponds to 16 bytes):\\n  0x007efdfd2080: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2090: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20a0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20b0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20c0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20d0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20e0: 00  00  00  00  00  00  00  00  c6  c6  c6  c6  c6  c6  c6  c6\\n  0x007efdfd20f0: c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6\\n=>0x007efdfd2100: 0c [00] 00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2110: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2120: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2130: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2140: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2150: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2160: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2170: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2180: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\nTags for short granules around the buggy address (one tag corresponds to 16 bytes):\\n  0x007efdfd20f0: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\\n=>0x007efdfd2100: c6 [..] ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\\n  0x007efdfd2110: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\\nSee https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html#short-granules for a description of short granule tags\\nRegisters where the failure occurred (pc 0x005578a3dad0):\\n    x0  c600007fdfd21014  x1  c600007fdfd20e84  x2  0000007fdfd21010  x3  0000000000006000\\n    x4  0000007fdfd20fdc  x5  0000007fdfd20fdc  x6  0000000033313732  x7  3a6b636174735f6c\\n    x8  0000000000000000  x9  0200007efdfd20e8  x10 c600007fdfd20e80  x11 0000000000000065\\n    x12 000000000000000c  x13 0101010101010101  x14 0000000000000002  x15 0000000000000000\\n    x16 0000007fbc3a74ac  x17 0000000000000007  x18 0000000000000000  x19 0000007fdfd210a8\\n    x20 0200007700000000  x21 0000005578a3d9f4  x22 0000007fdfd210b8  x23 00000000000000f0\\n    x24 0000007fbd45c060  x25 0000007fbd459140  x26 0000007fbd45c988  x27 0000000000000001\\n    x28 0000007fbd45c0b0  x29 0000007fdfd21020  x30 0000005578a3dad4   sp 0000007fdfd20e70\\nSUMMARY: HWAddressSanitizer: tag-mismatch (/data/local/tmp/test.out+0x1ad0)\\n==27137==End Hwasan report\\nSignal 6 对应的日志结构如下，  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section937251519196\\\"'><a name='\\\"section937251519196\\\"'></a><a name='\\\"section937251519196\\\"'></a><h4>[h2]地址越界问题的日志分析</h4><p>对于地址越界问题的日志分析，由于日志落盘与cppcrash日志相似，具体参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-crash-cpp-way\\\"'>CppCrash问题排查方法</a>，详细的步骤为：</p> <p>1）获取HWAsan检测工具，检测到的地址越界问题日志；</p> <p>2）获取符号表，定位行号（use栈、free栈）；</p> <p>3）结合应用代码逻辑分析代码的内存操作；</p> <p></p> <ul><li>地址越界问题代码示例：</li></ul> <p>以地址越界问题类型栈缓存区溢出（stack-buffer-overflow）为例，该类型是指程序读、写的栈内存超出预期范围，程序运行异常、崩溃，具体影响如下</p> <p>1）对于越界读的场景时，读取到无效数据并且使用时，程序运行出现异常；</p> <p>2）对于越界写的场景时，出现对有效数据的覆盖，甚至覆盖支撑问题定位的信息（例如，栈帧信息）；</p> <p>地址越界问题类型的示例代码如下，</p>  <ul><li>地址越界问题日志分析</li></ul> <p>开启HWAsan检测，上报的地址越界问题日志如下，</p> <pre class='\\\"screen\\\"'>==27137==ERROR: HWAddressSanitizer: tag-mismatch on address 0x007fdfd21014 at pc 0x005578a3dad0\\nREAD of size 4 at 0x007fdfd21014 tags: c6/00 (ptr/mem) in thread T0\\n    #0 0x5578a3dad0  (/data/local/tmp/test.out+0x1ad0)\\n    #1 0x7fbd30c574  (/lib/ld-musl-aarch64.so.1+0xa0574) (BuildId: 8504e35ee1068ac2f54be5cafe869af6)\\n    #2 0x5578a3d8b4  (/data/local/tmp/test.out+0x18b4)\\nCause: stack tag-mismatch\\nAddress 0x007fdfd21014 is located in stack of thread T0\\nThread: T0 0x007600002000 stack: [0x007fdf522000,0x007fdfd22000) sz: 8388608 tls: [0x007fbd45c200,0x007fbd45c8f8)\\nPreviously allocated frames:\\n  record_addr:0x7fbd21c630 record:0x2102005578a3da1c  (/data/local/tmp/test.out+0x1a1c)\\nMemory tags around the buggy address (one tag corresponds to 16 bytes):\\n  0x007efdfd2080: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2090: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20a0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20b0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20c0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20d0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd20e0: 00  00  00  00  00  00  00  00  c6  c6  c6  c6  c6  c6  c6  c6\\n  0x007efdfd20f0: c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6  c6\\n=&gt;0x007efdfd2100: 0c [00] 00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2110: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2120: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2130: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2140: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2150: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2160: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2170: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\n  0x007efdfd2180: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\\nTags for short granules around the buggy address (one tag corresponds to 16 bytes):\\n  0x007efdfd20f0: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\\n=&gt;0x007efdfd2100: c6 [..] ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\\n  0x007efdfd2110: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\\nSee https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html#short-granules for a description of short granule tags\\nRegisters where the failure occurred (pc 0x005578a3dad0):\\n    x0  c600007fdfd21014  x1  c600007fdfd20e84  x2  0000007fdfd21010  x3  0000000000006000\\n    x4  0000007fdfd20fdc  x5  0000007fdfd20fdc  x6  0000000033313732  x7  3a6b636174735f6c\\n    x8  0000000000000000  x9  0200007efdfd20e8  x10 c600007fdfd20e80  x11 0000000000000065\\n    x12 000000000000000c  x13 0101010101010101  x14 0000000000000002  x15 0000000000000000\\n    x16 0000007fbc3a74ac  x17 0000000000000007  x18 0000000000000000  x19 0000007fdfd210a8\\n    x20 0200007700000000  x21 0000005578a3d9f4  x22 0000007fdfd210b8  x23 00000000000000f0\\n    x24 0000007fbd45c060  x25 0000007fbd459140  x26 0000007fbd45c988  x27 0000000000000001\\n    x28 0000007fbd45c0b0  x29 0000007fdfd21020  x30 0000005578a3dad4   sp 0000007fdfd20e70\\nSUMMARY: HWAddressSanitizer: tag-mismatch (/data/local/tmp/test.out+0x1ad0)\\n==27137==End Hwasan report\\nSignal 6</pre> <p>对应的日志结构如下，</p> <p><span><img originheight='\\\"846\\\"' originwidth='\\\"1441\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161241.78293315358758089339643024665644:50001231000000:2800:2D25A7DEE3B385369A69560F8C0DEADC834819E75588347C509055DB086C14C0.png\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-stability-address-illegal-way.html"
    },
    {
        "id": 66,
        "pre": "let filePath = pathDir + \\\"/test.txt\\\";\\nlet file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);\\nlet str: string = \\\"hello, world\\\";\\n// 使用异步方式往ROM里写文件\\nfileIo.write(file.fd, str).then((writeLen: number) => {\\n  console.info(\\\"write data to file succeed and size is:\\\" + writeLen);\\n}).catch((err: BusinessError) => {\\n  console.error(\\\"write data to file failed with error message: \\\" + err.message + \\\", error code: \\\" + err.code);\\n}).finally(() => {\\n  fileIo.closeSync(file);\\n});",
        "type": "Reference",
        "function_call": "write()",
        "function_name": "开发步骤",
        "parent_text": "开发步骤推荐使用异步接口fileIo.write()写文件到ROM，函数的返回值number为实际写入的数据长度（单位字节）。统计返回值的累计值，这个累计值是应用一段时间内写到ROM里的文件总大小。因此，确保视频、小视频在线播放时，文件下载的速率<20MB/min。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section7181529165813\\\"'><a name='\\\"section7181529165813\\\"'></a><a name='\\\"section7181529165813\\\"'></a><h4>开发步骤</h4><p>推荐使用异步接口fileIo.write()写文件到ROM，函数的<span rgb(64,72,91);\\\"=\"\" style='\\\"color:'>返回值</span><span rgb(64,72,91);\\\"=\"\" style='\\\"color:'>number</span><span rgb(64,72,91);\\\"=\"\" style='\\\"color:'>为实际写入的数据长度（单位字节）。统计</span>返回值的累计值，这个累计值是应用一段时间内写到ROM里的文件总大小。因此，确保视频、小视频在线播放时，文件下载的速率&lt;20MB/min。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-rom.html"
    },
    {
        "id": 67,
        "pre": "if (deviceInfo.deviceType === 'tablet' || display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_EXPANDED) {\\n  windowObj.setPreferredOrientation(window.Orientation.AUTO_ROTATION_RESTRICTED);\\n} else {\\n  windowObj.setPreferredOrientation(window.Orientation.PORTRAIT);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "其他情况下应用竖屏显示。 ",
        "import_module": null,
        "parent": "<li>其他情况下应用竖屏显示。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window.html"
    },
    {
        "id": 68,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { window } from '@kit.ArkUI';\\nimport { BusinessError, deviceInfo } from '@kit.BasicServicesKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  windowObj: window.Window | undefined = undefined;\\n  private onWindowSizeChange: (data: window.Size) => void = (data: window.Size) => {\\n    this.setDefaultOrientation();\\n  }\\n  // ...\\n  setDefaultOrientation(): void {\\n    const BREAKPOINT_MD = 600;\\n    let windowRect: window.Rect = this.windowObj!.getWindowProperties().windowRect;\\n    let windowWidthVp: number = px2vp(windowRect.width);\\n    let windowHeightVp: number = px2vp(windowRect.height);\\n    let aspectRatio: number = windowHeightVp / windowWidthVp;\\n    if (Math.min(windowWidthVp, windowHeightVp) >= BREAKPOINT_MD || (aspectRatio < 1.2 && aspectRatio >= 0.8) || deviceInfo.deviceType === 'tablet') {\\n      // Rotation supported.\\n      this.windowObj?.setPreferredOrientation(window.Orientation.AUTO_ROTATION_RESTRICTED);\\n    } else {\\n      // Portrait display.\\n      this.windowObj?.setPreferredOrientation(window.Orientation.PORTRAIT);\\n    }\\n  }\\n\\n  onWindowStageCreate(windowStage: window.WindowStage): void {\\n    // Main window is created, set main page for this ability\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');\\n    windowStage.getMainWindow().then((windowObj) => {\\n      this.windowObj = windowObj;\\n      this.setDefaultOrientation();\\n      this.windowObj.on('windowSizeChange', this.onWindowSizeChange);\\n    }).catch((err: BusinessError) => {\\n      hilog.error(0x0000, 'testTag', `Failed to obtain the main window. Cause code: ${err.code}, message: ${err.message}`);\\n    });\\n    windowStage.loadContent('pages/Index', (err) => {\\n      if (err.code) {\\n        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\\n        return;\\n      }\\n      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');\\n    });\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]示例代码",
        "parent_text": "[h2]示例代码针对一多横竖屏推荐的旋转方案，通用的适配方案参考如下代码。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section151761036183415\\\"'><a name='\\\"section151761036183415\\\"'></a><a name='\\\"section151761036183415\\\"'></a><h4>[h2]示例代码</h4><p>针对一多横竖屏推荐的旋转方案，通用的适配方案参考如下代码。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window.html"
    },
    {
        "id": 69,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { window } from '@kit.ArkUI';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  private onAvoidAreaChange: (avoidArea: window.AvoidAreaOptions) => void = (avoidArea: window.AvoidAreaOptions) => {\\n    if (avoidArea.type === window.AvoidAreaType.TYPE_SYSTEM) {\\n      // Updates the height of the top status bar.\\n      AppStorage.setOrCreate('topAvoidHeight', px2vp(avoidArea.area.topRect.height));\\n    } else if (avoidArea.type === window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {\\n      // Updated the bottom navigation bar.\\n      AppStorage.setOrCreate('bottomAvoidHeight', px2vp(avoidArea.area.bottomRect.height));\\n    }\\n  };\\n\\n  onWindowStageCreate(windowStage: window.WindowStage): void {\\n    windowStage.getMainWindow((err, window: window.Window) => {\\n      // ...\\n      window.setWindowLayoutFullScreen(true);\\n      let topAvoidHeight: window.AvoidArea = window.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);\\n      AppStorage.setOrCreate('topAvoidHeight', px2vp(topAvoidHeight.topRect.height));\\n      let bottomAvoidHeight: window.AvoidArea =\\n        window.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR);\\n      AppStorage.setOrCreate('bottomAvoidHeight', px2vp(bottomAvoidHeight.bottomRect.height));\\n    });\\n    window.on('avoidAreaChange', this.onAvoidAreaChange);\\n\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "通过getWindowAvoidArea()",
        "function_name": null,
        "parent_text": "在UIAbility的onWindowStageCreate生命周期回调中，获取窗口对象后使用setWindowLayoutFullScreen(true)设置窗口为全屏模式。通过getWindowAvoidArea()接口获取当前系统避让区高度（包含顶部状态栏高度及底部导航栏高度），保存至全局状态存储中。并使用on('avoidAreaChange')接口监听避让区变化获取避让区变化后的高度，同步至全局状态存储。 ",
        "import_module": null,
        "parent": "<li>在UIAbility的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-lifecycle\\\"' target='\\\"_blank\\\"'>onWindowStageCreate</a>生命周期回调中，获取窗口对象后使用setWindowLayoutFullScreen(true)设置窗口为全屏模式。通过getWindowAvoidArea()接口获取当前系统避让区高度（包含顶部状态栏高度及底部导航栏高度），保存至全局状态存储中。并使用on('avoidAreaChange')接口监听避让区变化获取避让区变化后的高度，同步至全局状态存储。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window.html"
    },
    {
        "id": 70,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { window } from '@kit.ArkUI';\\nimport { deviceInfo } from '@kit.BasicServicesKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onWindowStageCreate(windowStage: window.WindowStage) {\\n    // ...\\n    let windowClass: window.Window | null = null;\\n    windowStage.getMainWindow().then((data: window.Window) => {\\n      // ...\\n      windowClass = data;\\n      if (deviceInfo.deviceType !== '2in1') {\\n        windowClass.setWindowLayoutFullScreen(true);\\n      }\\n    });\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在UIAbility的onWindowStageCreate生命周期回调中获取窗口对象后，仅设备不为PC/2in1时窗口设置为全屏。 ",
        "import_module": null,
        "parent": "<li>在UIAbility的onWindowStageCreate生命周期回调中获取窗口对象后，仅设备不为PC/2in1时窗口设置为全屏。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window.html"
    },
    {
        "id": 71,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { window } from '@kit.ArkUI';\\nimport { deviceInfo } from '@kit.BasicServicesKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onWindowStageCreate(windowStage: window.WindowStage): void {\\n    windowStage.loadContent('pages/Index', (err) => {\\n      if (err.code) {\\n        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err));\\n        return;\\n      }\\n      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');\\n    });\\n    // ...\\n    windowStage.getMainWindow().then((data: window.Window) => {\\n      let deviceTypeInfo: string = deviceInfo.deviceType;\\n      if (deviceTypeInfo === '2in1') {\\n        // Set the title bar of the 2in1 device to be invisible after the loadContent() call takes effect.\\n        data.setWindowDecorVisible(false);\\n        // When the title bar is invisible, set the height of the title bar and control the height of the three buttons (full screen/restore, maximize, and close) in the upper right corner.\\n        data.setWindowDecorHeight(64);\\n      }\\n    })\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "调用setWindowDecorHeight()",
        "function_name": "[h2]示例代码",
        "parent_text": "[h2]示例代码在UIAbility的onWindowStageCreate生命周期回调中，判断PC/2in1设备类型，调用setWindowDecorVisible(false)接口设置标题栏不可见，调用setWindowDecorHeight()接口设置右上角三键区的高度。  PC/2in1上的完整代码工程请参考一多商务办公。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12161131417568\\\"'><a name='\\\"section12161131417568\\\"'></a><a name='\\\"section12161131417568\\\"'></a><h4>[h2]示例代码</h4><p>在UIAbility的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-lifecycle\\\"' target='\\\"_blank\\\"'>onWindowStageCreate</a>生命周期回调中，判断PC/2in1设备类型，调用setWindowDecorVisible(false)接口设置标题栏不可见，调用setWindowDecorHeight()接口设置右上角三键区的高度。</p>  <p>PC/2in1上的完整代码工程请参考<a href='\\\"https://gitee.com/harmonyos_samples/MultiBusinessOffice\\\"' target='\\\"_blank\\\"'>一多商务办公</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window.html"
    },
    {
        "id": 72,
        "pre": "import { BusinessError } from '@kit.BasicServicesKit';\\nimport { window } from '@kit.ArkUI';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\n\\n@Observed\\nexport class WindowUtil {\\n  private mainWindowClass?: window.Window;\\n\\n  // ...\\n  maximize(): void {\\n    if (this.mainWindowClass!.getWindowStatus() === window.WindowStatusType.FLOATING) {\\n      this.mainWindowClass!.maximize()\\n        .then(() => {\\n          hilog.info(0x0000, 'testTag', '%{public}s', `Succeed in maximizing the window.`);\\n        })\\n        .catch((err: BusinessError) => {\\n          hilog.error(0x0000, 'testTag', `Failed to maximize the window. Code: ${err.code}, message: ${err.message}`,\\n            JSON.stringify(err) ?? '');\\n        });\\n    }\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "maximize()",
        "function_name": null,
        "parent_text": "双击视频区域以及点击视频全屏按钮分别采用TapGesture双击事件以及onClick点击事件实现。事件触发后获取当前窗口模式，若窗口模式为自由窗口，调用maximize()接口最大化窗口进入沉浸式全屏。 ",
        "import_module": null,
        "parent": "<li>双击视频区域以及点击视频全屏按钮分别采用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-tapgesture\\\"' target='\\\"_blank\\\"'>TapGesture</a>双击事件以及<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-click\\\"' target='\\\"_blank\\\"'>onClick</a>点击事件实现。事件触发后获取当前窗口模式，若窗口模式为自由窗口，调用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#maximize12\\\"' target='\\\"_blank\\\"'>maximize()</a>接口最大化窗口进入沉浸式全屏。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window.html"
    },
    {
        "id": 73,
        "pre": "  // 声明ArkTS侧函数\\n  @State value: number = 0;\\n  work: Function = (param: number) => {\\n    param += 30;\\n    this.value = param;\\n    return param;\\n  }",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在ArkTS侧实现一个回调函数，参数为param，函数体中对参数param加30后刷新变量value，并返回最新的param值。将回调函数作为参数调用Native侧的threadSafeCase接口。             // 调用Native侧函数并传递ArkTS侧函数到Native侧\\n            testNapi.threadSafeCase(this.work); ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>在ArkTS侧实现一个回调函数，参数为param，函数体中对参数param加30后刷新变量value，并返回最新的param值。将回调函数作为参数调用Native侧的threadSafeCase接口。 <pre class='\\\"screen\\\"'>            // 调用Native侧函数并传递ArkTS侧函数到Native侧\\n            testNapi.threadSafeCase(this.work);</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-native-sub-main-comm.html"
    },
    {
        "id": 74,
        "pre": "import(\\\"//build/config/sysroot.gni\\\")\\nimport(\\\"//build/toolchain/gcc_toolchain.gni\\\")\\n\\ndeclare_args() {\\n  # Whether unstripped binaries, i.e. compiled with debug symbols, should be\\n  # considered runtime_deps rather than stripped ones.\\n  ohos_unstripped_runtime_outputs = true\\n  ohos_extra_cflags = \\\"\\\"\\n  ohos_extra_cppflags = \\\"\\\"\\n  ohos_extra_cxxflags = \\\"\\\"\\n  ohos_extra_asmflags = \\\"\\\"\\n  ohos_extra_ldflags = \\\"\\\"\\n}\\n\\n# The ohos clang toolchains share most of the same parameters, so we have this\\n# wrapper around gcc_toolchain to avoid duplication of logic.\\n#\\n# Parameters:\\n#  - toolchain_root\\n#      Path to cpu-specific toolchain within the ndk.\\n#  - sysroot\\n#      Sysroot for this architecture.\\n#  - lib_dir\\n#      Subdirectory inside of sysroot where libs go.\\n#  - binary_prefix\\n#      Prefix of compiler executables.\\ntemplate(\\\"ohos_clang_toolchain\\\") {\\n  gcc_toolchain(target_name) {\\n    assert(defined(invoker.toolchain_args),\\n           \\\"toolchain_args must be defined for ohos_clang_toolchain()\\\")\\n    toolchain_args = invoker.toolchain_args\\n    toolchain_args.current_os = \\\"ohos\\\"\\n\\n    # Output linker map files for binary size analysis.\\n    enable_linker_map = true\\n\\n    ohos_libc_dir =\\n        rebase_path(invoker.sysroot + \\\"/\\\" + invoker.lib_dir, root_build_dir)\\n    libs_section_prefix = \\\"${ohos_libc_dir}/Scrt1.o\\\"\\n    libs_section_prefix += \\\" ${ohos_libc_dir}/crti.o\\\"\\n    libs_section_postfix = \\\"${ohos_libc_dir}/crtn.o\\\"\\n\\n    if (invoker.target_name == \\\"ohos_clang_arm\\\") {\\n      abi_target = \\\"arm-linux-ohos\\\"\\n    } else if (invoker.target_name == \\\"ohos_clang_arm64\\\") {\\n      abi_target = \\\"aarch64-linux-ohos\\\"\\n    } else if (invoker.target_name == \\\"ohos_clang_x86_64\\\") {\\n      abi_target = \\\"x86_64-linux-ohos\\\"\\n    }\\n\\n    clang_rt_dir =\\n        rebase_path(\\\"${clang_lib_path}/${abi_target}/nanlegacy\\\",\\n                    root_build_dir)\\n    print(\\\"ohos_libc_dir :\\\", ohos_libc_dir)\\n    print(\\\"clang_rt_dir :\\\", clang_rt_dir)\\n    solink_libs_section_prefix = \\\"${ohos_libc_dir}/crti.o\\\"\\n    solink_libs_section_prefix += \\\" ${clang_rt_dir}/clang_rt.crtbegin.o\\\"\\n    solink_libs_section_postfix = \\\"${ohos_libc_dir}/crtn.o\\\"\\n    solink_libs_section_postfix += \\\" ${clang_rt_dir}/clang_rt.crtend.o\\\"\\n\\n    _prefix = rebase_path(\\\"${clang_base_path}/bin\\\", root_build_dir)\\n    cc = \\\"${_prefix}/clang\\\"\\n    cxx = \\\"${_prefix}/clang++\\\"\\n    ar = \\\"${_prefix}/llvm-ar\\\"\\n    ld = cxx\\n    readelf = \\\"${_prefix}/llvm-readobj\\\"\\n    nm = \\\"${_prefix}/llvm-nm\\\"\\n    if (!is_debug) {\\n      strip = rebase_path(\\\"${clang_base_path}/bin/llvm-strip\\\", root_build_dir)\\n      use_unstripped_as_runtime_outputs = ohos_unstripped_runtime_outputs\\n    }\\n    extra_cflags = ohos_extra_cflags\\n    extra_cppflags = ohos_extra_cppflags\\n    extra_cxxflags = ohos_extra_cxxflags\\n    extra_asmflags = ohos_extra_asmflags\\n    extra_ldflags = ohos_extra_ldflags\\n  }\\n}\\n\\nohos_clang_toolchain(\\\"ohos_clang_arm\\\") {\\n  sysroot = \\\"${sysroot}\\\"\\n  lib_dir = \\\"usr/lib/arm-linux-ohos\\\"\\n  toolchain_args = {\\n    current_cpu = \\\"arm\\\"\\n  }\\n}\\n\\nohos_clang_toolchain(\\\"ohos_clang_arm64\\\") {\\n  sysroot = \\\"${sysroot}\\\"\\n  lib_dir = \\\"usr/lib/aarch64-linux-ohos\\\"\\n  toolchain_args = {\\n    current_cpu = \\\"arm64\\\"\\n  }\\n}\\n\\nohos_clang_toolchain(\\\"ohos_clang_x86_64\\\") {\\n  sysroot = \\\"${sysroot}\\\"\\n  lib_dir = \\\"usr/lib/x86_64-linux-ohos\\\"\\n  toolchain_args = {\\n    current_cpu = \\\"x86_64\\\"\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "设置各个架构的ohos_clang_toolchain这里主要是在build/toolchain路径下新建一个ohos/BUILD.gn文件，用于配置ohos_clang_toolchain，里面主要配置了HarmonyOS用于启动引导程序的.o文件。同时设置HarmonyOS不同架构(主要包括ohos_clang_arm、ohos_clang_arm64、ohos_clang_x86_64)的ohos_clang_toolchain配置信息。具体添加内容如下：  ",
        "import_module": null,
        "parent": "<li><strong>设置各个架构的ohos_clang_toolchain</strong><p>这里主要是在build/toolchain路径下新建一个ohos/BUILD.gn文件，用于配置ohos_clang_toolchain，里面主要配置了HarmonyOS用于启动引导程序的.o文件。同时设置HarmonyOS不同架构(主要包括ohos_clang_arm、ohos_clang_arm64、ohos_clang_x86_64)的ohos_clang_toolchain配置信息。具体添加内容如下：</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gn-adapts-to-harmonyos.html"
    },
    {
        "id": 75,
        "pre": "import fs from 'fs'\\n\\ninterface OhPackage {\\n    name: string;\\n    version: number;\\n    description: string;\\n    author: string;\\n}\\n\\nexport function renameHarTask(str?: string) {\\n    return {\\n        pluginId: 'RenameHarTaskID',\\n        apply(pluginContext) {\\n            pluginContext.registerTask({\\n                // 编写自定义任务\\n                name: 'renameHarTask',\\n                run: (taskContext) => {\\n                    // 读取oh-package.json5，解析出version\\n                    const packageFile = taskContext.modulePath+'\\\\\\\\oh-package.json5';\\n                    console.log('file: ', packageFile);\\n                    let fileContent = fs.readFileSync(packageFile, 'utf8');\\n                    console.log(fileContent);\\n                    const content: OhPackage = JSON.parse(fileContent);\\n                    const version = content.version;\\n                    const author = content.author;\\n\\n                    console.log('renameHarTask: ', taskContext.moduleName, taskContext.modulePath);\\n                    const sourceFile = taskContext.modulePath + '\\\\\\\\build\\\\\\\\default\\\\\\\\outputs\\\\\\\\default\\\\\\\\' + taskContext.moduleName + '.har';\\n                    const targetPath = taskContext.modulePath + '\\\\\\\\build\\\\\\\\default\\\\\\\\outputs\\\\\\\\target\\\\\\\\';\\n                    const targetFile = targetPath\\n                        + taskContext.moduleName + '-' + version + '-' + author +'.har';\\n                    console.log('renameHarTask: sourceFile: ', sourceFile);\\n                    console.log('renameHarTask: targetFile: ', targetFile);\\n\\n                    // 创建目录\\n                    fs.mkdir(targetPath, { recursive: true }, (err) => {\\n                        if (err) throw err;\\n                        // 移动并修改产物文件名\\n                        fs.rename(sourceFile, targetFile, (err)=> {\\n                            console.log('err: ' + err);\\n                        });\\n                    });\\n                },\\n                // 确认自定义任务插入位置\\n                dependencies: ['default@PackageHar'],\\n                postDependencies: ['assembleHar']\\n            })\\n        }\\n    }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "插件代码示例如下： ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>插件代码示例如下： </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-hvigor-plugin.html"
    },
    {
        "id": 76,
        "pre": "let taskNum: number = 14; // 并发任务数控制，可根据需求调节\\nlet curTaskNum: number = taskNum <= 64 ? taskNum : 64; // 控制最多允许同时运行64个Worker实例\\nlet Workers: Worker.ThreadWorker[] = [];\\nfor (let i = 0; i < curTaskNum; i++) { // 根据限制控制Worker的实例化次数\\n    let WorkerInstance = new Worker.ThreadWorker(WorkerName); \\n    Workers.push(WorkerInstance);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "根据任务数创建Worker实例，由于Worker最多同时运行的子线程数量为64个（API12新增支持，旧版本为8个），所以当任务数超过64时需要做相应限制，示例代码如下。 ",
        "import_module": null,
        "parent": "<li><span>根据任务数创建Worker实例，由于Worker最多同时运行的子线程数量为64个（API12新增支持，旧版本为8个），所以当任务数超过64时需要做相应限制，示例代码如下。</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-comparative_practice_of_taskpool_and_worker.html"
    },
    {
        "id": 77,
        "pre": "@Component\\nexport struct VideoCard{\\n  // ...\\n  aboutToAppear(): void {\\n    // 创建复杂对象任务，若该任务执行耗时1s，则组件将在1s后再渲染\\n    this.createComplexVideoPlayer();\\n  }\\n  // ...\\n}\\n\\n@Component\\nexport struct CardList {\\n  @State videoList: VideoItem[] = getVideoList();\\n\\n  build() {\\n    List() {\\n      ForEach(this.videoList, (item: VideoItem) => {\\n        ListItem() {\\n          VideoCard({ item })\\n        }\\n      }, (item: VideoItem) => item.id)\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "反例 ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'><strong>反例</strong> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-component-performance-optimization.html"
    },
    {
        "id": 78,
        "pre": "build() {\\n  Stack() {\\n    this.renderChildren()\\n  }\\n  .width(this.descriptor.layoutMetrics.frame.size.width)\\n  .height(this.descriptor.layoutMetrics.frame.size.height)\\n  .backgroundColor(convertColorSegmentsToString(this.descriptor.props.backgroundColor))\\n  .position({ y: this.descriptor.layoutMetrics.frame.origin.y, x: this.descriptor.layoutMetrics.frame.origin.x })\\n  .borderWidth(this.descriptor.props.borderWidth)\\n  .borderColor({\\n    left: convertColorSegmentsToString(this.descriptor.props.borderColor.left),\\n    top: convertColorSegmentsToString(this.descriptor.props.borderColor.top),\\n    right: convertColorSegmentsToString(this.descriptor.props.borderColor.right),\\n    bottom: convertColorSegmentsToString(this.descriptor.props.borderColor.bottom)\\n  })\\n  .borderRadius(this.descriptor.props.borderRadius)\\n  .borderStyle(this.getBorderStyle())\\n  .opacity(this.getOpacity())\\n  .transform(this.descriptor.props.transform != undefined ? convertMatrixArrayToMatrix4(this.descriptor.props.transform) : undefined)\\n  .clip(this.getClip())\\n  .hitTestBehavior(this.getHitTestMode())\\n  .shadow(this.getShadow())\\n}",
        "type": "Reference",
        "function_call": "getInstance()",
        "function_name": "按需注册组件属性",
        "parent_text": "按需注册组件属性在使用组件开发应用UI界面时，会为每个组件设置属性，进行UI样式、行为等逻辑处理。当应用中单个组件设置了大量属性且该组件在应用中被大量使用时，单个组件的设置对应用的整体性能会产生较大影响。比如，在RN框架开发中，单个组件需要设置21个属性，且该组件在ForEach循环中使用。在该场景下，由于不知道应用实际需要使用哪些属性，因此把所有的属性通过属性方法的方式设置到组件上。而在实际使用中，大部分应用只会用到其中很少的几个属性，其他属性均维持默认值，这导致了大量属性的冗余设置。该场景示例代码片段如下：  从该场景中可以看到，在应用开发中，当注册了大量冗余属性的组件需要在视图上批量展示时对性能有较大影响。此时，可以考虑采用AttributeModifier动态注册组件属性的方式，替换使用属性方法静态注册组件属性的方式。 使用AttributeModifier动态注册组件属性相比于直接在组件上使用属性方法静态注册组件属性，主要存在以下两点区别： 动态注册属性：系统提供AttributeModifier接口，支持开发者自定义AttributeModifier接口的实现类。 当应用运行时，系统调用AttributeModifier接口的实现类中与组件样式相关的方法，在该方法内按照开发者自定义的业务逻辑动态设置组件属性。Diff更新属性：当组件创建或者更新时，重新执行组件的样式属性对象的更新接口。属性Diff逻辑基于Map实现，其中key值是属性类型，value值是属性修改器对象。更新场景下，通过key找到对应的属性修改器对象进行Diff对比，若有更新变化再通知native侧进行属性更新。 以一个简单的公共头像组件为例演示AttributeModifier方案的性能收益。公共头像组件要求对于有用户头像的数据，界面展示用户头像图片。对于没有用户头像的数据，界面展示灰色背景和用户名的第一个字符。现列表展示1000个头像组件，界面效果如下： 图3 表格展示头像组件界面    使用属性方法的方式给头像组件设置属性，代码如下：import util from '@kit.ArkTS';\\n\\n@Observed\\nclass User {\\n  id: string;\\n  name: string;\\n  avatarImage: ResourceStr;\\n\\n  constructor(id: string, name: string, avatarImage: ResourceStr) {\\n    this.id = id;\\n    this.name = name;\\n    this.avatarImage = avatarImage;\\n  }\\n}\\n//造数据\\nconst DEFAULT_BACKGROUND_COLOR = Color.Grey;\\nconst getUsers = () => {\\n  return Array.from(Array(1000), (item: User, i: number) => {\\n    return new User(\\n      util.generateRandomUUID(),\\n      i % 2 === 0 ? '张三' : '李四',\\n      i % 2 === 0 ? '' : $r('app.media.avatar')\\n    );\\n  });\\n}\\n\\n@Entry\\n@Component\\nexport struct AvatarGrid {\\n  @State users: User[] = getUsers();\\n\\n  build() {\\n    Grid() {\\n      ForEach(this.users, (u: User) => {\\n        GridItem() {\\n          Avatar({ user: u })\\n        }\\n      }, (user: User) => user.id)\\n    }\\n    .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr')\\n    .columnsGap(4)\\n    .rowsGap(4)\\n  }\\n}\\n// 头像组件\\n@Component\\nstruct Avatar {\\n  @ObjectLink user: User;\\n\\n  build() {\\n    Row() {\\n      if (!this.user.avatarImage) {\\n        Text(this.user.name.charAt(0))\\n          .fontSize(28)\\n          .fontColor(Color.White)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n    }\\n    .backgroundImage(this.user.avatarImage)\\n    .backgroundImageSize(ImageSize.Cover)\\n    .backgroundColor(DEFAULT_BACKGROUND_COLOR)\\n    .justifyContent(FlexAlign.Center)\\n    .size({ width: 50, height: 50 })\\n    .borderRadius(25)\\n    // .padding(2)\\n    // .margin(2)\\n    // .opacity(1)\\n    // .clip(false)\\n    // .layoutWeight(1)\\n    // .backgroundBlurStyle(BlurStyle.NONE)\\n    // .alignItems(VerticalAlign.Center)\\n    // .borderWidth(1)\\n    // .borderColor(Color.Pink)\\n    // .borderStyle(BorderStyle.Solid)\\n    // .expandSafeArea([SafeAreaType.SYSTEM])\\n    // .rotate({angle: 5})\\n    // .responseRegion({x: 0})\\n    // .mouseResponseRegion({x: 0})\\n    // .constraintSize({minWidth: 25})\\n    // .hitTestBehavior(HitTestMode.Default)\\n    // .backgroundImagePosition(Alignment.Center)\\n    // .foregroundBlurStyle(BlurStyle.NONE)\\n  }\\n}  将方案改为采用AttributeModifier动态注册属性的方式，需要新增自定义类实现AttributeModifier接口，并修改Avatar组件的属性注册逻辑。具体改动代码如下： // 1.自定义属性修改器，该类实现了AttributeModifier接口\\nclass RowModifier implements AttributeModifier<RowAttribute> {\\n  private customImage: ResourceStr = '';\\n  private static instance: RowModifier;\\n\\n  constructor() {}\\n\\n  setCustomImage(customImage: ResourceStr) {\\n    this.customImage = customImage;\\n    return this;\\n  }\\n  // 采用单例模式，避免为每个组件都创建一个新的修改器，增加创建产生的性能开销\\n  public static getInstance(): RowModifier {\\n    if (!RowModifier.instance) {\\n      RowModifier.instance = new RowModifier();\\n    }\\n    return RowModifier.instance;\\n  }\\n  // 2.实现AttributeModifier接口的applyNormalAttribute方法，自定义属性设置的逻辑\\n  applyNormalAttribute(instance: RowAttribute) {\\n    if (this.customImage) {\\n      instance.backgroundImage(this.customImage);\\n      instance.backgroundImageSize(ImageSize.Cover);\\n     } else {\\n      instance.backgroundColor(DEFAULT_BACKGROUND_COLOR);\\n      instance.justifyContent(FlexAlign.Center);\\n      // instance.padding(2)\\n      // instance.margin(2)\\n      // instance.opacity(1)\\n      // instance.clip(false)\\n      // instance.layoutWeight(1)\\n      // instance.backgroundBlurStyle(BlurStyle.NONE)\\n      // instance.alignItems(VerticalAlign.Center)\\n      // instance.borderWidth(1)\\n      // instance.borderColor(Color.Pink)\\n      // instance.borderStyle(BorderStyle.Solid)\\n      // instance.expandSafeArea([SafeAreaType.SYSTEM])\\n      // instance.rotate({ angle: 5 })\\n      // instance.responseRegion({x: 0})\\n      //instance.mouseResponseRegion({x: 0})\\n      // instance.constraintSize({minWidth: 25})\\n      // instance.hitTestBehavior(HitTestMode.Default)\\n      //instance.backgroundImagePosition(Alignment.Center)\\n      //instance.foregroundBlurStyle(BlurStyle.NONE)\\n    }\\n    instance.size({ width: 50, height: 50 });\\n    instance.borderRadius(25);\\n  }\\n}\\n\\n@Component\\nstruct Avatar {\\n  @ObjectLink user: User;\\n\\n  build() {\\n    Row() {\\n      if (!this.user.avatarImage) {\\n        Text(this.user.name.charAt(0))\\n          .fontSize(28)\\n          .fontColor(Color.White)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n    }\\n    // 3.将自定义RowModifier类作为参数传入，实现按需注册属性\\n    .attributeModifier(RowModifier.getInstance().setCustomImage(this.user.avatarImage))\\n  }\\n}\\n 对于上述两种方案，逐渐增加注册的属性个数，通过DevEco Studio提供的场景化调优工具DevEco Profiler获取两个方案的页面加载耗时（PageRouterManager::LoadPage）和应用侧首帧耗时（First Frame - App Phase），对比如下： 表2 静态注册属性和动态注册属性在不同属性数量下耗时   静态注册属性  动态注册属性    注册的属性个数  6个  12个  18个  24个  6个  12个  18个  24个   PageRouterManager::LoadPage  639ms900μs  668ms624μs  719ms139μs  764ms437μs  640ms989μs  662ms112μs  705ms407μs  717ms294μs   First Frame - App Phase  45ms554μs  45ms638μs  52ms918μs  52ms643μs  44ms603μs  43ms923μs  46ms709μs  46ms355μs     图4 静态注册属性和动态注册属性在不同属性数量下LoadPage耗时 图5 静态注册属性和动态注册属性在不同属性数量下First Frame - App Phase耗时 可以看到，当注册的属性个数较少时，使用动态注册的方案收益并不明显。当注册的属性个数递增时，动态注册的收益效果同步线性递增。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section14178121175019\\\"'><a name='\\\"section14178121175019\\\"'></a><a name='\\\"section14178121175019\\\"'></a><h4>按需注册组件属性</h4><p>在使用组件开发应用UI界面时，会为每个组件设置属性，进行UI样式、行为等逻辑处理。当应用中单个组件设置了大量属性且该组件在应用中被大量使用时，单个组件的设置对应用的整体性能会产生较大影响。比如，在RN框架开发中，单个组件需要设置21个属性，且该组件在ForEach循环中使用。在该场景下，由于不知道应用实际需要使用哪些属性，因此把所有的属性通过属性方法的方式设置到组件上。而在实际使用中，大部分应用只会用到其中很少的几个属性，其他属性均维持默认值，这导致了大量属性的冗余设置。该场景示例代码片段如下：</p>  <p>从该场景中可以看到，在应用开发中，当注册了大量冗余属性的组件需要在视图上批量展示时对性能有较大影响。此时，可以考虑采用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-attribute-modifier\\\"' target='\\\"_blank\\\"'>AttributeModifier</a>动态注册组件属性的方式，替换使用属性方法静态注册组件属性的方式。</p> <p>使用AttributeModifier动态注册组件属性相比于直接在组件上使用属性方法静态注册组件属性，主要存在以下两点区别：</p> <ul><li>动态注册属性：系统提供AttributeModifier接口，支持开发者自定义AttributeModifier接口的实现类。 当应用运行时，系统调用AttributeModifier接口的实现类中与组件样式相关的方法，在该方法内按照开发者自定义的业务逻辑动态设置组件属性。</li><li>Diff更新属性：当组件创建或者更新时，重新执行组件的样式属性对象的更新接口。属性Diff逻辑基于Map实现，其中key值是属性类型，value值是属性修改器对象。更新场景下，通过key找到对应的属性修改器对象进行Diff对比，若有更新变化再通知native侧进行属性更新。</li></ul> <p>以一个简单的公共头像组件为例演示AttributeModifier方案的性能收益。公共头像组件要求对于有用户头像的数据，界面展示用户头像图片。对于没有用户头像的数据，界面展示灰色背景和用户名的第一个字符。现列表展示1000个头像组件，界面效果如下：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图3 </b>表格展示头像组件界面</span><p></p> <p><span><img height='\\\"545.7522\\\"' originheight='\\\"1026\\\"' originwidth='\\\"497\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161105.49115002616918217766613108674297:50001231000000:2800:14A97681792D85B7E74A1328805E77406457F3788CDEBB61847D118E9983401D.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p></p> </div> <div class='\\\"p\\\"'>使用属性方法的方式给头像组件设置属性，代码如下：<pre class='\\\"screen\\\"'>import util from '@kit.ArkTS';\\n\\n@Observed\\nclass User {\\n  id: string;\\n  name: string;\\n  avatarImage: ResourceStr;\\n\\n  constructor(id: string, name: string, avatarImage: ResourceStr) {\\n    this.id = id;\\n    this.name = name;\\n    this.avatarImage = avatarImage;\\n  }\\n}\\n//造数据\\nconst DEFAULT_BACKGROUND_COLOR = Color.Grey;\\nconst getUsers = () =&gt; {\\n  return Array.from(Array(1000), (item: User, i: number) =&gt; {\\n    return new User(\\n      util.generateRandomUUID(),\\n      i % 2 === 0 ? '张三' : '李四',\\n      i % 2 === 0 ? '' : $r('app.media.avatar')\\n    );\\n  });\\n}\\n\\n@Entry\\n@Component\\nexport struct AvatarGrid {\\n  @State users: User[] = getUsers();\\n\\n  build() {\\n    Grid() {\\n      ForEach(this.users, (u: User) =&gt; {\\n        GridItem() {\\n          Avatar({ user: u })\\n        }\\n      }, (user: User) =&gt; user.id)\\n    }\\n    .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr')\\n    .columnsGap(4)\\n    .rowsGap(4)\\n  }\\n}\\n// 头像组件\\n@Component\\nstruct Avatar {\\n  @ObjectLink user: User;\\n\\n  build() {\\n    Row() {\\n      if (!this.user.avatarImage) {\\n        Text(this.user.name.charAt(0))\\n          .fontSize(28)\\n          .fontColor(Color.White)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n    }\\n    .backgroundImage(this.user.avatarImage)\\n    .backgroundImageSize(ImageSize.Cover)\\n    .backgroundColor(DEFAULT_BACKGROUND_COLOR)\\n    .justifyContent(FlexAlign.Center)\\n    .size({ width: 50, height: 50 })\\n    .borderRadius(25)\\n    // .padding(2)\\n    // .margin(2)\\n    // .opacity(1)\\n    // .clip(false)\\n    // .layoutWeight(1)\\n    // .backgroundBlurStyle(BlurStyle.NONE)\\n    // .alignItems(VerticalAlign.Center)\\n    // .borderWidth(1)\\n    // .borderColor(Color.Pink)\\n    // .borderStyle(BorderStyle.Solid)\\n    // .expandSafeArea([SafeAreaType.SYSTEM])\\n    // .rotate({angle: 5})\\n    // .responseRegion({x: 0})\\n    // .mouseResponseRegion({x: 0})\\n    // .constraintSize({minWidth: 25})\\n    // .hitTestBehavior(HitTestMode.Default)\\n    // .backgroundImagePosition(Alignment.Center)\\n    // .foregroundBlurStyle(BlurStyle.NONE)\\n  }\\n}</pre> </div> <p>将方案改为采用AttributeModifier动态注册属性的方式，需要新增自定义类实现AttributeModifier接口，并修改Avatar组件的属性注册逻辑。具体改动代码如下：</p> <pre class='\\\"screen\\\"'>// 1.自定义属性修改器，该类实现了AttributeModifier接口\\nclass RowModifier implements AttributeModifier&lt;RowAttribute&gt; {\\n  private customImage: ResourceStr = '';\\n  private static instance: RowModifier;\\n\\n  constructor() {}\\n\\n  setCustomImage(customImage: ResourceStr) {\\n    this.customImage = customImage;\\n    return this;\\n  }\\n  // 采用单例模式，避免为每个组件都创建一个新的修改器，增加创建产生的性能开销\\n  public static getInstance(): RowModifier {\\n    if (!RowModifier.instance) {\\n      RowModifier.instance = new RowModifier();\\n    }\\n    return RowModifier.instance;\\n  }\\n  // 2.实现AttributeModifier接口的applyNormalAttribute方法，自定义属性设置的逻辑\\n  applyNormalAttribute(instance: RowAttribute) {\\n    if (this.customImage) {\\n      instance.backgroundImage(this.customImage);\\n      instance.backgroundImageSize(ImageSize.Cover);\\n     } else {\\n      instance.backgroundColor(DEFAULT_BACKGROUND_COLOR);\\n      instance.justifyContent(FlexAlign.Center);\\n      // instance.padding(2)\\n      // instance.margin(2)\\n      // instance.opacity(1)\\n      // instance.clip(false)\\n      // instance.layoutWeight(1)\\n      // instance.backgroundBlurStyle(BlurStyle.NONE)\\n      // instance.alignItems(VerticalAlign.Center)\\n      // instance.borderWidth(1)\\n      // instance.borderColor(Color.Pink)\\n      // instance.borderStyle(BorderStyle.Solid)\\n      // instance.expandSafeArea([SafeAreaType.SYSTEM])\\n      // instance.rotate({ angle: 5 })\\n      // instance.responseRegion({x: 0})\\n      //instance.mouseResponseRegion({x: 0})\\n      // instance.constraintSize({minWidth: 25})\\n      // instance.hitTestBehavior(HitTestMode.Default)\\n      //instance.backgroundImagePosition(Alignment.Center)\\n      //instance.foregroundBlurStyle(BlurStyle.NONE)\\n    }\\n    instance.size({ width: 50, height: 50 });\\n    instance.borderRadius(25);\\n  }\\n}\\n\\n@Component\\nstruct Avatar {\\n  @ObjectLink user: User;\\n\\n  build() {\\n    Row() {\\n      if (!this.user.avatarImage) {\\n        Text(this.user.name.charAt(0))\\n          .fontSize(28)\\n          .fontColor(Color.White)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n    }\\n    // 3.将自定义RowModifier类作为参数传入，实现按需注册属性\\n    .attributeModifier(RowModifier.getInstance().setCustomImage(this.user.avatarImage))\\n  }\\n}\\n</pre> <p>对于上述两种方案，逐渐增加注册的属性个数，通过DevEco Studio提供的场景化调优工具<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-profiler\\\"' target='\\\"_blank\\\"'>DevEco Profiler</a>获取两个方案的页面加载耗时（PageRouterManager::LoadPage）和应用侧首帧耗时（First Frame - App Phase），对比如下：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表2 </b>静态注册属性和动态注册属性在不同属性数量下耗时</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.23.13.2.10.1.1\\\"' valign='\\\"top\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' colspan='\\\"4\\\"' id='\\\"mcps1.3.23.13.2.10.1.2\\\"' valign='\\\"top\\\"'><p>静态注册属性</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' colspan='\\\"4\\\"' id='\\\"mcps1.3.23.13.2.10.1.3\\\"' valign='\\\"top\\\"'><p>动态注册属性</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.458054194580544%\\\"'><p>注册的属性个数</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"8.809119088091192%\\\"'><p>6个</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.57904209579042%\\\"'><p>12个</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.799020097990201%\\\"'><p>18个</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.839016098390161%\\\"'><p>24个</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"11.228877112288771%\\\"'><p>6个</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"11.198880111988801%\\\"'><p>12个</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"10.4989501049895%\\\"'><p>18个</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.58904109589041%\\\"'><p>24个</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.458054194580544%\\\"'><p>PageRouterManager::LoadPage</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"8.809119088091192%\\\"'><p>639ms900μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.57904209579042%\\\"'><p>668ms624μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.799020097990201%\\\"'><p>719ms139μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.839016098390161%\\\"'><p>764ms437μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"11.228877112288771%\\\"'><p>640ms989μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"11.198880111988801%\\\"'><p>662ms112μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"10.4989501049895%\\\"'><p>705ms407μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.58904109589041%\\\"'><p>717ms294μs</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.458054194580544%\\\"'><p>First Frame - App Phase</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"8.809119088091192%\\\"'><p>45ms554μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.57904209579042%\\\"'><p>45ms638μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.799020097990201%\\\"'><p>52ms918μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.839016098390161%\\\"'><p>52ms643μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"11.228877112288771%\\\"'><p>44ms603μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"11.198880111988801%\\\"'><p>43ms923μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"10.4989501049895%\\\"'><p>46ms709μs</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.58904109589041%\\\"'><p>46ms355μs</p> </td> </tr> </tbody></table> </div> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图4 </b>静态注册属性和动态注册属性在不同属性数量下LoadPage耗时</span><br/><span><img height='\\\"311.169061\\\"' originheight='\\\"452\\\"' originwidth='\\\"752\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161105.96847670318094678941407069611551:50001231000000:2800:CD7CB67CD3609EE577B249D59AB1AAF29AB9BDCF0CCD42AE9CEC88EB834F2962.png\\\"' title='\\\"点击放大\\\"' width='\\\"517.705559\\\"'/></span></div> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图5 </b>静态注册属性和动态注册属性在不同属性数量下First Frame - App Phase耗时</span><br/><span><img height='\\\"312.969615\\\"' originheight='\\\"452\\\"' originwidth='\\\"752\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161105.75559264766536968482111729036389:50001231000000:2800:49D8E08C58EA9B4FF0FD25414572314A45BE7CA0A326E7A94EB7BBB8D95A5627.png\\\"' title='\\\"点击放大\\\"' width='\\\"520.6980590000001\\\"'/></span></div> <p>可以看到，当注册的属性个数较少时，使用动态注册的方案收益并不明显。当注册的属性个数递增时，动态注册的收益效果同步线性递增。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-component-performance-optimization.html"
    },
    {
        "id": 79,
        "pre": "import { util } from '@kit.ArkTS';\\n\\ninterface User {\\n  id: string;\\n  name: string;\\n  age?: number;\\n  avatarImage?: ResourceStr;\\n  //introduction: string;\\n  // ...\\n}\\n\\n// 造数据\\nconst DEFAULT_BACKGROUND_COLOR = Color.Pink;\\nconst getUsers = () => {\\n  const USERS: User[] = [{\\n    id: '1',\\n    name: '张三',\\n  }, {\\n    id: '2',\\n    name: '李四',\\n  }, {\\n    id: '3',\\n    name: '王五',\\n  }];\\n  return Array.from(Array(30), (item: User, i: number) => {\\n    return {\\n      id: util.generateRandomUUID(),\\n      name: USERS[i%3].name,\\n      avatarImage: $r('app.media.avatar'),\\n      age: 18 + i\\n    } as User;\\n  });\\n}\\n\\n// 用户卡片列表组件\\n@Component\\nexport struct UserCardList {\\n  @State users: User[] = getUsers();\\n\\n  build() {\\n    List({space: 8}) {\\n      ForEach(this.users, (item: User) => {\\n        ListItem() {\\n          UserCard({name: item.name, age: item.age, avatarImage: item.avatarImage})\\n        }\\n      }, (item: User) => item.id)\\n    }\\n    .alignListItem(ListItemAlign.Center)\\n  }\\n}\\n\\n// 用户卡片自定义组件\\n@Component\\nstruct UserCard {\\n  @Prop avatarImage: ResourceStr;\\n  @Prop name: string;\\n  @Prop age: number;\\n\\n  build() {\\n    Row() {\\n      Row(){\\n        Image(this.avatarImage)\\n          .size({width: 50, height: 50})\\n          .borderRadius(25)\\n          .margin(8)\\n        Text(this.name)\\n          .fontSize(30)\\n      }\\n      Text(`年龄：${this.age.toString()}`)\\n        .fontSize(20)\\n    }\\n    .backgroundColor(DEFAULT_BACKGROUND_COLOR)\\n    .justifyContent(FlexAlign.SpaceBetween)\\n    .borderRadius(8)\\n    .padding(8)\\n    .height(66)\\n    .width('80%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "ListItem()",
        "function_name": "优先使用@Builder方法代替自定义组件",
        "parent_text": "优先使用@Builder方法代替自定义组件在ArkUI中使用自定义组件时，在build阶段将在后端FrameNode树创建一个相应的CustomNode节点，在渲染阶段时也会创建对应的RenderNode节点，如下图所示。 图6 前后端UI组件树关系图  前端UI描述结构会在后端创建相应的FrameNode节点树；FrameNode节点树主要用于处理UI组件属性更新、布局测算、事件处理等业务逻辑；CustomNode作为FrameNode的子类，用于处理自定义组件相关业务逻辑，比如执行build函数。FrameNode节点树在渲染阶段生成后端渲染树进行UI渲染。 因此，在应用开发时，减少自定义组件的使用，尤其是自定义组件在循环中的使用，将成倍减少FrameNode节点树上CustomNode节点数量，有效缩短页面的加载和渲染时长。当在应用中使用自定义组件时，可以优先考虑使用@Builder函数代替自定义组件，@Builder函数不会在后端FrameNode节点树上创建一个新的树节点。如，在使用ForEach循环展示卡片列表信息时，若卡片组件仅作展示，无需使用自定义组件的复杂能力如生命周期函数时，可以创建一个@Builder函数代替创建自定义卡片组件，界面展示如下： 图7 卡片列表界面    使用自定义组件方案，示例代码如下：  改用@Builder函数的方式代替自定义组件UserCard的方案，具体修改的代码如下: // 1. 自定义@Builder函数组件\\n@Builder\\nfunction UserCardBuilder(name: string, age?: number, avatarImage?: ResourceStr) {\\n  Row() {\\n    Row(){\\n      Image(avatarImage)\\n        .size({width: 50, height: 50})\\n        .borderRadius(25)\\n        .margin(8)\\n      Text(name)\\n        .fontSize(30)\\n    }\\n    Text(`年龄：${age?.toString()}`)\\n      .fontSize(20)\\n  }\\n  .backgroundColor(DEFAULT_BACKGROUND_COLOR)\\n  .justifyContent(FlexAlign.SpaceBetween)\\n  .borderRadius(8)\\n  .padding(8)\\n  .height(66)\\n  .width('80%')\\n}\\n\\n@Component\\nexport struct UserCardList {\\n  @State users: User[] = getUsers();\\n\\n  build() {\\n    List({space: 8}) {\\n      ForEach(this.users, (item: User) => {\\n        ListItem() {\\n          // 2. 在build函数中使用@Builder函数\\n          UserCardBuilder(item.name,item.age,item.avatarImage)\\n        }\\n      }, (item: User) => item.id)\\n    }\\n    .alignListItem(ListItemAlign.Center)\\n  }\\n} 将组件数量从30个递增到3000个，通过profiler获取页面加载标签PageRouterManager::LoadPage和页面UI刷新任务标签UITaskScheduler::FlushTask的耗时，对比两种方案的耗时如下： 图8 两种方案LoadPage标签耗时对比 图9 两种方案UITaskSchedule标签耗时对比 通过对比图可以看到，@Builder方案在页面加载和刷新UI页面（包括布局、渲染和动画）方面优于自定义组件方案。随着组件个数增加，收益也线性增加。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section18773182614502\\\"'><a name='\\\"section18773182614502\\\"'></a><a name='\\\"section18773182614502\\\"'></a><h4>优先使用@Builder方法代替自定义组件</h4><p>在ArkUI中使用自定义组件时，在build阶段将在后端FrameNode树创建一个相应的CustomNode节点，在渲染阶段时也会创建对应的RenderNode节点，如下图所示。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图6 </b>前后端UI组件树关系图</span><br/><span><img height='\\\"360.1906\\\"' originheight='\\\"663\\\"' originwidth='\\\"1575\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161105.66476466237580192804354718105245:50001231000000:2800:2EC10AADDD6420B924F13F889D4D77FBE4A17F151F655339EA461242D8DFC99B.png\\\"' title='\\\"点击放大\\\"' width='\\\"851.2\\\"'/></span></div> <p></p> <ul><li>前端UI描述结构会在后端创建相应的FrameNode节点树；</li><li>FrameNode节点树主要用于处理UI组件属性更新、布局测算、事件处理等业务逻辑；</li><li>CustomNode作为FrameNode的子类，用于处理自定义组件相关业务逻辑，比如执行build函数。</li><li>FrameNode节点树在渲染阶段生成后端渲染树进行UI渲染。</li></ul> <p>因此，在应用开发时，减少自定义组件的使用，尤其是自定义组件在循环中的使用，将成倍减少FrameNode节点树上CustomNode节点数量，有效缩短页面的加载和渲染时长。当在应用中使用自定义组件时，可以优先考虑使用@Builder函数代替自定义组件，@Builder函数不会在后端FrameNode节点树上创建一个新的树节点。如，在使用ForEach循环展示卡片列表信息时，若卡片组件仅作展示，无需使用自定义组件的复杂能力如生命周期函数时，可以创建一个@Builder函数代替创建自定义卡片组件，界面展示如下：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图7 </b>卡片列表界面</span></div> <p></p> <p><span><img height='\\\"545.7522\\\"' originheight='\\\"1026\\\"' originwidth='\\\"497\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161105.79931854525718725818840952742169:50001231000000:2800:93CBE0C09B5E76D188E64109792D71BA7B7E06FFFBF68036130D213A840EC273.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p></p> <p>使用自定义组件方案，示例代码如下：</p>  <p>改用@Builder函数的方式代替自定义组件UserCard的方案，具体修改的代码如下:</p> <pre class='\\\"screen\\\"'>// 1. 自定义@Builder函数组件\\n@Builder\\nfunction UserCardBuilder(name: string, age?: number, avatarImage?: ResourceStr) {\\n  Row() {\\n    Row(){\\n      Image(avatarImage)\\n        .size({width: 50, height: 50})\\n        .borderRadius(25)\\n        .margin(8)\\n      Text(name)\\n        .fontSize(30)\\n    }\\n    Text(`年龄：${age?.toString()}`)\\n      .fontSize(20)\\n  }\\n  .backgroundColor(DEFAULT_BACKGROUND_COLOR)\\n  .justifyContent(FlexAlign.SpaceBetween)\\n  .borderRadius(8)\\n  .padding(8)\\n  .height(66)\\n  .width('80%')\\n}\\n\\n@Component\\nexport struct UserCardList {\\n  @State users: User[] = getUsers();\\n\\n  build() {\\n    List({space: 8}) {\\n      ForEach(this.users, (item: User) =&gt; {\\n        ListItem() {\\n          // 2. 在build函数中使用@Builder函数\\n          UserCardBuilder(item.name,item.age,item.avatarImage)\\n        }\\n      }, (item: User) =&gt; item.id)\\n    }\\n    .alignListItem(ListItemAlign.Center)\\n  }\\n}</pre> <p>将组件数量从30个递增到3000个，通过profiler获取页面加载标签PageRouterManager::LoadPage和页面UI刷新任务标签UITaskScheduler::FlushTask的耗时，对比两种方案的耗时如下：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图8 </b>两种方案LoadPage标签耗时对比</span><br/><span><img height='\\\"307.584179\\\"' originheight='\\\"452\\\"' originwidth='\\\"752\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161105.42954143896577210459689037757702:50001231000000:2800:D3A6762BD9BD62BDF641CF72875545C052979A243B2E8E438AFC91E9309BAD78.png\\\"' title='\\\"点击放大\\\"' width='\\\"511.71750000000003\\\"'/></span></div> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图9 </b>两种方案UITaskSchedule标签耗时对比</span><br/><span><img height='\\\"306.22146100000003\\\"' originheight='\\\"452\\\"' originwidth='\\\"752\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161105.02172306051990577982897258461936:50001231000000:2800:7C9378D7A351FB869B114FB883C578D03BC02C7F39FF475BAF3179E8F60DFD78.png\\\"' title='\\\"点击放大\\\"' width='\\\"509.46514500000006\\\"'/></span></div> <p>通过对比图可以看到，@Builder方案在页面加载和刷新UI页面（包括布局、渲染和动画）方面优于自定义组件方案。随着组件个数增加，收益也线性增加。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-component-performance-optimization.html"
    },
    {
        "id": 80,
        "pre": "import { Want } from '@kit.AbilityKit';\\nimport { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\n// ...\\nconst TAG: string = 'EntryFormAbility';\\n\\nexport default class EntryFormAbility extends FormExtensionAbility {\\n  onAddForm(want: Want): formBindingData.FormBindingData {\\n    if(!want || !want.parameters) {\\n      hilog.error(0x0000, TAG, `FormAbility onAddForm want or want.parameters is undefined`);\\n      return formBindingData.createFormBindingData('');\\n    }\\n\\n    let formName: string = want.parameters[formInfo.FormParam.NAME_KEY] as string;\\n    let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY] as string;\\n    // ...\\n    return formBindingData.createFormBindingData('');\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "build()",
        "function_name": "[h2]开发流程",
        "parent_text": "[h2]开发流程添加卡片时，卡片数据初始化流程： 图6 卡片数据初始化流程 桌面长按应用图标待展示卡片列表时，首先触发FormExtensionAbility生命周期接口onAddForm()。使用卡片参数枚举FormParam可以从生命周期接口onAddForm()的入参want中取出卡片的相关信息如卡片标识、卡片名称、卡片宽高等。针对必要的信息可以进行判断或者保存等操作。  创建需要返回卡片的数据类，可以是包含若干键值对的Object或JSON格式的字符串。使用卡片数据绑定模块formBindingData的createFormBindingData()接口封装卡片需要使用的数据类，作为生命周期接口onAddForm()的返回值并传递给卡片。 说明：若onAddForm()接口中无法直接构建数据类作为接口返回值初始化卡片，例如依赖数据库查询结果或等待网络数据等使用异步的场景，可以使用FormProvider模块提供的updateForm()接口将异步获取的数据推送至卡片。 export class FormData {\\n  formId: string = '';\\n  formTime: string = '';\\n  isFavor?: boolean = false;\\n  index?: number = 0;\\n  cardList: Array<CardListItemData> = [];\\n\\n  constructor(formId: string) {\\n    this.formId = formId;\\n  }\\n} import { systemDateTime } from '@kit.BasicServicesKit';\\nimport { Want } from '@kit.AbilityKit';\\nimport { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { CardListItemData, CommonData, FormData } from '../common/CommonData';\\n// ...\\nconst TAG: string = 'EntryFormAbility';\\n\\nexport default class EntryFormAbility extends FormExtensionAbility {\\n  onAddForm(want: Want): formBindingData.FormBindingData {\\n    if(!want || !want.parameters) {\\n      hilog.error(0x0000, TAG, `FormAbility onAddForm want or want.parameters is undefined`);\\n      return formBindingData.createFormBindingData('');\\n    }\\n\\n    let formName: string = want.parameters[formInfo.FormParam.NAME_KEY] as string;\\n    let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY] as string;\\n    // ...\\n    if (formName === 'card_info_refresh') {\\n      let formData = new FormData(formId);\\n      formData.formTime = systemDateTime.getTime().toString();\\n      let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n      return formInfo;\\n    }\\n    // ...\\n    return formBindingData.createFormBindingData('');\\n  }\\n  // ...\\n} 卡片页面使用页面级的UI状态存储LocalStorage接收onAddForm()接口传递的数据。使用装饰器@LocalStorageProp装饰的状态变量接收数据类的详细信息，装饰器@LocalStorageProp(key)中的key值需与数据类的键值一一对应。使用获取的数据初始化卡片页面。 let storageLocal = new LocalStorage();\\n\\n@Entry(storageLocal)\\n@Component\\nstruct WidgetCard {\\n  // ...\\n  @LocalStorageProp('formTime') @Watch('onFormTimeChange') formTime: string = '';\\n  @LocalStorageProp('formId') formId: string = '';\\n  // ...\\n  onFormTimeChange() {\\n    // ...\\n  }\\n  // ...\\n  build() {\\n    // ...\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section2566201617118\\\"'><a name='\\\"section2566201617118\\\"'></a><a name='\\\"section2566201617118\\\"'></a><h4>[h2]开发流程</h4><p>添加卡片时，卡片数据初始化流程：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图6 </b>卡片数据初始化流程</span><br/><span><img originheight='\\\"299\\\"' originwidth='\\\"905\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161101.89031763824576845419010624111837:50001231000000:2800:5D2726A6C12CD67C374A15C67D397D57A99C13879B29878768962418002C0B35.png\\\"'/></span></div> <p>桌面长按应用图标待展示卡片列表时，首先触发<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formextensionability\\\"' target='\\\"_blank\\\"'>FormExtensionAbility</a>生命周期接口onAddForm()。使用卡片参数枚举<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-forminfo#formparam\\\"' target='\\\"_blank\\\"'>FormParam</a>可以从生命周期接口onAddForm()的入参<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-want\\\"' target='\\\"_blank\\\"'>want</a>中取出卡片的相关信息如卡片标识、卡片名称、卡片宽高等。针对必要的信息可以进行判断或者保存等操作。</p>  <p>创建需要返回卡片的数据类，可以是包含若干键值对的Object或JSON格式的字符串。使用卡片数据绑定模块<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formbindingdata#formbindingdata\\\"' target='\\\"_blank\\\"'>formBindingData</a>的createFormBindingData()接口封装卡片需要使用的数据类，作为生命周期接口onAddForm()的返回值并传递给卡片。</p> <p>说明：若onAddForm()接口中无法直接构建数据类作为接口返回值初始化卡片，例如依赖数据库查询结果或等待网络数据等使用异步的场景，可以使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#updateform\\\"' target='\\\"_blank\\\"'>FormProvider模块</a>提供的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#updateform\\\"' target='\\\"_blank\\\"'>updateForm()</a>接口将异步获取的数据推送至卡片。</p> <pre class='\\\"screen\\\"'>export class FormData {\\n  formId: string = '';\\n  formTime: string = '';\\n  isFavor?: boolean = false;\\n  index?: number = 0;\\n  cardList: Array&lt;CardListItemData&gt; = [];\\n\\n  constructor(formId: string) {\\n    this.formId = formId;\\n  }\\n}</pre> <pre class='\\\"screen\\\"'>import { systemDateTime } from '@kit.BasicServicesKit';\\nimport { Want } from '@kit.AbilityKit';\\nimport { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { CardListItemData, CommonData, FormData } from '../common/CommonData';\\n// ...\\nconst TAG: string = 'EntryFormAbility';\\n\\nexport default class EntryFormAbility extends FormExtensionAbility {\\n  onAddForm(want: Want): formBindingData.FormBindingData {\\n    if(!want || !want.parameters) {\\n      hilog.error(0x0000, TAG, `FormAbility onAddForm want or want.parameters is undefined`);\\n      return formBindingData.createFormBindingData('');\\n    }\\n\\n    let formName: string = want.parameters[formInfo.FormParam.NAME_KEY] as string;\\n    let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY] as string;\\n    // ...\\n    if (formName === 'card_info_refresh') {\\n      let formData = new FormData(formId);\\n      formData.formTime = systemDateTime.getTime().toString();\\n      let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n      return formInfo;\\n    }\\n    // ...\\n    return formBindingData.createFormBindingData('');\\n  }\\n  // ...\\n}</pre> <p>卡片页面使用页面级的UI状态存储<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage\\\"' target='\\\"_blank\\\"'>LocalStorage</a>接收onAddForm()接口传递的数据。使用装饰器@LocalStorageProp装饰的状态变量接收数据类的详细信息，装饰器@LocalStorageProp(key)中的key值需与数据类的键值一一对应。使用获取的数据初始化卡片页面。</p> <pre class='\\\"screen\\\"'>let storageLocal = new LocalStorage();\\n\\n@Entry(storageLocal)\\n@Component\\nstruct WidgetCard {\\n  // ...\\n  @LocalStorageProp('formTime') @Watch('onFormTimeChange') formTime: string = '';\\n  @LocalStorageProp('formId') formId: string = '';\\n  // ...\\n  onFormTimeChange() {\\n    // ...\\n  }\\n  // ...\\n  build() {\\n    // ...\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-card-update-and-data-interaction.html"
    },
    {
        "id": 81,
        "pre": "Row() {\\n  this.buttonBuilder($r('app.string.call'))\\n}\\n.onClick(() => {\\n  postCardAction(this, {\\n    action: 'call',\\n    abilityName: 'EntryAbility',\\n    params: {\\n      formId: this.formId,\\n      method: 'updateCardInfo',\\n      params: {\\n        message: 'Call refresh card.'\\n      }\\n    }\\n  });\\n})",
        "type": "Reference",
        "function_call": "readInt()",
        "function_name": "[h2]开发流程",
        "parent_text": "[h2]开发流程图8 拉起应用至后台时更新卡片 在卡片页面注册onClick()点击事件，本文以动态卡片为例，在回调中调用postCardAction()接口（静态卡片使用静态用的FormLink），action参数选择call并配置需要调用的方法和传递的数据，触发call事件后台拉起指定UIAbility。配置参数注意以下限制： abilityName参数仅支持配置当前应用下的UIAbility，即配置在module.json5文件中的UIAbility。method为必选参数，且类型为string类型，用于触发UIAbility中对应的方法。在当前call事件触发指定卡片刷新场景中，需设置formId参数，用于UIAbility接收后更新当前卡片。  在被拉起的UIAbility的onCreate()生命周期中，需要配置监听call事件所需的方法，监听的方法名与call事件配置的method保持一致。通过readString()方法读取传递的字符串值后，使用JSON.parse()解析传递的参数。使用传递的formId并构建更新卡片需要的数据类型，调用updateForm()接口推送数据至卡片。 注意，进程退出时需在onDestroy()生命周期中解除监听；监听配置的方法需返回实现rpc.Parcelable()接口的数据类。 import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { formBindingData, formInfo, formProvider } from '@kit.FormKit';\\nimport { rpc } from '@kit.IPCKit';\\nimport { CardListItemData, CommonData, FormData } from '../common/CommonData';\\n// ...\\nconst TAG: string = 'EntryAbility';\\n\\nexport default class EntryAbility extends UIAbility {\\n  private callFunc = (data: rpc.MessageSequence): MyParcelable => {\\n    let params: Record<string, string> = JSON.parse(data.readString());\\n    if (params.formId !== undefined) {\\n      let formId: string = params.formId;\\n      let formData = new FormData(formId);\\n      // ...\\n      let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n      formProvider.updateForm(formId, formMsg).then((data) => {\\n        hilog.info(0x0000, TAG, 'updateForm success.', JSON.stringify(data));\\n      }).catch((error: Error) => {\\n        hilog.info(0x0000, TAG, 'updateForm failed.', JSON.stringify(error));\\n      });\\n    }\\n    return new MyParcelable(1);\\n  };\\n  // ...\\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    // ...\\n    this.callee.on('updateCardInfo', this.callFunc);\\n    // ...\\n  }\\n  // ...\\n  onDestroy(): void {\\n    // ...\\n    try {\\n      this.callee.off('updateCardInfo');\\n      // ...\\n    } catch (err) {\\n      hilog.error(0x0000, TAG, 'Failed to disconnect callee. Cause: %{public}s', JSON.stringify(err) ?? '');\\n    }\\n  }\\n  // ...\\n}\\n\\nclass MyParcelable implements rpc.Parcelable {\\n  num: number;\\n\\n  constructor(num: number) {\\n    this.num = num;\\n  }\\n\\n  marshalling(dataOut: rpc.MessageSequence): boolean {\\n    dataOut.writeInt(this.num);\\n    return true;\\n  }\\n\\n  unmarshalling(dataIn: rpc.MessageSequence): boolean {\\n    this.num = dataIn.readInt();\\n    return true;\\n  }\\n}  提供方应用需要具备后台运行权限（ohos.permission.KEEP_BACKGROUND_RUNNING）。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section748210461186\\\"'><a name='\\\"section748210461186\\\"'></a><a name='\\\"section748210461186\\\"'></a><h4>[h2]开发流程</h4><div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图8 </b>拉起应用至后台时更新卡片</span><br/><span><img originheight='\\\"315\\\"' originwidth='\\\"903\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161102.39233248563940905192010188543176:50001231000000:2800:A325B3EEAFC868284FD6A8817D25928EE12E718442D71A07E42650A4F69BAF4B.png\\\"'/></span></div> <p>在卡片页面注册onClick()点击事件，本文以动态卡片为例，在回调中调用postCardAction()接口（静态卡片使用静态用的FormLink），action参数选择call并配置需要调用的方法和传递的数据，触发call事件后台拉起指定UIAbility。配置参数注意以下限制：</p> <ul><li>abilityName参数仅支持配置当前应用下的UIAbility，即配置在module.json5文件中的UIAbility。</li><li>method为必选参数，且类型为string类型，用于触发UIAbility中对应的方法。</li><li>在当前call事件触发指定卡片刷新场景中，需设置formId参数，用于UIAbility接收后更新当前卡片。</li></ul>  <p>在被拉起的UIAbility的onCreate()生命周期中，需要配置监听call事件所需的方法，监听的方法名与call事件配置的method保持一致。通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-rpc#readstring\\\"' target='\\\"_blank\\\"'>readString()</a>方法读取传递的字符串值后，使用JSON.parse()解析传递的参数。使用传递的formId并构建更新卡片需要的数据类型，调用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#updateform\\\"' target='\\\"_blank\\\"'>updateForm()</a>接口推送数据至卡片。</p> <p>注意，进程退出时需在onDestroy()生命周期中解除监听；监听配置的方法需返回实现rpc.Parcelable()接口的数据类。</p> <pre class='\\\"screen\\\"'>import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { formBindingData, formInfo, formProvider } from '@kit.FormKit';\\nimport { rpc } from '@kit.IPCKit';\\nimport { CardListItemData, CommonData, FormData } from '../common/CommonData';\\n// ...\\nconst TAG: string = 'EntryAbility';\\n\\nexport default class EntryAbility extends UIAbility {\\n  private callFunc = (data: rpc.MessageSequence): MyParcelable =&gt; {\\n    let params: Record&lt;string, string&gt; = JSON.parse(data.readString());\\n    if (params.formId !== undefined) {\\n      let formId: string = params.formId;\\n      let formData = new FormData(formId);\\n      // ...\\n      let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n      formProvider.updateForm(formId, formMsg).then((data) =&gt; {\\n        hilog.info(0x0000, TAG, 'updateForm success.', JSON.stringify(data));\\n      }).catch((error: Error) =&gt; {\\n        hilog.info(0x0000, TAG, 'updateForm failed.', JSON.stringify(error));\\n      });\\n    }\\n    return new MyParcelable(1);\\n  };\\n  // ...\\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    // ...\\n    this.callee.on('updateCardInfo', this.callFunc);\\n    // ...\\n  }\\n  // ...\\n  onDestroy(): void {\\n    // ...\\n    try {\\n      this.callee.off('updateCardInfo');\\n      // ...\\n    } catch (err) {\\n      hilog.error(0x0000, TAG, 'Failed to disconnect callee. Cause: %{public}s', JSON.stringify(err) ?? '');\\n    }\\n  }\\n  // ...\\n}\\n\\nclass MyParcelable implements rpc.Parcelable {\\n  num: number;\\n\\n  constructor(num: number) {\\n    this.num = num;\\n  }\\n\\n  marshalling(dataOut: rpc.MessageSequence): boolean {\\n    dataOut.writeInt(this.num);\\n    return true;\\n  }\\n\\n  unmarshalling(dataIn: rpc.MessageSequence): boolean {\\n    this.num = dataIn.readInt();\\n    return true;\\n  }\\n}</pre> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161102.50345646790742264304623243359670:50001231000000:2800:47F18A57347A57EFEE881CD974F875CB7414C83E0C107F9981591D1F359534D7.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>提供方应用需要具备后台运行权限（<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/permissions-for-all#ohospermissionkeep_background_running\\\"' target='\\\"_blank\\\"'>ohos.permission.KEEP_BACKGROUND_RUNNING</a>）。</p> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-card-update-and-data-interaction.html"
    },
    {
        "id": 82,
        "pre": "Row() {\\n  this.buttonBuilder($r('app.string.router'))\\n}\\n.onClick(() => {\\n  postCardAction(this, {\\n    action: 'router',\\n    abilityName: 'EntryAbility',\\n    params: {\\n      message: 'Router refresh card.'\\n    }\\n  });\\n})",
        "type": "Reference",
        "function_call": "toString()",
        "function_name": "[h2]开发流程",
        "parent_text": "[h2]开发流程图9 跳转到应用后更新卡片 在卡片页面注册onClick()点击事件，在回调中调用postCardAction()接口，action参数选择router触发router事件。router事件拉起指定的UIAbility，使用abilityName进行配置。  在UIAbility中接收router事件并获取参数。若UIAbility未在后台运行，触发onCreate生命周期回调。若UIAbility已在后台运行，会触发onNewWant()生命周期回调。生命周期参数want包含卡片相关信息，执行卡片相关操作。判断params中包含的参数，构建卡片更新需要的数据类，调用updateForm()接口推送数据至卡片。 import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { formBindingData, formInfo, formProvider } from '@kit.FormKit';\\nimport { CardListItemData, CommonData, FormData } from '../common/CommonData';\\n// ...\\nconst TAG: string = 'EntryAbility';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    // ...\\n    this.updateInfo(want);\\n    // ...\\n  }\\n  // ...\\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    this.updateInfo(want);\\n  }\\n\\n  private updateInfo(want: Want) {\\n    if (!want || !want.parameters || want.parameters[formInfo.FormParam.IDENTITY_KEY] === undefined) {\\n      return;\\n    }\\n    let message: string = (JSON.parse(want.parameters?.params as string))?.message;\\n    if (message === 'Router refresh card.') {\\n      let formId = want.parameters[formInfo.FormParam.IDENTITY_KEY].toString();\\n      let formData = new FormData(formId);\\n      // ...\\n\\n      let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n      formProvider.updateForm(formId, formMsg)\\n        .then((data) => {\\n          hilog.info(0x0000, TAG, 'updateForm success.', JSON.stringify(data));\\n        })\\n        .catch((error: Error) => {\\n          hilog.info(0x0000, TAG, 'updateForm failed.', JSON.stringify(error));\\n        });\\n    }\\n  }\\n  // ...\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section723263731911\\\"'><a name='\\\"section723263731911\\\"'></a><a name='\\\"section723263731911\\\"'></a><h4>[h2]开发流程</h4><div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图9 </b>跳转到应用后更新卡片</span><br/><span><img originheight='\\\"324\\\"' originwidth='\\\"928\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161102.80885637575943281831384417515439:50001231000000:2800:119020A41B855EAFF14A31385288531FCD02FA591666134387FB688ACFCAFB52.png\\\"'/></span></div> <p>在卡片页面注册onClick()点击事件，在回调中调用postCardAction()接口，action参数选择router触发router事件。router事件拉起指定的UIAbility，使用abilityName进行配置。</p>  <p>在UIAbility中接收router事件并获取参数。若UIAbility未在后台运行，触发onCreate生命周期回调。若UIAbility已在后台运行，会触发onNewWant()生命周期回调。生命周期参数want包含卡片相关信息，执行卡片相关操作。判断params中包含的参数，构建卡片更新需要的数据类，调用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-form-formprovider#updateform\\\"' target='\\\"_blank\\\"'>updateForm()</a>接口推送数据至卡片。</p> <pre class='\\\"screen\\\"'>import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { formBindingData, formInfo, formProvider } from '@kit.FormKit';\\nimport { CardListItemData, CommonData, FormData } from '../common/CommonData';\\n// ...\\nconst TAG: string = 'EntryAbility';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    // ...\\n    this.updateInfo(want);\\n    // ...\\n  }\\n  // ...\\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    this.updateInfo(want);\\n  }\\n\\n  private updateInfo(want: Want) {\\n    if (!want || !want.parameters || want.parameters[formInfo.FormParam.IDENTITY_KEY] === undefined) {\\n      return;\\n    }\\n    let message: string = (JSON.parse(want.parameters?.params as string))?.message;\\n    if (message === 'Router refresh card.') {\\n      let formId = want.parameters[formInfo.FormParam.IDENTITY_KEY].toString();\\n      let formData = new FormData(formId);\\n      // ...\\n\\n      let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n      formProvider.updateForm(formId, formMsg)\\n        .then((data) =&gt; {\\n          hilog.info(0x0000, TAG, 'updateForm success.', JSON.stringify(data));\\n        })\\n        .catch((error: Error) =&gt; {\\n          hilog.info(0x0000, TAG, 'updateForm failed.', JSON.stringify(error));\\n        });\\n    }\\n  }\\n  // ...\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-card-update-and-data-interaction.html"
    },
    {
        "id": 83,
        "pre": "import { Want } from '@kit.AbilityKit';\\nimport { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { CardListItemData, CommonData, FormData } from '../common/CommonData';\\nimport { PreferencesUtil } from '../common/utils/PreferencesUtil';\\n\\nconst TAG: string = 'EntryFormAbility';\\n\\nexport default class EntryFormAbility extends FormExtensionAbility {\\n  onAddForm(want: Want): formBindingData.FormBindingData {\\n    if(!want || !want.parameters) {\\n      hilog.error(0x0000, TAG, `FormAbility onAddForm want or want.parameters is undefined`);\\n      return formBindingData.createFormBindingData('');\\n    }\\n\\n    let formName: string = want.parameters[formInfo.FormParam.NAME_KEY] as string;\\n    let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY] as string;\\n    let util = PreferencesUtil.getInstance();\\n    let preferences = util.getPreferences(this.context);\\n    // Save form id using preferences.\\n    util.addFormId(preferences, formId);\\n    // ...\\n\\n    let key: string = `${formId}_show_index`;\\n    let data = util.getFormInitData(key, preferences);\\n    if (formName === 'card_info_update') {\\n      // Save the index of the data items currently displayed on the card.\\n      util.preferencesPut(preferences, key, data.id);\\n      let formData = new FormData(formId);\\n      formData.cardList.push(data);\\n      let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n      return formInfo;\\n    }\\n    return formBindingData.createFormBindingData('');\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "getInstance()",
        "function_name": "[h2]开发流程",
        "parent_text": "[h2]开发流程应用侧UI交互引起卡片数据变化时： 图10 从应用更新数据到卡片流程 图片展示卡片创建时，在onAddForm()生命周期中使用首选项保存卡片ID至卡片ID列表及卡片当前状态。  应用侧收藏按钮注册onClick()事件，事件回调触发时，使用首选项更新收藏状态，查询当前正在展示该收藏状态变化的数据的卡片，更新收藏状态到对应卡片。 Row() {\\n  // ...\\n}\\n.onClick(() => {\\n  let util = PreferencesUtil.getInstance();\\n  let preferences = util.getPreferences(getContext(this));\\n  this.statusArr[this.itemData.id] = !this.statusArr[this.itemData.id]\\n  this.itemData.favour = this.statusArr[this.itemData.id!];\\n  util.preferencesPut(preferences, 'statusArr', this.statusArr)\\n\\n  // Update page display data.\\n  AppStorage.set('statusArr', [...this.statusArr]);\\n\\n  let idArr = PreferencesUtil.getInstance().getFormIds(preferences);\\n  if (idArr.length > 0) {\\n    idArr.forEach((formId: string) => {\\n      if (preferences.getSync(`${formId}_show_index`, -1) as number === this.itemData.id) {\\n        let formData = new FormData(formId);\\n        formData.cardList = [this.itemData];\\n        let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n        formProvider.updateForm(formId, formMsg).then(() => {\\n          hilog.info(0x0000, TAG, `updateForm success.`);\\n        }).catch((error: Error) => {\\n          hilog.error(0x0000, TAG, `updateForm failed: ${JSON.stringify(error)}`);\\n        });\\n      }\\n    })\\n  }\\n}) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section116517541126\\\"'><a name='\\\"section116517541126\\\"'></a><a name='\\\"section116517541126\\\"'></a><h4>[h2]开发流程</h4><p>应用侧UI交互引起卡片数据变化时：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图10 </b>从应用更新数据到卡片流程</span><br/><span><img originheight='\\\"286\\\"' originwidth='\\\"809\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161102.18930390925750297212645567462878:50001231000000:2800:A2EDB917A134FB3E1E232F0AB81D210AB5430312D76FBEBD2218084874D50FDC.png\\\"'/></span></div> <p>图片展示卡片创建时，在onAddForm()生命周期中使用首选项保存卡片ID至卡片ID列表及卡片当前状态。</p>  <p>应用侧收藏按钮注册onClick()事件，事件回调触发时，使用首选项更新收藏状态，查询当前正在展示该收藏状态变化的数据的卡片，更新收藏状态到对应卡片。</p> <pre class='\\\"screen\\\"'>Row() {\\n  // ...\\n}\\n.onClick(() =&gt; {\\n  let util = PreferencesUtil.getInstance();\\n  let preferences = util.getPreferences(getContext(this));\\n  this.statusArr[this.itemData.id] = !this.statusArr[this.itemData.id]\\n  this.itemData.favour = this.statusArr[this.itemData.id!];\\n  util.preferencesPut(preferences, 'statusArr', this.statusArr)\\n\\n  // Update page display data.\\n  AppStorage.set('statusArr', [...this.statusArr]);\\n\\n  let idArr = PreferencesUtil.getInstance().getFormIds(preferences);\\n  if (idArr.length &gt; 0) {\\n    idArr.forEach((formId: string) =&gt; {\\n      if (preferences.getSync(`${formId}_show_index`, -1) as number === this.itemData.id) {\\n        let formData = new FormData(formId);\\n        formData.cardList = [this.itemData];\\n        let formMsg: formBindingData.FormBindingData = formBindingData.createFormBindingData(formData);\\n        formProvider.updateForm(formId, formMsg).then(() =&gt; {\\n          hilog.info(0x0000, TAG, `updateForm success.`);\\n        }).catch((error: Error) =&gt; {\\n          hilog.error(0x0000, TAG, `updateForm failed: ${JSON.stringify(error)}`);\\n        });\\n      }\\n    })\\n  }\\n})</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-card-update-and-data-interaction.html"
    },
    {
        "id": 84,
        "pre": "XComponent({ id: 'XComponentId', type: 'surface', libraryname: 'entry'})\\n    .width(360)\\n    .height(360)",
        "type": "Reference",
        "function_call": null,
        "function_name": "开发步骤",
        "parent_text": "开发步骤应用使用XComponent组件时，有Surface和Texture两种模式。Surface模式会由一个XComponent组件创建一个独立的Surface图层。根据不同的播放场景，XComponent组件的使用数量也有所不同。在视频/小视频场景中，无弹幕全屏视频播放时，要求一个界面内的Surface模式的XComponent组件数量≤2；而在弹幕全屏视频播放时，由于弹幕功能需要额外Surface图层渲染弹幕内容，该限制放宽至一个界面内的Surface模式的XComponent组件数量≤3。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section7181529165813\\\"'><a name='\\\"section7181529165813\\\"'></a><a name='\\\"section7181529165813\\\"'></a><h4>开发步骤</h4><p><span rgb(64,64,64);\\\"=\"\" style='\\\"color:'>应用使用XComponent组件时，有Surface和Texture两种模式。Surface模式会由一个XComponent组件创建一个独立的Surface图层。根据不同的播放场景，XComponent组件的使用数量也有所不同。在视频/小视频场景中，无弹幕全屏视频播放时，要求一个界面内的Surface模式的XComponent组件数量≤2；而在弹幕全屏视频播放时，由于弹幕功能需要额外Surface图层渲染弹幕内容，该限制放宽至一个界面内的Surface模式的XComponent组件数量≤3。</span></p> <p></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-layer.html"
    },
    {
        "id": 85,
        "pre": "NavDestination() {\\n  Column() {\\n    Button($r('app.string.back_to_web_page'))\\n      .width('100%')\\n      .height(40)\\n      .onClick(() => {\\n        this.navPathStack.pushPath({ name: 'WebPage' });\\n      })\\n  }\\n  // ...\\n}\\n.title('ArkTS页面')",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]ArkTS页面跳转ArkWeb页面",
        "parent_text": "[h2]ArkTS页面跳转ArkWeb页面在HarmonyOS应用开发中，会有Web页面和ArkTS页面互相之间进行跳转的场景，例如列表页用了ArkTS进行开发，而详情页设计上只有简单的内容展示并没有复杂的逻辑操作，于是使用了Web开发并使用了ArkTS中的Web组件进行了加载，在这种场景下，从列表页跳转到详情页就是从ArkTS页面跳转到Web页面，在这种场景下，开发者只需要在ArkTS页面对应的事件回调函数中使用路由栈提供的跳转功能即可实现。关于Navigation组件的使用开发者可以参考：组件导航（Navigation）。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section17681055171310\\\"'><a name='\\\"section17681055171310\\\"'></a><a name='\\\"section17681055171310\\\"'></a><h4>[h2]ArkTS页面跳转ArkWeb页面</h4><p>在HarmonyOS应用开发中，会有Web页面和ArkTS页面互相之间进行跳转的场景，例如列表页用了ArkTS进行开发，而详情页设计上只有简单的内容展示并没有复杂的逻辑操作，于是使用了Web开发并使用了ArkTS中的Web组件进行了加载，在这种场景下，从列表页跳转到详情页就是从ArkTS页面跳转到Web页面，在这种场景下，开发者只需要在ArkTS页面对应的事件回调函数中使用路由栈提供的跳转功能即可实现。关于Navigation组件的使用开发者可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation\\\"' target='\\\"_blank\\\"'>组件导航（Navigation）</a>。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-web-app-jump-and-pull-up.html"
    },
    {
        "id": 86,
        "pre": "// entry/src/main/ets/pages/ShopDisplay.ets\\nFlex({\\n  direction: this.currentBreakpoint === BreakpointConstants.BREAKPOINT_LG && !this.ifShowSides ?\\n  FlexDirection.Row : FlexDirection.Column,\\n  justifyContent: FlexAlign.Start\\n}) {\\n  ShopHeader()\\n    .visibility(this.currentBreakpoint !== BreakpointConstants.BREAKPOINT_LG || this.ifShowSides ?\\n    Visibility.Visible : Visibility.None)\\n  ShopSideBar()\\n    .width(CommonConstants.THIRTY_SEVEN_PERCENT)\\n    .flexShrink(0)\\n    .visibility(this.currentBreakpoint === BreakpointConstants.BREAKPOINT_LG && !this.ifShowSides ?\\n    Visibility.Visible : Visibility.None)\\n  ShopOrderList()\\n    .height(CommonConstants.FULL_PERCENT)\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "店铺信息展示区使用Flex属性的direction属性根据断点切换上下或者左右布局，使用visibility属性根据断点切换显隐。  ",
        "import_module": null,
        "parent": "<li>店铺信息展示区<p>使用Flex属性的direction属性根据断点切换上下或者左右布局，使用visibility属性根据断点切换显隐。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-convenient-life.html"
    },
    {
        "id": 87,
        "pre": "import { BusinessError, request } from '@kit.BasicServicesKit';\\n\\nlet uploadTask: request.UploadTask;\\nlet uploadConfig: request.UploadConfig = {\\n  url: 'http://www.example.com', //需要手动替换为真实服务器地址\\n  header: { 'Accept': '*/*' },\\n  method: \\\"POST\\\",\\n  files: [{\\n    filename: \\\"test\\\",\\n    name: \\\"test\\\",\\n    uri: \\\"internal://cache/test.jpg\\\",\\n    type: \\\"jpg\\\"\\n  }],\\n  data: [{ name: \\\"name123\\\", value: \\\"123\\\" }],\\n};\\ntry {\\n  //上传请求\\n  request.uploadFile(getContext(), uploadConfig, (err: BusinessError, data: request.UploadTask) => {\\n    if (err) {\\n      console.error(`Failedtorequesttheupload.Code:${err.code},message:${err.message}`);\\n      return;\\n    }\\n    uploadTask = data;\\n  });\\n} catch (err) {\\n  console.error(`Failedtorequesttheupload.err:${JSON.stringify(err)}`);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]上传",
        "parent_text": "[h2]上传 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section19282032979\\\"'><a name='\\\"section19282032979\\\"'></a><a name='\\\"section19282032979\\\"'></a><h4>[h2]上传</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-request-use.html"
    },
    {
        "id": 88,
        "pre": "import { BusinessError, request } from '@kit.BasicServicesKit';\\n\\ntry {\\n  request.downloadFile(getContext(), {\\n    url: 'https://xxxx/xxxxx.hap', //需要下载的文件的服务器地址\\n    filePath: 'xxx/xxxxx.hap'\\n  }, (err: BusinessError, data: request.DownloadTask) => {\\n    if (err) {\\n      console.error(`Failedtorequestthedownload.Code:${err.code},message:${err.message}`);\\n      return;\\n    }\\n    let downloadTask: request.DownloadTask = data;\\n  });\\n} catch (err) {\\n  console.error(`Failedtorequestthedownload.err:${JSON.stringify(err)}`);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]下载",
        "parent_text": "[h2]下载 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section176268462714\\\"'><a name='\\\"section176268462714\\\"'></a><a name='\\\"section176268462714\\\"'></a><h4>[h2]下载</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-request-use.html"
    },
    {
        "id": 89,
        "pre": "build() {\\n  StackA() {\\n    ComponentB() {\\n      ComponentC()\\n    }\\n\\n    ComponentD() {\\n      ComponentE()\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "事件响应链收集",
        "parent_text": "事件响应链收集在HarmonyOS开发中，触摸事件（onTouch事件）是用户与设备交互的基础，是所有手势事件组成的基础，有Down，Move，Up，Cancel四种触摸事件的类型。手势均由触摸事件组成，例如，点击为Down+Up，滑动为Down+一系列Move+Up。 触摸事件的分发由触摸测试（TouchTest）结果决定，其结果会直接决定哪些控件的事件加入事件响应链（事件响应成员组成的链表），并最终按照响应链顺序判定是否消费。因此了解触摸事件的响应链收集过程，有助于开发者处理手势事件冲突问题。 ArkUI事件响应链收集，根据右子树（按组件布局的先后层级）优先的后序遍历流程。下面通过一个示例来介绍响应链收集的流程，示例伪代码如下：  其中A是最外层组件，B和D是A的子组件，C是B的子组件，E是D的子组件。界面效果示例以及组件树结构图如下：  用户触摸的动作如果发生在组件C上，事件响应链收集的流程如下，根据右子树（按组件布局的先后层级）优先的后序遍历流程，因为触摸点不在右边的树上，所以事件会从左边树的C节点开始往上传，触摸事件（onTouch事件）是冒泡事件默认会向上一直传递下去，直到被消费或者丢弃，允许多个组件同时触发。最终收集到的响应链是C->B->A。  用户触摸的动作如果发生在组件E上，事件响应链收集的流程如下，根据右子树优先的后序遍历流程，所以事件会从右边树的D节点开始往上传。虽然触摸点在组件D和组件B的交集上，但组件D的hitTestBehavior属性默认为HitTestMode.Default，D组件收集到事件后会阻塞兄弟节点（组件B），所以没有收集组件A的左子树，最终收集到的响应链是E->D->A。  上面介绍的事件响应链是系统默认的行为，如果需要改变响应的成员，比如触摸组件E的时候，希望把事件传递给B，该怎么实现呢？开发者可以通过设置D组件的hitTestMode属性为HitTestMode.None或者HitTestMode.Transparent来实现，比如设置为HitTestMode.Transparent，那么组件D自身进行触摸测试，同时不阻塞兄弟及父组件。最终收集到的响应链是E->D->B->A。  又例如触摸E组件的时候，只希望E响应触摸事件，不让其它组件响应触摸事件。可以通过stopPropagation来阻止事件冒泡，阻止触摸事件往上传递；也可以通过设置E组件的hitTestMode属性为HitTestMode.Block来实现，那么最终收集到的响应链成员只有组件E。  除了hitTestMode和stopPropagation，影响事件响应链的更多因素可以参考：触摸测试控制。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section2407326173013\\\"'><a name='\\\"section2407326173013\\\"'></a><a name='\\\"section2407326173013\\\"'></a><h4>事件响应链收集</h4><p>在HarmonyOS开发中，<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch\\\"' target='\\\"_blank\\\"'>触摸事件</a>（onTouch事件）是用户与设备交互的基础，是所有手势事件组成的基础，有Down，Move，Up，Cancel四种<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#touchtype\\\"' target='\\\"_blank\\\"'>触摸事件的类型</a>。手势均由触摸事件组成，例如，点击为Down+Up，滑动为Down+一系列Move+Up。</p> <p>触摸事件的分发由<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-distribute#触摸测试\\\"' target='\\\"_blank\\\"'>触摸测试</a>（TouchTest）结果决定，其结果会直接决定哪些控件的事件加入事件响应链（事件响应成员组成的链表），并最终按照响应链顺序判定是否消费。因此了解触摸事件的响应链收集过程，有助于开发者处理手势事件冲突问题。</p> <p>ArkUI事件响应链收集，根据右子树（按组件布局的先后层级）优先的后序遍历流程。下面通过一个示例来介绍响应链收集的流程，示例伪代码如下：</p>  <p>其中A是最外层组件，B和D是A的子组件，C是B的子组件，E是D的子组件。界面效果示例以及组件树结构图如下：</p> <p><span><img height='\\\"288.0248\\\"' originheight='\\\"560\\\"' originwidth='\\\"1086\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161122.73151743811314905852411453711777:50001231000000:2800:9075908118562542275FD642113A89C0951F54EE9B6B9E5164998D82ED71E7DD.png\\\"' title='\\\"点击放大\\\"' width='\\\"558.6\\\"'/></span></p> <p>用户触摸的动作如果发生在组件C上，事件响应链收集的流程如下，根据右子树（按组件布局的先后层级）优先的后序遍历流程，因为触摸点不在右边的树上，所以事件会从左边树的C节点开始往上传，触摸事件（onTouch事件）是冒泡事件默认会向上一直传递下去，直到被消费或者丢弃，允许多个组件同时触发。最终收集到的响应链是C-&gt;B-&gt;A。</p> <p><span><img height='\\\"285.5111\\\"' originheight='\\\"585\\\"' originwidth='\\\"1090\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161122.90727410684746911682558154686793:50001231000000:2800:4305234DE5213C014F65DFEEB3B87875F381EBF1F1AF4F8E84B5705DEFD802E2.png\\\"' title='\\\"点击放大\\\"' width='\\\"558.6\\\"'/></span></p> <p>用户触摸的动作如果发生在组件E上，事件响应链收集的流程如下，根据右子树优先的后序遍历流程，所以事件会从右边树的D节点开始往上传。虽然触摸点在组件D和组件B的交集上，但组件D的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior\\\"' target='\\\"_blank\\\"'>hitTestBehavior</a>属性默认为HitTestMode.Default，D组件收集到事件后会阻塞兄弟节点（组件B），所以没有收集组件A的左子树，最终收集到的响应链是E-&gt;D-&gt;A。</p> <p><span><img height='\\\"279.5527\\\"' originheight='\\\"567\\\"' originwidth='\\\"1079\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161122.85468007038080663431499826310284:50001231000000:2800:56B1C4CD01756D02C2B8EF78DFD9247A997833DE821D001844D7F8F17EF8A01E.png\\\"' title='\\\"点击放大\\\"' width='\\\"558.6\\\"'/></span></p> <p>上面介绍的事件响应链是系统默认的行为，如果需要改变响应的成员，比如触摸组件E的时候，希望把事件传递给B，该怎么实现呢？开发者可以通过设置D组件的hitTestMode属性为HitTestMode.None或者HitTestMode.Transparent来实现，比如设置为HitTestMode.Transparent，那么组件D自身进行触摸测试，同时不阻塞兄弟及父组件。最终收集到的响应链是E-&gt;D-&gt;B-&gt;A。</p> <p><span><img height='\\\"283.3033\\\"' originheight='\\\"567\\\"' originwidth='\\\"1118\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161123.69029787230309485850567303499866:50001231000000:2800:2E33AA2E5905047DBEF5B4ABC70DE2ACDB0368039D8316EA279CD028E90875C0.png\\\"' title='\\\"点击放大\\\"' width='\\\"558.6\\\"'/></span></p> <p>又例如触摸E组件的时候，只希望E响应触摸事件，不让其它组件响应触摸事件。可以通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#touchevent对象说明\\\"' target='\\\"_blank\\\"'>stopPropagation</a>来阻止事件冒泡，阻止触摸事件往上传递；也可以通过设置E组件的hitTestMode属性为HitTestMode.Block来实现，那么最终收集到的响应链成员只有组件E。</p> <p><span><img height='\\\"294.5418\\\"' originheight='\\\"570\\\"' originwidth='\\\"1081\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161123.80566082761075045206688598679240:50001231000000:2800:DD029809659F4256F7F651FF823661D0EBB14404DDA13C249FA66050F87C44A0.png\\\"' title='\\\"点击放大\\\"' width='\\\"558.6\\\"'/></span></p> <p>除了hitTestMode和stopPropagation，影响事件响应链的更多因素可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-distribute#触摸测试\\\"' target='\\\"_blank\\\"'>触摸测试控制</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gestures-practice.html"
    },
    {
        "id": 90,
        "pre": "@Entry\\n@Component\\nstruct GesturesConflictScene1 {\\n  build() {\\n    Scroll() {\\n      Column() {\\n        Column()\\n          .height('30%')\\n          .width('100%')\\n          .backgroundColor(Color.Blue)\\n        List() {\\n          ForEach([1, 2, 3, 4, 5, 6], (item: string) => {\\n            ListItem() {\\n              Text(item.toString())\\n                .height(300)\\n                .fontSize(50)\\n                .fontWeight(FontWeight.Bold)\\n            }\\n          }, (item: number) => item.toString())\\n        }\\n        .edgeEffect(EdgeEffect.None)\\n        .nestedScroll({\\n          scrollForward: NestedScrollMode.PARENT_FIRST,\\n          scrollBackward: NestedScrollMode.SELF_FIRST\\n        })\\n        .height('100%')\\n        .width('100%')\\n      }\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "Web(...)",
        "function_name": "[h2]滚动容器嵌套滚动容器事件冲突",
        "parent_text": "[h2]滚动容器嵌套滚动容器事件冲突1 Scroll组件嵌套List组件滑动事件冲突 Scroll组件嵌套List组件，子组件List组件的滑动手势优先级高于父组件Scroll的滑动手势，所以当List列表滚动时，不会响应Scroll组件的滚动事件，List不会和Scroll一起滚动。如果需要List和Scroll组件同步滚动可以使用nestedScroll属性来解决，设置向前向后两个方向上的嵌套滚动模式，实现与父组件的滚动联动。 使用nestedScroll属性设置List组件的嵌套滚动方式，NestedScrollMode设置成SELF_FIRST时，List组件滚动到页面边缘后，父组件继续滚动。NestedScrollMode设置为PARENT_FIRST时，父组件先滚动，滚动至边缘后通知List组件继续滚动。示例代码如下：  2 List、Scroller等滚动容器嵌套Web组件，滑动事件冲突 比如List组件嵌套Web组件，当Web加载的网页中也包含滚动视图的时候，这时候上下滚动Web组件，不能和List列表整体一起滑动。这是因为Web的滑动事件和List组件的冲突，如果想让Web随List一起整体滚动，解决方案和前面的例子一样，给Web组件添加nestedScroll属性。 Web(...)\\n.nestedScroll({\\n  scrollForward: NestedScrollMode.PARENT_FIRST,\\n  scrollBackward: NestedScrollMode.SELF_FIRST\\n}) 具体实现可以参考：Web组件嵌套滚动。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section067562063312\\\"'><a name='\\\"section067562063312\\\"'></a><a name='\\\"section067562063312\\\"'></a><h4>[h2]滚动容器嵌套滚动容器事件冲突</h4><p>1 Scroll组件嵌套List组件滑动事件冲<strong>突</strong></p> <p>Scroll组件嵌套List组件，子组件List组件的滑动手势优先级高于父组件Scroll的滑动手势，所以当List列表滚动时，不会响应Scroll组件的滚动事件，List不会和Scroll一起滚动。如果需要List和Scroll组件同步滚动可以使用nestedScroll属性来解决，设置向前向后两个方向上的嵌套滚动模式，实现与父组件的滚动联动。</p> <p>使用nestedScroll属性设置List组件的嵌套滚动方式，NestedScrollMode设置成SELF_FIRST时，List组件滚动到页面边缘后，父组件继续滚动。NestedScrollMode设置为PARENT_FIRST时，父组件先滚动，滚动至边缘后通知List组件继续滚动。示例代码如下：</p>  <p>2 List、Scroller等滚动容器嵌套Web组件，滑动事件冲突</p> <p>比如List组件嵌套Web组件，当Web加载的网页中也包含滚动视图的时候，这时候上下滚动Web组件，不能和List列表整体一起滑动。这是因为Web的滑动事件和List组件的冲突，如果想让Web随List一起整体滚动，解决方案和前面的例子一样，给Web组件添加nestedScroll属性。</p> <pre class='\\\"screen\\\"'>Web(...)\\n.nestedScroll({\\n  scrollForward: NestedScrollMode.PARENT_FIRST,\\n  scrollBackward: NestedScrollMode.SELF_FIRST\\n})</pre> <p>具体实现可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-nested-scrolling\\\"' target='\\\"_blank\\\"'>Web组件嵌套滚动</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gestures-practice.html"
    },
    {
        "id": 91,
        "pre": "@Entry\\n@Component\\nstruct GesturesConflictScene2 {\\n  @State count1: number = 0;\\n  @State count2: number = 0;\\n\\n  build() {\\n    Column() {\\n      Text('Exclusive gesture\\\\n' + 'tapGesture count is 1:' + this.count1 + '\\\\ntapGesture count is 2:' + this.count2 +\\n        '\\\\n')\\n        .fontSize(28)\\n    }\\n    .height(200)\\n    .width('100%')\\n    //以下组合手势为互斥并别，单击手势识别成功后，双击手势会识别失败\\n    .gesture(\\n      GestureGroup(GestureMode.Exclusive,\\n        TapGesture({ count: 1 })\\n          .onAction(() => {\\n            this.count1++;\\n          }),\\n        TapGesture({ count: 2 })\\n          .onAction(() => {\\n            this.count2++;\\n          })\\n      )\\n    )\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]使用组合手势同时绑定多个同类型手势冲突",
        "parent_text": "[h2]使用组合手势同时绑定多个同类型手势冲突例如给组件同时设置单击和双击的点击手势TapGesture，按如下方式设置发现双击手势失效了，这是因为在互斥识别的组合手势中，手势会按声明的顺序进行识别，若有一个手势识别成功，则结束手势识别。因为单击手势放在了前面，所以当双击的时候会优先识别了单击手势，单击成功后后面的双击回调就不会执行了。  可以设置手势为并行识别来解决，设置对应的GestureMode为Parallel： .gesture(\\n  GestureGroup(GestureMode.Parallel,\\n    TapGesture({ count: 2 })\\n      .onAction(() => {\\n        this.count2++;\\n      }),\\n    TapGesture({ count: 1 })\\n      .onAction(() => {\\n        this.count1++;\\n      })\\n  )\\n) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section9426114410339\\\"'><a name='\\\"section9426114410339\\\"'></a><a name='\\\"section9426114410339\\\"'></a><h4>[h2]使用组合手势同时绑定多个同类型手势冲突</h4><p>例如给组件同时设置单击和双击的点击手势TapGesture，按如下方式设置发现双击手势失效了，这是因为在互斥识别的组合手势中，手势会按声明的顺序进行识别，若有一个手势识别成功，则结束手势识别。因为单击手势放在了前面，所以当双击的时候会优先识别了单击手势，单击成功后后面的双击回调就不会执行了。</p>  <p>可以设置手势为并行识别来解决，设置对应的GestureMode为Parallel：</p> <pre class='\\\"screen\\\"'>.gesture(\\n  GestureGroup(GestureMode.Parallel,\\n    TapGesture({ count: 2 })\\n      .onAction(() =&gt; {\\n        this.count2++;\\n      }),\\n    TapGesture({ count: 1 })\\n      .onAction(() =&gt; {\\n        this.count1++;\\n      })\\n  )\\n)</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gestures-practice.html"
    },
    {
        "id": 92,
        "pre": "import { promptAction } from '@kit.ArkUI';\\n\\n@Entry\\n@Component\\nstruct GesturesConflictScene3 {\\n  @State message: string = 'Hello World';\\n\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n        Image($r('app.media.startIcon'))\\n          .margin({ top: 100 })\\n          .width(360)\\n          .height(360)\\n          .gesture(\\n            LongPressGesture({ repeat: true })\\n              .onAction((event: GestureEvent) => {\\n              })// 长按动作一结束触发\\n              .onActionEnd(() => {\\n                promptAction.showToast({ message: 'Long Press' });\\n              })\\n          )\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]系统手势和自定义手势之间冲突",
        "parent_text": "[h2]系统手势和自定义手势之间冲突对于一般同类型的手势，系统手势优先于自定义手势执行，可以通过priorityGesture或者parallelGesture的方式来绑定自定义手势，例如下面这个示例： 图片长按手势响应失败或冲突，在Image控件上添加长按手势后，长按图片无法响应对应方法，而是图片放大的动画，示例代码如下：  这是因为Image组件内置的长按动画和用户自定义的长按手势LongPressGesture冲突了。可以使用priorityGesture绑定手势的方式替代gesture的方式，这样就会只响应自定义手势LongPressGesture了。如果需要两者都执行可以使用parallelGesture的绑定方式。 .priorityGesture(\\n  LongPressGesture({ repeat: true })\\n    .onAction((event: GestureEvent) => {\\n    })// 长按动作一结束触发\\n    .onActionEnd(() => {\\n      promptAction.showToast({ message: 'Long Press' });\\n    })\\n) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12601118143411\\\"'><a name='\\\"section12601118143411\\\"'></a><a name='\\\"section12601118143411\\\"'></a><h4>[h2]系统手势和自定义手势之间冲突</h4><p>对于一般同类型的手势，系统手势优先于自定义手势执行，可以通过priorityGesture或者parallelGesture的方式来绑定自定义手势<strong>，</strong>例如下面这个示例<strong>：</strong></p> <p>图片长按手势响应失败或冲突，在Image控件上添加长按手势后，长按图片无法响应对应方法，而是图片放大的动画，示例代码如下：</p>  <p>这是因为Image组件内置的长按动画和用户自定义的长按手势LongPressGesture冲突了。可以使用priorityGesture绑定手势的方式替代gesture的方式，这样就会只响应自定义手势LongPressGesture了。如果需要两者都执行可以使用parallelGesture的绑定方式。</p> <pre class='\\\"screen\\\"'>.priorityGesture(\\n  LongPressGesture({ repeat: true })\\n    .onAction((event: GestureEvent) =&gt; {\\n    })// 长按动作一结束触发\\n    .onActionEnd(() =&gt; {\\n      promptAction.showToast({ message: 'Long Press' });\\n    })\\n)</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gestures-practice.html"
    },
    {
        "id": 93,
        "pre": "@Entry\\n@Component\\nstruct GesturesConflictScene4 {\\n  build() {\\n    Stack() {\\n      Column()//底层的Column\\n        .width('100%')\\n        .height('100%')\\n        .backgroundColor(Color.Black)\\n        .gesture(\\n          SwipeGesture({ direction: SwipeDirection.Horizontal })//水平方向滑动手势\\n            .onAction((event) => {\\n              if (event) {\\n                console.info('Column SwipeGesture');\\n              }\\n            })\\n        )\\n      Column()//上层的Column\\n        .width(300)\\n        .height(100)\\n        .backgroundColor(Color.Red)\\n        .hitTestBehavior(HitTestMode.None)\\n    }\\n    .width(300)\\n    .height(300)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]手势事件透传",
        "parent_text": "[h2]手势事件透传和触摸事件一样，手势事件也可以通过hitTestBehavior属性来进行透传，例如下面这个示例，上层的Column组件设置hitTestBehavior属性为hitTestMode.none后，可以将滑动手势SwipeGesture透传给被覆盖的Column组件。hitTestMode.none：自身不接收事件，但不会阻塞兄弟组件和子组件继续做触摸测试。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section10694115010342\\\"'><a name='\\\"section10694115010342\\\"'></a><a name='\\\"section10694115010342\\\"'></a><h4>[h2]手势事件透传</h4><p>和触摸事件一样，手势事件也可以通过hitTestBehavior属性来进行透传，例如下面这个示例，上层的Column组件设置hitTestBehavior属性为hitTestMode.none后，可以将滑动手势SwipeGesture透传给被覆盖的Column组件。hitTestMode.none：自身不接收事件，但不会阻塞兄弟组件和子组件继续做触摸测试。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gestures-practice.html"
    },
    {
        "id": 94,
        "pre": "@Entry\\n@Component\\nstruct GesturesConflictScene5 {\\n  @State message: string = 'Hello World';\\n\\n  build() {\\n    Column() {\\n      Row({ space: 20 }) {\\n        Button('Button1')\\n          .width(100)\\n          .height(40)\\n          .monopolizeEvents(true)\\n        Button('Button2')\\n          .width(200)\\n          .height(50)\\n          .onClick(() => {\\n            console.info('GesturesConflictScene5 Button2 click');\\n          })\\n      }\\n      .margin(20)\\n\\n      Text(this.message)\\n        .margin(15)\\n    }\\n    .width('100%')\\n    .onDragStart(() => {\\n      console.info('GesturesConflictScene5 Drag start.');\\n    })\\n    .gesture(\\n      TapGesture({ count: 1 })\\n        .onAction(() => {\\n          console.info('GesturesConflictScene5 TapGesture onAction.');\\n        }),\\n    )\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]多点触控场景下手势冲突",
        "parent_text": "[h2]多点触控场景下手势冲突当一个页面中有多个组件可以响应手势事件，在多个手指触控的情况下，多个组件可能会同时响应手势事件，从而导致业务异常。ArkUI提供了手势独占的属性monopolizeEvents，设置需要单独响应事件的组件的monopolizeEvents属性为true，可以解决这一问题。 例如下面这个示例，给按钮Button1设置了.monopolizeEvents(true)之后，当手指首先触摸在Button1之后，在手指离开之前，其它组件的手势和事件都不会触发。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section10131171943513\\\"'><a name='\\\"section10131171943513\\\"'></a><a name='\\\"section10131171943513\\\"'></a><h4>[h2]多点触控场景下手势冲突</h4><p>当一个页面中有多个组件可以响应手势事件，在多个手指触控的情况下，多个组件可能会同时响应手势事件，从而导致业务异常。ArkUI提供了手势独占的属性<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-monopolize-events#monopolizeevents\\\"' target='\\\"_blank\\\"'>monopolizeEvents</a>，设置需要单独响应事件的组件的monopolizeEvents属性为true，可以解决这一问题。</p> <p>例如下面这个示例，给按钮Button1设置了.monopolizeEvents(true)之后，当手指首先触摸在Button1之后，在手指离开之前，其它组件的手势和事件都不会触发。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gestures-practice.html"
    },
    {
        "id": 95,
        "pre": "@Entry\\n@Component\\nstruct GesturesConflictScene6 {\\n  @State message: string = 'Hello World';\\n\\n  build() {\\n    Column()\\n      .width('100%')\\n      .height(200)\\n      .backgroundColor(Color.Brown)\\n      .onDragStart(() => {\\n        console.info('GesturesConflictScene6 Drag start.');\\n      })\\n      .gesture(\\n        TapGesture({ count: 1 })\\n          .tag('tap1')\\n          .onAction(() => {\\n            console.info('GesturesConflictScene6 TapGesture onAction.');\\n          }),\\n      )\\n      .onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {\\n        if (gestureInfo.type === GestureControl.GestureType.LONG_PRESS_GESTURE) {\\n          let longPressEvent = event as LongPressGestureEvent;\\n          console.info('GesturesConflictScene6: ' + longPressEvent.repeat);\\n        }\\n        if (gestureInfo.type === GestureControl.GestureType.DRAG) {\\n          // 返回 REJECT 会使拖动手势失败\\n          return GestureJudgeResult.REJECT;\\n        } else if (gestureInfo.tag === 'tap1' && event.pressure > 10) {\\n          return GestureJudgeResult.CONTINUE\\n        }\\n        return GestureJudgeResult.CONTINUE;\\n      })\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]动态控制自定义手势是否响应",
        "parent_text": "[h2]动态控制自定义手势是否响应在手势识别期间，开发者决定是否响应手势，例如下面的示例代码，通过onGestureJudgeBegin回调方法在手势识别期间进行判定，当手势为GestureType.DRAG的时候，不响应该手势，所以会使定义的onDragStart事件失效。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1034513423354\\\"'><a name='\\\"section1034513423354\\\"'></a><a name='\\\"section1034513423354\\\"'></a><h4>[h2]动态控制自定义手势是否响应</h4><p>在手势识别期间，开发者决定是否响应手势，例如下面的示例代码，通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#ongesturejudgebegin\\\"' target='\\\"_blank\\\"'>onGestureJudgeBegin</a>回调方法在手势识别期间进行判定，当手势为GestureType.DRAG的时候，不响应该手势，所以会使定义的onDragStart事件失效。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gestures-practice.html"
    },
    {
        "id": 96,
        "pre": "@Entry\\n@Component\\nstruct GesturesConflictScene7 {\\n  scroller: Scroller = new Scroller();\\n  scroller2: Scroller = new Scroller();\\n  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\\n  private childRecognizer: GestureRecognizer = new GestureRecognizer();\\n  private currentRecognizer: GestureRecognizer = new GestureRecognizer();\\n\\n  build() {\\n    Stack({ alignContent: Alignment.TopStart }) {\\n      Scroll(this.scroller) { // 外部滚动容器\\n        Column() {\\n          Text('Scroll Area')\\n            .width('100%')\\n            .height(150)\\n            .backgroundColor(0xFFFFFF)\\n            .borderRadius(15)\\n            .fontSize(16)\\n            .textAlign(TextAlign.Center)\\n            .margin({ top: 10 })\\n          Scroll(this.scroller2) { // 内部滚动容器\\n            Column() {\\n              Text('Scroll Area2')\\n                .width('100%')\\n                .height(150)\\n                .backgroundColor(0xFFFFFF)\\n                .borderRadius(15)\\n                .fontSize(16)\\n                .textAlign(TextAlign.Center)\\n                .margin({ top: 10 })\\n              Column() {\\n                ForEach(this.arr, (item: number) => {\\n                  Text(item.toString())\\n                    .width('100%')\\n                    .height(200)\\n                    .backgroundColor(0xFFFFFF)\\n                    .borderRadius(15)\\n                    .fontSize(20)\\n                    .textAlign(TextAlign.Center)\\n                    .margin({ top: 10 })\\n                }, (item: string) => item)\\n              }\\n              .width('100%')\\n            }\\n          }\\n          .id('innerScroll')\\n          .scrollBar(BarState.Off) // 滚动条常驻显示\\n          .width('100%')\\n          .height(800)\\n        }.width('100%')\\n      }\\n      .id('outerScroll')\\n      .height(600)\\n      .scrollBar(BarState.Off) // 滚动条常驻显示\\n      .shouldBuiltInRecognizerParallelWith((current: GestureRecognizer, others: Array<GestureRecognizer>) => {\\n        for (let i = 0; i < others.length; i++) {\\n          let target = others[i].getEventTargetInfo();\\n          if (target) {\\n            if (target.getId() === 'innerScroll' && others[i].isBuiltIn() &&\\n              others[i].getType() === GestureControl.GestureType.PAN_GESTURE) { // 找到将要组成并行手势的识别器\\n              this.currentRecognizer = current; // 保存当前组件的识别器\\n              this.childRecognizer = others[i]; // 保存将要组成并行手势的识别器\\n              return others[i]; // 返回将要组成并行手势的识别器\\n            }\\n          }\\n        }\\n        return undefined;\\n      })\\n      .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer,\\n        others: Array<GestureRecognizer>) => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态\\n        if (current) {\\n          let target = current.getEventTargetInfo();\\n          if (target) {\\n            if (target.getId() === 'outerScroll' && current.isBuiltIn() &&\\n              current.getType() === GestureControl.GestureType.PAN_GESTURE) {\\n              if (others) {\\n                for (let i = 0; i < others.length; i++) {\\n                  let target = others[i].getEventTargetInfo() as ScrollableTargetInfo;\\n                  if (target instanceof ScrollableTargetInfo && target.getId() == 'innerScroll') { // 找到响应链上对应并行的识别器\\n                    let panEvent = event as PanGestureEvent;\\n                    if (target.isEnd()) { // isEnd返回当前滚动类容器组件是否在底部 根据当前组件状态以及移动方向动态控制识别器使能状态\\n                      if (panEvent && panEvent.offsetY < 0) {\\n                        this.childRecognizer.setEnabled(false) // 到底上拉\\n                        this.currentRecognizer.setEnabled(true)\\n                      } else {\\n                        this.childRecognizer.setEnabled(true)\\n                        this.currentRecognizer.setEnabled(false)\\n                      }\\n                    } else if (target.isBegin()) {\\n                      if (panEvent.offsetY > 0) { // 开始的时候下拉\\n                        this.childRecognizer.setEnabled(false)\\n                        this.currentRecognizer.setEnabled(true)\\n                      } else {\\n                        this.childRecognizer.setEnabled(true)\\n                        this.currentRecognizer.setEnabled(false)\\n                      }\\n                    } else {\\n                      this.childRecognizer.setEnabled(true)\\n                      this.currentRecognizer.setEnabled(false)\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n        return GestureJudgeResult.CONTINUE;\\n      })\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .backgroundColor(0xF1F3F5)\\n    .padding(12)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]父组件如何管理子组件手势",
        "parent_text": "[h2]父组件如何管理子组件手势父子组件嵌套滚动发生手势冲突，父组件有机制可以干预子组件的手势响应。下面例子介绍了如何使用手势拦截增强，在外层Scroll组件的shouldBuiltInRecognizerParallelWith和onGestureRecognizerJudgeBegin回调中，动态控制内外层Scroll手势事件的滚动。 1 首先在父组件Scroll的shouldBuiltInRecognizerParallelWith方法中收集需做并行处理的手势。下面示例代码中收集到了子组件的手势识别器childRecognizer，使其和父组件的手势识别器currentRecognizer并行处理。 2 调用onGestureRecognizerJudgeBegin方法，判断滚动组件是否滑动划到顶部或者底部，做业务逻辑处理，通过动态控制手势识别器是否可用，来决定并行处理器的childRecognizer和currentRecognizer是否可用。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1857645711352\\\"'><a name='\\\"section1857645711352\\\"'></a><a name='\\\"section1857645711352\\\"'></a><h4>[h2]父组件如何管理子组件手势</h4><p>父子组件嵌套滚动发生手势冲突，父组件有机制可以干预子组件的手势响应。下面例子介绍了如何使用<strong><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement\\\"' target='\\\"_blank\\\"'>手势拦截增强</a></strong>，在外层Scroll组件的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#shouldbuiltinrecognizerparallelwith\\\"' target='\\\"_blank\\\"'>shouldBuiltInRecognizerParallelWith</a>和<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin\\\"' target='\\\"_blank\\\"'>onGestureRecognizerJudgeBegin</a>回调中，动态控制内外层Scroll手势事件的滚动。</p> <p>1 首先在父组件Scroll的shouldBuiltInRecognizerParallelWith方法中收集需做并行处理的手势。下面示例代码中收集到了子组件的手势识别器childRecognizer，使其和父组件的手势识别器currentRecognizer并行处理。</p> <p>2 调用onGestureRecognizerJudgeBegin方法，判断滚动组件是否滑动划到顶部或者底部，做业务逻辑处理，通过动态控制手势识别器是否可用，来决定并行处理器的childRecognizer和currentRecognizer是否可用。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-gestures-practice.html"
    },
    {
        "id": 97,
        "pre": "// features/map/src/main/ets/view/MapView.ets\\nbuild() {\\n  Stack({ alignContent: Alignment.BottomStart }) {\\n    MapComponent({ mapOptions: this.mapOption, mapCallback: this.callback })\\n\\n    Column() {\\n      Row() {\\n        // ...\\n      }\\n      .height($r('app.float.bar_height'))\\n      .width(Common.FULL_WIDTH)\\n      .justifyContent(FlexAlign.Center)\\n      .gesture(\\n        PanGesture(this.panOptionHeight)\\n          .onActionUpdate((event?: GestureEvent) => {\\n            if (event) {\\n              let height = this.columnHeight - event.offsetY;\\n              this.tempColumnHeight = height;\\n              if (this.tempColumnHeight < Common.HEIGHT_LOW) {\\n                this.tempColumnHeight = Common.HEIGHT_LOW;\\n              }\\n              if (this.tempColumnHeight > this.columnMaxHeight) {\\n                this.tempColumnHeight = this.columnMaxHeight;\\n              }\\n            }\\n          })\\n          .onActionEnd(() => {\\n            if (this.tempColumnHeight > (this.columnMaxHeight - Common.HEIGHT_MIDDLE) / 2 + Common.HEIGHT_MIDDLE) {\\n              this.columnHeight = this.columnMaxHeight;\\n              this.isShowBack = false;\\n            } else if (this.tempColumnHeight < (Common.HEIGHT_MIDDLE - Common.HEIGHT_LOW) / 2 + Common.HEIGHT_LOW) {\\n              this.columnHeight = Common.HEIGHT_LOW;\\n              this.isShowBack = true;\\n            } else {\\n              this.columnHeight = Common.HEIGHT_MIDDLE;\\n              this.isShowBack = true;\\n            }\\n            this.tempColumnHeight = this.columnHeight;\\n          })\\n      )\\n      // ...\\n    }\\n    // ...\\n    .gesture(\\n      PanGesture(this.panOptionPosition)\\n        .onActionUpdate((event?: GestureEvent) => {\\n          if (event) {\\n            let position = this.left + event.offsetX;\\n            this.tempLeft = position;\\n            if (this.tempLeft < Common.LEFT_MD) {\\n              this.tempLeft = Common.LEFT_MD;\\n            }\\n            if (this.tempLeft > Common.RIGHT_MD) {\\n              this.tempLeft = Common.RIGHT_MD;\\n            }\\n          }\\n        })\\n        .onActionEnd(() => {\\n          if (this.tempLeft < Common.CHANGE) {\\n            this.left = Common.LEFT_MD;\\n          } else {\\n            this.left = Common.RIGHT_MD;\\n          }\\n          this.tempLeft = this.left;\\n        })\\n    )\\n    // ...\\n  }\\n  .height(Common.FULL_HEIGHT)\\n  .width(Common.FULL_WIDTH)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "面板通过Stack组件，在MapComponent上嵌套Column实现，并通过手势的判定，实现面板多档位调节及位置改变。 ",
        "import_module": null,
        "parent": "<li>面板通过Stack组件，在MapComponent上嵌套Column实现，并通过手势的判定，实现面板多档位调节及位置改变。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-travel-navigation.html"
    },
    {
        "id": 98,
        "pre": "// features/live/src/main/ets/viewmodel/LiveViewController.ets\\nprivate static async buildDefaultView(): Promise<liveViewManager.LiveView> {\\n  return {\\n    id: 0,\\n    event: 'PICK_UP',\\n    liveViewData: {\\n      primary: {\\n        title: LiveConstants.LIVE_VIEW_TITLE,\\n        content: [\\n          {\\n            text: LiveConstants.LIVE_VIEW_CONTENT,\\n          },\\n          {\\n            text: LiveConstants.LIVE_VIEW_DISTANCE,\\n            textColor: LiveConstants.LICE_VIEW_DISTANCE_COLOR\\n          }\\n        ],\\n        keepTime: LiveConstants.TIME,\\n        clickAction: await LiveViewController.buildWantAgent(),\\n        layoutData: {\\n          layoutType: liveViewManager.LayoutType.LAYOUT_TYPE_PICKUP,\\n          underlineColor: LiveConstants.UNDERLINE_COLOR,\\n          title: LiveConstants.TAXI_BRAND_INFO,\\n          content: LiveConstants.TAXI_LICENCE_INFO,\\n          descPic: LiveConstants.TAXI_ICON\\n        }\\n      },\\n      capsule: {\\n        type: liveViewManager.CapsuleType.CAPSULE_TYPE_TEXT,\\n        status: 1,\\n        icon: LiveConstants.CAPSULE_ICON,\\n        backgroundColor: LiveConstants.CAPSULE_COLOR,\\n        title: LiveConstants.LIVE_VIEW_DISTANCE\\n      }\\n    }\\n  };\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "应用处于后台运行时，拉起实况窗和实况胶囊。配置相应实况窗及胶囊参数。 ",
        "import_module": null,
        "parent": "<li>应用处于后台运行时，拉起实况窗和实况胶囊。配置相应实况窗及胶囊参数。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-travel-navigation.html"
    },
    {
        "id": 99,
        "pre": "Stack({ alignContent: Alignment.BottomEnd }) {\\n  // Background image.\\n  Row() {\\n    Image($r('app.media.background_image'))\\n      .height('100%')\\n      .objectFit(ImageFit.Cover)\\n      .aspectRatio(0.6)\\n  }\\n  .height('100%')\\n  .width('100%')\\n  .justifyContent(FlexAlign.Center)\\n\\n  // Bottom tabs.\\n  List() {\\n    // ...\\n  }\\n  .backgroundColor('#99000000')\\n  .listDirection(Axis.Horizontal)\\n  .height(this.bottomBarHeight)\\n  .padding({ bottom: this.bottomAvoidHeight })\\n  // ...\\n\\n  // Video description.\\n  Column() {\\n    // ...\\n  }\\n  .alignItems(HorizontalAlign.Start)\\n  .padding({\\n    left: $r('app.float.margin_md'),\\n    right: $r('app.float.margin_md')\\n  })\\n  // ...\\n\\n  // Sidebar buttons.\\n  Scroll() {\\n    Column() {\\n      Blank()\\n        .layoutWeight(3)\\n        .displayPriority(1)\\n      // ...\\n      Blank()\\n        .layoutWeight(1)\\n        .displayPriority(1)\\n    }\\n    // ...\\n  }\\n  .scrollBar(BarState.Off)\\n  .layoutWeight(1)\\n  .width('56vp')\\n  .edgeEffect(EdgeEffect.None)\\n  .align(Alignment.Bottom)\\n  .margin({\\n    top: this.topAvoidHeight + 24,\\n    bottom: this.bottomBarHeight,\\n    right: '8vp'\\n  })\\n\\n  // Top tabs.\\n  Row() {\\n    // ...\\n}\\n.height('100%')\\n.width('100%')\\n.backgroundColor(Color.Black)",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]短视频播放页面",
        "parent_text": "[h2]短视频播放页面Pura X外屏展示短视频播放页面，要求背景图片（视频）进行等比例缩放，并进行上下沉浸，上方沉浸至顶部标题栏，下方沉浸至底部页签栏。侧边控件可滑动，完整显示页面内容。  实现原理 使用Stack组件控制页面内容显示层级，控制背景图片上下沉浸，且互相不影响交互事件。Z层级由下到上分别是背景图片（视频）区、底部页签区、短视频描述区、侧边控件区、顶部页签区。顶部和底部页签设置内边距padding为topAvoidHeight或bottomAvoidHeight避让系统规避区。侧边控件区使用Scroll组件自动控制滑动是否生效，使用Blank组件和displayPriority属性控制侧边控件区上下两侧的留白，容器高度足够时上下留白，容器高度不足时自动隐藏。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section132361018222\\\"'><a name='\\\"section132361018222\\\"'></a><a name='\\\"section132361018222\\\"'></a><h4>[h2]短视频播放页面</h4><p>Pura X外屏展示短视频播放页面，要求背景图片（视频）进行等比例缩放，并进行上下沉浸，上方沉浸至顶部标题栏，下方沉浸至底部页签栏。侧边控件可滑动，完整显示页面内容。</p> <p><span><img originheight='\\\"394\\\"' originwidth='\\\"320\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161442.81390689333547623142257412722555:50001231000000:2800:BCAB929F15D38ABF43FCD2557477B11F30DE8B9F8D223CD831B6489B081A5655.gif\\\"'/></span></p> <p><strong>实现原理</strong></p> <p>使用Stack组件控制页面内容显示层级，控制背景图片上下沉浸，且互相不影响交互事件。Z层级由下到上分别是背景图片（视频）区、底部页签区、短视频描述区、侧边控件区、顶部页签区。顶部和底部页签设置内边距padding为topAvoidHeight或bottomAvoidHeight避让系统规避区。侧边控件区使用Scroll组件自动控制滑动是否生效，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-blank\\\"' target='\\\"_blank\\\"'>Blank组件</a>和<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-layout-constraints#displaypriority\\\"' target='\\\"_blank\\\"'>displayPriority属性</a>控制侧边控件区上下两侧的留白，容器高度足够时上下留白，容器高度不足时自动隐藏。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-purax-guide.html"
    },
    {
        "id": 100,
        "pre": "Scroll() {\\n  Column() {\\n    // ...\\n  }\\n}\\n.scrollBar(BarState.Off)\\n.constraintSize({\\n  minHeight: 0,\\n  maxHeight: '90%'\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]自定义弹窗适配小窗口",
        "parent_text": "[h2]自定义弹窗适配小窗口在Pura X外屏上，当窗口高度无法完整显示自定义弹窗时，可能出现弹窗内容截断，需要进行自定义弹窗适配小窗口。效果图如下：  实现原理 使用constraintSize设置约束尺寸，自定义弹窗的最大高度不超过父组件高度的90%。同时最外层使用Scroll组件自动支持滚动。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1793312013179\\\"'><a name='\\\"section1793312013179\\\"'></a><a name='\\\"section1793312013179\\\"'></a><h4>[h2]自定义弹窗适配小窗口</h4><p>在Pura X外屏上，当窗口高度无法完整显示自定义弹窗时，可能出现弹窗内容截断，需要进行自定义弹窗适配小窗口。效果图如下：</p> <p><span><img originheight='\\\"394\\\"' originwidth='\\\"320\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161443.97792527535781017923829297062575:50001231000000:2800:A8C241E95DAE9C3547A3CE3DDAF8709B737F71E876115B9398F99F81FDF450B0.gif\\\"'/></span></p> <p><strong>实现原理</strong></p> <p>使用constraintSize设置约束尺寸，自定义弹窗的最大高度不超过父组件高度的90%。同时最外层使用Scroll组件自动支持滚动。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-purax-guide.html"
    },
    {
        "id": 101,
        "pre": "<!-- 输出text组件内容 -->\\n<div class=\\\"container\\\">\\n    <text class=\\\"title\\\">\\n        Hello {{ title }}\\n    </text>\\n</div>",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]工程目录介绍",
        "parent_text": "[h2]工程目录介绍HelloWorld工程目录如下图所示：  pages/index/index.hml：此文件定义了index页面的布局，在index页面中用到的组件，以及这些组件的层级关系。以下示例代码包含了一个text组件，内容为“Hello World”。  pages/index/index.css：此文件定义了index页面的样式。以下示例代码定义了“container”和“title”的样式。 .container {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    left: 0px;\\n    top: 0px;\\n    width: 466px;\\n    height: 466px;\\n}\\n.title {\\n    font-size: 30px;\\n    text-align: center;\\n    width: 200px;\\n    height: 100px;\\n} pages/index/index.js：此文件定义了index页面的业务逻辑，比如数据绑定，事件处理等。以下示例代码变量通过动态绑定的形式定义“title”字符串为“World”。 export default {\\n    data: {\\n        title: 'World'\\n    }\\n} resources：此目录用于存放系统级资源配置文件，如应用图标等。 config.json：此文件是配置文件，主要定义了页面路由和应用信息，可根据DevEco Studio的工程和页面创建向导自动完成填充。 {\\n  \\\"app\\\": {\\n    \\\"bundleName\\\": \\\"com.example.litewearable\\\",\\n    \\\"vendor\\\": \\\"example\\\",\\n    \\\"version\\\": {\\n      \\\"code\\\": 1000000,\\n      \\\"name\\\": \\\"1.0.0\\\"\\n    }\\n  },\\n  \\\"deviceConfig\\\": {},\\n  \\\"module\\\": {\\n    \\\"deviceType\\\": [\\n      \\\"liteWearable\\\"\\n    ],\\n    \\\"distro\\\": {\\n      \\\"deliveryWithInstall\\\": true,\\n      \\\"moduleName\\\": \\\"entry\\\",\\n      \\\"moduleType\\\": \\\"entry\\\"\\n    },\\n    // ...\\n    \\\"abilities\\\": [\\n      {\\n        \\\"name\\\": \\\".MainAbility\\\",\\n        \\\"srcLanguage\\\": \\\"js\\\",\\n        \\\"srcPath\\\": \\\"MainAbility\\\",\\n        \\\"icon\\\": \\\"$media:icon\\\",\\n        \\\"description\\\": \\\"$string:MainAbility_desc\\\",\\n        \\\"label\\\": \\\"$string:MainAbility_label\\\",\\n        \\\"type\\\": \\\"page\\\"\\n      }\\n    ],\\n    \\\"js\\\": [\\n      {\\n        \\\"pages\\\": [\\n          \\\"pages/index/index\\\",\\n          // ...\\n        ],\\n        \\\"name\\\": \\\".MainAbility\\\"\\n      }\\n    ]\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section14714318182215\\\"'><a name='\\\"section14714318182215\\\"'></a><a name='\\\"section14714318182215\\\"'></a><h4>[h2]工程目录介绍</h4><p>HelloWorld工程目录如下图所示：</p> <p><span><img height='\\\"240.34430000000003\\\"' originheight='\\\"431\\\"' originwidth='\\\"477\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161446.23980962922750381440128155436594:50001231000000:2800:B8C189C71EA1017544FFC618CCC8B4481A619A88BC4B679C2E98AEE6F2510CA1.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p><strong>pages/index/index.hml</strong><strong>：</strong>此文件定义了index页面的布局，在index页面中用到的组件，以及这些组件的层级关系。以下示例代码包含了一个text组件，内容为“Hello World”。</p>  <p><strong>pages/index/index.css</strong><strong>：</strong>此文件定义了index页面的样式。以下示例代码定义了“container”和“title”的样式。</p> <pre class='\\\"screen\\\"'>.container {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    left: 0px;\\n    top: 0px;\\n    width: 466px;\\n    height: 466px;\\n}\\n.title {\\n    font-size: 30px;\\n    text-align: center;\\n    width: 200px;\\n    height: 100px;\\n}</pre> <p><strong>pages/index/index.js</strong><strong>：</strong>此文件定义了index页面的业务逻辑，比如数据绑定，事件处理等。以下示例代码变量通过动态绑定的形式定义“title”字符串为“World”。</p> <pre class='\\\"screen\\\"'>export default {\\n    data: {\\n        title: 'World'\\n    }\\n}</pre> <p><strong>resources</strong><strong>：</strong>此目录用于存放系统级资源配置文件，如应用图标等。</p> <p><strong>config.json</strong><strong>：</strong>此文件是配置文件，主要定义了页面路由和应用信息，可根据DevEco Studio的工程和页面创建向导自动完成填充。</p> <pre class='\\\"screen\\\"'>{\\n  \\\"app\\\": {\\n    \\\"bundleName\\\": \\\"com.example.litewearable\\\",\\n    \\\"vendor\\\": \\\"example\\\",\\n    \\\"version\\\": {\\n      \\\"code\\\": 1000000,\\n      \\\"name\\\": \\\"1.0.0\\\"\\n    }\\n  },\\n  \\\"deviceConfig\\\": {},\\n  \\\"module\\\": {\\n    \\\"deviceType\\\": [\\n      \\\"liteWearable\\\"\\n    ],\\n    \\\"distro\\\": {\\n      \\\"deliveryWithInstall\\\": true,\\n      \\\"moduleName\\\": \\\"entry\\\",\\n      \\\"moduleType\\\": \\\"entry\\\"\\n    },\\n    // ...\\n    \\\"abilities\\\": [\\n      {\\n        \\\"name\\\": \\\".MainAbility\\\",\\n        \\\"srcLanguage\\\": \\\"js\\\",\\n        \\\"srcPath\\\": \\\"MainAbility\\\",\\n        \\\"icon\\\": \\\"$media:icon\\\",\\n        \\\"description\\\": \\\"$string:MainAbility_desc\\\",\\n        \\\"label\\\": \\\"$string:MainAbility_label\\\",\\n        \\\"type\\\": \\\"page\\\"\\n      }\\n    ],\\n    \\\"js\\\": [\\n      {\\n        \\\"pages\\\": [\\n          \\\"pages/index/index\\\",\\n          // ...\\n        ],\\n        \\\"name\\\": \\\".MainAbility\\\"\\n      }\\n    ]\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lite-wearable-guide.html"
    },
    {
        "id": 102,
        "pre": "/* index.css */\\n/* .为类选择器，所有组件中class=\\\"container\\\" 的组件都会使用该样式 */ \\n.container {  \\n    display: flex; \\n    justify-content: center; \\n    align-items: center; \\n    width: 466px; \\n    height: 466px; \\n} \\n/* #为ID选择器，id为title的组件会使用该样式 */ \\n#title {\\n    font-size: 30px; \\n    text-align: center; \\n    width: 200px; \\n    height: 100px; \\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]选择器样式",
        "parent_text": "[h2]选择器样式使用行内样式存在以下缺点： 针对每个组件都要设置样式。如果多个组件需要设置相同的样式，则每个组件都写同样的样式，导致代码冗余；而且修改样式时，需要修改所有代码，工作量大。 针对以上问题，我们可以采用选择器样式，将所有的样式代码写到pages/index/index.css文件中，然后通过class、id等方式和组件关联起来。以上节中的代码为例，修改后的代码如下：  <!-- index.hml -->\\n<!-- 关联index.css中的.container样式代码块 -->\\n<div class=\\\"container\\\">\\n<!-- 关联index.css中的#title样式代码块 -->\\n    <text id=\\\"title\\\">\\n        Hello World\\n    </text>\\n</div> ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section0972111693319\\\"'><a name='\\\"section0972111693319\\\"'></a><a name='\\\"section0972111693319\\\"'></a><h4>[h2]选择器样式</h4><p>使用行内样式存在以下缺点：</p> <ul><li>针对每个组件都要设置样式。</li><li>如果多个组件需要设置相同的样式，则每个组件都写同样的样式，导致代码冗余；而且修改样式时，需要修改所有代码，工作量大。</li></ul> <p>针对以上问题，我们可以采用选择器样式，将所有的样式代码写到pages/index/index.css文件中，然后通过class、id等方式和组件关联起来。以上节中的代码为例，修改后的代码如下：</p>  <pre class='\\\"screen\\\"'>&lt;!-- index.hml --&gt;\\n&lt;!-- 关联index.css中的.container样式代码块 --&gt;\\n&lt;div class=\\\"container\\\"&gt;\\n&lt;!-- 关联index.css中的#title样式代码块 --&gt;\\n    &lt;text id=\\\"title\\\"&gt;\\n        Hello World\\n    &lt;/text&gt;\\n&lt;/div&gt;</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lite-wearable-guide.html"
    },
    {
        "id": 103,
        "pre": "<!-- index.hml -->\\n<div class=\\\"container\\\">\\n    <text class=\\\"title\\\" style=\\\"font-size: {{fontSize}}; color: {{fontColor}};\\\">\\n        Hello World\\n    </text>\\n</div>",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]动态绑定样式",
        "parent_text": "[h2]动态绑定样式在行内样式和选择器样式中，样式设置方式是静态的，即代码开发中设置的样式在程序运行的时候不能更改，这种方式限制了程序的显示效果。如果要在程序运行过程中动态地改变样式，需要用到动态绑定样式。动态绑定就是值和变量动态关联，随着值的变更而显示不同的效果。动态绑定的使用方式为“{{变量名}}”，其中变量名是js文件中data对象的属性值。目前动态绑定样式只支持绑定行内样式。 以下示例代码中，text的字体大小和data中的fontSize属性绑定，字体颜色和data中的fontColor属性绑定：  // index.js:\\nexport default {\\n    data: {\\n        fontSize: '30px',\\n        fontColor: '#FF0000',\\n    }\\n}; 现在已经完成了字体大小和颜色的样式绑定，下一节交互事件将介绍如何通过按钮的点击事件实现动态改变字体的样式。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section97813316383\\\"'><a name='\\\"section97813316383\\\"'></a><a name='\\\"section97813316383\\\"'></a><h4>[h2]动态绑定样式</h4><p>在行内样式和选择器样式中，样式设置方式是静态的，即代码开发中设置的样式在程序运行的时候不能更改，这种方式限制了程序的显示效果。如果要在程序运行过程中动态地改变样式，需要用到动态绑定样式。动态绑定就是值和变量动态关联，随着值的变更而显示不同的效果。动态绑定的使用方式为“{{变量名}}”，其中变量名是js文件中data对象的属性值。目前动态绑定样式只支持绑定行内样式。</p> <p>以下示例代码中，text的字体大小和data中的fontSize属性绑定，字体颜色和data中的fontColor属性绑定：</p>  <pre class='\\\"screen\\\"'>// index.js:\\nexport default {\\n    data: {\\n        fontSize: '30px',\\n        fontColor: '#FF0000',\\n    }\\n};</pre> <p>现在已经完成了字体大小和颜色的样式绑定，下一节交互事件将介绍如何通过按钮的点击事件实现动态改变字体的样式。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lite-wearable-guide.html"
    },
    {
        "id": 104,
        "pre": "<!-- index.hml：绑定div的swipe事件 -->\\n<div class=\\\"container\\\" onswipe=\\\"touchMove\\\">\\n    <text id=\\\"title\\\">\\n        Hello {{ title }}\\n    </text>\\n    <input type=\\\"button\\\" value=\\\"View\\\" style=\\\"width: 200px; height: 50px;\\\" onclick=\\\"clickAction\\\"></input>\\n</div>",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在index.hml页面的最外层父容器中绑定onswipe事件，当页面右滑的时候会触发onswipe事件绑定的函数。示例代码如下： ",
        "import_module": null,
        "parent": "<li><span>在index.hml页面的最外层父容器中绑定onswipe事件，当页面右滑的时候会触发onswipe事件绑定的函数。示例代码如下：</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lite-wearable-guide.html"
    },
    {
        "id": 105,
        "pre": "{\\n  // ...\\n  \\\"module\\\": {\\n    \\\"deviceType\\\": [\\n      \\\"liteWearable\\\"\\n    ],\\n    \\\"distro\\\": {\\n      \\\"deliveryWithInstall\\\": true,\\n      \\\"moduleName\\\": \\\"entry\\\",\\n      \\\"moduleType\\\": \\\"entry\\\"\\n    },\\n    \\\"distroFilter\\\": {\\n      \\\"screenShape\\\": {\\n        \\\"policy\\\": \\\"include\\\",\\n        \\\"value\\\": [\\n          \\\"rect\\\"\\n        ]\\n      },\\n      \\\"screenWindow\\\": {\\n        \\\"policy\\\": \\\"include\\\",\\n        \\\"value\\\": [\\n          \\\"408*480\\\"\\n        ]\\n      }\\n    },\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "打开新建entry的config.json文件，修改deviceType为liteWearable，并添加distroFilter属性如下：（以方表分辨率408*480为例） ",
        "import_module": null,
        "parent": "<li><span>打开新建entry的config.json文件，修改deviceType为liteWearable，并添加distroFilter属性如下：（以方表分辨率408*480为例）</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lite-wearable-guide.html"
    },
    {
        "id": 106,
        "pre": "import huks from '@ohos.security.huks';\\n\\n// 别名，用于区分生成的KEY\\nconst DES_CBC_64_KEY_ALIAS = 'DesCBC64KeyAlias';\\n// ...\\n\\n// 配置生成密钥所需的Tag\\nfunction getDesGenProperties() {\\n    let properties = new Array();\\n    let index = 0;\\n    // DES算法\\n    properties[index++] = {\\n        tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\\n        value: huks.HuksKeyAlg.HUKS_ALG_DES\\n    };\\n    // 密钥长度64\\n    properties[index++] = {\\n        tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\\n        value: huks.HuksKeySize.HUKS_DES_KEY_SIZE_64\\n    };\\n    // 密钥用途，加密和解密\\n    properties[index++] = {\\n        tag: huks.HuksTag.HUKS_TAG_PURPOSE,\\n        value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT\\n    };\\n\\n    return properties;\\n}\\n\\n// 生成密钥\\nfunction generateDESKey() {\\n    let huksInfo;\\n    let options = { properties: getDesGenProperties() }\\n    huks.generateKeyItem(DES_CBC_64_KEY_ALIAS, options, (err, data) => {\\n        if (err) {\\n            huksInfo = 'generateKeyDES return code:' + err.code + ' ： ' + err.message;\\n        } else {\\n            huksInfo = 'The key has been generated:' + JSON.stringify(data);\\n        }\\n    });\\n    return huksInfo;\\n}",
        "type": "Reference",
        "function_call": "并在generateDESKey()",
        "function_name": null,
        "parent_text": "生成DES-CBC算法密钥：定义一个 getDesCBCEncryptProperties()的函数，用于生成一个包含 DES-CBC加密算法相关属性的数组。这些属性用于配置加密操作的参数，并在generateDESKey()方法中生成密钥。 ",
        "import_module": null,
        "parent": "<li><span><span rgb(64,64,64);\\\"=\"\" style='\\\"color:'>生成DES-CBC算法密钥：定义一个 </span>getDesCBCEncryptProperties<span rgb(64,64,64);\\\"=\"\" style='\\\"color:'>()的函数，用于生成一个包含 DES-CBC加密算法相关属性的数组。这些属性用于配置加密操作的参数，并在generateDESKey()方法中生成密钥。</span></span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lite-wearable-guide.html"
    },
    {
        "id": 107,
        "pre": "import cryptoFramework from '@ohos.security.cryptoFramework';\\n// ...\\nfunction stringToUint8Array(str) {\\n    let arr = [];\\n    for (let i = 0, j = str.length; i < j; ++i) {\\n        arr.push(str.charCodeAt(i));\\n    }\\n    let tmpUint8Array = new Uint8Array(arr);\\n    return tmpUint8Array;\\n}\\n\\nfunction doMd() {\\n    let mdAlgName = 'SHA256'; // 摘要算法名\\n    let message = 'mdTestMessage'; // 待摘要的数据\\n    let handle;\\n    let mdResult;\\n    let mdLen;\\n    //指定摘要算法SHA256，生成摘要操作实例\\n    try {\\n        handle = cryptoFramework.createMd(mdAlgName);\\n    } catch (error) {\\n        console.error(`createMd error, code: ${error.code}, msg: ${error.message}`);\\n    }\\n    try {\\n        // 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制\\n        handle?.updateSync({ data: stringToUint8Array(message) });\\n    } catch (error) {\\n        console.error(`updateSync error, code:+${error.code}, msg: ${error.message}`);\\n    }\\n    // 获取摘要计算结果。\\n    try {\\n        mdResult = handle?.digest();\\n    } catch (error) {\\n        console.error(`digest error, code: ${error.code}, msg: ${error.message}`);\\n    }\\n    console.info('Md result:' + mdResult?.data);\\n    // 获取摘要计算长度，单位为字节\\n    try {\\n        mdLen = handle?.getMdLength();\\n    } catch (error) {\\n        console.error(`getMdLength error, code: ${error.code}, msg: ${error.message}`);\\n    }\\n    console.info(`md len: ${mdLen}`);\\n}",
        "type": "Reference",
        "function_call": "digest()",
        "function_name": null,
        "parent_text": "消息摘要算法首先通过cryptoFramework.createMd()方法创建基于SHA256算法的摘要操作实例，将其赋值给handle；其次调用handle的updateSync()方法，将待摘要的消息转换为Uint8Array后传入，用于更新摘要操作实例中的数据；最后调用handle的digest方法，获取摘要计算的结果，并用handle的getMdLength()方法获取摘要的长度。   在同一应用内，开发者应该避免连续多次调用handle.digest()接口，否则会导致不必要的内存开销。  ",
        "import_module": null,
        "parent": "<li>消息摘要算法<p>首先通过cryptoFramework.createMd()方法创建基于SHA256算法的摘要操作实例，将其赋值给handle；其次调用handle的updateSync()方法，将待摘要的消息转换为Uint8Array后传入，用于更新摘要操作实例中的数据；最后调用handle的digest方法，获取摘要计算的结果，并用handle的getMdLength()方法获取摘要的长度。</p>  <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161447.49801004876402402713120195802533:50001231000000:2800:15B82E21ECB5E3CD2DF42C56CFC78237ED0C54DB357486A26D4320FD637B1E51.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>在同一应用内，开发者应该避免连续多次调用handle.digest()接口，否则会导致不必要的内存开销。</p> </div></div> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lite-wearable-guide.html"
    },
    {
        "id": 108,
        "pre": "import screenLock from '@ohos.screenLock';\\n\\n// ...\\n\\nfunction unlockScreen() {\\n    let result;\\n    screenLock.unlockScreen((err) => {\\n        if (err) {\\n            result = `Failed to unlock the screen, Code: ${err.code}, ${err.message}`;\\n        } else {\\n            result = `call unlockScreen sucess`;\\n        }\\n    });\\n\\n    return result;\\n}",
        "type": "Reference",
        "function_call": "unlockScreen()",
        "function_name": null,
        "parent_text": "解锁屏幕：调用screen.unlockScreen()方法解锁。 ",
        "import_module": null,
        "parent": "<li>解锁屏幕：调用screen.unlockScreen()方法解锁。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-lite-wearable-guide.html"
    },
    {
        "id": 109,
        "pre": "@Component\\nstruct DiscoverView {\\n  // ...\\n  build() {\\n    // 列表\\n    List() {\\n      LazyForEach(this.dataSource, (item: LearningResource) => {\\n        ListItem() {\\n          ArticleCardView() // 省略参数\\n            .reuseId('article')\\n        }\\n      }, (item: LearningResource) => item.id)\\n    }\\n  }\\n}\\n\\n// 列表Item\\n@Reusable\\n@Component\\nexport struct ArticleCardView {\\n  // ...\\n  aboutToReuse(params: Record<string, Object>): void {\\n    // ...\\n  }\\n  Row() {\\n    ActionButtonBuilder() // 省略参数\\n    ActionButtonBuilder()\\n    ActionButtonBuilder()\\n  }\\n  build() {\\n    // ...\\n  }\\n}\\n\\n// 使用@Builder构建子组件\\n@Builder\\nfunction ActionButtonBuilder() {  // 省略参数\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]第3步：选择优化方案",
        "parent_text": "[h2]第3步：选择优化方案选择优化方案需要一些经验的积累，开发者可以参考一些性能优化的最佳实践，来选择相应的优化方法。 下面我们对丢帧问题进行优化，针对前面的一些分析结果，我们可以从两方面来入手解决卡顿问题： 使用组件复用能力@Reusable来减少组件的频繁创建。可复用组件从组件树上移除时，会进入到一个回收缓存区。后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。简化组件创建的逻辑，使用更高效的@Builder来构建列表项Item的子组件，替代原有@Component自定义组件的方式。此外使用@Builder以后，就不需要使用@Prop了，从而减少了数据的深拷贝耗时。 优化后示例代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12559101516198\\\"'><a name='\\\"section12559101516198\\\"'></a><a name='\\\"section12559101516198\\\"'></a><h4>[h2]第3步：选择优化方案</h4><p>选择优化方案需要一些经验的积累，开发者可以参考一些<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-optimization\\\"' target='\\\"_blank\\\"'>性能优化</a>的最佳实践，来选择相应的优化方法。</p> <p>下面我们对丢帧问题进行优化，针对前面的一些分析结果，我们可以从两方面来入手解决卡顿问题：</p> <ul><li>使用组件复用能力@Reusable来减少组件的频繁创建。可复用组件从组件树上移除时，会进入到一个回收缓存区。后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。</li><li>简化组件创建的逻辑，使用更高效的@Builder来构建列表项Item的子组件，替代原有@Component自定义组件的方式。此外使用@Builder以后，就不需要使用@Prop了，从而减少了数据的深拷贝耗时。</li></ul> <p>优化后示例代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-frame-practice.html"
    },
    {
        "id": 110,
        "pre": "@Entry\\n@Component\\nstruct AnimationDemo1 {\\n  @State widthSize: number = 200;\\n  @State heightSize: number = 100;\\n  @State flag: boolean = true;\\n\\n  computeSize() {\\n    let duration = 2000;\\n    let period = 16;\\n    let widthSizeEnd = 0;\\n    let heightSizeEnd = 0;\\n    if (this.flag) {\\n      widthSizeEnd = 100;\\n      heightSizeEnd = 50;\\n    } else {\\n      widthSizeEnd = 200;\\n      heightSizeEnd = 100;\\n    }\\n    let doTimes = duration / period;\\n    let deltaHeight = (heightSizeEnd - this.heightSize) / doTimes;\\n    let deltaWeight = (widthSizeEnd - this.widthSize) / doTimes;\\n    for (let i = 1; i <= doTimes; i++) {\\n      let t = period * (i);\\n      setTimeout(() => {\\n        this.heightSize = this.heightSize + deltaHeight;\\n        this.widthSize = this.widthSize + deltaWeight;\\n      }, t);\\n    }\\n    this.flag = !this.flag;\\n  }\\n\\n  build() {\\n    Column() {\\n      Button('click me')\\n        .onClick(() => {\\n          let delay = 500;\\n          setTimeout(() => {\\n            this.computeSize();\\n          }, delay);\\n        })\\n        .width(this.widthSize)\\n        .height(this.heightSize)\\n        .backgroundColor(0x317aff)\\n    }.width('100%')\\n    .margin({ top: 5 })\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]自定义动画丢帧问题",
        "parent_text": "[h2]自定义动画丢帧问题在播放动画或者生成动画时，画面产生停滞而导致帧率过低的现象，称为动画丢帧。 播放动画时，系统需要在一个刷新周期内完成动画变化曲线的计算，完成组件布局绘制等操作。建议使用系统提供的动画接口，只需设置曲线类型、终点位置、时长等信息，就能够满足常用的动画功能，减少UI主线程的负载。 下面使用了自定义动画，动画曲线计算过程很容易引起UI线程高负载，易导致丢帧。  使用Frame Profiler录制Trace，可以看到动画帧率只有63fps左右，而当前设备是支持的设备刷新率是120Hz。  建议开发者通过系统提供的属性动效API实现上述动效功能，使用属性动画或者显式动画，下面以属性动画实现上面的效果为例： @Entry\\n@Component\\nstruct AnimationDemo2 {\\n  @State widthSize: number = 200;\\n  @State heightSize: number = 100;\\n  @State flag: boolean = true;\\n\\n  build() {\\n    Column() {\\n      Button('click me')\\n        .onClick(() => {\\n          if (this.flag) {\\n            this.widthSize = 100;\\n            this.heightSize = 50;\\n          } else {\\n            this.widthSize = 200;\\n            this.heightSize = 100;\\n          }\\n          this.flag = !this.flag;\\n        })\\n        .width(this.widthSize)\\n        .height(this.heightSize)\\n        .backgroundColor(0x317aff)\\n        .animation({\\n          duration: 2000, // 动画时长\\n          curve: Curve.Linear, // 动画曲线\\n          delay: 500, // 动画延迟\\n          iterations: 1, // 播放次数\\n          playMode: PlayMode.Normal // 动画模式\\n        }) // 对Button组件的宽高属性进行动画配置\\n    }\\n    .width('100%')\\n    .margin({ top: 5 })\\n  }\\n} 使用Frame Profiler录制优化后的Trace，可以看到动画帧率有了较大的提升，达到了116.9fps。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1625312350214\\\"'><a name='\\\"section1625312350214\\\"'></a><a name='\\\"section1625312350214\\\"'></a><h4>[h2]自定义动画丢帧问题</h4><p>在播放动画或者生成动画时，画面产生停滞而导致帧率过低的现象，称为动画丢帧。</p> <p>播放动画时，系统需要在一个刷新周期内完成动画变化曲线的计算，完成组件布局绘制等操作。建议使用系统提供的动画接口，只需设置曲线类型、终点位置、时长等信息，就能够满足常用的动画功能，减少UI主线程的负载。</p> <p>下面使用了自定义动画，动画曲线计算过程很容易引起UI线程高负载，易导致丢帧。</p>  <p>使用Frame Profiler录制Trace，可以看到动画帧率只有63fps左右，而当前设备是支持的设备刷新率是120Hz。</p> <p><span><img height='\\\"247.8854\\\"' originheight='\\\"579\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161201.03302378643443741803666130666321:50001231000000:2800:0D66637DD46B4E53FB450C21790F4F33441973180301CD36EC8108DB4114D065.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p>建议开发者通过系统提供的属性动效API实现上述动效功能，使用属性动画或者显式动画，下面以属性动画实现上面的效果为例：</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct AnimationDemo2 {\\n  @State widthSize: number = 200;\\n  @State heightSize: number = 100;\\n  @State flag: boolean = true;\\n\\n  build() {\\n    Column() {\\n      Button('click me')\\n        .onClick(() =&gt; {\\n          if (this.flag) {\\n            this.widthSize = 100;\\n            this.heightSize = 50;\\n          } else {\\n            this.widthSize = 200;\\n            this.heightSize = 100;\\n          }\\n          this.flag = !this.flag;\\n        })\\n        .width(this.widthSize)\\n        .height(this.heightSize)\\n        .backgroundColor(0x317aff)\\n        .animation({\\n          duration: 2000, // 动画时长\\n          curve: Curve.Linear, // 动画曲线\\n          delay: 500, // 动画延迟\\n          iterations: 1, // 播放次数\\n          playMode: PlayMode.Normal // 动画模式\\n        }) // 对Button组件的宽高属性进行动画配置\\n    }\\n    .width('100%')\\n    .margin({ top: 5 })\\n  }\\n}</pre> <p>使用Frame Profiler录制优化后的Trace，可以看到动画帧率有了较大的提升，达到了116.9fps。</p> <p><span><img height='\\\"200.3512\\\"' originheight='\\\"468\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161201.20477857979811718929666497766039:50001231000000:2800:E465F8DA21F1D6A1641E40D574FA2FF107EBB381002E9E88DA632642861D5658.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-frame-practice.html"
    },
    {
        "id": 111,
        "pre": "class MyDataSource implements IDataSource {\\n  private dataArray: string[] = [];\\n\\n  public pushData(data: string): void {\\n    this.dataArray.push(data);\\n  }\\n\\n  public totalCount(): number {\\n    return this.dataArray.length;\\n  }\\n\\n  public getData(index: number): string {\\n    return this.dataArray[index];\\n  }\\n\\n  registerDataChangeListener(listener: DataChangeListener): void {\\n  }\\n\\n  unregisterDataChangeListener(listener: DataChangeListener): void {\\n  }\\n}\\n\\n@Entry\\n@Component\\nstruct StackDemo1 {\\n  // ... 此处省略LazyForEach数据初始化过程\\n\\n  private data: MyDataSource = new MyDataSource();\\n\\n  build() {\\n    List() {\\n      LazyForEach(this.data, (item: string) => {\\n        ListItem() {\\n          ChildComponent({ item: item })\\n        }\\n        .reuseId('child')\\n      }, (item: string) => item)\\n    }.cachedCount(5)\\n  }\\n}\\n\\n@Reusable\\n@Component\\nstruct ChildComponent {\\n  @State item: string = '';\\n\\n  aboutToReuse(params: Record<string, Object>): void {\\n    this.item = params.item as string;\\n  }\\n\\n  build() {\\n    Stack() {\\n      Stack() {\\n        // ... 此处省略Stack嵌套\\n        Text(this.item)\\n          .fontSize(50)\\n          .margin({ left: 10, right: 10 })\\n      }\\n      // ...\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "Stack()",
        "function_name": "[h2]布局嵌套过深",
        "parent_text": "[h2]布局嵌套过深视图的嵌套层次会影响应用的性能。在屏幕刷新率为120Hz的设备上，每8.3ms刷新一帧，如果视图的嵌套层次多，可能会导致没法在8.3ms内完成一次屏幕刷新，就会造成丢帧卡顿，影响用户体验。因此推荐开发者移除多余的嵌套层次，使用相对布局 (RelativeContainer)，缩短组件刷新耗时。 例如下面这个示例在列表中加载了2000条数据，同时子组件ChildComponent里面的布局嵌套了20层Stack组件。  使用Frame Profiler进行录制，这里我们直接看应用侧的Trace数据，具体分析步骤可以看前面的丢帧问题分析思路章节  结合卡顿帧对应时间段的Trace数据，可以定位到FlushLayoutTask耗时过长，它的作用是重新测量和布局所有的Item，其中Measure方法耗时比较久，因此卡顿原因可能是布局处理逻辑过于复杂或低效。 开发者可以使用ArkUI Inspector，在DevEco Studio上查看应用在真机上的UI显示效果。利用ArkUI Inspector工具，开发者可以快速定位布局问题或其他UI相关问题，效果图如下：  可以直观的看到Item的嵌套比较深，接下来我们可以减少不必要的嵌套来尝试解决丢帧问题，示例代码如下： @Reusable\\n@Component\\nstruct ChildComponent {\\n  @State item: string = '';\\n\\n  aboutToReuse(params: Record<string, Object>): void {\\n    this.item = params.item as string;\\n  }\\n\\n  build() {\\n    Stack() {\\n      Text(this.item)\\n        .fontSize(50)\\n        .margin({ left: 10, right: 10 })\\n    }\\n  }\\n} 再次使用Frame Profiler进行录制，可以看到丢帧问题已得到解决。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1861971332220\\\"'><a name='\\\"section1861971332220\\\"'></a><a name='\\\"section1861971332220\\\"'></a><h4>[h2]布局嵌套过深</h4><p>视图的嵌套层次会影响应用的性能。在屏幕刷新率为120Hz的设备上，每8.3ms刷新一帧，如果视图的嵌套层次多，可能会导致没法在8.3ms内完成一次屏幕刷新，就会造成丢帧卡顿，影响用户体验。因此推荐开发者移除多余的嵌套层次，使用相对布局 (RelativeContainer)，缩短组件刷新耗时。</p> <p>例如下面这个示例在列表中加载了2000条数据，同时子组件ChildComponent里面的布局嵌套了20层Stack组件。</p>  <p>使用Frame Profiler进行录制，这里我们直接看应用侧的Trace数据，具体分析步骤可以看前面的丢帧问题分析思路章节</p> <p><span><img height='\\\"238.89460000000003\\\"' originheight='\\\"558\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161201.57375266441758062127169740542913:50001231000000:2800:4C3F5102C208AA717A899829B88FD839CF73CC0BFD74A10CD2384E25B4BDBFA7.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p>结合卡顿帧对应时间段的Trace数据，可以定位到FlushLayoutTask耗时过长，它的作用是重新测量和布局所有的Item，其中Measure方法耗时比较久，因此卡顿原因可能是布局处理逻辑过于复杂或低效。</p> <p>开发者可以使用ArkUI Inspector，在DevEco Studio上查看应用在真机上的UI显示效果。利用ArkUI Inspector工具，开发者可以快速定位布局问题或其他UI相关问题，效果图如下：</p> <p><span><img height='\\\"247.3933\\\"' originheight='\\\"581\\\"' originwidth='\\\"1874\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161202.16987448457250406760302851672176:50001231000000:2800:1E472CD2BB8AB70C3F21DBDCADCCAB2508158DE0ACC5B7940791E427B7AF5E81.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p>可以直观的看到Item的嵌套比较深，接下来我们可以减少不必要的嵌套来尝试解决丢帧问题，示例代码如下：</p> <pre class='\\\"screen\\\"'>@Reusable\\n@Component\\nstruct ChildComponent {\\n  @State item: string = '';\\n\\n  aboutToReuse(params: Record&lt;string, Object&gt;): void {\\n    this.item = params.item as string;\\n  }\\n\\n  build() {\\n    Stack() {\\n      Text(this.item)\\n        .fontSize(50)\\n        .margin({ left: 10, right: 10 })\\n    }\\n  }\\n}</pre> <p>再次使用Frame Profiler进行录制，可以看到丢帧问题已得到解决。</p> <p><span><img height='\\\"238.4557\\\"' originheight='\\\"557\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161202.64454451657140452224591481684350:50001231000000:2800:3470A5DFF78B490986F49B9BFEF00F2462896173CDC7289EB195CCBB36C27EA8.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-frame-practice.html"
    },
    {
        "id": 112,
        "pre": "let test:string = \\\"{name:'xiaoming' age:10}\\\";\\nlet result:object = JSON.parse(test);",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "参照如下示例，手动制造一次崩溃。 ",
        "import_module": null,
        "parent": "<li><span>参照如下示例，手动制造一次崩溃。</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-crash-monitor-practice.html"
    },
    {
        "id": 113,
        "pre": "private windowObj?: window.Window;\\nprivate onWindowSizeChange: (windowSize: window.Size) => void = (windowSize: window.Size) => {\\n  AppStorage.setOrCreate('windowWidth', windowSize.width);\\n  AppStorage.setOrCreate('windowHeight', windowSize.height);\\n};\\n// ...\\n\\nonWindowStageCreate(windowStage: window.WindowStage) {\\n  // ...\\n  windowStage.getMainWindow().then((data: window.Window) => {\\n    this.windowObj = data;\\n    AppStorage.setOrCreate('windowWidth', data.getWindowProperties().windowRect.width);\\n    AppStorage.setOrCreate('windowHeight', data.getWindowProperties().windowRect.height);\\n    this.windowObj.on('windowSizeChange', this.onWindowSizeChange);\\n    // ...\\n  });\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]侧边导航栏",
        "parent_text": "  [h2]侧边导航栏 当应用窗口宽度 ≥ 840 vp，且窗口宽度 > 高度时，应用的底部导航栏推荐切换为侧边导航栏。     示意图 sm lg    效果示意图      导航页签使用Tabs组件实现，其参数barPosition支持设置Tabs的位置，属性vertical支持设置页签是否为纵向。分别设置barPosition和vertical的值，可以将页签设置在父容器的左右侧、顶部或底部。    表1 页签位置枚举         属性值 vertical = true vertical = false   barPosition = Start 容器左侧 容器顶部   barPosition = End 容器右侧 容器底部    开发过程中，设置不同断点下barPosition和vertical的值即可。 在多数场景下，窗口宽度 < 840vp，即窗口非lg断点时，页签位于页面底部，此时vertical = false，barPosition = End。 若窗口宽度 ≥ 840 vp，即窗口为lg断点时，页签位于页面左侧，此时vertical = true，barPosition = Start。     在部分平板设备上，应用处于竖屏状态时，宽度 > 840vp，仍推荐采用底部页签。所以需要增加判断条件：若窗口的宽度 < 高度，页签位于底部；否则位于左侧。   在EntryAbility.ets文件中，开启窗口尺寸变化订阅：  在页面文件中设置Tabs组件的位置： @StorageLink('windowWidth') windowWidth: number = 0;\\n@StorageLink('windowHeight') windowHeight: number = 0;\\n\\nTabs({\\n  // lg断点且横屏时为Start，其他场景时为End\\n  barPosition: (this.currentWidthBreakpoint === BreakpointConstants.BREAKPOINT_LG && this.windowWidth > this.windowHeight) ?\\n    BarPosition.Start : BarPosition.End\\n}) {\\n  // ...\\n}\\n// lg断点且横屏时为纵向Tabs，其他场景时为横向Tabs\\n.vertical(this.currentWidthBreakpoint === BreakpointConstants.BREAKPOINT_LG && this.windowWidth > this.windowHeight) 详细实现案例请参考一多长视频。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section3696152152919\\\"'> <a name='\\\"section3696152152919\\\"'></a><a name='\\\"section3696152152919\\\"'></a> <h4>[h2]侧边导航栏</h4> <p>当应用窗口宽度 ≥ 840 vp，且窗口宽度 &gt; 高度时，应用的底部导航栏推荐切换为侧边导航栏。</p> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.3.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>示意图</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.3.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"27.42%\\\"'><p>sm</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.3.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"65.06%\\\"'><p>lg</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>效果示意图</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.42%\\\"'><p><span><img height='\\\"576.0762\\\"' originheight='\\\"1560\\\"' originwidth='\\\"720\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161443.03489023024074918560056485070618:50001231000000:2800:6C6C104FAE5E734C51F9A8852BCF46C1CBA363D6D9ADC674399E17B238BC6A85.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"65.06%\\\"'><p><span><img height='\\\"513.7657\\\"' originheight='\\\"1650\\\"' originwidth='\\\"2560\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161443.90614996100899482502465986072973:50001231000000:2800:63221EA5E639819D2088062679AE45E8980D912399649CFA13E090BBDEF39218.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p></td> </tr> </tbody></table> </div> <p>导航页签使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs\\\"' target='\\\"_blank\\\"'>Tabs</a>组件实现，其参数barPosition支持设置Tabs的位置，属性vertical支持设置页签是否为纵向。分别设置barPosition和vertical的值，可以将页签设置在父容器的左右侧、顶部或底部。</p> <div class='\\\"tablenoborder\\\"'> <table> <caption> <b>表1 </b>页签位置枚举       </caption> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>属性值</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>vertical = true</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>vertical = false</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>barPosition = Start</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>容器左侧</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>容器顶部</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>barPosition = End</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>容器右侧</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"33.33333333333333%\\\"'><p>容器底部</p></td> </tr> </tbody></table> </div> <p>开发过程中，设置不同断点下barPosition和vertical的值即可。</p> <p>在多数场景下，窗口宽度 &lt; 840vp，即窗口非lg断点时，页签位于页面底部，此时vertical = false，barPosition = End。</p> <p>若窗口宽度 ≥ 840 vp，即窗口为lg断点时，页签位于页面左侧，此时vertical = true，barPosition = Start。</p> <div class='\\\"note\\\"'> <img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161443.97628082886778805986272257491346:50001231000000:2800:AF89B941DC27CDE603851AC2E779988C1B8BB22160A321734D075219CB27F9B0.png\\\"'/><span class='\\\"notetitle\\\"'> </span> <div class='\\\"notebody\\\"'> <p>在部分平板设备上，应用处于竖屏状态时，宽度 &gt; 840vp，仍推荐采用底部页签。所以需要增加判断条件：若窗口的宽度 &lt; 高度，页签位于底部；否则位于左侧。</p> </div> </div> <p>在EntryAbility.ets文件中，开启窗口尺寸变化订阅：</p>  <p>在页面文件中设置Tabs组件的位置：</p> <pre class='\\\"screen\\\"'>@StorageLink('windowWidth') windowWidth: number = 0;\\n@StorageLink('windowHeight') windowHeight: number = 0;\\n\\nTabs({\\n  // lg断点且横屏时为Start，其他场景时为End\\n  barPosition: (this.currentWidthBreakpoint === BreakpointConstants.BREAKPOINT_LG &amp;&amp; this.windowWidth &gt; this.windowHeight) ?\\n    BarPosition.Start : BarPosition.End\\n}) {\\n  // ...\\n}\\n// lg断点且横屏时为纵向Tabs，其他场景时为横向Tabs\\n.vertical(this.currentWidthBreakpoint === BreakpointConstants.BREAKPOINT_LG &amp;&amp; this.windowWidth &gt; this.windowHeight)</pre> <p>详细实现案例请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/multi-video-app#zh-cn_topic_0000001744653537_li1226615201361\\\"' target='\\\"_blank\\\"'>一多长视频</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-tablet-2in1-guide.html"
    },
    {
        "id": 114,
        "pre": "List() {\\n  // ...\\n}\\n// 设置不同断点下的列数，sm和md断点下为2，lg断点下为3\\n.lanes(this.currentWidthBreakpoint === BreakpointConstants.BREAKPOINT_LG ? 3 : 2)",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "列表            示意图 sm lg    效果示意图      List组件提供lanes属性，支持设置布局列数或行数。通常，在lg断点下，需要通过该属性设置更多列数。 例如，在大屏设备上的列表项展示为3列，其他设备上展示为2列。  详细实现案例请参考一多长视频。",
        "import_module": null,
        "parent": "<li>列表        <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.4.3.1.1.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>示意图</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.4.3.1.1.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"27.42%\\\"'><p>sm</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.4.3.1.1.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"65.06%\\\"'><p>lg</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>效果示意图</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.42%\\\"'><p><span><img height='\\\"576.0762\\\"' originheight='\\\"1560\\\"' originwidth='\\\"720\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161443.63652408544959493086437104226968:50001231000000:2800:F6BA2C37226C09477E44DD1C68A75C2BC072713A6435743F3C5C91D096C67158.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"65.06%\\\"'><p><span><img height='\\\"498.56380000000007\\\"' originheight='\\\"1600\\\"' originwidth='\\\"2560\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161444.69843999147969859779346153861488:50001231000000:2800:550449B25B1EA55CA7D0AEE855A67643D52483E6A654B17B443FD1B6A00BE340.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p></td> </tr> </tbody></table> </div> <p>List组件提供<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#lanes9\\\"' target='\\\"_blank\\\"'>lanes</a>属性，支持设置布局列数或行数。通常，在lg断点下，需要通过该属性设置更多列数。</p> <p>例如，在大屏设备上的列表项展示为3列，其他设备上展示为2列。</p>  <p>详细实现案例请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/multi-video-app#section1932711221013\\\"' target='\\\"_blank\\\"'>一多长视频</a>。</p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-tablet-2in1-guide.html"
    },
    {
        "id": 115,
        "pre": "GridRow({\\n  // 栅格数4、12、12列\\n  columns: { sm: 4, md: 12, lg: 12 }\\n}) {\\n  GridCol({\\n    // 子元素A在不同断点分别占用4、4、4列\\n    span: { sm: 4, md: 4, lg: 4 }\\n  }) {\\n    // 子元素A\\n  }\\n\\n  GridCol({\\n    // 子元素B在不同断点下分别占用4、8、8列\\n    span: { sm: 4, md: 8, lg: 8 }\\n  }) {\\n    // 子元素B\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]挪移布局",
        "parent_text": "  [h2]挪移布局     示意图 sm lg    效果示意图      在一些特殊场景下，页面在sm断点下呈现上下布局，在lg断点下呈现左右布局。 此时需要借助栅格组件GridRow和GridCol，配置在不同断点下栅格子元素占据的列数。当一行中的列数超过栅格组件在该断点的总列数时，可以自动换行，实现挪移布局效果。 在开发中，应用根据具体设计，规划在不同断点下子元素占用的列数即可。  呈现效果：     示意图 sm lg    栅格布局示意图      详细实现案例请参考一多长视频。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section56025391910\\\"'> <a name='\\\"section56025391910\\\"'></a><a name='\\\"section56025391910\\\"'></a> <h4>[h2]挪移布局</h4> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.2.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>示意图</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.2.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"27.42%\\\"'><p>sm</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.2.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"65.06%\\\"'><p>lg</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>效果示意图</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.42%\\\"'><p><span><img height='\\\"576.0762\\\"' originheight='\\\"1560\\\"' originwidth='\\\"720\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161445.52473276627880567001125270379849:50001231000000:2800:33B0DF108E99657966E0375154821C97FD03416493CDC5F12FFC118E1A24DBD4.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"65.06%\\\"'><p><span><img height='\\\"498.56380000000007\\\"' originheight='\\\"1600\\\"' originwidth='\\\"2560\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161445.06788432967751693108935270161322:50001231000000:2800:8CD54E9EBA48294F96D3825701EB5C22FAACDE93B544A08E07D9FFEF15A8D5B0.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p></td> </tr> </tbody></table> </div> <p>在一些特殊场景下，页面在sm断点下呈现上下布局，在lg断点下呈现左右布局。</p> <p>此时需要借助栅格组件<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridrow\\\"' target='\\\"_blank\\\"'>GridRow</a>和<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridcol\\\"' target='\\\"_blank\\\"'>GridCol</a>，配置在不同断点下栅格子元素占据的列数。当一行中的列数超过栅格组件在该断点的总列数时，可以自动换行，实现挪移布局效果。</p> <p>在开发中，应用根据具体设计，规划在不同断点下子元素占用的列数即可。</p>  <p>呈现效果：</p> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.8.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"8.12%\\\"'><p>示意图</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.8.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"27.49%\\\"'><p>sm</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.8.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"64.39%\\\"'><p>lg</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"8.12%\\\"'><p>栅格布局示意图</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.49%\\\"'><p><span><img height='\\\"576.0762\\\"' originheight='\\\"1560\\\"' originwidth='\\\"720\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161445.46378273324662525312225564439247:50001231000000:2800:5D8A9A1220E0BB96307130466A6D281C2571030A547816FF9E7041ACBCFC6D9A.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"64.39%\\\"'><p><span><img height='\\\"498.56380000000007\\\"' originheight='\\\"1600\\\"' originwidth='\\\"2560\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161445.29640417882723762070707157153019:50001231000000:2800:884C84FE9FC9D5311432466FB1BDD8078493E5DA204E0B30D20952E90976D0C2.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p></td> </tr> </tbody></table> </div> <p>详细实现案例请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/multi-video-app#zh-cn_topic_0000001744653537_li1938820294129\\\"' target='\\\"_blank\\\"'>一多长视频</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-tablet-2in1-guide.html"
    },
    {
        "id": 116,
        "pre": "SideBarContainer() {\\n  Column() {\\n    // 侧边栏区域内容\\n  }\\n  .onAreaChange((newValue: Area) => {\\n    if (newValue.width !== 0) {\\n      // 侧边栏宽度发生变更时的处理\\n    }\\n  })\\n\\n  Column() {\\n    // 内容区域\\n  }\\n}\\n.showSideBar(this.currentWidthBreakpoint === BreakpointConstants.BREAKPOINT_LG ? true : false)\\n.sideBarWidth(320)\\n.minSideBarWidth(320)\\n.maxSideBarWidth(500)",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]侧边栏",
        "parent_text": "  [h2]侧边栏  在大屏设备上，可以使用SideBarContainer组件展示侧边栏，显示更多内容，便于用户操作。 该组件需要传入两个子组件，分别表示侧边栏区域和内容区域，对应上图中右侧深色区域和左侧浅色区域。 在lg断点下设置showSideBar为true，显示侧边栏；其他断点下根据应用需要进行配置即可。 设置属性sideBarPosition的值，控制侧边栏显示在容器左侧/右侧，默认位于左侧；示意图中设置其为SideBarPosition.End，表示侧边栏位于容器右侧。 通过属性sideBarWidth设置侧边栏宽度的初始值；侧边栏支持通过拖拽改变宽度，需要设置其最大宽度maxSideBarWidth和最小宽度minSideBarWidth，并在通用事件onAreaChange中实现侧边栏宽度变更时的逻辑处理。  详细实现案例请参考一多长视频。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section10658184812248\\\"'> <a name='\\\"section10658184812248\\\"'></a><a name='\\\"section10658184812248\\\"'></a> <h4>[h2]侧边栏</h4> <p><span><img height='\\\"498.56380000000007\\\"' originheight='\\\"1600\\\"' originwidth='\\\"2560\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161445.29589537774042002003627413440167:50001231000000:2800:3F06773A781BEF22E187061E4550B0C3F2A296B123371D7723D20CD77EDDAF06.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p>在大屏设备上，可以使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer\\\"' target='\\\"_blank\\\"'>SideBarContainer</a>组件展示侧边栏，显示更多内容，便于用户操作。</p> <p>该组件需要传入两个子组件，分别表示侧边栏区域和内容区域，对应上图中右侧深色区域和左侧浅色区域。</p> <p>在lg断点下设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer#showsidebar\\\"' target='\\\"_blank\\\"'>showSideBar</a>为true，显示侧边栏；其他断点下根据应用需要进行配置即可。</p> <p>设置属性<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer#sidebarposition9\\\"' target='\\\"_blank\\\"'>sideBarPosition</a>的值，控制侧边栏显示在容器左侧/右侧，默认位于左侧；示意图中设置其为SideBarPosition.End，表示侧边栏位于容器右侧。</p> <p>通过属性<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer#sidebarwidth\\\"' target='\\\"_blank\\\"'>sideBarWidth</a>设置侧边栏宽度的初始值；侧边栏支持通过拖拽改变宽度，需要设置其最大宽度<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer#maxsidebarwidth9\\\"' target='\\\"_blank\\\"'>maxSideBarWidth</a>和最小宽度<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer#minsidebarwidth9\\\"' target='\\\"_blank\\\"'>minSideBarWidth</a>，并在通用事件<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-component-area-change-event#onareachange\\\"' target='\\\"_blank\\\"'>onAreaChange</a>中实现侧边栏宽度变更时的逻辑处理。</p>  <p>详细实现案例请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/multi-video-app#zh-cn_topic_0000001744653537_li10952411168\\\"' target='\\\"_blank\\\"'>一多长视频</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-tablet-2in1-guide.html"
    },
    {
        "id": 117,
        "pre": "//src/main/ets/common/utils/PhotoUtils.ets\\n/**\\n * Pull up the gallery picker and select a video.\\n * @returns The url of the selected video.\\n */\\nasync selectVideo(): Promise<string> {\\n  let photoViewPicker = new photoAccessHelper.PhotoViewPicker();\\n  return photoViewPicker.select({\\n    MIMEType: photoAccessHelper.PhotoViewMIMETypes.VIDEO_TYPE,\\n    maxSelectNumber: 1\\n  }).then((photoSelectResult: photoAccessHelper.PhotoSelectResult): string => {\\n    if (photoSelectResult.photoUris.length <= 0) {\\n      return '';\\n    }\\n    return photoSelectResult.photoUris[0];\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "通过相册管理模块@ohos.file.photoAccessHelper的PhotoViewPicker选取图库视频，获得视频的URL。 ",
        "import_module": null,
        "parent": "<li>通过相册管理模块<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-photoaccesshelper\\\"' target='\\\"_blank\\\"'>@ohos.file.photoAccessHelper</a>的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-photoaccesshelper#photoviewpicker\\\"' target='\\\"_blank\\\"'>PhotoViewPicker</a>选取图库视频，获得视频的URL。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-thumbnail.html"
    },
    {
        "id": 118,
        "pre": "//src/main/ets/pages/Index.ets\\n/**\\n * Obtain video resources through AVImageGenerator.\\n */\\nasync imageGeneratorGetThumbnail() {\\n  this.photoUtils.selectVideo().then(async (result: string) => {\\n    // ...\\n    this.fileAlbum = fileIo.openSync(result, fileIo.OpenMode.READ_ONLY);\\n    this.avFileDescriptor = { fd: this.fileAlbum.fd };\\n    // ...\\n  }\\n  ).catch((error: BusinessError) => {\\n    hilog.error(0x0000, TAG,\\n      `Invoke imageGeneratorGetThumbnail failed!, error code: ${error.code}, message: ${error.message}`);\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "拉起图库picker，选取视频获取文件资源描述符。 ",
        "import_module": null,
        "parent": "<li>拉起图库picker，选取视频获取文件资源描述符。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-thumbnail.html"
    },
    {
        "id": 119,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { audio } from '@kit.AudioKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  //在前台时按业务所需创建AudioRenderer\\n  onForeground(): void {\\n    audio.createAudioRenderer(audioRendererOptions, ((err: BusinessError) => {}));\\n  }\\n\\n  onBackground(): void {\\n    //退到后台停止或者暂停\\n    audioRenderer.stop((err: BusinessError) => {});\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]播音场景（audioRenderer）",
        "parent_text": "[h2]播音场景（audioRenderer） ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section7717642134215\\\"'><a name='\\\"section7717642134215\\\"'></a><a name='\\\"section7717642134215\\\"'></a><h4>[h2]播音场景（audioRenderer）</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-audio-use.html"
    },
    {
        "id": 120,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onForeground(): void {\\n    //在前台时按业务所需进行播放\\n    avPlayer.play();\\n  }\\n\\n  onBackground(): void {\\n    //退到后台停止播放或者暂停\\n    avPlayer.stop(); //或者pause();\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]播音场景（AVPlayer）",
        "parent_text": "[h2]播音场景（AVPlayer） ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section166941764441\\\"'><a name='\\\"section166941764441\\\"'></a><a name='\\\"section166941764441\\\"'></a><h4>[h2]播音场景（AVPlayer）</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-audio-use.html"
    },
    {
        "id": 121,
        "pre": "//  构造播放音频流\\nawait fs.open('/test_01.mp3', fs.OpenMode.READ_ONLY).then((file: fs.File) => {\\n  console.info(\\\"filefd:\\\" + file.fd);\\n  uri = 'fd://' + (file.fd).toString()\\n}); //'/test_01.mp3'作为样例，使用时需要传入文件对应路径。\\nsoundId = awaitsoundPool.load(uri);\\n//前台场景开始播放\\nstreamId = await soundPool.play(soundId);\\n//后台场景停止播放使用：soundPool.stop(streamId);",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]播音场景（SoundPool）",
        "parent_text": "[h2]播音场景（SoundPool） 有关音频播放开发相关接口的使用，详情可以参考音频播放。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section4798174854416\\\"'><a name='\\\"section4798174854416\\\"'></a><a name='\\\"section4798174854416\\\"'></a><h4>[h2]播音场景（SoundPool）</h4> <p>有关音频播放开发相关接口的使用，详情可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-playback\\\"' target='\\\"_blank\\\"'>音频播放</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-audio-use.html"
    },
    {
        "id": 122,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\nimport { audio } from '@kit.AudioKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n\\n  onForeground(): void {\\n    //申请系统需要的资源，或者重新申请在onBackground()中释放的资源\\n    audio.createAudioCapturer(audioCapturerOptions, (err, data) => {\\n      if (err) {\\n        console.error(`InvokecreateAudioCapturerfailed,codeis${err.code},messageis${err.message}`);\\n      } else {\\n        console.info('InvokecreateAudioCapturersucceeded.');\\n      }\\n    });\\n  }\\n\\n  onBackground(): void {\\n    // 释放UI不可见时释放资源\\n    audioCapturer.stop((err: BusinessError) => {});\\n    //或者pause();\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]录音场景",
        "parent_text": "[h2]录音场景 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1357126154814\\\"'><a name='\\\"section1357126154814\\\"'></a><a name='\\\"section1357126154814\\\"'></a><h4>[h2]录音场景</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-audio-use.html"
    },
    {
        "id": 123,
        "pre": "@Entry\\n@Component\\nstruct ReuseType1 {\\n  // ...\\n  build() {\\n    Column() {\\n      List() {\\n        LazyForEach(this.dataSource, (item: string) => {\\n          ListItem() {\\n            CardView({ item: item })\\n          }\\n        }, (item: string) => item)\\n      }\\n    }\\n  }\\n}\\n\\n// 复用组件\\n@Reusable\\n@Component\\nexport struct CardView {\\n  @State item: string = '';\\n\\n  aboutToReuse(params: Record<string, Object>): void {\\n    this.item = params.item as string;\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]标准型",
        "parent_text": "[h2]标准型 这是一个标准的组件复用场景，一个滚动容器内的复用组件布局相同，只有数据不同，这种类型的组件复用可以直接参考资料组件复用。其缓存池如下，因为该场景只有一个复用组件，所以在缓存中只有一个复用组件list：  典型场景如下，列表Item布局基本完全相同。   标准型组件复用的示例代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section412518548398\\\"'><a name='\\\"section412518548398\\\"'></a><a name='\\\"section412518548398\\\"'></a><h4>[h2]标准型</h4><p><span><img height='\\\"404.276775\\\"' originheight='\\\"925\\\"' originwidth='\\\"671\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.18768317037665134760671753927224:50001231000000:2800:AE388F3A2DB54D8056D9A13FA51F024EACBB3553CC71F4B9E4E81B96C26AB6C1.png\\\"' title='\\\"点击放大\\\"' width='\\\"293.26500000000004\\\"'/></span></p> <p>这是一个标准的组件复用场景，一个滚动容器内的复用组件布局相同，只有数据不同，这种类型的组件复用可以直接参考资料<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse#section5923195311402\\\"' target='\\\"_blank\\\"'>组件复用</a>。其缓存池如下，因为该场景只有一个复用组件，所以在缓存中只有一个复用组件list：</p> <p><span><img height='\\\"392.52529400000003\\\"' originheight='\\\"634\\\"' originwidth='\\\"609\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.26287614399345630048034563771795:50001231000000:2800:308EA85D97674C1A106E30FDF0C9444358482F8190D202BB10491274FD7ACEB0.png\\\"' title='\\\"点击放大\\\"' width='\\\"377.055\\\"'/></span></p> <p>典型场景如下，列表Item布局基本完全相同。</p> <p></p> <p><span><img height='\\\"549.024\\\"' originheight='\\\"1026\\\"' originwidth='\\\"494\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.45847218575668588655325154499792:50001231000000:2800:6D23C13DF2289109F69667CF211CFF1413C06A9AE7B008B5F28EB71A531E813C.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>标准型组件复用的示例代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-reuse-scenarios-methods.html"
    },
    {
        "id": 124,
        "pre": "@Entry\\n@Component\\nstruct ReuseType2A {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      List() {\\n        LazyForEach(this.dataSource, (item: number) => {\\n          ListItem() {\\n            if (item % 2 === 0) { // 模拟业务条件判断\\n              SinglePicture({ item: item }) // 渲染单图片列表项\\n            } else {\\n              MultiPicture({ item: item }) // 渲染多图片列表项\\n            }\\n          }\\n        }, (item: number) => item + '')\\n      }\\n    }\\n  }\\n}\\n\\n// 复用组件1\\n@Reusable\\n@Component\\nstruct SinglePicture {\\n  // ...\\n}\\n\\n// 复用组件2\\n@Reusable\\n@Component\\nstruct MultiPicture {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "Row()",
        "function_name": "[h2]有限变化型",
        "parent_text": "[h2]有限变化型 如上图所示，有限变化型指的是父组件内存在多个类型的复用单元，这些类型的单元布局有所不同，根据业务逻辑的差异可以分为以下两种情况： 类型1和类型2布局不同，业务逻辑不同：这种情况可以使用两个不同的自定义组件进行复用。类型1和类型2布局不同，但是很多业务逻辑公用：这种情况为了复用公用的逻辑代码，减少代码冗余，可以给同一个组件设置不同的reuseId来进行复用。 下面将分别介绍这两种场景下的组件复用方法。 类型1和类型2布局不同，业务逻辑不同：因为两种类型的组件布局会对应应用不同的业务处理逻辑，建议将两种类型的组件分别使用两个不同的自定义组件，分别进行复用。给复用组件1和复用组件2设置不同的reuseId，此时组件复用池内的状态如下图所示，复用组件1和复用组件2处于不同的复用list中。  例如下面的列表场景，列表项布局差距比较大，有多图片的列表项，有单图片的列表项：   实现方式可参考以下示例代码：  类型1和类型2布局不同，但是很多业务逻辑公用：在这种情况下，如果将组件分为两个自定义组件进行复用，会存在代码冗余问题。根据布局的差异，可以给同一个组件设置不同的reuseId从而复用同一个组件，达到逻辑代码的复用。 根据组件复用原理与使用可知，复用组件是依据reuseId来区分复用缓存池的，而自定义组件的名称就是默认的reuseId。因此，为复用组件显式设置两个不同的reuseId与使用两个自定义组件进行复用，对于 ArkUI 而言，复用逻辑完全相同，复用池也一样，只不过复用池中复用组件的list以reuseId作为标识，如下图所示。  例如下面这个场景，布局差异比较小，业务逻辑一样都是跳转到页面详情。这种情况复用同一个组件，只需要使用if/else条件语句来控制布局的结构，就可以实现，同时可以复用跳转详情的公用逻辑代码。但是这样会导致在不同逻辑会反复去修改布局，造成性能损耗。开发者可以根据不同的条件，设置不同的reuseId来标识需要复用的组件，省去重复执行if的删除重创逻辑，提高组件复用的效率和性能。   实现方式可以参考以下示例： @Entry\\n@Component\\nstruct ReuseType2B {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      List() {\\n        LazyForEach(this.dataSource, (item: MemoInfo) => {\\n          ListItem() {\\n            MemoItem({ memoItem: item })// 使用reuseId进行组件复用的控制\\n              .reuseId((item.imageSrc !== '') ? 'withImage' : 'noImage')\\n          }\\n        }, (item: MemoInfo) => JSON.stringify(item))\\n      }\\n    }\\n  }\\n}\\n\\n@Reusable\\n@Component\\nexport default struct MemoItem {\\n  @State memoItem: MemoInfo = MEMO_DATA[0];\\n\\n  aboutToReuse(params: Record<string, Object>) {\\n    this.memoItem = params.memoItem as MemoInfo;\\n  }\\n\\n  build() {\\n    Row() {\\n      // ...\\n      if (this.memoItem.imageSrc !== '') {\\n        Image($r(this.memoItem.imageSrc))\\n          .width(90)\\n          .aspectRatio(1)\\n          .borderRadius(10)\\n      }\\n    }\\n    // ...\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12567163194014\\\"'><a name='\\\"section12567163194014\\\"'></a><a name='\\\"section12567163194014\\\"'></a><h4>[h2]有限变化型</h4><p><span><img height='\\\"440.02917\\\"' originheight='\\\"925\\\"' originwidth='\\\"671\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.04865713558599313727820301720623:50001231000000:2800:43D783C17B8A6BD9E801375E6631337B3A008993643A1ABB91AAF29EC76772A8.png\\\"' title='\\\"点击放大\\\"' width='\\\"319.20000000000005\\\"'/></span></p> <p>如上图所示，有限变化型指的是父组件内存在多个类型的复用单元，这些类型的单元布局有所不同，根据业务逻辑的差异可以分为以下两种情况：</p> <ul><li><strong>类型1和类型2布局不同，业务逻辑不同：</strong>这种情况可以使用两个不同的自定义组件进行复用。</li><li><strong>类型1和类型2布局不同，但是很多业务逻辑公用：</strong>这种情况为了复用公用的逻辑代码，减少代码冗余，可以给同一个组件设置不同的reuseId来进行复用。</li></ul> <p>下面将分别介绍这两种场景下的组件复用方法。</p> <p><strong>类型1和类型2布局不同，业务逻辑不同</strong>：因为两种类型的组件布局会对应应用不同的业务处理逻辑，建议将两种类型的组件分别使用两个不同的自定义组件，分别进行复用。给复用组件1和复用组件2设置不同的reuseId，此时组件复用池内的状态如下图所示，复用组件1和复用组件2处于不同的复用list中。</p> <p><span><img height='\\\"339.113159\\\"' originheight='\\\"643\\\"' originwidth='\\\"1375\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.10276378574665572439525512260584:50001231000000:2800:2E9035351E0503460F24E98B772F470931290D44CF069CC80F3C4D8951E25A8F.png\\\"' title='\\\"点击放大\\\"' width='\\\"725.1825\\\"'/></span></p> <p>例如下面的列表场景，列表项布局差距比较大，有多图片的列表项，有单图片的列表项：</p> <p></p> <p><span><img height='\\\"546.2842\\\"' originheight='\\\"1027\\\"' originwidth='\\\"497\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.77321664632250562407597430522891:50001231000000:2800:5B9BB24B797869B0C45725601F274B1AB0C50DD70E0E4BF591BFA3C989E866A8.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>实现方式可参考以下示例代码：</p>  <p><strong>类型1和类型2布局不同，</strong><strong>但是很多业务逻辑公用</strong>：在这种情况下，如果将组件分为两个自定义组件进行复用，会存在代码冗余问题。根据布局的差异，可以给同一个组件设置不同的reuseId从而复用同一个组件，达到逻辑代码的复用。</p> <p>根据<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse#section142448345398\\\"' target='\\\"_blank\\\"'>组件复用原理与使用</a>可知，复用组件是依据reuseId来区分复用缓存池的，而自定义组件的名称就是默认的reuseId。因此，为复用组件显式设置两个不同的reuseId与使用两个自定义组件进行复用，对于 ArkUI 而言，复用逻辑完全相同，复用池也一样，<strong>只不过复用池中复用组件的list以reuseId作为标识，</strong>如下图所示。</p> <p><span><img height='\\\"319.992946\\\"' originheight='\\\"643\\\"' originwidth='\\\"1375\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.14964488959760668516215413463752:50001231000000:2800:9F46696E5F154461B4228EF620CE14621969435FF89C58A1B1D9FECC1B3A9521.png\\\"' title='\\\"点击放大\\\"' width='\\\"684.2850000000001\\\"'/></span></p> <p>例如下面这个场景，布局差异比较小，业务逻辑一样都是跳转到页面详情。这种情况复用同一个组件，只需要使用if/else条件语句来控制布局的结构，就可以实现，同时可以复用跳转详情的公用逻辑代码。但是这样会导致在不同逻辑会反复去修改布局，造成性能损耗。开发者可以根据不同的条件，设置不同的reuseId来标识需要复用的组件，省去重复执行if的删除重创逻辑，提高组件复用的效率和性能。</p> <p></p> <p><span><img height='\\\"545.7522\\\"' originheight='\\\"1026\\\"' originwidth='\\\"497\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.54570586711993520116416043684039:50001231000000:2800:994AF767B63CC87D0BE99BC4DFB57E0851760C017328BA9587537C0EB122430E.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>实现方式可以参考以下示例：</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct ReuseType2B {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      List() {\\n        LazyForEach(this.dataSource, (item: MemoInfo) =&gt; {\\n          ListItem() {\\n            MemoItem({ memoItem: item })// 使用reuseId进行组件复用的控制\\n              .reuseId((item.imageSrc !== '') ? 'withImage' : 'noImage')\\n          }\\n        }, (item: MemoInfo) =&gt; JSON.stringify(item))\\n      }\\n    }\\n  }\\n}\\n\\n@Reusable\\n@Component\\nexport default struct MemoItem {\\n  @State memoItem: MemoInfo = MEMO_DATA[0];\\n\\n  aboutToReuse(params: Record&lt;string, Object&gt;) {\\n    this.memoItem = params.memoItem as MemoInfo;\\n  }\\n\\n  build() {\\n    Row() {\\n      // ...\\n      if (this.memoItem.imageSrc !== '') {\\n        Image($r(this.memoItem.imageSrc))\\n          .width(90)\\n          .aspectRatio(1)\\n          .borderRadius(10)\\n      }\\n    }\\n    // ...\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-reuse-scenarios-methods.html"
    },
    {
        "id": 125,
        "pre": "@Entry\\n@Component\\nstruct ReuseType3 {\\n  // ...\\n\\n  @Builder\\n  itemBuilderSingleImage(item: FriendMoment) { // 单大图列表项\\n    // ...\\n  }\\n\\n  @Builder\\n  itemBuilderGrid(item: FriendMoment) { // 九宫格列表项\\n    // ...\\n  }\\n\\n  @Builder\\n  itemBuilderVideo(item: FriendMoment) { // 视频列表项\\n    // ...\\n  }\\n\\n  build() {\\n    Column() {\\n      List() {\\n        LazyForEach(this.momentDataSource, (item: FriendMoment) => {\\n          ListItem() {\\n            if (item.type === 1) { // 根据不同类型，使用不同的组合\\n              this.itemBuilderSingleImage(item);\\n            } else if (item.type === 2) {\\n              this.itemBuilderGrid(item);\\n            } else if (item.type === 3) {\\n              this.itemBuilderVideo(item);\\n            } else {\\n              // ...\\n            }\\n          }\\n        }, (moment: FriendMoment) => JSON.stringify(moment))\\n      }\\n    }\\n  }\\n}\\n\\n@Reusable\\n@Component\\nstruct ItemTop {\\n  // ...\\n}\\n\\n@Reusable\\n@Component\\nstruct ItemBottom {\\n  // ...\\n}\\n\\n@Reusable\\n@Component\\nstruct MiddleSingleImage {\\n  // ...\\n}\\n\\n@Reusable\\n@Component\\nstruct MiddleGrid {\\n  // ...\\n}\\n\\n@Reusable\\n@Component\\nstruct MiddleVideo {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]组合型",
        "parent_text": "[h2]组合型这种类型中复用组件之间存在不同，并且情况比较多，但拥有共同的子组件。如果使用有限变化型的组件复用方式，将所有类型的复用组件写成自定义组件分别复用，不同复用组件（组件名不同或者reuseld不同）之间相同子组件无法复用，因为它们在缓存池的不同List中。 对此可以将复用组件转变为@Builder函数，使复用组件内部共同的子组件的缓存池在父组件上共享，此时组件复用池内的状态如下图所示。  典型场景如下图，这个列表的Item有多种组合方式。但是每个Item上面和下面的布局是一样的，中间部分的布局有所不同，有单一图片、视频、九宫等等。   示例代码如下，列举了单一图片、视频和九宫格图片三种类型的列表项目，使用Builder函数后将子组件组合成三种不同的类型，使内部共同的子组件就处于同一个父组件FriendsMomentsPage下。对这些子组件使用组件复用时，他们的缓存池也会在父组件上共享，节省组件创建时的消耗。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section164517474019\\\"'><a name='\\\"section164517474019\\\"'></a><a name='\\\"section164517474019\\\"'></a><h4>[h2]组合型</h4><p>这种类型中复用组件之间存在不同，并且情况比较多，但拥有共同的子组件。如果使用有限变化型的组件复用方式，将所有类型的复用组件写成自定义组件分别复用，不同复用组件（组件名不同或者reuseld不同）之间相同子组件无法复用，因为它们在缓存池的不同List中。</p> <p>对此可以将复用组件转变为@Builder函数，使复用组件内部共同的子组件的缓存池在父组件上共享，此时组件复用池内的状态如下图所示。</p> <p><span><img height='\\\"329.973\\\"' originheight='\\\"530\\\"' originwidth='\\\"1709\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.80617031296351691971759928558383:50001231000000:2800:23D3BAFA9ABDF26ED27DD6579F543A1F883ED23DC23D8E3D09F6E1E423DA0822.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></p> <p>典型场景如下图，这个列表的Item有多种组合方式。但是每个Item上面和下面的布局是一样的，中间部分的布局有所不同，有单一图片、视频、九宫等等。</p> <p></p> <p><span><img height='\\\"545.7522\\\"' originheight='\\\"1026\\\"' originwidth='\\\"497\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.45760531392576973959594271607913:50001231000000:2800:ECE3E0E9F41ADCB616297B8327495BC324BB7F8D9E79692EC058C6E4CE9F0CE1.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>示例代码如下，列举了单一图片、视频和九宫格图片三种类型的列表项目，使用Builder函数后将子组件组合成三种不同的类型，使内部共同的子组件就处于同一个父组件FriendsMomentsPage下。对这些子组件使用组件复用时，他们的缓存池也会在父组件上共享，节省组件创建时的消耗。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-reuse-scenarios-methods.html"
    },
    {
        "id": 126,
        "pre": "@Entry\\n@Component\\nstruct ReuseType5A {\\n  // ...\\n  build() {\\n    Column() {\\n      List() {\\n        LazyForEach(this.dataSource, (item: number) => {\\n          ListItem() {\\n            if (item % 2 === 0) { // 模拟类型一的条件\\n              ReusableComponent({ item: item })\\n                .reuseId('type1')\\n            } else if (item % 3 === 0) { // 模拟类型二的条件\\n              ReusableComponent({ item: item })\\n                .reuseId('type2')\\n            } else { // 模拟类型三的条件\\n              ReusableComponent({ item: item })\\n                .reuseId('type3')\\n            }\\n          }\\n        }, (item: number) => item.toString())\\n      }\\n    }\\n  }\\n}\\n\\n// 复用组件\\n@Reusable\\n@Component\\nstruct ReusableComponent {\\n  @State item: number = 0;\\n\\n  build() {\\n    Column() {\\n      ComponentA()\\n      if (this.item % 2 === 0) {\\n        ComponentB1()\\n      } else if (this.item % 3 === 0) {\\n        ComponentB2()\\n      } else {\\n        ComponentB3()\\n      }\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ComponentA {\\n  // ...\\n}\\n\\n@Component\\nstruct ComponentB1 {\\n  build() {\\n    Column() {\\n      ComponentC()\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ComponentB2 {\\n  build() {\\n    Column() {\\n      ComponentD()\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ComponentB3 {\\n  build() {\\n    Column() {\\n      ComponentE()\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ComponentC {\\n  // ...\\n}\\n\\n@Component\\nstruct ComponentD {\\n  // ...\\n}\\n\\n@Component\\nstruct ComponentE {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "CommentText()",
        "function_name": "[h2]嵌套型",
        "parent_text": "[h2]嵌套型图1 嵌套型示意图 嵌套型是指复用组件的子组件的子组件之间存在差异的复用场景。如上图所示，列表项复用组件1之间的差异是子组件B的子组件不一样，有子组件C、D、E三种。这种情况可以运行化归的思想，将复杂的问题转化为已知的、简单的问题 嵌套型实际上是上面四种类型的组合，以上图为例，可以通过有限变化型的方案，将子组件B变为子组件B1/B2/B3，这样问题就变成了一个标准的有限变化型，A/B1/C、A/B2/D、A/B3/E会分别作为一个组合进行复用，复用池如下：  下面列举一个简单的示例介绍嵌套型的使用：  或者通过组合型的方案，将子组件B改为@Builder函数，使子组件C、D、E和子组件A在同一组件层级。然后分别给子组件A、C、D、E添加@Reusable装饰器，使他们能够单独复用，具体实现可以参考组合型，改造成组合型之后复用池如下：  下面还是以朋友圈为例，如果复用组件的嵌套比较复杂，复用组件内部含有带状态的业务逻辑，不适合改为Builder函数，这种情况可能就不适合使用组合型了，这时候可以尝试通过有限变化型来复用。   图中列表项的复用组件为CardItem，子组件由三部分组成ItemTop、ItemMiddle以及ItemBottom，其中ItemMiddle子组件（即复用组件CardItem子组件的子组件）之间有差异，对于这种情况的复用，可以将子ItemMiddle组件变为ItemMiddle1、ItemMiddle2、ItemMiddle3，这样就变成了一个有限变化型复用。示例代码如下： @Entry\\n@Component\\nstruct ReuseType5 {\\n  // ...\\n  build() {\\n    Column() {\\n      List({ space: 30 }) {\\n        LazyForEach(this.momentDataSource, (item: FriendMoment, index: number) => {\\n          ListItem() {\\n            Column() {\\n              if (item.type === 1) {\\n                CardItem({ item: item })\\n                  .reuseId('ItemMiddle1')\\n              } else if (item.type === 2) {\\n                CardItem({ item: item })\\n                  .reuseId('ItemMiddle2')\\n              } else if (item.type === 3) {\\n                CardItem({ item: item })\\n                  .reuseId('ItemMiddle3')\\n              } else {\\n                // ...\\n              }\\n            }\\n          }\\n        }, (item: FriendMoment) => JSON.stringify(item))\\n      }\\n    }\\n  }\\n}\\n\\n@Reusable\\n@Component\\nstruct CardItem {\\n  // ...\\n  build() {\\n    Column() {\\n      ItemTop({ item: this.item })\\n      if (this.item.type === 1) { // 模拟条件1\\n        ItemMiddle1({ item: this.item })\\n      } else if (this.item.type === 2) { // 模拟条件2\\n        ItemMiddle2({ item: this.item })\\n      } else if (this.item.type === 3) {\\n        ItemMiddle3({ item: this.item }) // // 模拟条件3\\n      } else {\\n        // ...\\n      }\\n      ItemBottom({ item: this.item })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ItemTop {\\n  // ...\\n}\\n\\n@Component\\nstruct ItemBottom {\\n  // ...\\n}\\n\\n@Component\\nstruct ItemMiddle1 {\\n  // ...\\n  build() {\\n    Column() {\\n      CommentText()\\n      MiddleSingleImage({ item: this.item })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ItemMiddle2 {\\n  // ...\\n  build() {\\n    Column() {\\n      CommentText()\\n      MiddleGrid({ item: this.item })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ItemMiddle3 {\\n  // ...\\n  build() {\\n    Column() {\\n      CommentText()\\n      MiddleVideo({ item: this.item })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct MiddleSingleImage {\\n  // ...\\n}\\n\\n@Component\\nstruct MiddleGrid {\\n  // ...\\n}\\n\\n@Component\\nstruct MiddleVideo {\\n  // ...\\n}\\n\\n@Component\\nstruct CommentText {\\n  // ...\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1994114184010\\\"'><a name='\\\"section1994114184010\\\"'></a><a name='\\\"section1994114184010\\\"'></a><h4>[h2]嵌套型</h4><div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图1 </b>嵌套型示意图</span><br/><span><img height='\\\"632.252341\\\"' originheight='\\\"905\\\"' originwidth='\\\"504\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.21137545504687694031423549651739:50001231000000:2800:87D67D21FE980908A8B620D9543B4EB3BE4A85CA85EB9317D9CED921A8608BEF.png\\\"' title='\\\"点击放大\\\"' width='\\\"352.1175\\\"'/></span></div> <p>嵌套型是指复用组件的子组件的子组件之间存在差异的复用场景。如上图所示，列表项复用组件1之间的差异是子组件B的子组件不一样，有子组件C、D、E三种。这种情况可以运行化归的思想，将复杂的问题转化为已知的、简单的问题</p> <p>嵌套型实际上是上面四种类型的组合，以上图为例，可以通过<a href='\\\"#section12567163194014\\\"'>有限变化型</a>的方案，将子组件B变为子组件B1/B2/B3，这样问题就变成了一个标准的有限变化型，A/B1/C、A/B2/D、A/B3/E会分别作为一个组合进行复用，复用池如下：</p> <p><span><img height='\\\"371.806155\\\"' originheight='\\\"633\\\"' originwidth='\\\"1722\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161113.80922865294327909409383952594560:50001231000000:2800:E843B2A4FB7BEE6541D48DC33324A6D5BC30DE36B9400D437E9B7AD52663DFD2.png\\\"' title='\\\"点击放大\\\"' width='\\\"1011.465\\\"'/></span></p> <p>下面列举一个简单的示例介绍嵌套型的使用：</p>  <p>或者通过组合型的方案，将子组件B改为@Builder函数，使子组件C、D、E和子组件A在同一组件层级。然后分别给子组件A、C、D、E添加@Reusable装饰器，使他们能够单独复用，具体实现可以参考<a href='\\\"#section164517474019\\\"'>组合型</a>，改造成组合型之后复用池如下：</p> <p><span><img height='\\\"300.23845600000004\\\"' originheight='\\\"529\\\"' originwidth='\\\"1441\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161114.61646962294620028021967660273579:50001231000000:2800:B4AF87C363BA0A79DD975EB5EEC535A2765120EE93EB579D465BB9F7B332C727.png\\\"' title='\\\"点击放大\\\"' width='\\\"817.95\\\"'/></span></p> <p>下面还是以朋友圈为例，如果复用组件的嵌套比较复杂，复用组件内部含有带状态的业务逻辑，不适合改为Builder函数，这种情况可能就不适合使用组合型了，这时候可以尝试通过有限变化型来复用。</p> <p></p> <p><span><img height='\\\"545.7522\\\"' originheight='\\\"1026\\\"' originwidth='\\\"497\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161114.72198500432263208706963839876482:50001231000000:2800:3AF89C11E741967F840AA9624141542376759ADC15806F877D0EDFAF181C86BB.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>图中列表项的复用组件为CardItem，子组件由三部分组成ItemTop、ItemMiddle以及ItemBottom，其中ItemMiddle子组件（即复用组件CardItem子组件的子组件）之间有差异，对于这种情况的复用，可以将子ItemMiddle组件变为ItemMiddle1、ItemMiddle2、ItemMiddle3，这样就变成了一个有限变化型复用。示例代码如下：</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct ReuseType5 {\\n  // ...\\n  build() {\\n    Column() {\\n      List({ space: 30 }) {\\n        LazyForEach(this.momentDataSource, (item: FriendMoment, index: number) =&gt; {\\n          ListItem() {\\n            Column() {\\n              if (item.type === 1) {\\n                CardItem({ item: item })\\n                  .reuseId('ItemMiddle1')\\n              } else if (item.type === 2) {\\n                CardItem({ item: item })\\n                  .reuseId('ItemMiddle2')\\n              } else if (item.type === 3) {\\n                CardItem({ item: item })\\n                  .reuseId('ItemMiddle3')\\n              } else {\\n                // ...\\n              }\\n            }\\n          }\\n        }, (item: FriendMoment) =&gt; JSON.stringify(item))\\n      }\\n    }\\n  }\\n}\\n\\n@Reusable\\n@Component\\nstruct CardItem {\\n  // ...\\n  build() {\\n    Column() {\\n      ItemTop({ item: this.item })\\n      if (this.item.type === 1) { // 模拟条件1\\n        ItemMiddle1({ item: this.item })\\n      } else if (this.item.type === 2) { // 模拟条件2\\n        ItemMiddle2({ item: this.item })\\n      } else if (this.item.type === 3) {\\n        ItemMiddle3({ item: this.item }) // // 模拟条件3\\n      } else {\\n        // ...\\n      }\\n      ItemBottom({ item: this.item })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ItemTop {\\n  // ...\\n}\\n\\n@Component\\nstruct ItemBottom {\\n  // ...\\n}\\n\\n@Component\\nstruct ItemMiddle1 {\\n  // ...\\n  build() {\\n    Column() {\\n      CommentText()\\n      MiddleSingleImage({ item: this.item })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ItemMiddle2 {\\n  // ...\\n  build() {\\n    Column() {\\n      CommentText()\\n      MiddleGrid({ item: this.item })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ItemMiddle3 {\\n  // ...\\n  build() {\\n    Column() {\\n      CommentText()\\n      MiddleVideo({ item: this.item })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct MiddleSingleImage {\\n  // ...\\n}\\n\\n@Component\\nstruct MiddleGrid {\\n  // ...\\n}\\n\\n@Component\\nstruct MiddleVideo {\\n  // ...\\n}\\n\\n@Component\\nstruct CommentText {\\n  // ...\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-reuse-scenarios-methods.html"
    },
    {
        "id": 127,
        "pre": "// src/main/ets/pages/Index.ets\\n\\nWeb({\\n  src: $rawfile(/zh/.test(this.language) ? 'index_cn.html' : 'index_en.html'),\\n  controller: this.webController\\n})\\n  // ...\\n  .expandSafeArea([SafeAreaType.SYSTEM])",
        "type": "Reference",
        "function_call": "expandSafeArea()",
        "function_name": null,
        "parent_text": "Web页面实现时需要注意进行非安全区内容避让，Web组件在加载Web页面时通过expandSafeArea()扩展其安全区域，从而让视频沉浸式显示。 ",
        "import_module": null,
        "parent": "<li>Web页面实现时需要注意进行非安全区内容避让，Web组件在加载Web页面时通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V13/ts-universal-attributes-expand-safe-area-V13#expandsafearea\\\"' target='\\\"_blank\\\"'>expandSafeArea()</a>扩展其安全区域，从而让视频沉浸式显示。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-adaptation-based-web.html"
    },
    {
        "id": 128,
        "pre": "//src/main/ets/view/CustomPopupMenu.ets\\n\\n/**\\n * A custom popup menu Builder.\\n *\\n * @param uri - The URI for which the popup menu will be built.\\n * @param context - The UI context in which the popup menu will be used. This should be an instance of `common.UIAbilityContext`.\\n * @param openDownloadDialog - A function that, when called, will open a download dialog.\\n * @param closeDownloadDialog - A function that, when called, will close the download dialog.\\n * @param changeIsShow - A function that, when called, will change the visibility of certain UI elements.\\n */\\n@Builder\\nexport function customPopupMenuBuilder(\\n  uri: string,\\n  context: common.UIAbilityContext,\\n  openDownloadDialog: Function,\\n  closeDownloadDialog: Function,\\n  changeIsShow: Function\\n) {\\n  Column() {\\n    Menu() {\\n      ForEach(menus, (menu: MenuItem) => {\\n        MenuItem({\\n          content: menu.text\\n        })\\n          .height(singlePopupHeight)\\n          .onClick(() => {\\n            try {\\n              menu.caller && menu.caller(uri, context, openDownloadDialog, closeDownloadDialog);\\n              changeIsShow();\\n            } catch (e) {\\n              hilog.error(0x000, Constants.TAG, `some error happend, ${JSON.stringify(e)}`);\\n            }\\n          })\\n      }, (menu: MenuItem) => menu.id)\\n    }\\n    .width(popupWidth)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "定义弹窗内容组件，此处使用Menu作为弹窗内容，通过循环渲染menus菜单数据生成对应的菜单列表。 ",
        "import_module": null,
        "parent": "<li>定义弹窗内容组件，此处使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V13/ts-basic-components-menu-V13\\\"' target='\\\"_blank\\\"'>Menu</a>作为弹窗内容，通过循环渲染menus菜单数据生成对应的菜单列表。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-adaptation-based-web.html"
    },
    {
        "id": 129,
        "pre": "// src/main/ets/pages/Index.ets\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State isShow: boolean = false;\\n  // ...\\n\\n  build() {\\n    Column() {\\n      Web({\\n        src: $rawfile(/zh/.test(this.language) ? 'index_cn.html' : 'index_en.html'),\\n        controller: this.webController\\n      })\\n        // ...\\n        .onContextMenuShow((event) => {\\n          if (!event) {\\n            return false;\\n          }\\n          // ...\\n          this.linkUrl = event.param.getSourceUrl();\\n          this.isShow = true;\\n          return true;\\n        })\\n        // ...\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "getSourceUrl()",
        "function_name": null,
        "parent_text": "通过Web组件的onContextMenuShow()事件，在事件参数event中通过event.param.getSourceUrl()获取到视频链接地址。 ",
        "import_module": null,
        "parent": "<li>通过Web组件的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V13/ts-basic-components-web-V13#oncontextmenushow9\\\"' target='\\\"_blank\\\"'>onContextMenuShow()</a>事件，在事件参数event中通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V13/ts-basic-components-web-V13#getsourceurl9\\\"' target='\\\"_blank\\\"'>event.param.getSourceUrl()</a>获取到视频链接地址。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-adaptation-based-web.html"
    },
    {
        "id": 130,
        "pre": "// features/home/src/main/ets/pages/Index.ets\\nNavigation(this.pageInfo) {\\n  if (this.currentPageIndex === 0) {\\n    Flex({ direction: FlexDirection.Column, justifyContent: FlexAlign.Center }) {\\n      ConversationList({\\n        currentConversationUserName: $currentConversationUserName,\\n        currentContactUserName: $currentContactUserName\\n      })\\n        .flexGrow(1)\\n        .width('100%')\\n      HomeTab({ currentPageIndex: $currentPageIndex })\\n        .width(Adaptive.HomeTabWidth(this.currentBreakpoint))\\n        .height(Adaptive.HomeTabHeight(this.currentBreakpoint))\\n        .visibility(this.currentBreakpoint !== 'lg' ? Visibility.Visible : Visibility.None)\\n    }\\n    .padding({\\n      bottom: deviceInfo.deviceType !== '2in1' && this.currentBreakpoint !== 'lg' ? 28 : 0\\n    })\\n    .height('100%')\\n\\n  } else if (this.currentPageIndex === 1) {\\n    Flex({ direction: FlexDirection.Column, justifyContent: FlexAlign.Center }) {\\n      ContactsList({\\n        currentContactUserName: $currentContactUserName,\\n        currentConversationUserName: $currentConversationUserName,\\n        currentContactUserIcon: $currentContactUserIcon\\n      })\\n        .flexGrow(1)\\n        .width('100%')\\n      HomeTab({ currentPageIndex: $currentPageIndex })\\n        .width(Adaptive.HomeTabWidth(this.currentBreakpoint))\\n        .height(Adaptive.HomeTabHeight(this.currentBreakpoint))\\n        .visibility(this.currentBreakpoint !== 'lg' ? Visibility.Visible : Visibility.None)\\n    }\\n    .height('100%')\\n    .padding({\\n      bottom: deviceInfo.deviceType !== '2in1' && this.currentBreakpoint !== 'lg' ? 28 : 0\\n    })\\n  }\\n}",
        "type": "Reference",
        "function_call": "pop()",
        "function_name": null,
        "parent_text": "在Navigation组件中，定义了对话列表，出于封装的考虑，并不会在一个页面中去使用NavRouter组件做路由跳转，因此使用NavPathStack栈去做路由处理，所以定义了pageInfo去存储路由栈，当点击对话列表中一条对话信息时，向pageInfo中推送跳转路由。关系大致如下： // features/home/src/main/ets/pages/ConversationList.ets\\nList() {\\n  ForEach(ConversationListData, (item: ConversationDataInterface, index: number) => {\\n    ListItem() {\\n      ConversationItem(item)\\n        .onClick(() => {\\n          if (this.pageInfo.size() > 1) {\\n            this.pageInfo.pop();\\n          }\\n          this.pageInfo.pushPath({ name: 'ConversationDetail' });\\n          this.currentConversationUserName = item.name;\\n          this.currentContactUserName = '';\\n          this.currentIndex = index;\\n        })\\n        .backgroundColor(this.currentIndex === index ? $r('app.color.conversation_clicked_bg_color') : Color.White)\\n    }\\n    .height(Adaptive.ContactItemHeight(this.currentBreakpoint))\\n\\n  }, (item: ConversationDataInterface, index: number) => index + JSON.stringify(item))\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>在Navigation组件中，定义了对话列表，出于封装的考虑，并不会在一个页面中去使用NavRouter组件做路由跳转，因此使用NavPathStack栈去做路由处理，所以定义了pageInfo去存储路由栈，当点击对话列表中一条对话信息时，向pageInfo中推送跳转路由。关系大致如下： <pre class='\\\"screen\\\"'>// features/home/src/main/ets/pages/ConversationList.ets\\nList() {\\n  ForEach(ConversationListData, (item: ConversationDataInterface, index: number) =&gt; {\\n    ListItem() {\\n      ConversationItem(item)\\n        .onClick(() =&gt; {\\n          if (this.pageInfo.size() &gt; 1) {\\n            this.pageInfo.pop();\\n          }\\n          this.pageInfo.pushPath({ name: 'ConversationDetail' });\\n          this.currentConversationUserName = item.name;\\n          this.currentContactUserName = '';\\n          this.currentIndex = index;\\n        })\\n        .backgroundColor(this.currentIndex === index ? $r('app.color.conversation_clicked_bg_color') : Color.White)\\n    }\\n    .height(Adaptive.ContactItemHeight(this.currentBreakpoint))\\n\\n  }, (item: ConversationDataInterface, index: number) =&gt; index + JSON.stringify(item))\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-communication-app.html"
    },
    {
        "id": 131,
        "pre": "@ObservedV2\\nexport class TodoStoreModel {\\n  @Trace todoList: TodoItemData[] = [];\\n  @Trace isShow: boolean = false;\\n  addTaskTextInputValue: string = '';\\n  // ...\\n\\n  @Computed\\n  get uncompletedTodoList(): TodoItemData[] {\\n    return this.todoList.filter(item =>!item.selected);\\n  }\\n\\n  @Computed\\n  get completedTodoList(): TodoItemData[] {\\n    return this.todoList.filter(item => item.selected);\\n  }\\n}",
        "type": "Reference",
        "function_call": "now()",
        "function_name": null,
        "parent_text": "定义页面数据使用@ObservedV2定义页面需要的数据TodoList、TodoItem。  @ObservedV2\\nexport class TodoItemData {\\n  id: number = 0;\\n  @Trace taskDetail: string = '';\\n  @Trace selected?: boolean;\\n  // ...\\n  constructor(taskDetail: string, selected?: boolean, id?: number) {\\n    this.id = id ? id : Date.now();\\n    this.taskDetail = taskDetail;\\n    this.selected = selected;\\n    // ...\\n  }\\n\\n  // ...\\n} ",
        "import_module": null,
        "parent": "<li>定义页面数据<p>使用@ObservedV2定义页面需要的数据TodoList、TodoItem。</p>  <pre class='\\\"screen\\\"'>@ObservedV2\\nexport class TodoItemData {\\n  id: number = 0;\\n  @Trace taskDetail: string = '';\\n  @Trace selected?: boolean;\\n  // ...\\n  constructor(taskDetail: string, selected?: boolean, id?: number) {\\n    this.id = id ? id : Date.now();\\n    this.taskDetail = taskDetail;\\n    this.selected = selected;\\n    // ...\\n  }\\n\\n  // ...\\n}</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-global-state-management-state-store.html"
    },
    {
        "id": 132,
        "pre": "@Sendable\\nexport class ToDoItemSendable implements lang.ISendable {\\n  id: number;\\n  detail: string;\\n  selected: boolean;\\n  state: number;\\n\\n  constructor(id: number, detail: string, selected: boolean = false) {\\n    this.id = id;\\n    this.selected = selected;\\n    this.detail = detail;\\n    this.state = 0;\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "定义数据 ",
        "import_module": null,
        "parent": "<li>定义数据 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-global-state-management-state-store.html"
    },
    {
        "id": 133,
        "pre": "export class MiddlewareInstance<T> extends Middleware<T> {\\n  beforeAction: MiddlewareFuncType<T>;\\n  afterAction: MiddlewareFuncType<T>;\\n\\n  constructor(beforeAction: MiddlewareFuncType<T>, afterAction: MiddlewareFuncType<T>) {\\n    super();\\n    this.beforeAction = beforeAction;\\n    this.afterAction = afterAction;\\n  }\\n}\\n\\nexport const LogMiddleware = new MiddlewareInstance<TodoStoreModel>((state: TodoStoreModel, action: Action) => {\\n  hilog.info(0x0000, 'StateStoreSample', 'logMiddleware-before1:', JSON.stringify(state.todoList), action.type);\\n  return MiddlewareStatus.NEXT;\\n}, (state: TodoStoreModel) => {\\n  hilog.info(0x0000, 'StateStoreSample', 'logMiddleware-after:', JSON.stringify(state.todoList));\\n  return MiddlewareStatus.NEXT;\\n});",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "定义中间件开发者根据业务逻辑需要来实现beforeAction和afterAction两个钩子方法，分别在状态更新前后执行自定义逻辑。  ",
        "import_module": null,
        "parent": "<li>定义中间件<p>开发者根据业务逻辑需要来实现beforeAction和afterAction两个钩子方法，分别在状态更新前后执行自定义逻辑。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-global-state-management-state-store.html"
    },
    {
        "id": 134,
        "pre": "// TabBar.ets\\n@Builder\\nTabBuilder(id: number, index: number) {\\n  Column() {\\n    Text(this.tabBarArray[id].name)\\n      // ...\\n  }\\n  .alignItems(HorizontalAlign.Start)\\n}\\n\\nbuild() {\\n  Tabs({ barPosition: BarPosition.Start }) {\\n    ForEach(this.tabBarArray, (tabsItem: NewsTypeModel, index: number) => {\\n      TabContent() {\\n        // ...\\n      }\\n      // ...\\n    }, (item: NewsTypeModel) => JSON.stringify(item));\\n  }\\n  // ...\\n  .onAnimationStart((_index: number, targetIndex: number, _event: TabsAnimationEvent) => {\\n    this.currentIndex = targetIndex;\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "动效触发事件节点推荐使用onAnimationStart事件设置切换标签动效，使用onChange会导致页面切换后再触发动效导致效果延迟触发，使用onClick事件会与页面切换冲突。  ",
        "import_module": null,
        "parent": "<li>动效触发事件节点<p>推荐使用onAnimationStart事件设置切换标签动效，使用onChange会导致页面切换后再触发动效导致效果延迟触发，使用onClick事件会与页面切换冲突。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-news_homepage.html"
    },
    {
        "id": 135,
        "pre": "import { media } from '@kit.MediaKit';\\n// 创建avPlayer实例对象\\nlet player = await media.createAVPlayer();\\nlet headers: Record<string, string> = {\\\"User-Agent\\\" : \\\"User-Agent-Value\\\"};\\nlet mediaSource : media.MediaSource = media.createMediaSourceWithUrl(\\\"http://xxx\\\",  headers);\\n// 将preferredBufferDuration设置为最大值20MB；preferredWidth为播放策略首选宽度；preferredHeight为播放策略首选高度；preferredHdr为播放策略true是hdr，false非hdr\\nlet playStrategy : media.PlaybackStrategy = {preferredWidth: 1, preferredHeight: 2, preferredBufferDuration: 20, preferredHdr: false};\\n// 设置媒体来源和播放策略\\nplayer.setMediaSource(mediaSource, playStrategy);",
        "type": "Reference",
        "function_call": null,
        "function_name": "合理设置缓冲区大小",
        "parent_text": "合理设置缓冲区大小为应对弱网及高码率片源的卡顿，用户需根据资源文件的大小设置尽可能大的缓冲区。这样在卡顿时，可以保证缓冲区能够缓存起播水线的数据量，从而避免卡成幻灯片的情况出现，保证卡顿后播放的连续性。 表2 流媒体缓冲区大小设置默认缓冲区大小  用户自定义缓冲区大小    20MB  5MB ~ 20MB     AVPlayer支持用户自定义缓冲区大小，可通过setMediaSource接口设置PlaybackStrategy中的preferredBufferDuration，自定义缓冲区大小。preferredBufferDuration的单位为秒，缓冲区大小将设置为preferredBufferDuration * 1MB。如：preferredBufferDuration设置为20秒，缓冲区大小将设置为20MB。示例可参考视频播放。缓冲区的大小是根据资源文件的大小来设置的，缓冲区大小需要大于整个媒体文件大小。如果媒体文件大小超过用户自定义缓冲区最大值20MB，此时可将缓冲区设置为最大值20MB。  本文的测试场景为弱网条件下使用AVPlayer+XComponent渲染播放一个大小为56MB的在线视频。 表3 自定义缓冲区大小的卡顿率（注：测试视频大小为56MB，视频暂停超过100ms算一次卡顿）用户自定义缓冲区大小  卡顿率（卡顿率=卡顿次数/播放时间）    5MB  65.79%   10MB  28.95%   20MB  5.26%     图2 视频卡顿率折线图 从实验数据可以看出： 当媒体文件大小超过可设置的缓冲区最大值时，可将缓冲区设置为最大值20MB，从而最小程度减少视频卡顿。当媒体文件大小未超过可设置的缓冲区的范围时，可根据媒体文件的大小来设置缓冲区大小。  循环播放时，若应用会重新创建下载实例，则新的实例会重新下载数据。循环播放时，若应用不会重新创建下载实例，且媒体文件大小，小于缓冲区大小，则会循环读取已下载数据，不会重新触发下载。循环播放时，若应用不会重新创建下载实例，且媒体文件大小，大于缓冲区大小，则会循环下载数据。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section135221411115711\\\"'><a name='\\\"section135221411115711\\\"'></a><a name='\\\"section135221411115711\\\"'></a><h4>合理设置缓冲区大小</h4><p>为应对弱网及高码率片源的卡顿，用户需根据资源文件的大小设置尽可能大的缓冲区。这样在卡顿时，可以保证缓冲区能够缓存起播水线的数据量，从而避免卡成幻灯片的情况出现，保证卡顿后播放的连续性。</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表2 </b>流媒体缓冲区大小设置</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.3.2.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>默认缓冲区大小</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.3.2.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>用户自定义缓冲区大小</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>20MB</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>5MB ~ 20MB</p> </td> </tr> </tbody></table> </div> <p>AVPlayer支持用户自定义缓冲区大小，可通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-media#setmediasource12\\\"' target='\\\"_blank\\\"'>setMediaSource</a>接口设置PlaybackStrategy中的preferredBufferDuration，自定义缓冲区大小。preferredBufferDuration的单位为秒，缓冲区大小将设置为preferredBufferDuration * 1MB。如：preferredBufferDuration设置为20秒，缓冲区大小将设置为20MB。示例可参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-playback\\\"' target='\\\"_blank\\\"'>视频播放</a>。缓冲区的大小是根据资源文件的大小来设置的，缓冲区大小需要大于整个媒体文件大小。如果媒体文件大小超过用户自定义缓冲区最大值20MB，此时可将缓冲区设置为最大值20MB。</p>  <p>本文的测试场景为弱网条件下使用AVPlayer+XComponent渲染播放一个大小为56MB的在线视频。</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表3 </b>自定义缓冲区大小的卡顿率（注：测试视频大小为56MB，视频暂停超过100ms算一次卡顿）</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.7.2.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>用户自定义缓冲区大小</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.7.2.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>卡顿率（卡顿率=卡顿次数/播放时间）</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>5MB</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>65.79%</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>10MB</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>28.95%</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>20MB</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>5.26%</p> </td> </tr> </tbody></table> </div> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图2 </b>视频卡顿率折线图</span><br/><span><img height='\\\"360.0975\\\"' originheight='\\\"502\\\"' originwidth='\\\"729\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161046.37410318730296111333276689936956:50001231000000:2800:0D7EEB9700C46DD3A784D2CBEFC6CBAFCDBDA5EBC6772AA426BD8445B97A6865.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></div> <p>从实验数据可以看出：</p> <ol><li>当媒体文件大小超过可设置的缓冲区最大值时，可将缓冲区设置为最大值20MB，从而最小程度减少视频卡顿。</li><li>当媒体文件大小未超过可设置的缓冲区的范围时，可根据媒体文件的大小来设置缓冲区大小。</li></ol> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161046.15925388067858754363230677023610:50001231000000:2800:78E2E62B8637F58DD805C2321075298D37E9762498759E540E01749382409032.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><ol><li>循环播放时，若应用会重新创建下载实例，<strong>则新的实例</strong><strong>会重新下载数据</strong>。</li><li>循环播放时，若应用不会重新创建下载实例，且媒体文件大小，小于缓冲区大小，<strong>则会循环读取已下载数据，不会重新触发下载</strong>。</li><li>循环播放时，若应用不会重新创建下载实例，且媒体文件大小，大于缓冲区大小，<strong>则会循环下载数据</strong>。</li></ol> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-online-video-playback-lags-practice.html"
    },
    {
        "id": 136,
        "pre": "// src/main/ets/pages/HotelDetailsPage.ets\\nScroll(this.scroller) {\\n  HotelDetailsPictureView({ topLength: this.topLength })\\n}\\n.scrollBar(BarState.Off)\\n.width(CommonConstants.FULL_WIDTH_PERCENT)\\n.height(CommonConstants.FULL_WIDTH_PERCENT)\\n.onReachStart(() => {\\n  if (!this.isInitialization) {\\n    this.topLength = CommonConstants.MIN_MARIN_TOP;\\n    this.isInitialization = true;\\n  } else {\\n    this.topLength = CommonConstants.MAX_MARIN_TOP;\\n  }\\n})\\n.onWillScroll((xOffset: number, yOffset: number)=>{\\n  if (yOffset > 0) {\\n    this.topLength = CommonConstants.MIN_MARIN_TOP;\\n  }\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]酒店详情页",
        "parent_text": "[h2]酒店详情页旅行订票酒店详情页提供酒店的详细内容，包括预览图以及房间类型、价格等信息，方便用户对酒店房间的选择与预订。 将酒店详情页划分为4个部分，效果图如下： 示意图  sm  md  lg    效果图              对其中的各个区域分析使用的一多能力，实现方案如下表： 区域编号  简介  实现方案    1  顶部控件  使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。   2  酒店卡片  使用GridCol栅格子组件实现挪移布局。   3  订房优惠  使用拉伸能力实现文字与按钮的拉伸自适应。   4  房间详情  List组件实现延伸能力，layoutWeight实现拉伸能力。     顶部banner的具体实现 顶部banner会根据不同设备类型展示不同的效果，手机会支持顶部banner上滑，图片展开的动效。折叠屏支持Scroll组件展示小图，点击后更换大图展示的效果。平板支持Swiper滑动切换视图的效果。 手机的上滑展开，下滑收起，主要使用了Scroll组件的onReachStart属性和onWillScroll属性。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section185431244812\\\"'><a name='\\\"section185431244812\\\"'></a><a name='\\\"section185431244812\\\"'></a><h4>[h2]酒店详情页</h4><p>旅行订票酒店详情页提供酒店的详细内容，包括预览图以及房间类型、价格等信息，方便用户对酒店房间的选择与预订。</p> <ul><li>将酒店详情页划分为4个部分，效果图如下： <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.3.1.1.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"6.779661016949154%\\\"'><p>示意图</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.3.1.1.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"25.162227602905567%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.3.1.1.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"38.295399515738495%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.3.1.1.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"29.762711864406782%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.779661016949154%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"25.162227602905567%\\\"'><p></p> <p><span><img height='\\\"551.7771\\\"' originheight='\\\"804\\\"' originwidth='\\\"385\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161344.54571532189429477078438867311682:50001231000000:2800:D382DB237C646F10F8198BB0643A55BE73CA6775850E2B0E630A8596B4B9F5FD.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"38.295399515738495%\\\"'><p></p> <p><span><img height='\\\"534.0881\\\"' originheight='\\\"787\\\"' originwidth='\\\"705\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161344.60904213980619626779534799535357:50001231000000:2800:740451F4B763E4B394194097A68A8358E7D60E880D9A2FE1F8A2938D7E01402B.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"29.762711864406782%\\\"'><p></p> <p><span><img height='\\\"517.0109000000001\\\"' originheight='\\\"869\\\"' originwidth='\\\"1344\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161344.70874845217940868412408078906819:50001231000000:2800:29C10B7FAE1C5D063B5160A74B4A4A65E940249C212DFF999842A6911E3D2571.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div> </li><li>对其中的各个区域分析使用的一多能力，实现方案如下表： <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.3.2.1.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"6.851996867658575%\\\"'><p>区域编号</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.3.2.1.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"9.602584181675802%\\\"'><p>简介</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.3.2.1.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"83.54541895066562%\\\"'><p>实现方案</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.851996867658575%\\\"'><p>1</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.602584181675802%\\\"'><p>顶部控件</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"83.54541895066562%\\\"'><p>使用栅格断点能力，设置在不同断点下顶部控件实现拉伸能力。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.851996867658575%\\\"'><p>2</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.602584181675802%\\\"'><p>酒店卡片</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"83.54541895066562%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-gridrow\\\"' target='\\\"_blank\\\"'>GridCol栅格子组件</a>实现挪移布局。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.851996867658575%\\\"'><p>3</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.602584181675802%\\\"'><p>订房优惠</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"83.54541895066562%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/adaptive-layout#拉伸能力\\\"' target='\\\"_blank\\\"'>拉伸能力</a>实现文字与按钮的拉伸自适应。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.851996867658575%\\\"'><p>4</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"9.602584181675802%\\\"'><p>房间详情</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"83.54541895066562%\\\"'><p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list\\\"' target='\\\"_blank\\\"'>List组件</a>实现延伸能力，layoutWeight实现拉伸能力。</p> </td> </tr> </tbody></table> </div> </li><li>顶部banner的具体实现</li></ul> <p>顶部banner会根据不同设备类型展示不同的效果，手机会支持顶部banner上滑，图片展开的动效。折叠屏支持Scroll组件展示小图，点击后更换大图展示的效果。平板支持Swiper滑动切换视图的效果。</p> <p>手机的上滑展开，下滑收起，主要使用了Scroll组件的onReachStart属性和onWillScroll属性。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-travel-accommodation.html"
    },
    {
        "id": 137,
        "pre": "// src/main/ets/view/HotelDetailsRoomView.ets\\ngetFoldStatus() {\\n  if (this.isShowingCalendar) {\\n    this.dialogController.open();\\n  } else {\\n    this.dialogController.close()\\n  }\\n}\\n\\n// ...\\n\\nColumn() {\\n  Image($r(\\\"app.media.cheap_day\\\"))\\n    .width($r('app.float.January_2024_margin_top'))\\n  Text(CommonConstants.ROOM_BUTTON_MESSAGES[CommonConstants.NUMBER_FIVE])\\n    .font({ size: $r('app.float.room_bundle_font_size'), weight: CommonConstants.FONT_WEIGHT_500 })\\n    .opacity(CommonConstants.OPACITY_FORTY_PERCENT)\\n}\\n.onClick(() => {\\n  if (this.breakPoint === CommonConstants.BREAK_POINT_SM) {\\n    this.pageInfos.pushPath(new NavPathInfo(CommonConstants.LOW_PRICE_CALENDAR_URL,[]));\\n  } else {\\n    this.isShowingCalendar = true;\\n  }\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "低价日历根据栅格布局监听断点变化，根据断点不同实现不同的响应效果。   ",
        "import_module": null,
        "parent": "<li>低价日历<p>根据栅格布局监听断点变化，根据断点不同实现不同的响应效果。</p>  <p></p> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-travel-accommodation.html"
    },
    {
        "id": 138,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { ble } from '@kit.ConnectivityKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onForeground(): void {\\n    //在前台时按业务所需启动Ble扫描和广播\\n    ble.startBLEScan([scanFilter], scanOptions);\\n    ble.startAdvertising(setting, advData, advResponse);\\n  }\\n\\n  onBackground(): void {\\n    //退到后台停止Ble扫描和广播，和申请时对应\\n    ble.stopBLEScan();\\n    ble.stopAdvertising();\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "示例",
        "parent_text": "示例 有关蓝牙相关接口的使用，详情可以参考广播与扫描开发指导 。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12530100121615\\\"'><a name='\\\"section12530100121615\\\"'></a><a name='\\\"section12530100121615\\\"'></a><h4>示例</h4> <p>有关蓝牙相关接口的使用，详情可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ble-development-guide\\\"' target='\\\"_blank\\\"'>广播与扫描开发指导</a> 。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-bluetooth-use.html"
    },
    {
        "id": 139,
        "pre": "{\\n  \\\"abilities\\\": [\\n    {\\n      \\\"skills\\\": [\\n        {\\n          \\\"uris\\\": [\\n            {\\n              \\\"scheme\\\": \\\"maps\\\", // 这里仅示意，应用需确保这里声明的的uri能被外部正常拉起\\n              \\\"host\\\": \\\"navigation\\\",\\n              \\\"path\\\": \\\"\\\",\\n              \\\"linkFeature\\\": \\\"Navigation\\\" // 声明应用支持导航功能\\n            }\\n          ]\\n        }\\n      ]\\n    }\\n  ]\\n}",
        "type": "Reference",
        "function_call": "与onNewWant()",
        "function_name": null,
        "parent_text": "目标方配置：作为被拉起应用需要在module.json5文件中配置uris，并在onCreate()与onNewWant()中进行参数接收与处理，以下代码为配置应用支持导航功能的module.json5示例，其他功能以及参数接收与解析开发者可参考目标方开发步骤。 ",
        "import_module": null,
        "parent": "<li>目标方配置：作为被拉起应用需要在module.json5文件中配置uris，并在onCreate()与onNewWant()中进行参数接收与处理，以下代码为配置应用支持导航功能的module.json5示例，其他功能以及参数接收与解析开发者可参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/start-navigation-apps#目标方开发步骤\\\"' target='\\\"_blank\\\"'>目标方开发步骤</a>。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-jump-between-application.html"
    },
    {
        "id": 140,
        "pre": "// entry/src/main/ets/component/Watermark.ets\\n@Component\\nexport struct Watermark {\\n  private settings: RenderingContextSettings = new RenderingContextSettings(true);\\n  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);\\n  // ...\\n  build() {\\n    Canvas(this.context)\\n      .width('100%')\\n      .height('100%')\\n      .hitTestBehavior(HitTestMode.Transparent)\\n      .onReady(() => this.draw())\\n  }\\n}",
        "type": "Reference",
        "function_call": "在回调中进行水印绘制draw()",
        "function_name": null,
        "parent_text": "创建Canvas组件，监听Canvas.onReady事件，该事件回调在Canvas组件初始化完成时或大小变化时执行，在回调中进行水印绘制draw()方法的执行。并通过设置Canvas组件的hitTestBehavior属性，使水印组件不影响其他组件的触摸测试，让页面能正常交互。 ",
        "import_module": null,
        "parent": "<li>创建Canvas组件，监听<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-components-canvas-canvas#事件\\\"' target='\\\"_blank\\\"'>Canvas.onReady</a>事件，该事件回调在Canvas组件初始化完成时或大小变化时执行，在回调中进行水印绘制draw()方法的执行。并通过设置Canvas组件的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior#hittestbehavior\\\"' target='\\\"_blank\\\"'>hitTestBehavior</a>属性，使水印组件不影响其他组件的触摸测试，让页面能正常交互。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-add-watermark.html"
    },
    {
        "id": 141,
        "pre": "// entry/src/main/ets/pages/SaveImagePage.ets\\nasync getImagePixelMap(resource: Resource): Promise<ImagePixelMap> {\\n  const data: Uint8Array = await getContext(this).resourceManager.getMediaContent(resource);\\n  const arrayBuffer: ArrayBuffer = data.buffer.slice(data.byteOffset, data.byteLength + data.byteOffset);\\n  const imageSource: image.ImageSource = image.createImageSource(arrayBuffer);\\n  return await imageSource2PixelMap(imageSource);\\n}",
        "type": "Reference",
        "function_call": "createImageSource(buf: ArrayBuffer)",
        "function_name": null,
        "parent_text": "使用resourceManager.getMediaContent()方法获取图片内容，得到ArrayBuffer数据。使用image.createImageSource(buf: ArrayBuffer)方法创建图片源实例。 ",
        "import_module": null,
        "parent": "<li>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-resource-manager#getmediacontent9-3\\\"' target='\\\"_blank\\\"'>resourceManager.getMediaContent()</a>方法获取图片内容，得到ArrayBuffer数据。使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-image#imagecreateimagesource9-2\\\"' target='\\\"_blank\\\"'>image.createImageSource(buf: ArrayBuffer)</a>方法创建图片源实例。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-add-watermark.html"
    },
    {
        "id": 142,
        "pre": "// entry/src/main/ets/pages/WatermarkPdfPage.ets\\nsavePdfToSandbox(): string {\\n  const filePath = this.getPdfSandboxPath();\\n  fileIo.accessSync(filePath);\\n  const content: Uint8Array = getContext().resourceManager.getRawFileContentSync('watermark.pdf');\\n  const file = fileIo.openSync(filePath, fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.CREATE | fileIo.OpenMode.TRUNC);\\n  fileIo.writeSync(file.fd, content.buffer);\\n  fileIo.closeSync(file.fd);\\n  return filePath;\\n}",
        "type": "Reference",
        "function_call": "writeSync()",
        "function_name": null,
        "parent_text": "使用getRawFileContentSync()方法获取resource/rawfile目录下的PDF文件内容，使用fs.writeSync()方法写入沙箱中。 ",
        "import_module": null,
        "parent": "<li>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-resource-manager#getrawfilecontentsync10\\\"' target='\\\"_blank\\\"'>getRawFileContentSync()</a>方法获取resource/rawfile目录下的PDF文件内容，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-file-fs#writesync10\\\"' target='\\\"_blank\\\"'>fs.writeSync()</a>方法写入沙箱中。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-add-watermark.html"
    },
    {
        "id": 143,
        "pre": "bool ArkNativeObject::SetProperty(const char* name, NativeValue* value)\\n{\\n    auto vm = engine_->GetEcmaVm();\\n    LocalScope scope(vm);\\n\\n    Global<ObjectRef> obj = value_;\\n    Local<StringRef> key = StringRef::NewFromUtf8(vm, name);\\n    Global<JSValueRef> val = *value;\\n\\n    return obj->Set(vm, key, val.ToLocal(vm));\\n}",
        "type": "Reference",
        "function_call": "operator T()",
        "function_name": "[h2]传入的NativeValue*为空指针",
        "parent_text": "[h2]传入的NativeValue*为空指针问题描述 调用用SetProperty发生崩溃，堆栈如下：  定位分析 通过addr2line工具，得知崩溃时的调用代码如下。  但这里看不出具体原因，所以继续使用objdump反汇编看一下具体的汇编指令。 从堆栈上看，最后崩溃在 2bc0c 上，反汇编结果对应的指令如下：  上面的指令ldr x1, [x19, #8]，其中x19为参数value(x19最近一次是通过x2赋值的，x2就是第二个参数value，x0为this，x1为第一个参数name)，结合上面Registers可以看出，x19寄存器的值为0x0，加上了偏移8，也就是取地址0x8的内容。 到此，可以得出初步结论SetProperty的时候，传入的第二个参数value为nullptr。 另外一方面从日志也可以看出，创建JsResourceManager也发生了异常。  NativeValue* CreateJsBaseContext(NativeEngine& engine, std::shared_ptr<Context> context, bool keepContext)\\n{\\n    NativeValue* objValue = engine.CreateObject();\\n    NativeObject* object = ConvertNativeValueTo<NativeObject>(objValue);\\n    if (object == nullptr) {\\n        HILOG_WARN(\\\"invalid object\\\");\\n        return objValue;\\n    }\\n    auto jsContext = std::make_unique<JsBaseContext>(context);\\n    SetNameNativePointer(engine, *object, BASE_CONTEXT_NAME, jsContext.release(), JsBaseContext::Finalizer);\\n    auto appInfo = context->GetApplicationInfo();\\n    if (appInfo!= nullptr) {\\n        object->SetProperty(\\\"applicationInfo\\\", CreateJsApplicationInfo(engine, *appInfo));\\n    }\\n    auto hapModuleInfo = context->GetApplicationInfo();\\n    if (hapModuleInfo!= nullptr) {\\n        object->SetProperty(\\\"currentHapModuleInfo\\\", CreateJsApplicationInfo(engine, *hapModuleInfo));\\n    }\\n    auto resourceManager = context->GetApplicationInfo();\\n    if (appInfo!= nullptr) {\\n        object->SetProperty(\\\"resourceManager\\\", CreateJsApplicationInfo(engine, resourceManager, context));\\n    }\\n    BindNativeProperty(*object, \\\"cacheDir\\\", JsBaseContext::GetCacheDir);\\n    BindNativeProperty(*object, \\\"tempDir\\\", JsBaseContext::GetTempDir);\\n    BindNativeProperty(*object, \\\"filesDir\\\", JsBaseContext::GetFilesDir);\\n    BindNativeProperty(*object, \\\"distributeFilesDir\\\", JsBaseContext::GetDistributeFilesDir);\\n    BindNativeProperty(*object, \\\"databaseDir\\\", JsBaseContext::GetDatabaseDir);\\n    BindNativeProperty(*object, \\\"preferencesDir\\\", JsBaseContext::GetPreferencesDir);\\n    BindNativeProperty(*object, \\\"bundleCodeDir\\\", JsBaseContext::GetBundleCodeDir);\\n    BindNativeProperty(*object, \\\"area\\\", JsBaseContext::GetArea);\\n    const char *moduleName = \\\"JsBaseContext\\\";\\n    BindNativeFunction(engine, *object, \\\"createBundleContext\\\", moduleName, JsBaseContext::CreateBundleContext);\\n    BindNativeFunction(engine, *object, \\\"getApplicationContext\\\", moduleName, JsBaseContext::GetApplicationContext);\\n    BindNativeFunction(engine, *object, \\\"switchArea\\\", moduleName, JsBaseContext::SwitchArea);\\n    BindNativeFunction(engine, *object, \\\"getArea\\\", moduleName, JsBaseContext::GetArea);\\n    BindNativeFunction(engine, *object, \\\"createModuleContext\\\", moduleName, JsBaseContext::CreateModuleContext);\\n\\n    return objValue;\\n} 接下来，继续分析一下x19 需要加上#8的原因。下面3条指令是调用 GetHandleAddr(const EcmaVM *vm, uintptr_t localAddress) 方法，这样对应起来[x19, #8]保存的应该是address。对比代码，可以看出下面的指令对应的逻辑为val.ToLocal 。2bc0c: f9400661 ldr x1, [x19, #8]\\n2bc10: aa1603e0 mov x0, x22\\n2bc14: 94000abf bl -0x2e710 <_ZN5panda6JSNApi13GetHandleAddrEPKNS_10ecmascript6EcmaVMEm@plt>  Local<T> ToLocal() const\\n{\\n    if (IsEmpty()) {\\n        return Local<T>();\\n    }\\n    return Local<T>(vm_, *this);\\n} template<typename T>\\nLocal<T>::Local(const EcmaVM *vm, const Global<T> &current)\\n{\\n    address_ = JSNApi::GetHandleAddr(vm, reinterpret_cast<uintptr_t>(*current));\\n} NativeValue到Global涉及了多层的转换， NativeValue* 指向的内容和Global是一样的，所以通过Global拿address等同于通过NativeValue*去取其第一个成员的值。因为NativeValue析构函数为virtual，所以取成员需要加上虚表偏移#8 。 class NativeValue {\\npublic:\\n    virtual ~NativeValue() {}\\n    template<typename T> operator T()\\n    {\\n        return value_;\\n    }\\n    ...\\n} 因此，问题根因已找到：CreateJsResourceManager返回了nullptr。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section5652027185516\\\"'><a name='\\\"section5652027185516\\\"'></a><a name='\\\"section5652027185516\\\"'></a><h4>[h2]传入的NativeValue*为空指针</h4><p><strong>问题描述</strong></p> <p>调用用SetProperty发生崩溃，堆栈如下：</p> <p><span><img height='\\\"306.3389\\\"' originheight='\\\"724\\\"' originwidth='\\\"1886\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161257.34997834980688198317052737264195:50001231000000:2800:07A5E8FFB71339AC526F2ED2FF602EDDE04A6F154F31FBEEB20229519048F3DC.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p><strong>定位分析</strong></p> <p>通过addr2line工具，得知崩溃时的调用代码如下。</p>  <p>但这里看不出具体原因，所以继续使用objdump反汇编看一下具体的汇编指令。</p> <p>从堆栈上看，最后崩溃在 2bc0c 上，反汇编结果对应的指令如下：</p> <p><span><img height='\\\"497.48650000000004\\\"' originheight='\\\"543\\\"' originwidth='\\\"871\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161257.25615738744124974339666527675140:50001231000000:2800:3415B1BFCCC71B23065B5F262030865E2D4B9FE9B46C6A237F9740B1BE0B5053.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p>上面的指令ldr x1, [x19, #8]，其中x19为参数value(x19最近一次是通过x2赋值的，x2就是第二个参数value，x0为this，x1为第一个参数name)，结合上面Registers可以看出，x19寄存器的值为0x0，加上了偏移8，也就是取地址0x8的内容。</p> <p>到此，可以得出初步结论SetProperty的时候，传入的第二个参数value为nullptr。 另外一方面从日志也可以看出，创建JsResourceManager也发生了异常。</p> <p><span><img height='\\\"196.95970000000003\\\"' originheight='\\\"505\\\"' originwidth='\\\"2046\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161257.51577716009642014974214520291112:50001231000000:2800:3EFC8A01A6049A1C7EBD770B568672661B0097E51D4EB05532B0A745448664D7.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <pre class='\\\"screen\\\"'>NativeValue* CreateJsBaseContext(NativeEngine&amp; engine, std::shared_ptr&lt;Context&gt; context, bool keepContext)\\n{\\n    NativeValue* objValue = engine.CreateObject();\\n    NativeObject* object = ConvertNativeValueTo&lt;NativeObject&gt;(objValue);\\n    if (object == nullptr) {\\n        HILOG_WARN(\\\"invalid object\\\");\\n        return objValue;\\n    }\\n    auto jsContext = std::make_unique&lt;JsBaseContext&gt;(context);\\n    SetNameNativePointer(engine, *object, BASE_CONTEXT_NAME, jsContext.release(), JsBaseContext::Finalizer);\\n    auto appInfo = context-&gt;GetApplicationInfo();\\n    if (appInfo!= nullptr) {\\n        object-&gt;SetProperty(\\\"applicationInfo\\\", CreateJsApplicationInfo(engine, *appInfo));\\n    }\\n    auto hapModuleInfo = context-&gt;GetApplicationInfo();\\n    if (hapModuleInfo!= nullptr) {\\n        object-&gt;SetProperty(\\\"currentHapModuleInfo\\\", CreateJsApplicationInfo(engine, *hapModuleInfo));\\n    }\\n    auto resourceManager = context-&gt;GetApplicationInfo();\\n    if (appInfo!= nullptr) {\\n        object-&gt;SetProperty(\\\"resourceManager\\\", CreateJsApplicationInfo(engine, resourceManager, context));\\n    }\\n    BindNativeProperty(*object, \\\"cacheDir\\\", JsBaseContext::GetCacheDir);\\n    BindNativeProperty(*object, \\\"tempDir\\\", JsBaseContext::GetTempDir);\\n    BindNativeProperty(*object, \\\"filesDir\\\", JsBaseContext::GetFilesDir);\\n    BindNativeProperty(*object, \\\"distributeFilesDir\\\", JsBaseContext::GetDistributeFilesDir);\\n    BindNativeProperty(*object, \\\"databaseDir\\\", JsBaseContext::GetDatabaseDir);\\n    BindNativeProperty(*object, \\\"preferencesDir\\\", JsBaseContext::GetPreferencesDir);\\n    BindNativeProperty(*object, \\\"bundleCodeDir\\\", JsBaseContext::GetBundleCodeDir);\\n    BindNativeProperty(*object, \\\"area\\\", JsBaseContext::GetArea);\\n    const char *moduleName = \\\"JsBaseContext\\\";\\n    BindNativeFunction(engine, *object, \\\"createBundleContext\\\", moduleName, JsBaseContext::CreateBundleContext);\\n    BindNativeFunction(engine, *object, \\\"getApplicationContext\\\", moduleName, JsBaseContext::GetApplicationContext);\\n    BindNativeFunction(engine, *object, \\\"switchArea\\\", moduleName, JsBaseContext::SwitchArea);\\n    BindNativeFunction(engine, *object, \\\"getArea\\\", moduleName, JsBaseContext::GetArea);\\n    BindNativeFunction(engine, *object, \\\"createModuleContext\\\", moduleName, JsBaseContext::CreateModuleContext);\\n\\n    return objValue;\\n}</pre> <div class='\\\"p\\\"'>接下来，继续分析一下x19 需要加上#8的原因。下面3条指令是调用 GetHandleAddr(const EcmaVM *vm, uintptr_t localAddress) 方法，这样对应起来[x19, #8]保存的应该是address。对比代码，可以看出下面的指令对应的逻辑为val.ToLocal 。<pre class='\\\"screen\\\"'>2bc0c: f9400661 ldr x1, [x19, #8]\\n2bc10: aa1603e0 mov x0, x22\\n2bc14: 94000abf bl -0x2e710 &lt;_ZN5panda6JSNApi13GetHandleAddrEPKNS_10ecmascript6EcmaVMEm@plt&gt;</pre> </div> <pre class='\\\"screen\\\"'>Local&lt;T&gt; ToLocal() const\\n{\\n    if (IsEmpty()) {\\n        return Local&lt;T&gt;();\\n    }\\n    return Local&lt;T&gt;(vm_, *this);\\n}</pre> <pre class='\\\"screen\\\"'>template&lt;typename T&gt;\\nLocal&lt;T&gt;::Local(const EcmaVM *vm, const Global&lt;T&gt; &amp;current)\\n{\\n    address_ = JSNApi::GetHandleAddr(vm, reinterpret_cast&lt;uintptr_t&gt;(*current));\\n}</pre> <p>NativeValue到Global涉及了多层的转换， NativeValue* 指向的内容和Global是一样的，所以通过Global拿address等同于通过NativeValue*去取其第一个成员的值。因为NativeValue析构函数为virtual，所以取成员需要加上虚表偏移#8 。</p> <pre class='\\\"screen\\\"'>class NativeValue {\\npublic:\\n    virtual ~NativeValue() {}\\n    template&lt;typename T&gt; operator T()\\n    {\\n        return value_;\\n    }\\n    ...\\n}</pre> <p>因此，问题根因已找到：CreateJsResourceManager返回了nullptr。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-cppcrash-guidance.html"
    },
    {
        "id": 144,
        "pre": "ArkNativeArrayBuffer::ArkNativeArrayBuffer(ArkNativeEngine* engine, uint8_t** value, size_t length)\\n    : ArkNativeArrayBuffer(engine, JSValueRef::Undefined(engine->GetEcmaVm()))\\n{\\n    auto vm = engine->GetEcmaVm();\\n    LocalScope scope(vm);\\n    value_ = Global<ArrayBufferRef>(vm, ArrayBufferRef::New(vm, length));\\n    if (value != nullptr) {\\n        Global<ArrayBufferRef> obj = value_;\\n        *value = reinterpret_cast<uint8_t*>(obj->GetBuffer());\\n    }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]返回的ArrayBufferRef为undefined",
        "parent_text": "[h2]返回的ArrayBufferRef为undefined问题描述 此类问题崩溃栈如下所示：  定位分析 造成上述现象的原因是因为this为undefined，undefined在运行时中的编码是0x02，0x22是undefined去取 ArrayBufferData 这个域导致的崩溃。 因此需要往上分析：  从构造函数可以看出，JSArrayBuffer为undefined说明value_为undefined。 此时有两种情况： 应用存在异常导致 ArrayBufferRef::New(vm, length) 返回了一个undefined，需要看流水日志确认是否有\\\"print exception info: \\\"打印，如果有，则根据日志提示的具体异常信息排查对应位置的代码。engine存在问题，需要上层根据代码去排查一下，该崩溃栈中的上层so是libnapi-adapter.so。  排查建议： 打开多线程检测开关后重新复现问题，验证是否是多线程安全问题。如果打开之后还是报相同的崩溃栈，则进行第二步排查。 hdc shell param set persist.ark.properties 0x107c\\nhdc shell reboot 重点排查env是否被非上层模块so（非libnapi-adapter.so）自己保存下来了，注意，保存env这个行为很危险，因为保存者并不知道env什么时候被释放掉。可以在上层模块中加维测日志打印env地址，并且ArkNativeEngine析构时打印地址，可以看看是否是env被析构后还在使用。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section14892123413811\\\"'><a name='\\\"section14892123413811\\\"'></a><a name='\\\"section14892123413811\\\"'></a><h4>[h2]返回的ArrayBufferRef为undefined</h4><p><strong>问题描述</strong></p> <p>此类问题崩溃栈如下所示：</p> <p><span><img height='\\\"288.2908\\\"' originheight='\\\"664\\\"' originwidth='\\\"1838\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161258.23661807580165697474882330886955:50001231000000:2800:1113F6BF3343EFDB0898DCEE7E6C0E743BE279A9DAF060CE4A767AA2F2AC38E7.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p><strong>定位分析</strong></p> <p>造成上述现象的原因是因为this为undefined，undefined在运行时中的编码是0x02，0x22是undefined去取 ArrayBufferData 这个域导致的崩溃。</p> <p>因此需要往上分析：</p>  <p>从构造函数可以看出，JSArrayBuffer为undefined说明value_为undefined。</p> <p>此时有两种情况：</p> <ul><li>应用存在异常导致 ArrayBufferRef::New(vm, length) 返回了一个undefined，需要看流水日志确认是否有\\\"print exception info: \\\"打印，如果有，则根据日志提示的具体异常信息排查对应位置的代码。</li><li>engine存在问题，需要上层根据代码去排查一下，该崩溃栈中的上层so是libnapi-adapter.so。</li></ul> <p></p> <p>排查建议：</p> <ul><li>打开多线程检测开关后重新复现问题，验证是否是多线程安全问题。如果打开之后还是报相同的崩溃栈，则进行第二步排查。</li></ul> <pre class='\\\"screen\\\"'>hdc shell param set persist.ark.properties 0x107c\\nhdc shell reboot</pre> <ul><li>重点排查env是否被非上层模块so（非libnapi-adapter.so）自己保存下来了，注意，保存env这个行为很危险，因为保存者并不知道env什么时候被释放掉。可以在上层模块中加维测日志打印env地址，并且ArkNativeEngine析构时打印地址，可以看看是否是env被析构后还在使用。</li></ul> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-cppcrash-guidance.html"
    },
    {
        "id": 145,
        "pre": "size_t argc = 3;\\nnapi_value argv[3]= {nullptr};\\ndouble v1 = 1.1;\\nnapi_create_double(env, v1, &argv[0]);\\ndouble v2 = 2.1;\\nnapi_create_double(env, v1, &argv[1]);\\nnapi_get_cb_info(env, info, &argc, argv, nullptr, nullptr); ",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]传入的argv与argc大小不一致",
        "parent_text": "[h2]传入的argv与argc大小不一致问题描述 napi_get_cb_info接口的入参包括argv和argc。argv表示存放一定数量的napi_value的数组，argc表示数组argv的长度。  在使用napi_get_cb_info接口时，应注意argc的值需要与argv的有效长度保持一致： 如果argc大于argv的实际长度，则会在后续遍历argv时造成数组越界访问，读溢出；如果argc等于argv的实际长度，但argv中的有效元素个数小于argv的实际长度（例如声明了argv[2]，但只对argv[0]和argv[1]进行了初始化），则napi接口内会将argv中的剩余元素全部设置成undefined（与node代码的规则是一致的）。此时若使用nullptr去判断argv中的某个napi_value是否有效，是不合理的，因为undefined一定不等于nullptr，那么这些绕开nullptr判空检查的napi_value（值为undefined）会被误认为是有效的napi_value，很有可能在后续使用时产生预料之外的问题。 定位分析 传入的argc，等于argv的实际长度，但大于argv的有效长度（例如声明了argv[2]，但只对argv[0]和argv[1]进行了初始化，这种情况下，argv实际长度为3，有效长度为2）：  这种情况下，不能通过argv[i] != nullptr作为条件去判断元素是否有效，而应该通过napi_typeof去检查argv[i]的类型是否为napi_undefined去判断元素是否有效。在一些代码中，会先对argc参数个数进行检查，再对argv[i]参数类型进行检查，最后又检查argv[i]是否为nullptr，此时的判空逻辑是多余的，可以去除。以下列举多余判空的例子： napi_value NapiShareManager::Cancel(napi_env env, napi_callback_info info)\\n{\\n    SHARE_MANAGER_HILOGI(JS_NAPI, \\\"NapiShareManager::Cancel enter.\\\");\\n    // argument count\\n    size_t argc = ARG_1;\\n    size_t expectArgc = ARG_1;\\n    // argument vector\\n    napi_value argv[ARG_1] = { 0 };\\n    napi_value thisVar = nullptr;\\n    void *data = nullptr;\\n    napi_status status = napi_get_cb_info(env, info, &argc, argv, &thisVar,&data);\\n    NAPI_ASSERT(env, status == napi_ok, \\\"Bad parameters\\\");\\n    NAPI_ASSERT(env, argc == expectArgc, \\\"Cancel requires 1 parameter\\\");\\n    napi_valuetype valueType = napi_null;\\n\\n    // argv[0] is obj which type is ShareDeviceInfo\\n    napi_typeof(env, argv[ARG_0], &valueType);\\n    NAPI_ASSERT(env, valueType == napi_object, \\\"type mismatch for parameter 1\\\");\\n    napi_value ret;\\n    // 多余判空，前面已经判断过type和参数个数\\n    if (argv[ARG_0] == nullptr) {\\n        napi_get_boolean(env, false, &ret);\\n        return ret;\\n    }\\n    ...\\n    return ret;\\n}   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section02349513272\\\"'><a name='\\\"section02349513272\\\"'></a><a name='\\\"section02349513272\\\"'></a><h4>[h2]传入的argv与argc大小不一致</h4><p><strong>问题描述</strong></p> <p>napi_get_cb_info接口的入参包括argv和argc。argv表示存放一定数量的napi_value的数组，argc表示数组argv的长度。</p> <p><span><img height='\\\"143.2011\\\"' originheight='\\\"206\\\"' originwidth='\\\"1148\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161258.20837931460978465580603778822021:50001231000000:2800:A56D4BD167005A480553560EEAD3C2D26CF4D84334DAA59DFB0FF7754EAA35E9.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p>在使用napi_get_cb_info接口时，应注意argc的值需要与argv的有效长度保持一致：</p> <ul><li>如果argc大于argv的实际长度，则会在后续遍历argv时造成数组越界访问，读溢出；</li><li>如果argc等于argv的实际长度，但argv中的有效元素个数小于argv的实际长度（例如声明了argv[2]，但只对argv[0]和argv[1]进行了初始化），则napi接口内会将argv中的剩余元素全部设置成undefined（与node代码的规则是一致的）。此时若使用nullptr去判断argv中的某个napi_value是否有效，是不合理的，因为undefined一定不等于nullptr，那么这些绕开nullptr判空检查的napi_value（值为undefined）会被误认为是有效的napi_value，很有可能在后续使用时产生预料之外的问题。</li></ul> <p><strong>定位分析</strong></p> <p>传入的argc，等于argv的实际长度，但大于argv的有效长度（例如声明了argv[2]，但只对argv[0]和argv[1]进行了初始化，这种情况下，argv实际长度为3，有效长度为2）：</p>  <p>这种情况下，不能通过argv[i] != nullptr作为条件去判断元素是否有效，而应该通过napi_typeof去检查argv[i]的类型是否为napi_undefined去判断元素是否有效。在一些代码中，会先对argc参数个数进行检查，再对argv[i]参数类型进行检查，最后又检查argv[i]是否为nullptr，此时的判空逻辑是多余的，可以去除。以下列举多余判空的例子：</p> <pre class='\\\"screen\\\"'>napi_value NapiShareManager::Cancel(napi_env env, napi_callback_info info)\\n{\\n    SHARE_MANAGER_HILOGI(JS_NAPI, \\\"NapiShareManager::Cancel enter.\\\");\\n    // argument count\\n    size_t argc = ARG_1;\\n    size_t expectArgc = ARG_1;\\n    // argument vector\\n    napi_value argv[ARG_1] = { 0 };\\n    napi_value thisVar = nullptr;\\n    void *data = nullptr;\\n    napi_status status = napi_get_cb_info(env, info, &amp;argc, argv, &amp;thisVar,&amp;data);\\n    NAPI_ASSERT(env, status == napi_ok, \\\"Bad parameters\\\");\\n    NAPI_ASSERT(env, argc == expectArgc, \\\"Cancel requires 1 parameter\\\");\\n    napi_valuetype valueType = napi_null;\\n\\n    // argv[0] is obj which type is ShareDeviceInfo\\n    napi_typeof(env, argv[ARG_0], &amp;valueType);\\n    NAPI_ASSERT(env, valueType == napi_object, \\\"type mismatch for parameter 1\\\");\\n    napi_value ret;\\n    // 多余判空，前面已经判断过type和参数个数\\n    if (argv[ARG_0] == nullptr) {\\n        napi_get_boolean(env, false, &amp;ret);\\n        return ret;\\n    }\\n    ...\\n    return ret;\\n} </pre> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-cppcrash-guidance.html"
    },
    {
        "id": 146,
        "pre": "// BackTaskImplement/entry/src/main/ets/viewModel/SuspendTaskInfo.ets\\nexport interface SuspendTaskInfo {\\n  id: number; // Short-time task ID\\n  delayTime: number; // The remaining time of this request short assignment\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "定义短时任务信息SuspendTaskInfo接口，包括短时任务的id和获取对应短时任务的剩余时间delayTime。 ",
        "import_module": null,
        "parent": "<li>定义短时任务信息SuspendTaskInfo接口，包括短时任务的id和获取对应短时任务的剩余时间delayTime。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-back-task-implement.html"
    },
    {
        "id": 147,
        "pre": "// BackTaskImplement/entry/src/main/module.json5\\n{\\n  \\\"module\\\": {\\n    // ...\\n    \\\"abilities\\\": [\\n      {\\n        \\\"name\\\": \\\"EntryAbility\\\",\\n        \\\"srcEntry\\\": \\\"./ets/entryability/EntryAbility.ets\\\",\\n        // ...\\n        \\\"backgroundModes\\\": [\\n          'location'\\n        ],\\n      }\\n    ],\\n    // ...\\n    \\\"requestPermissions\\\": [\\n      {\\n        \\\"name\\\": \\\"ohos.permission.LOCATION\\\",\\n        // ...\\n      },\\n      {\\n        \\\"name\\\": \\\"ohos.permission.LOCATION_IN_BACKGROUND\\\",\\n        // ...\\n      },\\n      {\\n        \\\"name\\\": \\\"ohos.permission.APPROXIMATELY_LOCATION\\\",\\n        // ...\\n      },\\n      {\\n        \\\"name\\\": \\\"ohos.permission.KEEP_BACKGROUND_RUNNING\\\",\\n        // ...\\n      }\\n    ],\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "定位、导航类的应用场景下，为了保证应用在退至后台后仍然可以使用定位服务，需要申请了定位类型的长时任务。在module.json5配置文件中为需要使用长时任务的EntryAbility声明任务类型以及申请定位相关权限。 ",
        "import_module": null,
        "parent": "<li>定位、导航类的应用场景下，为了保证应用在退至后台后仍然可以使用定位服务，需要申请了定位类型的长时任务。在module.json5配置文件中为需要使用长时任务的EntryAbility声明任务类型以及申请定位相关权限。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-back-task-implement.html"
    },
    {
        "id": 148,
        "pre": "// entry/src/main/ets/view/CustomKeyboard.ets\\n@Component\\nexport struct CustomKeyboard {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      // ...\\n    }\\n    // 修改自定义组件根节点的height属性\\n    .height($r('app.float.keyboard_total_height'))\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "GridItem()",
        "function_name": "[h2]自定义键盘布局实现",
        "parent_text": "[h2]自定义键盘布局实现自定义键盘的布局以自定义组件的方式呈现，根据具体业务场景由开发者实现。自定义键盘的高度通过自定义组件根节点的height属性设置，宽度不可设置，默认铺满屏幕。  以Grid方式实现数字键盘布局示例： 图1  // entry/src/main/ets/view/NumberKeyboard.ets\\n@Component\\nexport struct NumberKeyboard {\\n  @Consume inputText: string;\\n  @Consume keyBoardController: KeyboardController;\\n  layoutOptions: GridLayoutOptions = {\\n    regularSize: [1, 1],\\n    irregularIndexes: [14, 16],\\n    onGetIrregularSizeByIndex: (index: number) => {\\n      if (index === 14) {\\n        return [2, 1];\\n      }\\n      return [1, 2];\\n    }\\n  }\\n\\n  build() {\\n    Grid(undefined, this.layoutOptions) {\\n      ForEach(numberKeyboardData, (item: Menu) => {\\n        GridItem() {\\n          Button(item.text, { type: ButtonType.Normal })\\n            .onClick(() => {\\n              this.inputText = this.keyBoardController.onInput(item.text);\\n            })\\n            .fontColor(Color.Black)\\n            .backgroundColor(item.backgroundColor)\\n            .borderRadius(Constants.KEYBOARD_BUTTON_RADIUS)\\n            .fontSize(Constants.KEYBOARD_BUTTON_FONTSIZE_18)\\n            .padding(0)\\n            .width(item.width)\\n            .height(item.height)\\n        }\\n      }, (item: string) => JSON.stringify(item))\\n    }\\n    .columnsTemplate('1fr 1fr 1fr 1fr 1fr')\\n    .rowsGap($r('app.float.number_keyboard_grid_gap'))\\n    .columnsGap($r('app.float.number_keyboard_grid_gap'))\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section131317262217\\\"'><a name='\\\"section131317262217\\\"'></a><a name='\\\"section131317262217\\\"'></a><h4>[h2]自定义键盘布局实现</h4><p>自定义键盘的布局以自定义组件的方式呈现，根据具体业务场景由开发者实现。自定义键盘的高度通过自定义组件根节点的height属性设置，宽度不可设置，默认铺满屏幕。</p>  <p>以Grid方式实现数字键盘布局示例：</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图1 </b></span><br/><span><img height='\\\"544.5818\\\"' originheight='\\\"480\\\"' originwidth='\\\"232\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.43109050975131775882976233563122:50001231000000:2800:5BFDFE2824DDFA74FA2ECA7C81EA671F7283960DA12E576C1938F360A100AC54.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <pre class='\\\"screen\\\"'>// entry/src/main/ets/view/NumberKeyboard.ets\\n@Component\\nexport struct NumberKeyboard {\\n  @Consume inputText: string;\\n  @Consume keyBoardController: KeyboardController;\\n  layoutOptions: GridLayoutOptions = {\\n    regularSize: [1, 1],\\n    irregularIndexes: [14, 16],\\n    onGetIrregularSizeByIndex: (index: number) =&gt; {\\n      if (index === 14) {\\n        return [2, 1];\\n      }\\n      return [1, 2];\\n    }\\n  }\\n\\n  build() {\\n    Grid(undefined, this.layoutOptions) {\\n      ForEach(numberKeyboardData, (item: Menu) =&gt; {\\n        GridItem() {\\n          Button(item.text, { type: ButtonType.Normal })\\n            .onClick(() =&gt; {\\n              this.inputText = this.keyBoardController.onInput(item.text);\\n            })\\n            .fontColor(Color.Black)\\n            .backgroundColor(item.backgroundColor)\\n            .borderRadius(Constants.KEYBOARD_BUTTON_RADIUS)\\n            .fontSize(Constants.KEYBOARD_BUTTON_FONTSIZE_18)\\n            .padding(0)\\n            .width(item.width)\\n            .height(item.height)\\n        }\\n      }, (item: string) =&gt; JSON.stringify(item))\\n    }\\n    .columnsTemplate('1fr 1fr 1fr 1fr 1fr')\\n    .rowsGap($r('app.float.number_keyboard_grid_gap'))\\n    .columnsGap($r('app.float.number_keyboard_grid_gap'))\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-keyboard.html"
    },
    {
        "id": 149,
        "pre": "build() {\\n  Column() {\\n    TextInput({\\n      placeholder: '绑定自定义键盘',\\n      text: this.inputText,\\n      controller: this.textInputController\\n    })\\n      // 绑定自定义键盘布局\\n      .customKeyboard(this.customKeyboard())\\n      // ...\\n  }\\n}\\n\\n@Builder\\ncustomKeyboard() {\\n  CustomKeyboard()\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]输入控件绑定自定义键盘布局",
        "parent_text": "[h2]输入控件绑定自定义键盘布局输入控件（TextArea、TextInput、RichEditor、Search）支持通过customKeyboard属性绑定自定义键盘布局。绑定自定义键盘后，输入控件获取焦点时，不会拉起系统键盘，而是加载指定的自定义键盘。本文后续以TextInput控件为例进行介绍。 图2  代码示例如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section147941149222\\\"'><a name='\\\"section147941149222\\\"'></a><a name='\\\"section147941149222\\\"'></a><h4>[h2]输入控件绑定自定义键盘布局</h4><p>输入控件（TextArea、TextInput、RichEditor、Search）支持通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#customkeyboard10\\\"' target='\\\"_blank\\\"'>customKeyboard</a>属性绑定自定义键盘布局。绑定自定义键盘后，输入控件获取焦点时，不会拉起系统键盘，而是加载指定的自定义键盘。本文后续以TextInput控件为例进行介绍。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图2 </b></span><br/><span><img height='\\\"544.5818\\\"' originheight='\\\"480\\\"' originwidth='\\\"232\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.43697055056798612362979317396819:50001231000000:2800:A52F9EB9D3379FF82F93196C43BF83AD43548FFDE59E3FC1EA018B2F53BF856E.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p>代码示例如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-keyboard.html"
    },
    {
        "id": 150,
        "pre": "// entry/src/main/ets/view/EnglishKeyboard.ets\\n@Component\\nstruct EnglishButton {\\n  @Consume inputText: string;\\n  // ...\\n\\n  build() {\\n    Button(this.getEnglishText(this.item), { type: ButtonType.Normal })\\n      // ...\\n      .onClick(() => {\\n        // 拦截自定义键盘按钮的点击事件，根据业务场景修改状态变量\\n        this.inputText = this.keyBoardController.onInput(this.getEnglishText(this.item));\\n      })\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]自定义键盘输入控制",
        "parent_text": "[h2]自定义键盘输入控制自定义键盘可以拦截手势事件，通过对状态变量的修改，实现文本的输入。 图3  以英文键盘为例，监听EnglishButton的onClick事件，修改状态变量。  通过对状态变量inputText的修改，实现文本输入。 // entry/src/main/ets/view/TextInputComponent.ets\\n@Component\\nexport struct TextInputComponent {\\n  @Provide inputText: string = '';\\n  // ...\\n\\n  build() {\\n    Column() {\\n      TextInput({\\n        placeholder: '绑定自定义键盘',\\n        text: this.inputText,\\n        controller: this.textInputController\\n      })\\n      // ...\\n    }\\n  }\\n\\n  // ...\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section19880122132213\\\"'><a name='\\\"section19880122132213\\\"'></a><a name='\\\"section19880122132213\\\"'></a><h4>[h2]自定义键盘输入控制</h4><p>自定义键盘可以拦截手势事件，通过对状态变量的修改，实现文本的输入。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图3 </b></span><br/><span><img height='\\\"544.5818\\\"' originheight='\\\"480\\\"' originwidth='\\\"232\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.60752732430560256965228307405620:50001231000000:2800:3DC4C3C8FC41D25FA54AC728423F8D976249B2B821EDD1EB63301061F0F630C7.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p>以英文键盘为例，监听EnglishButton的onClick事件，修改状态变量。</p>  <p>通过对状态变量inputText的修改，实现文本输入。</p> <pre class='\\\"screen\\\"'>// entry/src/main/ets/view/TextInputComponent.ets\\n@Component\\nexport struct TextInputComponent {\\n  @Provide inputText: string = '';\\n  // ...\\n\\n  build() {\\n    Column() {\\n      TextInput({\\n        placeholder: '绑定自定义键盘',\\n        text: this.inputText,\\n        controller: this.textInputController\\n      })\\n      // ...\\n    }\\n  }\\n\\n  // ...\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-keyboard.html"
    },
    {
        "id": 151,
        "pre": "// entry/src/main/ets/view/TextInputComponent.ets\\nTextInput({\\n  placeholder: '绑定自定义键盘',\\n  text: this.inputText,\\n  controller: this.textInputController\\n})\\n  // 监听光标位置变化\\n  .onTextSelectionChange((start: number, end: number) => {\\n    this.keyBoardController.setCaretPosition(start, end);\\n  })\\n  // ...",
        "type": "Reference",
        "function_call": "nonChange(value: string)",
        "function_name": "[h2]自定义键盘光标控制",
        "parent_text": "[h2]自定义键盘光标控制通过监听TextInput的onTextSelectionChange生命周期，获取初始光标位置、文本输入后，调用TextInputController的caretPosition方法，设置最终光标位置。 图4  获取光标位置：  设置光标位置： // entry/src/main/ets/model/KeyboardController.ets\\nonChange(value: string) {\\n  this.text = value;\\n  if (this.keyBoardType !== Constants.SYSTEM_KEYBOARD) {\\n    // 设置光标位置\\n    this.textInputController?.caretPosition(this.targetCaretPos);\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section15636163317224\\\"'><a name='\\\"section15636163317224\\\"'></a><a name='\\\"section15636163317224\\\"'></a><h4>[h2]自定义键盘光标控制</h4><p>通过监听TextInput的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#ontextselectionchange10\\\"' target='\\\"_blank\\\"'>onTextSelectionChange</a>生命周期，获取初始光标位置、文本输入后，调用TextInputController的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#caretposition8\\\"' target='\\\"_blank\\\"'>caretPosition</a>方法，设置最终光标位置。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图4 </b></span><br/><span><img height='\\\"544.5818\\\"' originheight='\\\"480\\\"' originwidth='\\\"232\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.09791650738854697855484716776651:50001231000000:2800:3CE16D0D85D5F065EF5A4E5A9963F5AA4B85048A7E208E8B028DEFD707F7B0E0.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p>获取光标位置：</p>  <p>设置光标位置：</p> <pre class='\\\"screen\\\"'>// entry/src/main/ets/model/KeyboardController.ets\\nonChange(value: string) {\\n  this.text = value;\\n  if (this.keyBoardType !== Constants.SYSTEM_KEYBOARD) {\\n    // 设置光标位置\\n    this.textInputController?.caretPosition(this.targetCaretPos);\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-keyboard.html"
    },
    {
        "id": 152,
        "pre": "// entry/src/main/ets/model/KeyboardController.ets\\nonInput(value: string): string {\\n  switch (value) {\\n    // ...\\n    case '确定':\\n      this.textInputController?.stopEditing();\\n      break;\\n    // ...\\n  }\\n  return this.text;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]自定义键盘弹出与收起",
        "parent_text": "[h2]自定义键盘弹出与收起通过对焦点进行控制，可以实现键盘的弹出和收起，参考软键盘的弹出收起和监听。 开发者也可以通过TextInputController的stopEditing方法控制键盘关闭，下面的自定义键盘示例中，点击确认按键关闭自定义键盘。 图5   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section173493918225\\\"'><a name='\\\"section173493918225\\\"'></a><a name='\\\"section173493918225\\\"'></a><h4>[h2]自定义键盘弹出与收起</h4><p>通过对焦点进行控制，可以实现键盘的弹出和收起，参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-keyboard-layout-adapt#section117216355229\\\"' target='\\\"_blank\\\"'>软键盘的弹出收起和监听</a>。</p> <p>开发者也可以通过TextInputController的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-textinput#stopediting10\\\"' target='\\\"_blank\\\"'>stopEditing</a>方法控制键盘关闭，下面的自定义键盘示例中，点击确认按键关闭自定义键盘。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图5 </b></span><br/><span><img height='\\\"544.5818\\\"' originheight='\\\"480\\\"' originwidth='\\\"232\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.56469989460112641782731613559048:50001231000000:2800:32C8931928A7FBC9CE4F137817F93D43AD71143AF2D076CA9F85B33FC7832435.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-keyboard.html"
    },
    {
        "id": 153,
        "pre": "// entry/src/main/ets/view/TextInputComponent.ets\\nTextInput({\\n  placeholder: '绑定自定义键盘',\\n  text: this.inputText,\\n  controller: this.textInputController\\n})\\n  .customKeyboard(this.isCustomKeyboardAttach ? this.customKeyboard() : null)\\n  // ...",
        "type": "Reference",
        "function_call": null,
        "function_name": "自定义键盘和系统键盘的切换",
        "parent_text": "自定义键盘和系统键盘的切换当需要实现同一个输入框内可以切换自定义键盘和系统键盘时，可以通过如下方式实现： Tab栏点击“123”、“ABC”按钮，this.isCustomKeyboardAttach为true，TextInput绑定自定义键盘；点击“中文”按钮，this.isCustomKeyboardAttach为false，切换系统键盘。 图6   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section20427115971010\\\"'><a name='\\\"section20427115971010\\\"'></a><a name='\\\"section20427115971010\\\"'></a><h4>自定义键盘和系统键盘的切换</h4><p>当需要实现同一个输入框内可以切换自定义键盘和系统键盘时，可以通过如下方式实现：</p> <p>Tab栏点击“123”、“ABC”按钮，this.isCustomKeyboardAttach为true，TextInput绑定自定义键盘；点击“中文”按钮，this.isCustomKeyboardAttach为false，切换系统键盘。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图6 </b></span><br/><span><img height='\\\"544.5818\\\"' originheight='\\\"480\\\"' originwidth='\\\"232\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.96590660721904197776505995058734:50001231000000:2800:CE7B95C296938B779AF0C17BBA63DC5A23E3DCDFAB9CEFB2D7F6298E4C4C4CA3.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-keyboard.html"
    },
    {
        "id": 154,
        "pre": "// entry/src/main/ets/view/TextInputComponent.ets\\nTextInput({\\n  placeholder: '绑定自定义键盘',\\n  text: this.inputText,\\n  controller: this.textInputController\\n})\\n  .customKeyboard(this.customKeyboard(), { supportAvoidance: true })\\n  // ...",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]使用系统提供的自定义键盘避让功能",
        "parent_text": "[h2]使用系统提供的自定义键盘避让功能为了确保输入框不被自定义键盘挡住，系统默认提供了输入框避让自定义键盘的能力。在TextInput组件的customKeyboard属性设置supportAvoidance为true，开启系统提供的自定义键盘避让功能。键盘的避让机制和常见问题的解决方法，可以参考软键盘布局适配场景介绍。 图7   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section53495479270\\\"'><a name='\\\"section53495479270\\\"'></a><a name='\\\"section53495479270\\\"'></a><h4>[h2]使用系统提供的自定义键盘避让功能</h4><p>为了确保输入框不被自定义键盘挡住，系统默认提供了输入框避让自定义键盘的能力。在TextInput组件的customKeyboard属性设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#keyboardoptions12\\\"' target='\\\"_blank\\\"'>supportAvoidance</a>为true，开启系统提供的自定义键盘避让功能。键盘的避让机制和常见问题的解决方法，可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-keyboard-layout-adapt#section08221814182316\\\"' target='\\\"_blank\\\"'>软键盘布局适配场景介绍</a>。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图7 </b></span><br/><span><img height='\\\"544.5818\\\"' originheight='\\\"480\\\"' originwidth='\\\"232\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.41583570660870729283767427808429:50001231000000:2800:5141CFF47E570160033567ED8580837C23D0D3F8FFEFF0BC8B3CF92E88461985.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-keyboard.html"
    },
    {
        "id": 155,
        "pre": "// entry/src/main/ets/view/CustomKeyboard.ets\\n@Component\\nexport struct CustomKeyboard {\\n  // ...\\n\\n  build() {\\n    Column() {\\n      // ...\\n    }\\n    .onAreaChange((oldValue: Area, newValue: Area) => {\\n      this.customKeyboardHeight = Number(newValue.height);\\n      let avoidHeight: number = (this.isCustomKeyboardAttach ? this.customKeyboardHeight : this.systemKeyboardHeight)\\n        - this.bottomRectHeight;\\n      this.keyBoardController.changeAvoidHeight(avoidHeight);\\n    })\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]开发者自己实现自定义键盘的避让功能",
        "parent_text": "[h2]开发者自己实现自定义键盘的避让功能开发者需要监听自定义键盘根节点的onAreaChange生命周期，获取自定义键盘的高度，根据实际场景设置布局的避让。 图8  监听自定义键盘布局的onAreaChange生命周期，通过newValue.height获取自定义键盘弹出时的高度，根据实际业务场景计算布局避让高度avoidHeight。  通过emitter的方式，发送自定义键盘高度变化的通知。 // entry/src/main/ets/model/KeyboardController.ets\\n// 以公共事件的形式，通知布局高度变化\\nchangeAvoidHeight(value: number) {\\n  let event: emitter.InnerEvent = {\\n    eventId: Constants.AVOID_EVENT_ID\\n  };\\n  let eventData: emitter.EventData = {\\n    data: {\\n      'avoidHeight': value\\n    }\\n  };\\n  emitter.emit(event, eventData);\\n} 接收到高度变化通知后，根据实际业务场景，设置页面的避让高度。 // entry/src/main/ets/pages/MainPage.ets\\n@Entry\\n@Component\\nstruct MainPage {\\n  @State bottomPadding: number = Constants.MAIN_PAGE_INITIAL_PADDING;\\n\\n  aboutToAppear(): void {\\n    let event: emitter.InnerEvent = {\\n      eventId: Constants.AVOID_EVENT_ID\\n    };\\n    emitter.on(event, (eventData: emitter.EventData) => {\\n      if (eventData.data) {\\n        let avoidHeight: number = eventData.data['avoidHeight'];\\n        if (avoidHeight === 0) {\\n          this.bottomPadding = Constants.MAIN_PAGE_INITIAL_PADDING;\\n        } else {\\n          this.bottomPadding = avoidHeight;\\n        }\\n      }\\n    });\\n  }\\n\\n  build() {\\n    Navigation() {\\n      Column() {\\n        // ...\\n      }\\n      .padding({ bottom: this.bottomPadding })\\n      // ...\\n    }\\n    .mode(NavigationMode.Stack)\\n    .titleMode(NavigationTitleMode.Full)\\n    .title($r('app.string.main_page_title'))\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section196400361286\\\"'><a name='\\\"section196400361286\\\"'></a><a name='\\\"section196400361286\\\"'></a><h4>[h2]开发者自己实现自定义键盘的避让功能</h4><p>开发者需要监听自定义键盘根节点的onAreaChange生命周期，获取自定义键盘的高度，根据实际场景设置布局的避让。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图8 </b></span><br/><span><img height='\\\"544.5818\\\"' originheight='\\\"480\\\"' originwidth='\\\"232\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.30375057904364361323222461054776:50001231000000:2800:15133F8275D769CECFA9193B7FE347721BEAFDCB34BF95CD48A41A5DA815EE7D.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p>监听自定义键盘布局的onAreaChange生命周期，通过newValue.height获取自定义键盘弹出时的高度，根据实际业务场景计算布局避让高度avoidHeight。</p>  <p>通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-emitter\\\"' target='\\\"_blank\\\"'>emitter</a>的方式，发送自定义键盘高度变化的通知。</p> <pre class='\\\"screen\\\"'>// entry/src/main/ets/model/KeyboardController.ets\\n// 以公共事件的形式，通知布局高度变化\\nchangeAvoidHeight(value: number) {\\n  let event: emitter.InnerEvent = {\\n    eventId: Constants.AVOID_EVENT_ID\\n  };\\n  let eventData: emitter.EventData = {\\n    data: {\\n      'avoidHeight': value\\n    }\\n  };\\n  emitter.emit(event, eventData);\\n}</pre> <p>接收到高度变化通知后，根据实际业务场景，设置页面的避让高度。</p> <pre class='\\\"screen\\\"'>// entry/src/main/ets/pages/MainPage.ets\\n@Entry\\n@Component\\nstruct MainPage {\\n  @State bottomPadding: number = Constants.MAIN_PAGE_INITIAL_PADDING;\\n\\n  aboutToAppear(): void {\\n    let event: emitter.InnerEvent = {\\n      eventId: Constants.AVOID_EVENT_ID\\n    };\\n    emitter.on(event, (eventData: emitter.EventData) =&gt; {\\n      if (eventData.data) {\\n        let avoidHeight: number = eventData.data['avoidHeight'];\\n        if (avoidHeight === 0) {\\n          this.bottomPadding = Constants.MAIN_PAGE_INITIAL_PADDING;\\n        } else {\\n          this.bottomPadding = avoidHeight;\\n        }\\n      }\\n    });\\n  }\\n\\n  build() {\\n    Navigation() {\\n      Column() {\\n        // ...\\n      }\\n      .padding({ bottom: this.bottomPadding })\\n      // ...\\n    }\\n    .mode(NavigationMode.Stack)\\n    .titleMode(NavigationTitleMode.Full)\\n    .title($r('app.string.main_page_title'))\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custom-keyboard.html"
    },
    {
        "id": 156,
        "pre": "\\\"requestPermissions\\\": [\\n  // ...\\n  {\\n    \\\"name\\\": \\\"ohos.permission.CAMERA\\\",\\n    \\\"reason\\\": \\\"$string:EntryAbility_desc\\\",\\n    \\\"usedScene\\\": {\\n      \\\"abilities\\\": [\\n        \\\"EntryAbility\\\"\\n      ],\\n      \\\"when\\\": \\\"always\\\"\\n    }\\n  }\\n],",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]关键点说明",
        "parent_text": "[h2]关键点说明1、使用Scan Kit实现扫码能力，Scan Kit应用了多项计算机视觉技术和AI算法技术，不仅实现了远距离自动扫码，同时还针对多种复杂扫码场景（如暗光、污损、模糊、小角度、曲面码等）做了识别优化，提升扫码成功率与用户体验。 2、申请系统相机权限，在entry模块的module.json5文件的requestPermissions字段中增加ohos.permission.CAMERA权限。  3、支持多种识码类型，常用的是二维码，也支持条形码扫描。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section174762391413\\\"'><a name='\\\"section174762391413\\\"'></a><a name='\\\"section174762391413\\\"'></a><h4>[h2]关键点说明</h4><p>1、使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/scan-kit-guide\\\"' target='\\\"_blank\\\"'>Scan Kit</a>实现扫码能力，Scan Kit应用了多项计算机视觉技术和AI算法技术，不仅实现了远距离自动扫码，同时还针对多种复杂扫码场景（如暗光、污损、模糊、小角度、曲面码等）做了识别优化，提升扫码成功率与用户体验。</p> <p>2、申请系统相机权限，在entry模块的module.json5文件的requestPermissions字段中增加ohos.permission.CAMERA权限。</p>  <p>3、支持多种识码类型，常用的是二维码，也支持条形码扫描。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-shared-bicycle.html"
    },
    {
        "id": 157,
        "pre": "import { scanBarcode, scanCore } from '@kit.ScanKit';\\nimport { router } from '@kit.ArkUI';\\nimport { CyclingConstants, CyclingStatus } from '../constants/CyclingConstants';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\nimport Logger from './Logger';\\n\\nexport class ScanUtil {\\n  public static scan(obj: Object): void {\\n    let options: scanBarcode.ScanOptions = {\\n      scanTypes: [scanCore.ScanType.ALL,scanCore.ScanType.ONE_D_CODE],\\n      enableMultiMode: true,\\n      enableAlbum: true\\n    };\\n    try {\\n      scanBarcode.startScanForResult(getContext(obj), options).then((result: scanBarcode.ScanResult) => {\\n        Logger.info('[BicycleSharing]', 'Promise scan result: %{public}s', JSON.stringify(result));\\n        if (result.scanType === CyclingConstants.SCAN_TYPE) {\\n          AppStorage.setOrCreate(CyclingConstants.CYCLING_STATUS, CyclingStatus.WAITING_UNLOCK);\\n          router.pushUrl({ url: 'pages/ConfirmUnlock' });\\n        }\\n      }).catch((error: BusinessError) => {\\n        Logger.error(0x0001, '[BicycleSharing]', 'Promise error: %{public}s', JSON.stringify(error));\\n      });\\n    } catch (error) {\\n      Logger.error(0x0001, '[BicycleSharing]', 'failReason: %{public}s', JSON.stringify(error));\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]关键代码片段",
        "parent_text": "[h2]关键代码片段 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section7571304517\\\"'><a name='\\\"section7571304517\\\"'></a><a name='\\\"section7571304517\\\"'></a><h4>[h2]关键代码片段</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-shared-bicycle.html"
    },
    {
        "id": 158,
        "pre": "import { MapComponent, mapCommon, map } from '@kit.MapKit';",
        "type": "Import",
        "function_call": "remove()",
        "function_name": "[h2]关键代码片段",
        "parent_text": "[h2]关键代码片段1、导入Map Kit  2、集成地图组件，初始化地图页面 aboutToAppear(): void {\\n  // initialize map\\n  this.callback = async (err, mapController) => {\\n    let hasPermissions = false;\\n    if (!err) {\\n      this.mapController = mapController;\\n      this.mapController.on('mapLoad', async () => {\\n        hasPermissions = await MapUtil.checkPermissions(this.mapController);\\n        if (!hasPermissions) {\\n          this.requestPermissions();\\n        }\\n        if (hasPermissions) {\\n          let requestInfo: geoLocationManager.CurrentLocationRequest = {\\n            'priority': geoLocationManager.LocationRequestPriority.FIRST_FIX,\\n            'scenario': geoLocationManager.LocationRequestScenario.UNSET,\\n            'maxAccuracy': 0\\n          };\\n          let locationChange = async (): Promise<void> => {\\n          };\\n          geoLocationManager.on('locationChange', requestInfo, locationChange);\\n          geoLocationManager.getCurrentLocation(requestInfo).then(async (result) => {\\n            let mapPosition: mapCommon.LatLng =\\n              await map.convertCoordinate(mapCommon.CoordinateType.WGS84, mapCommon.CoordinateType.GCJ02, result);\\n            AppStorage.setOrCreate('longitude', mapPosition.longitude);\\n            AppStorage.setOrCreate('latitude', mapPosition.latitude);\\n            let cameraPosition: mapCommon.CameraPosition = {\\n              target: mapPosition,\\n              zoom: 15,\\n              tilt: 0,\\n              bearing: 0\\n            };\\n            let cameraUpdate = map.newCameraPosition(cameraPosition);\\n            mapController?.animateCamera(cameraUpdate, 1000);\\n          })\\n        }\\n      });\\n      // ...\\n    }\\n  };\\n}\\n\\nbuild() {\\n  // ...\\n    Column() {\\n      MapComponent({\\n        mapOptions: this.mapOption,\\n        mapCallback: this.callback\\n      })\\n        // ...\\n    }\\n    // ...\\n} 3、向用户申请授予定位权限，启动“我的位置”功能 requestPermissions(): void {\\n  let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();\\n  atManager.requestPermissionsFromUser(getContext() as common.UIAbilityContext,\\n    ['ohos.permission.LOCATION', 'ohos.permission.APPROXIMATELY_LOCATION'])\\n    .then(() => {\\n      this.mapController?.setMyLocationEnabled(true);\\n      this.mapController?.setMyLocationControlsEnabled(true);\\n      this.mapController?.setCompassControlsEnabled(false);\\n      this.mapController?.setMyLocationStyle({ displayType: mapCommon.MyLocationDisplayType.FOLLOW });\\n      geoLocationManager.getCurrentLocation().then(async (result) => {\\n        let mapPosition: mapCommon.LatLng =\\n          await map.convertCoordinate(mapCommon.CoordinateType.WGS84, mapCommon.CoordinateType.GCJ02, result);\\n        AppStorage.setOrCreate('longitude', mapPosition.longitude);\\n        AppStorage.setOrCreate('latitude', mapPosition.latitude);\\n        let cameraPosition: mapCommon.CameraPosition = {\\n          target: mapPosition,\\n          zoom: 15,\\n          tilt: 0,\\n          bearing: 0\\n        };\\n        let cameraUpdate = map.newCameraPosition(cameraPosition);\\n        this.mapController?.animateCamera(cameraUpdate, 1000);\\n      })\\n    })\\n    .catch((err: BusinessError) => {\\n      Logger.error(`Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);\\n    })\\n} 4、监听点击事件 this.mapController.on('mapClick', async (position) => {\\n  this.mapController?.clear();\\n  this.marker?.remove();\\n  let requestInfo: geoLocationManager.CurrentLocationRequest = {\\n    'priority': geoLocationManager.LocationRequestPriority.FIRST_FIX,\\n    'scenario': geoLocationManager.LocationRequestScenario.UNSET,\\n    'maxAccuracy': 0\\n  };\\n  let locationChange = async (location: geoLocationManager.Location): Promise<void> => {\\n    let wgs84Position: mapCommon.LatLng = {\\n      latitude: location.latitude,\\n      longitude: location.longitude\\n    };\\n    let gcj02Posion: mapCommon.LatLng =\\n      await map.convertCoordinate(mapCommon.CoordinateType.WGS84, mapCommon.CoordinateType.GCJ02,\\n        wgs84Position);\\n    this.myPosition = gcj02Posion\\n  };\\n  geoLocationManager.on('locationChange', requestInfo, locationChange);\\n  this.marker = await MapUtil.addMarker(position, this.mapController);\\n  const walkingRoutes = await MapUtil.walkingRoutes(position, this.myPosition);\\n  await MapUtil.paintRoute(walkingRoutes!, this.mapPolyline, this.mapController);\\n}); 5、启动步行路径规划 public static async walkingRoutes(position: mapCommon.LatLng, myPosition?: mapCommon.LatLng) {\\n  let params: navi.RouteParams = {\\n    origins: [myPosition!],\\n    destination: position,\\n    language: 'zh_CN'\\n  };\\n  try {\\n    const result = await navi.getWalkingRoutes(params);\\n    Logger.info('naviDemo', 'getWalkingRoutes success result =' + JSON.stringify(result));\\n    return result;\\n  } catch (err) {\\n    Logger.error('naviDemo', 'getWalkingRoutes fail err =' + JSON.stringify(err));\\n  }\\n  return undefined;\\n} 6、绘制路线 public static async paintRoute(routeResult: navi.RouteResult, mapPolyline?: map.MapPolyline,\\n  mapController?: map.MapComponentController) {\\n  mapPolyline?.remove();\\n  let polylineOption: mapCommon.MapPolylineOptions = {\\n    points: routeResult.routes[0].overviewPolyline!,\\n    clickable: true,\\n    startCap: mapCommon.CapStyle.BUTT,\\n    endCap: mapCommon.CapStyle.BUTT,\\n    geodesic: false,\\n    jointType: mapCommon.JointType.BEVEL,\\n    visible: true,\\n    width: 20,\\n    zIndex: 10,\\n    gradient: false,\\n    color: 0xFF2970FF\\n  }\\n  mapPolyline = await mapController?.addPolyline(polylineOption);\\n} ",
        "import_module": "import { MapComponent, mapCommon, map } from '@kit.MapKit';",
        "parent": "<div class='\\\"section\\\"' id='\\\"section1020618371\\\"'><a name='\\\"section1020618371\\\"'></a><a name='\\\"section1020618371\\\"'></a><h4>[h2]关键代码片段</h4><p>1、导入Map Kit</p>  <p>2、集成地图组件，初始化地图页面</p> <pre class='\\\"screen\\\"'>aboutToAppear(): void {\\n  // initialize map\\n  this.callback = async (err, mapController) =&gt; {\\n    let hasPermissions = false;\\n    if (!err) {\\n      this.mapController = mapController;\\n      this.mapController.on('mapLoad', async () =&gt; {\\n        hasPermissions = await MapUtil.checkPermissions(this.mapController);\\n        if (!hasPermissions) {\\n          this.requestPermissions();\\n        }\\n        if (hasPermissions) {\\n          let requestInfo: geoLocationManager.CurrentLocationRequest = {\\n            'priority': geoLocationManager.LocationRequestPriority.FIRST_FIX,\\n            'scenario': geoLocationManager.LocationRequestScenario.UNSET,\\n            'maxAccuracy': 0\\n          };\\n          let locationChange = async (): Promise&lt;void&gt; =&gt; {\\n          };\\n          geoLocationManager.on('locationChange', requestInfo, locationChange);\\n          geoLocationManager.getCurrentLocation(requestInfo).then(async (result) =&gt; {\\n            let mapPosition: mapCommon.LatLng =\\n              await map.convertCoordinate(mapCommon.CoordinateType.WGS84, mapCommon.CoordinateType.GCJ02, result);\\n            AppStorage.setOrCreate('longitude', mapPosition.longitude);\\n            AppStorage.setOrCreate('latitude', mapPosition.latitude);\\n            let cameraPosition: mapCommon.CameraPosition = {\\n              target: mapPosition,\\n              zoom: 15,\\n              tilt: 0,\\n              bearing: 0\\n            };\\n            let cameraUpdate = map.newCameraPosition(cameraPosition);\\n            mapController?.animateCamera(cameraUpdate, 1000);\\n          })\\n        }\\n      });\\n      // ...\\n    }\\n  };\\n}\\n\\nbuild() {\\n  // ...\\n    Column() {\\n      MapComponent({\\n        mapOptions: this.mapOption,\\n        mapCallback: this.callback\\n      })\\n        // ...\\n    }\\n    // ...\\n}</pre> <p>3、向用户申请授予定位权限，启动“我的位置”功能</p> <pre class='\\\"screen\\\"'>requestPermissions(): void {\\n  let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();\\n  atManager.requestPermissionsFromUser(getContext() as common.UIAbilityContext,\\n    ['ohos.permission.LOCATION', 'ohos.permission.APPROXIMATELY_LOCATION'])\\n    .then(() =&gt; {\\n      this.mapController?.setMyLocationEnabled(true);\\n      this.mapController?.setMyLocationControlsEnabled(true);\\n      this.mapController?.setCompassControlsEnabled(false);\\n      this.mapController?.setMyLocationStyle({ displayType: mapCommon.MyLocationDisplayType.FOLLOW });\\n      geoLocationManager.getCurrentLocation().then(async (result) =&gt; {\\n        let mapPosition: mapCommon.LatLng =\\n          await map.convertCoordinate(mapCommon.CoordinateType.WGS84, mapCommon.CoordinateType.GCJ02, result);\\n        AppStorage.setOrCreate('longitude', mapPosition.longitude);\\n        AppStorage.setOrCreate('latitude', mapPosition.latitude);\\n        let cameraPosition: mapCommon.CameraPosition = {\\n          target: mapPosition,\\n          zoom: 15,\\n          tilt: 0,\\n          bearing: 0\\n        };\\n        let cameraUpdate = map.newCameraPosition(cameraPosition);\\n        this.mapController?.animateCamera(cameraUpdate, 1000);\\n      })\\n    })\\n    .catch((err: BusinessError) =&gt; {\\n      Logger.error(`Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);\\n    })\\n}</pre> <p>4、监听点击事件</p> <pre class='\\\"screen\\\"'>this.mapController.on('mapClick', async (position) =&gt; {\\n  this.mapController?.clear();\\n  this.marker?.remove();\\n  let requestInfo: geoLocationManager.CurrentLocationRequest = {\\n    'priority': geoLocationManager.LocationRequestPriority.FIRST_FIX,\\n    'scenario': geoLocationManager.LocationRequestScenario.UNSET,\\n    'maxAccuracy': 0\\n  };\\n  let locationChange = async (location: geoLocationManager.Location): Promise&lt;void&gt; =&gt; {\\n    let wgs84Position: mapCommon.LatLng = {\\n      latitude: location.latitude,\\n      longitude: location.longitude\\n    };\\n    let gcj02Posion: mapCommon.LatLng =\\n      await map.convertCoordinate(mapCommon.CoordinateType.WGS84, mapCommon.CoordinateType.GCJ02,\\n        wgs84Position);\\n    this.myPosition = gcj02Posion\\n  };\\n  geoLocationManager.on('locationChange', requestInfo, locationChange);\\n  this.marker = await MapUtil.addMarker(position, this.mapController);\\n  const walkingRoutes = await MapUtil.walkingRoutes(position, this.myPosition);\\n  await MapUtil.paintRoute(walkingRoutes!, this.mapPolyline, this.mapController);\\n});</pre> <p>5、启动步行路径规划</p> <pre class='\\\"screen\\\"'>public static async walkingRoutes(position: mapCommon.LatLng, myPosition?: mapCommon.LatLng) {\\n  let params: navi.RouteParams = {\\n    origins: [myPosition!],\\n    destination: position,\\n    language: 'zh_CN'\\n  };\\n  try {\\n    const result = await navi.getWalkingRoutes(params);\\n    Logger.info('naviDemo', 'getWalkingRoutes success result =' + JSON.stringify(result));\\n    return result;\\n  } catch (err) {\\n    Logger.error('naviDemo', 'getWalkingRoutes fail err =' + JSON.stringify(err));\\n  }\\n  return undefined;\\n}</pre> <p>6、绘制路线</p> <pre class='\\\"screen\\\"'>public static async paintRoute(routeResult: navi.RouteResult, mapPolyline?: map.MapPolyline,\\n  mapController?: map.MapComponentController) {\\n  mapPolyline?.remove();\\n  let polylineOption: mapCommon.MapPolylineOptions = {\\n    points: routeResult.routes[0].overviewPolyline!,\\n    clickable: true,\\n    startCap: mapCommon.CapStyle.BUTT,\\n    endCap: mapCommon.CapStyle.BUTT,\\n    geodesic: false,\\n    jointType: mapCommon.JointType.BEVEL,\\n    visible: true,\\n    width: 20,\\n    zIndex: 10,\\n    gradient: false,\\n    color: 0xFF2970FF\\n  }\\n  mapPolyline = await mapController?.addPolyline(polylineOption);\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-shared-bicycle.html"
    },
    {
        "id": 159,
        "pre": "import { liveViewManager } from '@kit.LiveViewKit';",
        "type": "Import",
        "function_call": "onSessionDestroy(_session: UIExtensionContentSession)",
        "function_name": "[h2]关键代码片段",
        "parent_text": "[h2]关键代码片段1、导入Live View Kit  2、创建实况窗 public async startLiveView(context: LiveViewContext,\\n  liveViewEnvironment?: LiveViewEnvironment): Promise<liveViewManager.LiveViewResult> {\\n  // build liveView\\n  this.liveViewData = await LiveViewController.buildDefaultView(context);\\n  let env = liveViewEnvironment;\\n  if (!env) {\\n    env = {\\n      id: 0,\\n      event: 'RENT'\\n    };\\n  }\\n  this.liveNotification = LiveNotification.from(context, env);\\n  return await this.liveNotification.create(this.liveViewData);\\n}\\n\\nprivate static async buildDefaultView(context: LiveViewContext) {\\n  const layoutData = new TextLayoutBuilder()\\n    .setTitle(CyclingConstants.DEFAULT_VIEW_LAYOUT_TITLE)\\n    .setContent(CyclingConstants.WAITING_PAYMENT_LAYOUT_CONTENT)\\n    .setDescPic('bike_page.png');\\n\\n  const capsule = new TextCapsuleBuilder()\\n    .setIcon('white_bike.png')\\n    .setBackgroundColor(CyclingConstants.CAPSULE_COLOR)\\n    .setTitle(CyclingConstants.DEFAULT_VIEW_RIDING)\\n\\n  const liveViewData = new LiveViewDataBuilder()\\n    .setTitle(CyclingConstants.DEFAULT_VIEW_RIDING)\\n    .setContentText(CyclingConstants.DEFAULT_VIEW_RIDING_TIME)\\n    .setContentColor(CyclingConstants.CONTENT_COLOR)\\n    .setLayoutData(layoutData)\\n    .setCapsule(capsule)\\n    .setWant(await LiveViewController.buildWantAgent(context.want))\\n\\n  return liveViewData;\\n}; 3、更新和结束实况窗 public async updateLiveView(status: number, context: LiveViewContext): Promise<liveViewManager.LiveViewResult> {\\n  // update liveView\\n  const liveViewData = this.liveViewData!;\\n  switch (status) {\\n    case CyclingStatus.WAITING_PAYMENT:\\n      liveViewData.primary.title = CyclingConstants.WAITING_PAYMENT_TITLE;\\n      liveViewData.primary.content = [\\n        {\\n          text:  CyclingConstants.WAITING_PAYMENT_CONTENT,\\n          textColor: CyclingConstants.CONTENT_COLOR\\n        }\\n      ];\\n      liveViewData.primary.clickAction = await LiveViewController.buildWantAgent(context.want);\\n      liveViewData.primary.layoutData = new TextLayoutBuilder()\\n        .setTitle(CyclingConstants.WAITING_PAYMENT_LAYOUT_TITLE)\\n        .setContent(CyclingConstants.WAITING_PAYMENT_LAYOUT_CONTENT)\\n        .setDescPic('bike_page.png');\\n\\n      liveViewData.capsule = new TextCapsuleBuilder()\\n        .setIcon('white_bike.png')\\n        .setBackgroundColor(CyclingConstants.CAPSULE_COLOR)\\n        .setTitle(CyclingConstants.WAITING_PAYMENT_LAYOUT_TITLE)\\n      break;\\n    case CyclingStatus.PAYMENT_COMPLETED:\\n      liveViewData.primary.title = CyclingConstants.WAITING_PAYMENT_TITLE;\\n      liveViewData.primary.clickAction = await LiveViewController.buildWantAgent(context.want);\\n      liveViewData.primary.content = [\\n        {\\n          text: CyclingConstants.WAITING_PAYMENT_PAY,\\n          textColor: CyclingConstants.CONTENT_COLOR\\n        },\\n        {\\n          text: CyclingConstants.WAITING_PAYMENT_PAY_SUCCESS,\\n          textColor: CyclingConstants.CONTENT_COLOR\\n        }\\n      ];\\n\\n      liveViewData.primary.layoutData = new TextLayoutBuilder()\\n        .setTitle(CyclingConstants.WAITING_PAYMENT_PAY_END)\\n        .setContent(CyclingConstants.WAITING_PAYMENT_LAYOUT_CONTENT)\\n        .setDescPic('bike_page.png');\\n\\n      liveViewData.capsule = new TextCapsuleBuilder()\\n        .setIcon('white_bike.png')\\n        .setBackgroundColor(CyclingConstants.CAPSULE_COLOR)\\n        .setTitle(CyclingConstants.PAYMENT_COMPLETED_CAPSULE_TITLE)\\n\\n      return await this.liveNotification!.stop(liveViewData);\\n    default:\\n      break;\\n  }\\n\\n  return await this.liveNotification!.update(liveViewData);\\n} 4、开发用户自定义向沉浸态实况窗 export default class LiveViewLockScreenExtAbility extends LiveViewLockScreenExtensionAbility {\\n  onCreate() {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onCreate begin.');\\n  }\\n\\n  onForeground() {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onForeground begin.');\\n  }\\n\\n  onBackground() {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onBackground begin.');\\n  }\\n\\n  onDestroy() {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onDestroy begin.');\\n  }\\n\\n  onSessionCreate(_want: Want, session: UIExtensionContentSession) {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onSessionCreate begin.');\\n    session.loadContent('pages/LiveViewLockScreenPage');\\n  }\\n\\n  onSessionDestroy(_session: UIExtensionContentSession) {\\n  }\\n} 5、在LiveViewDataBuilder中配置沉浸态实况窗参数 this.primary = {\\n  title: '',\\n  content: [\\n    {\\n      text: '',\\n      textColor: ''\\n    }\\n  ],\\n  keepTime: CyclingConstants.KEEP_TIME,\\n  clickAction: undefined,\\n  layoutData: undefined,\\n  liveViewLockScreenPicture: 'icBike.png',\\n  liveViewLockScreenAbilityName: 'LiveViewLockScreenExtAbility',\\n  liveViewLockScreenAbilityParameters: parameters\\n}; 6、在module.json5中配置拓展的ability \\\"extensionAbilities\\\": [\\n  {\\n    \\\"name\\\": \\\"LiveViewLockScreenExtAbility\\\",\\n    \\\"type\\\": \\\"liveViewLockScreen\\\",\\n    \\\"srcEntry\\\": \\\"./ets/entryability/LiveViewLockScreenExtAbility.ets\\\",\\n    \\\"exported\\\": true\\n  }\\n], ",
        "import_module": "import { liveViewManager } from '@kit.LiveViewKit';",
        "parent": "<div class='\\\"section\\\"' id='\\\"section8686194918810\\\"'><a name='\\\"section8686194918810\\\"'></a><a name='\\\"section8686194918810\\\"'></a><h4>[h2]关键代码片段</h4><p>1、导入Live View Kit</p>  <p>2、创建实况窗</p> <pre class='\\\"screen\\\"'>public async startLiveView(context: LiveViewContext,\\n  liveViewEnvironment?: LiveViewEnvironment): Promise&lt;liveViewManager.LiveViewResult&gt; {\\n  // build liveView\\n  this.liveViewData = await LiveViewController.buildDefaultView(context);\\n  let env = liveViewEnvironment;\\n  if (!env) {\\n    env = {\\n      id: 0,\\n      event: 'RENT'\\n    };\\n  }\\n  this.liveNotification = LiveNotification.from(context, env);\\n  return await this.liveNotification.create(this.liveViewData);\\n}\\n\\nprivate static async buildDefaultView(context: LiveViewContext) {\\n  const layoutData = new TextLayoutBuilder()\\n    .setTitle(CyclingConstants.DEFAULT_VIEW_LAYOUT_TITLE)\\n    .setContent(CyclingConstants.WAITING_PAYMENT_LAYOUT_CONTENT)\\n    .setDescPic('bike_page.png');\\n\\n  const capsule = new TextCapsuleBuilder()\\n    .setIcon('white_bike.png')\\n    .setBackgroundColor(CyclingConstants.CAPSULE_COLOR)\\n    .setTitle(CyclingConstants.DEFAULT_VIEW_RIDING)\\n\\n  const liveViewData = new LiveViewDataBuilder()\\n    .setTitle(CyclingConstants.DEFAULT_VIEW_RIDING)\\n    .setContentText(CyclingConstants.DEFAULT_VIEW_RIDING_TIME)\\n    .setContentColor(CyclingConstants.CONTENT_COLOR)\\n    .setLayoutData(layoutData)\\n    .setCapsule(capsule)\\n    .setWant(await LiveViewController.buildWantAgent(context.want))\\n\\n  return liveViewData;\\n};</pre> <p>3、更新和结束实况窗</p> <pre class='\\\"screen\\\"'>public async updateLiveView(status: number, context: LiveViewContext): Promise&lt;liveViewManager.LiveViewResult&gt; {\\n  // update liveView\\n  const liveViewData = this.liveViewData!;\\n  switch (status) {\\n    case CyclingStatus.WAITING_PAYMENT:\\n      liveViewData.primary.title = CyclingConstants.WAITING_PAYMENT_TITLE;\\n      liveViewData.primary.content = [\\n        {\\n          text:  CyclingConstants.WAITING_PAYMENT_CONTENT,\\n          textColor: CyclingConstants.CONTENT_COLOR\\n        }\\n      ];\\n      liveViewData.primary.clickAction = await LiveViewController.buildWantAgent(context.want);\\n      liveViewData.primary.layoutData = new TextLayoutBuilder()\\n        .setTitle(CyclingConstants.WAITING_PAYMENT_LAYOUT_TITLE)\\n        .setContent(CyclingConstants.WAITING_PAYMENT_LAYOUT_CONTENT)\\n        .setDescPic('bike_page.png');\\n\\n      liveViewData.capsule = new TextCapsuleBuilder()\\n        .setIcon('white_bike.png')\\n        .setBackgroundColor(CyclingConstants.CAPSULE_COLOR)\\n        .setTitle(CyclingConstants.WAITING_PAYMENT_LAYOUT_TITLE)\\n      break;\\n    case CyclingStatus.PAYMENT_COMPLETED:\\n      liveViewData.primary.title = CyclingConstants.WAITING_PAYMENT_TITLE;\\n      liveViewData.primary.clickAction = await LiveViewController.buildWantAgent(context.want);\\n      liveViewData.primary.content = [\\n        {\\n          text: CyclingConstants.WAITING_PAYMENT_PAY,\\n          textColor: CyclingConstants.CONTENT_COLOR\\n        },\\n        {\\n          text: CyclingConstants.WAITING_PAYMENT_PAY_SUCCESS,\\n          textColor: CyclingConstants.CONTENT_COLOR\\n        }\\n      ];\\n\\n      liveViewData.primary.layoutData = new TextLayoutBuilder()\\n        .setTitle(CyclingConstants.WAITING_PAYMENT_PAY_END)\\n        .setContent(CyclingConstants.WAITING_PAYMENT_LAYOUT_CONTENT)\\n        .setDescPic('bike_page.png');\\n\\n      liveViewData.capsule = new TextCapsuleBuilder()\\n        .setIcon('white_bike.png')\\n        .setBackgroundColor(CyclingConstants.CAPSULE_COLOR)\\n        .setTitle(CyclingConstants.PAYMENT_COMPLETED_CAPSULE_TITLE)\\n\\n      return await this.liveNotification!.stop(liveViewData);\\n    default:\\n      break;\\n  }\\n\\n  return await this.liveNotification!.update(liveViewData);\\n}</pre> <p>4、开发用户自定义向沉浸态实况窗</p> <pre class='\\\"screen\\\"'>export default class LiveViewLockScreenExtAbility extends LiveViewLockScreenExtensionAbility {\\n  onCreate() {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onCreate begin.');\\n  }\\n\\n  onForeground() {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onForeground begin.');\\n  }\\n\\n  onBackground() {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onBackground begin.');\\n  }\\n\\n  onDestroy() {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onDestroy begin.');\\n  }\\n\\n  onSessionCreate(_want: Want, session: UIExtensionContentSession) {\\n    hilog.info(0x0000, 'LiveViewLockScreenTag', 'LiveViewLockScreenExtAbility onSessionCreate begin.');\\n    session.loadContent('pages/LiveViewLockScreenPage');\\n  }\\n\\n  onSessionDestroy(_session: UIExtensionContentSession) {\\n  }\\n}</pre> <p>5、在LiveViewDataBuilder中配置沉浸态实况窗参数</p> <pre class='\\\"screen\\\"'>this.primary = {\\n  title: '',\\n  content: [\\n    {\\n      text: '',\\n      textColor: ''\\n    }\\n  ],\\n  keepTime: CyclingConstants.KEEP_TIME,\\n  clickAction: undefined,\\n  layoutData: undefined,\\n  liveViewLockScreenPicture: 'icBike.png',\\n  liveViewLockScreenAbilityName: 'LiveViewLockScreenExtAbility',\\n  liveViewLockScreenAbilityParameters: parameters\\n};</pre> <p>6、在module.json5中配置拓展的ability</p> <pre class='\\\"screen\\\"'>\\\"extensionAbilities\\\": [\\n  {\\n    \\\"name\\\": \\\"LiveViewLockScreenExtAbility\\\",\\n    \\\"type\\\": \\\"liveViewLockScreen\\\",\\n    \\\"srcEntry\\\": \\\"./ets/entryability/LiveViewLockScreenExtAbility.ets\\\",\\n    \\\"exported\\\": true\\n  }\\n],</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-shared-bicycle.html"
    },
    {
        "id": 160,
        "pre": "// features/albumView/src/main/ets/views/AlbumView.ets\\n// 监控组件区域变化\\nFlex({ direction: FlexDirection.Column }) {\\n  // ...\\n  .onAreaChange((oldValue: Area, newValue: Area) => {\\n    this.gridColumn = this.getGridColumn(newValue.width);\\n  })\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "ngetGridColumn(value: Length): number",
        "function_name": "[h2]布局能力",
        "parent_text": "[h2]布局能力本节由不同页面展开，介绍每个页面区域使用到的具体布局能力，帮助开发者从零到一进行图片美化应用的开发。 相册 相册页显示所有图片。观察相册页在折叠屏上的UX设计图，可以进行如下设计： 将相册页划分为2个区域，效果图如下：   相册页的2个基础区域介绍及实现方案如下表所示： 区域编号  简介  实现方案    1  顶部返回  使用自适应布局实现左侧返回图标及文字，右侧图标。   2  相册列表  使用网格实现相册列表。     示意图如下： 示意图  sm  md  lg    效果图               当组件区域宽度变化时，可以通过onAreaChange API获取组件的相关信息，并调整相册列数。  // features/albumView/src/main/ets/views/AlbumView.ets\\n// 列数计算公式\\ngetGridColumn(value: Length): number {\\n  return Math.floor(2 * ((parseInt(JSON.stringify(value)) / 360) - 1) + 4);\\n}  大图预览 大图预览显示一张图片。观察大图预览页在折叠屏上的UX设计图，可以进行如下设计： 将大图预览页划分为4个区域，效果图如下：   相册页的4个基础区域介绍及实现方案如下表所示： 区域编号  简介  实现方案    1  顶部返回  使用自适应布局实现左侧返回图标及文字，右侧图标。   2  图片展示  使用Image组件展示图片。   3  相册滚动展示  使用列表实现相册滚动展示。   4  图片操作  使用自适应布局实现图标自适应摆放。     示意图如下： 示意图  sm  md  lg    效果图             图片编辑 在折叠屏中，可以切换图片区域与编辑操作区域的摆放位置。观察图片编辑页在折叠屏上的UX设计图，可以进行如下设计： 将图片编辑页划分为3个区域，效果图如下：     区域2与区域3使用Flex组件实现左右摆放与上下摆放的切换  图片编辑的3个基础区域介绍及实现方案如下表所示： 区域编号  简介  实现方案    1  顶部返回  使用自适应布局实现左侧返回图标及文字，右侧图标。   2  图片展示  使用Image组件展示图片。   3  编辑操作栏  使用Flex组件实现编辑操作栏的自适应摆放。     示意图如下： 示意图  sm  md  lg    效果图               ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section14920839161019\\\"'><a name='\\\"section14920839161019\\\"'></a><a name='\\\"section14920839161019\\\"'></a><h4>[h2]布局能力</h4><p>本节由不同页面展开，介绍每个页面区域使用到的具体布局能力，帮助开发者从零到一进行图片美化应用的开发。</p> <p><strong>相册</strong></p> <p>相册页显示所有图片。观察相册页在折叠屏上的UX设计图，可以进行如下设计：</p> <ul><li>将相册页划分为2个区域，效果图如下：</li></ul> <p><span><img height='\\\"534.2211000000001\\\"' originheight='\\\"824\\\"' originwidth='\\\"738\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161333.92531180616562281563927331772208:50001231000000:2800:4B93693A438E30723F50798CA36FB5B4DBD79F23ACD7BE43060215A8B09C7ED3.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p></p> <p>相册页的2个基础区域介绍及实现方案如下表所示：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.9.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>区域编号</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.9.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>简介</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.9.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>实现方案</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>1</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>顶部返回</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/adaptive-layout\\\"' target='\\\"_blank\\\"'>自适应布局</a>实现左侧返回图标及文字，右侧图标。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>2</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>相册列表</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-grid\\\"' target='\\\"_blank\\\"'>网格</a>实现相册列表。</p> </td> </tr> </tbody></table> </div> <p>示意图如下：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.11.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>示意图</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.11.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"18.35%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.11.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"29.49%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.11.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"44.64%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.35%\\\"'><p></p> <p><span><img height='\\\"551.7771\\\"' originheight='\\\"804\\\"' originwidth='\\\"385\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161333.23575102443360298264017199676538:50001231000000:2800:4A2D7EEE5A6BA689FEC972D382D123565310E17280E3357B984B688C8F341E0A.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"29.49%\\\"'><p></p> <p><span><img height='\\\"534.0881\\\"' originheight='\\\"787\\\"' originwidth='\\\"705\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161333.24661741401601697505049939552148:50001231000000:2800:2F0CE2246C57CE7A6E5C3E180C566A492126E2A2F940EF05B1804A7D4C083E8C.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"44.64%\\\"'><p></p> <p><span><img height='\\\"517.0109000000001\\\"' originheight='\\\"869\\\"' originwidth='\\\"1344\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161333.37735774086698999622170741040287:50001231000000:2800:5F12ADA454468CCE5DC6ACA40E2D8E5DEDB8EE528DD9B9FB7B8A6C14B890B732.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <p></p> </td> </tr> </tbody></table> </div> <p>当组件区域宽度变化时，可以通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-component-area-change-event\\\"' target='\\\"_blank\\\"'>onAreaChange</a> API获取组件的相关信息，并调整相册列数。</p>  <pre class='\\\"screen\\\"'>// features/albumView/src/main/ets/views/AlbumView.ets\\n// 列数计算公式\\ngetGridColumn(value: Length): number {\\n  return Math.floor(2 * ((parseInt(JSON.stringify(value)) / 360) - 1) + 4);\\n}</pre> <p></p> <p><strong>大图预览</strong></p> <p>大图预览显示一张图片。观察大图预览页在折叠屏上的UX设计图，可以进行如下设计：</p> <ul><li>将大图预览页划分为4个区域，效果图如下：</li></ul> <p></p> <p><span><img height='\\\"534.2211000000001\\\"' originheight='\\\"824\\\"' originwidth='\\\"738\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161333.33138373944393062456014945301680:50001231000000:2800:F807EC769362B72CB8FA6AF92DE521A5CE760DB5D440D7F5F1123B48E46033D0.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p>相册页的4个基础区域介绍及实现方案如下表所示：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.22.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>区域编号</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.22.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>简介</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.22.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>实现方案</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>1</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>顶部返回</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/adaptive-layout\\\"' target='\\\"_blank\\\"'>自适应布局</a>实现左侧返回图标及文字，右侧图标。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>2</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>图片展示</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image\\\"' target='\\\"_blank\\\"'>Image</a>组件展示图片。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>3</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>相册滚动展示</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-list\\\"' target='\\\"_blank\\\"'>列表</a>实现相册滚动展示。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>4</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>图片操作</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/adaptive-layout\\\"' target='\\\"_blank\\\"'>自适应布局</a>实现图标自适应摆放。</p> </td> </tr> </tbody></table> </div> <p>示意图如下：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.24.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>示意图</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.24.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"18.35%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.24.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"27.800000000000004%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.24.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"46.33%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.35%\\\"'><p></p> <p><span><img height='\\\"551.7771\\\"' originheight='\\\"804\\\"' originwidth='\\\"385\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161333.48995949604168076792341923495619:50001231000000:2800:574012FEC7A8A771F7538A7B50AF72396549473EFE7FDCD70E3B5E1C0DA0FFAD.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.800000000000004%\\\"'><p></p> <p><span><img height='\\\"534.0881\\\"' originheight='\\\"787\\\"' originwidth='\\\"705\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161333.34530099474238412583663252274820:50001231000000:2800:C4A0338C91FEF090634B90B357C2D08CB146FBF33C787242999C44FAC8B10318.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"46.33%\\\"'><p><span><img height='\\\"517.0109000000001\\\"' originheight='\\\"869\\\"' originwidth='\\\"1344\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161333.89329490643269239942297584611916:50001231000000:2800:FAD4B90C8736BA7972D43C600624E6917DF27B24347BED04EEA2BEA98C2C6BD8.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div> <p><strong>图片编辑</strong></p> <p>在折叠屏中，可以切换图片区域与编辑操作区域的摆放位置。观察图片编辑页在折叠屏上的UX设计图，可以进行如下设计：</p> <ul><li>将图片编辑页划分为3个区域，效果图如下：</li></ul> <p></p> <p><span><img height='\\\"534.2211000000001\\\"' originheight='\\\"824\\\"' originwidth='\\\"738\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161334.90415607741495171902881960348221:50001231000000:2800:790958A27191AFA6C9B42C2A3364F0FFB28D9B8F329C1CE1BD95C6B44ACEF904.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p><span><img height='\\\"534.2211000000001\\\"' originheight='\\\"824\\\"' originwidth='\\\"738\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161334.70124448130566122317841783509256:50001231000000:2800:FD88FC0F3C28F940AB987F52FAB71E396275BD24FAF9964383E6A0C91C741994.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p></p> <div class='\\\"p\\\"'><ul><li>区域2与区域3使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-flex-layout\\\"' target='\\\"_blank\\\"'>Flex</a>组件实现左右摆放与上下摆放的切换</li></ul> </div> <p>图片编辑的3个基础区域介绍及实现方案如下表所示：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.34.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>区域编号</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.34.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>简介</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.34.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>实现方案</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>1</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>顶部返回</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/adaptive-layout\\\"' target='\\\"_blank\\\"'>自适应布局</a>实现左侧返回图标及文字，右侧图标。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>2</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>图片展示</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image\\\"' target='\\\"_blank\\\"'>Image</a>组件展示图片。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"5.18%\\\"'><p>3</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"14.06%\\\"'><p>编辑操作栏</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"80.76%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flex\\\"' target='\\\"_blank\\\"'>Flex</a>组件实现编辑操作栏的自适应摆放。</p> </td> </tr> </tbody></table> </div> <p>示意图如下：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.36.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"6.833935370496926%\\\"'><p>示意图</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.36.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"16.743141657717466%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.36.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"28.69276579127209%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.36.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"47.73015718051352%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.833935370496926%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"16.743141657717466%\\\"'><p></p> <p><span><img height='\\\"529.5528\\\"' originheight='\\\"855\\\"' originwidth='\\\"427\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161334.07705976638598342552737781070967:50001231000000:2800:C0DDA5D94C1E8DAE3AB9107DB69F636BEB23AED09E7FC580929DB0A5B6910237.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"28.69276579127209%\\\"'><p></p> <p></p> <p><span><img height='\\\"534.0881\\\"' originheight='\\\"787\\\"' originwidth='\\\"705\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161334.39181466676008474181079017062505:50001231000000:2800:D1C4ABC8ACED867A0550A0C91E3AF2E906FEFB606EBC75E1BDE52D9B6B133935.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p><span><img height='\\\"534.2211000000001\\\"' originheight='\\\"824\\\"' originwidth='\\\"738\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161334.44279044532566755912101729397526:50001231000000:2800:4CAAC8E1FDEEC3F642B127E133EB1E99F0DE9D09E5CA987C5BF4D04D1A92D17A.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"47.73015718051352%\\\"'><p><span><img height='\\\"524.1131\\\"' originheight='\\\"881\\\"' originwidth='\\\"1344\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161334.64066879911682533723537061800066:50001231000000:2800:44E600AF317BDAB9CB7BC107294D35C1841C4ED887B6A2E9C56021A044154DA9.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-picture-app.html"
    },
    {
        "id": 161,
        "pre": "Navigation(this.pathInfo) {\\n  // ...\\n}\\n.mode(this.currentBreakPoint === 'sm' ? NavigationMode.Stack : this.notesNavMode)",
        "type": "Reference",
        "function_call": "MailNavigation()",
        "function_name": "分栏实现原理",
        "parent_text": "分栏实现原理单双栏： 单双栏通常是使用Navigation实现的，Navigation是路由容器组件，一般作为首页的根容器，包括单栏(Stack)、分栏(Split)和自适应(Auto)三种显示模式。自适应模式下，当页面宽度大于等于一定阈值时，Navigation组件采用分栏模式，反之采用单栏模式。  开发者可以通过更改Navigation组件的mode值来实现单双栏的切换，如果断点为sm，则mode值为Stack。如果不为sm，则mode值为Split，即可实现单双栏的自适应切换。  三分栏： Navigation组件实现了单双栏的效果。那么，在更大的屏幕宽度，要实现三分栏效果该如何实现呢？三分栏可以组合使用SideBarContainer与Navigation组件实现。SideBarContainer提供侧边栏可以显示和隐藏的侧边栏容器，通过子组件定义侧边栏和内容区，第一个子组件表示侧边栏，第二个子组件表示内容区。我们可以在内容区中加入Navigation组件，即可实现三分栏效果。  我们可以通过更改SideBarContainer组件的showSideBar值来控制是否显示侧边栏。如果断点为lg，则showSideBar值为true，默认显示侧边栏，反之，则为false，不显示。 SideBarContainer(SideBarContainerType.AUTO) {\\n  // 导航栏\\n  Column() {\\n    MailSideBar()\\n  }\\n  .width('100%')\\n  .height('100%')\\n  .backgroundColor('#f1f3f5')\\n\\n  // 内容区\\n  Column() {\\n    Stack() {\\n      MailNavigation()\\n      // ...\\n    }\\n  }\\n  .height('100%')\\n  .width('100%')\\n}\\n.showSideBar(this.currentBreakPoint === 'lg') ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section96012030498\\\"'><a name='\\\"section96012030498\\\"'></a><a name='\\\"section96012030498\\\"'></a><h4>分栏实现原理</h4><p><strong>单双栏</strong>：</p> <p>单双栏通常是使用Navigation实现的，<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation\\\"' target='\\\"_blank\\\"'>Navigation</a>是路由容器组件，一般作为首页的根容器，包括单栏(Stack)、分栏(Split)和自适应(Auto)三种显示模式。自适应模式下，当页面宽度大于等于一定阈值时，Navigation组件采用分栏模式，反之采用单栏模式。</p> <p><span><img originheight='\\\"449\\\"' originwidth='\\\"839\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161305.78907149102025889553799190203113:50001231000000:2800:33A62708ADB44311FA0960B80082A49171ACF7EFC52947102E326F130F8217F2.png\\\"'/></span></p> <p>开发者可以通过更改Navigation组件的mode值来实现单双栏的切换，如果断点为sm，则mode值为Stack。如果不为sm，则mode值为Split，即可实现单双栏的自适应切换。</p>  <p><strong>三分栏</strong>：</p> <p>Navigation组件实现了单双栏的效果。那么，在更大的屏幕宽度，要实现三分栏效果该如何实现呢？三分栏可以组合使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer\\\"' target='\\\"_blank\\\"'>SideBarContainer</a>与<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navigation\\\"' target='\\\"_blank\\\"'>Navigation组件</a>实现。SideBarContainer提供侧边栏可以显示和隐藏的侧边栏容器，通过子组件定义侧边栏和内容区，第一个子组件表示侧边栏，第二个子组件表示内容区。我们可以在内容区中加入Navigation组件，即可实现三分栏效果。</p> <p><span><img originheight='\\\"432\\\"' originwidth='\\\"1047\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161305.99208890052966530450158436931368:50001231000000:2800:CCAA07690FEAD2E04ED3A405B00CFAC9B916EFC14364F9B0A572A40EB0951490.png\\\"'/></span></p> <p>我们可以通过更改SideBarContainer组件的showSideBar值来控制是否显示侧边栏。如果断点为lg，则showSideBar值为true，默认显示侧边栏，反之，则为false，不显示。</p> <pre class='\\\"screen\\\"'>SideBarContainer(SideBarContainerType.AUTO) {\\n  // 导航栏\\n  Column() {\\n    MailSideBar()\\n  }\\n  .width('100%')\\n  .height('100%')\\n  .backgroundColor('#f1f3f5')\\n\\n  // 内容区\\n  Column() {\\n    Stack() {\\n      MailNavigation()\\n      // ...\\n    }\\n  }\\n  .height('100%')\\n  .width('100%')\\n}\\n.showSideBar(this.currentBreakPoint === 'lg')</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-columns.html"
    },
    {
        "id": 162,
        "pre": "// entry/src/main/ets/application/MailBox.ets\\nbuild() {\\n  // ...\\n      SideBarContainer(SideBarContainerType.AUTO) {\\n        // 导航栏\\n        Column() {\\n          MailSideBar()\\n        }\\n        .width('100%')\\n        .height('100%')\\n        .backgroundColor('#f1f3f5')\\n\\n        // 内容区\\n        Column() {\\n          Stack() {\\n            MailNavigation()\\n            // ...\\n          }\\n        }\\n        .height('100%')\\n        .width('100%')\\n      }\\n      .showSideBar(this.currentBreakPoint === 'lg')\\n      // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "对SideBarContainer组件的showSideBar属性进行赋值，如果断点为lg，则默认显示侧边栏，反之，则默认不显示。 ",
        "import_module": null,
        "parent": "<li>对SideBarContainer组件的showSideBar属性进行赋值，如果断点为lg，则默认显示侧边栏，反之，则默认不显示。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-columns.html"
    },
    {
        "id": 163,
        "pre": "Navigation(this.calendarPageInfos) {\\n  CalendarView()\\n}\\n.navDestination(this.pageMap)\\n.mode(this.breakPoint === CommonConstants.BREAK_POINT_SM ? NavigationMode.Stack : this.navMode)\\n// ...\\n.onNavigationModeChange((mode: NavigationMode) => {\\n  if (this.breakPoint === CommonConstants.BREAK_POINT_SM || mode === NavigationMode.Stack) {\\n    this.calendarPageInfos.clear();\\n  } else if (mode === NavigationMode.Split) {\\n    this.calendarPageInfos.pushPath({ name: this.selectedItem.date, param: this.selectedItem }, false);\\n  }\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]其他场景",
        "parent_text": "[h2]其他场景大部分情况下，单栏展示的是Navigation的内容区，但是存在某些场景，内容区的优先级比导航区的优先级要低，比如日历日程功能，在单栏的情况下，展示的是日历（Navigation的导航区）。效果如下。  日历日程分为三个层级，账户消息->日历->日程，开发者通常在单栏显示日历，双栏显示日历、日程，三栏显示账户信息、日历、日程。日历日程页面与邮箱页面的主要区别为，日历日程页面的单栏页面显示Navigation导航栏。 示意图  sm  md  lg    效果图           示例代码 在Navigation的onNavigationModeChange属性中进行判断，当Navigation首次显示或者单双栏状态发生变化时。 如果是单栏，则清空PathInfo路由，则Navigation的内容区不显示，即可实现单屏显示Navigation导航栏的目的。如果为双栏，则重新向PathInfo路由中push内容区参数，即可达到单栏变双栏的目的。  还有一种SideBarContainer在页面右边的场景，比如大多数页面的智能客服场景。通过sidebarposition属性设置侧边栏右侧显示。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1122442313473\\\"'><a name='\\\"section1122442313473\\\"'></a><a name='\\\"section1122442313473\\\"'></a><h4>[h2]其他场景</h4><p>大部分情况下，单栏展示的是Navigation的内容区，但是存在某些场景，内容区的优先级比导航区的优先级要低，比如日历日程功能，在单栏的情况下，展示的是日历（Navigation的导航区）。效果如下。</p> <p><span><img originheight='\\\"456\\\"' originwidth='\\\"1151\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161306.93488701393730913889488981469422:50001231000000:2800:6338A3EDFA8D8314DE02753284E66F770E65841DD7602230B34D63C0F08CAC3B.png\\\"'/></span></p> <p>日历日程分为三个层级，账户消息-&gt;日历-&gt;日程，开发者通常在单栏显示日历，双栏显示日历、日程，三栏显示账户信息、日历、日程。日历日程页面与邮箱页面的主要区别为，日历日程页面的单栏页面显示Navigation导航栏。</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.5.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.519248075192481%\\\"'><p>示意图</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.5.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"16.67833216678332%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.5.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"30.70692930706929%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.5.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"45.095490450954905%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.519248075192481%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"16.67833216678332%\\\"'><p><span><img height='\\\"494.562495\\\"' originheight='\\\"2258\\\"' originwidth='\\\"1093\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161306.82028909379409250809299967196943:50001231000000:2800:EEB6DC1EF13E47FFF08D3955B17F62CB924F1D6E10A46CE4DFDD1523FAE41374.png\\\"' title='\\\"点击放大\\\"' width='\\\"239.4\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"30.70692930706929%\\\"'><p><span><img height='\\\"500.23933400000004\\\"' originheight='\\\"2425\\\"' originwidth='\\\"2176\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161306.92954754647085270778678565222600:50001231000000:2800:3F26AB400F566DB1F648B68C432FF99C4BAD752FF3881BEFF70C26A9543829EA.png\\\"' title='\\\"点击放大\\\"' width='\\\"448.875\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"45.095490450954905%\\\"'><p><span><img height='\\\"338.15250000000003\\\"' originheight='\\\"2278\\\"' originwidth='\\\"3524\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161306.79513798723788665759303651474758:50001231000000:2800:A718462D4D6C95C8E26D830FAC2819BC76B8A736B621D50A41389E0F532D694B.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></p> </td> </tr> </tbody></table> </div> <p><strong>示例代码</strong></p> <p>在Navigation的onNavigationModeChange属性中进行判断，当Navigation首次显示或者单双栏状态发生变化时。</p> <ul><li>如果是单栏，则清空PathInfo路由，则Navigation的内容区不显示，即可实现单屏显示Navigation导航栏的目的。</li><li>如果为双栏，则重新向PathInfo路由中push内容区参数，即可达到单栏变双栏的目的。</li></ul>  <p>还有一种SideBarContainer在页面右边的场景，比如大多数页面的智能客服场景。通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-sidebarcontainer#sidebarposition9\\\"' target='\\\"_blank\\\"'>sidebarposition属性</a>设置侧边栏右侧显示。</p> <p><span><img originheight='\\\"458\\\"' originwidth='\\\"1251\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161307.68484294782333637128099079740454:50001231000000:2800:209DC1CC39BCAC17B9563CCF87C6FA3394095F42E93FAFF4E5948E113F30F91B.png\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-columns.html"
    },
    {
        "id": 164,
        "pre": "@Concurrent\\nfunction writeFile(fd: number[], content: string, times: number) {\\n  for (let i: number = 0; i < times; i++) {\\n    fileIo.write(fd[i], content);\\n  }\\n}",
        "type": "Reference",
        "function_call": "封装write()",
        "function_name": null,
        "parent_text": "封装write()函数，使用@Concurrent进行装饰，执行的并发函数需要使用该装饰器修饰，否则无法通过相关校验。 ",
        "import_module": null,
        "parent": "<li>封装write()函数，使用@Concurrent进行装饰，执行的并发函数需要使用该装饰器修饰，否则无法通过相关校验。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-local-file-and-data-multithreaded-io.html"
    },
    {
        "id": 165,
        "pre": "@Concurrent\\nasync function insert(context: common.UIAbilityContext, valueBucket: Array<relationalStore.ValuesBucket>,\\n  config: relationalStore.StoreConfig) {\\n  const store = await relationalStore.getRdbStore(context, config);\\n  store.batchInsert('EMPLOYEE', valueBucket);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "封装关系型数据库的写数据库的函数，使用@Concurrent进行装饰。 ",
        "import_module": null,
        "parent": "<li>封装关系型数据库的写数据库的函数，使用@Concurrent进行装饰。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-local-file-and-data-multithreaded-io.html"
    },
    {
        "id": 166,
        "pre": "@Sendable\\nclass Content {\\n  content: string;\\n\\n  constructor(content: string) {\\n    this.content = content;\\n  }\\n}",
        "type": "Reference",
        "function_call": "nfunction writeFile(fd: number[], content: Content, times: number)",
        "function_name": null,
        "parent_text": "在使用@Sendable进行文件写入操作时，首先需要定义Sendable对象存放写入数据，然后封装TaskPool函数传入。 @Concurrent\\nfunction writeFile(fd: number[], content: Content, times: number) {\\n  for (let i: number = 0; i < times; i++) {\\n    fileIo.write(fd[i], content.content);\\n  }\\n} ",
        "import_module": null,
        "parent": "<li>在使用@Sendable进行文件写入操作时，首先需要定义Sendable对象存放写入数据，然后封装TaskPool函数传入。 <pre class='\\\"screen\\\"'>@Concurrent\\nfunction writeFile(fd: number[], content: Content, times: number) {\\n  for (let i: number = 0; i &lt; times; i++) {\\n    fileIo.write(fd[i], content.content);\\n  }\\n}</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-local-file-and-data-multithreaded-io.html"
    },
    {
        "id": 167,
        "pre": "@Sendable\\nclass SharedValuesBucket {\\n  NAME: string;\\n  AGE: number;\\n  SALARY: number;\\n\\n  constructor(NAME: string, AGE: number, SALARY: number) {\\n    this.NAME = NAME;\\n    this.AGE = AGE;\\n    this.SALARY = SALARY;\\n  }\\n}",
        "type": "Reference",
        "function_call": "function insert(context: common.UIAbilityContext, valueBucket: Array&lt;SharedValuesBucket&gt;,\\n  config: relationalStore.StoreConfig)",
        "function_name": null,
        "parent_text": "在关系型数据库写入操作时，同样需要封装写入数据使用@Sendable进行装饰，传入TaskPool函数中。 @Concurrent\\nasync function insert(context: common.UIAbilityContext, valueBucket: Array<SharedValuesBucket>,\\n  config: relationalStore.StoreConfig) {\\n  const store = await relationalStore.getRdbStore(context, config);\\n  store.batchInsert('EMPLOYEE', valueBucket as object as Array<relationalStore.ValuesBucket>);\\n} ",
        "import_module": null,
        "parent": "<li>在关系型数据库写入操作时，同样需要封装写入数据使用@Sendable进行装饰，传入TaskPool函数中。 <pre class='\\\"screen\\\"'>@Concurrent\\nasync function insert(context: common.UIAbilityContext, valueBucket: Array&lt;SharedValuesBucket&gt;,\\n  config: relationalStore.StoreConfig) {\\n  const store = await relationalStore.getRdbStore(context, config);\\n  store.batchInsert('EMPLOYEE', valueBucket as object as Array&lt;relationalStore.ValuesBucket&gt;);\\n}</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-local-file-and-data-multithreaded-io.html"
    },
    {
        "id": 168,
        "pre": "// PicturePreview/entry/src/main/ets/view/ImageItemView.ets\\n// 单指拖动图片\\nPanGesture({ fingers: 1, distance: this.isDisableSwipe ? 3 : 50 })\\n  .onActionUpdate((event: GestureEvent) => {\\n    this.isDisableSwipe = this.imageModel.panGestureUpdate(event);\\n  })\\n  .onActionEnd(() => {\\n    this.imageModel.gestureEnd();\\n  }),",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "响应平移手势：使用PanGesture接口实现滑动手势控制，为了实现单指滑动效果，需将参数fingers设置为1，当图片拖动后，即可获取当前图片的偏移量，具体为event.offsetX与event.offsetY。 ",
        "import_module": null,
        "parent": "<li>响应平移手势：使用PanGesture接口实现滑动手势控制，为了实现单指滑动效果，需将参数fingers设置为1，当图片拖动后，即可获取当前图片的偏移量，具体为event.offsetX与event.offsetY。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-picture-preview.html"
    },
    {
        "id": 169,
        "pre": "// PicturePreview/entry/src/main/ets/view/ImageItemView.ets\\n// 获取并设置图片信息：图片的宽度、高度以及图片的宽高比\\ninitCurrentImageInfo(): void {\\n  let img = this.context.resourceManager.getMediaContentSync(this.imageData?.id);\\n  let imageSource = image.createImageSource(img.buffer.slice(0));\\n  imageSource.getImageInfo(0).then((data: image.ImageInfo) => {\\n    this.imageWHRatio = data.size.width / data.size.height;\\n    this.imageModel.imageWidth = this.imageModel.componentWidth;\\n    this.imageModel.imageHeight = this.imageModel.imageWidth / this.imageWHRatio;\\n  }).catch((err: BusinessError) => {\\n    hilog.error(0x0000, TAG, `[error][getImageInfo]${err.message}`);\\n  });\\n}",
        "type": "Reference",
        "function_call": "nevaluateOffsetRange(): void",
        "function_name": null,
        "parent_text": "图片边界限制：主要涉及两个方面：当前图片显示边界的计算以及offset范围计算。调用自定义initCurrentImageInfo()方法，计算出当前图片的宽度this.imageModel.imageWidth和高度this.imageModel.imageHeight。  调用自定义windowSize()方法，计算出当前组件的宽度this.componentWidth和高度this.componentHeight。 最后，调用自定义evaluateOffsetRange()方法，在图片缩放后，计算出图片在四个方向上的边界值：具体包括最大水平偏移量this.maxOffsetX、最小水平偏移量this.minOffsetX、最大垂直偏移量this.maxOffsetY以及最小垂直偏移量this.minOffsetY。// PicturePreview/entry/src/main/ets/model/CommonModel.ets\\n// 获取组件大小\\nwindowSize(): void {\\n  window.getLastWindow(getContext()).then((window: window.Window) => {\\n    this.componentWidth = px2vp(window.getWindowProperties().windowRect.width);\\n    this.componentHeight = px2vp(window.getWindowProperties().windowRect.height);\\n  });\\n}\\n// ...\\n// 计算图片边界的范围\\nevaluateOffsetRange(): void {\\n  this.maxOffsetX = Math.abs(Math.min(((1 - this.curScale) * this.componentWidth) / 2, 0));\\n  this.minOffsetX = -Math.abs(Math.max((this.componentWidth * (this.curScale - 1)) / 2, 0));\\n  this.maxOffsetY = Math.abs(Math.min((this.componentHeight -\\n    this.curScale * this.imageHeight * this.componentWidth / this.imageWidth) / 2, 0));\\n  this.minOffsetY = -Math.abs(Math.max((this.curScale * this.imageHeight * this.componentWidth / this.imageWidth -\\n  this.componentHeight) / 2, 0));\\n}  ",
        "import_module": null,
        "parent": "<li>图片边界限制：主要涉及两个方面：当前图片显示边界的计算以及offset范围计算。<p>调用自定义initCurrentImageInfo()方法，计算出当前图片的宽度this.imageModel.imageWidth和高度this.imageModel.imageHeight。</p>  <p>调用自定义windowSize()方法，计算出当前组件的宽度this.componentWidth和高度this.componentHeight。</p> <div class='\\\"p\\\"'>最后，调用自定义evaluateOffsetRange()方法，在图片缩放后，计算出图片在四个方向上的边界值：具体包括最大水平偏移量this.maxOffsetX、最小水平偏移量this.minOffsetX、最大垂直偏移量this.maxOffsetY以及最小垂直偏移量this.minOffsetY。<pre class='\\\"screen\\\"'>// PicturePreview/entry/src/main/ets/model/CommonModel.ets\\n// 获取组件大小\\nwindowSize(): void {\\n  window.getLastWindow(getContext()).then((window: window.Window) =&gt; {\\n    this.componentWidth = px2vp(window.getWindowProperties().windowRect.width);\\n    this.componentHeight = px2vp(window.getWindowProperties().windowRect.height);\\n  });\\n}\\n// ...\\n// 计算图片边界的范围\\nevaluateOffsetRange(): void {\\n  this.maxOffsetX = Math.abs(Math.min(((1 - this.curScale) * this.componentWidth) / 2, 0));\\n  this.minOffsetX = -Math.abs(Math.max((this.componentWidth * (this.curScale - 1)) / 2, 0));\\n  this.maxOffsetY = Math.abs(Math.min((this.componentHeight -\\n    this.curScale * this.imageHeight * this.componentWidth / this.imageWidth) / 2, 0));\\n  this.minOffsetY = -Math.abs(Math.max((this.curScale * this.imageHeight * this.componentWidth / this.imageWidth -\\n  this.componentHeight) / 2, 0));\\n}</pre> </div> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-picture-preview.html"
    },
    {
        "id": 170,
        "pre": "// PicturePreview/entry/src/main/ets/pages/HomePage.ets\\n@Builder\\nPhotoSwiper() {\\n  Swiper(this.homeSwipeController) {\\n    ForEach(this.ImgData, (img: Resource) => {\\n      ImageItemView({\\n        imageData: img,\\n        isOverlay: this.isOverlay\\n      })\\n        .width('100%')\\n        .height('100%')\\n    }, (img: Resource, index: number) => JSON.stringify(img) + index)\\n  }\\n  // ...\\n  .disableSwipe(this.isDisableSwipe)\\n  // ...",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "当图片处于默认尺寸，或是已滑动到左右边界之时，应将this.isDisableSwipe的值设定为false；当图片处于放大状态且尚未滑动至左右边界时，应将this.isDisableSwipe的值设定为true。 ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>当图片处于默认尺寸，或是已滑动到左右边界之时，应将this.isDisableSwipe的值设定为false；当图片处于放大状态且尚未滑动至左右边界时，应将this.isDisableSwipe的值设定为true。 </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-picture-preview.html"
    },
    {
        "id": 171,
        "pre": "// src/main/ets/feature/ImageLongTakeTransition/PinchToShareImage/PinchToShareImagePageOne.ets\\n@StorageProp('expand') @Watch('goToPageTwo') num1: number = 0;\\n// ...\\ngoToPageTwo() {\\n  let param: Record<string, Object> = {};\\n  param['onBack'] = () => { this.restoreNodeController() };\\n  this.pageInfo.pushPath({ name: 'PinchToShareImagePageTwo', param }, false);\\n  this.imageGalleryNodeController = undefined;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "小图模式和大图模式分别为两个页面，通过监听expand值来进行页面切换。 ",
        "import_module": null,
        "parent": "<li>小图模式和大图模式分别为两个页面，通过监听expand值来进行页面切换。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-one-shot-to-the-end.html"
    },
    {
        "id": 172,
        "pre": "// src/main/ets/feature/SearchLongTakeTransition/SearchLongTakeTransitionPageOne.ets\\nprivate showSearchPage(): void {\\n  this.transitionEffect = TransitionEffect.OPACITY;\\n  animateTo({\\n    curve: curves.interpolatingSpring(0, 1, 342, 38)\\n  }, () => {\\n    this.pageInfos.pushPath({ name: 'SearchLongTakeTransitionPageTwo' }, false);\\n  })\\n}\\n\\nbuild() {\\n  NavDestination() {\\n    Column({ space: 20 }) {\\n      Search({ placeholder: 'Search' })\\n        .height(40)\\n        .placeholderColor($r('sys.color.mask_secondary'))\\n        .width('100%')\\n        .geometryTransition('SEARCH_ONE_SHOT_DEMO_TRANSITION_ID', { follow: true })\\n        .backgroundColor('#0D000000')\\n        .defaultFocus(false)\\n        .focusOnTouch(false)\\n        .focusable(false)\\n        .onTouch((event: TouchEvent) => {\\n          if (event.type === TouchType.Up) {\\n            this.showSearchPage();\\n          }\\n        })\\n    }\\n    .size({\\n      width: '90%',\\n      height: '100%'\\n    })\\n  }\\n  .transition(TransitionEffect.OPACITY)\\n  .backgroundColor('#F1F3F5')\\n  .title(getResourceString($r('app.string.search_title'), this))\\n  .onReady((context: NavDestinationContext) => {\\n    this.pageInfos = context.pathStack;\\n  })\\n  .onBackPressed(() => {\\n    this.transitionEffect = TransitionEffect.IDENTITY;\\n    this.pageInfos.pop(true);\\n    return true;\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "搜索框首页在Search组件添加geometryTransition属性，并绑定id值，禁用掉Navigation本身转场的动画。 ",
        "import_module": null,
        "parent": "<li>搜索框首页在Search组件添加geometryTransition属性，并绑定id值，禁用掉Navigation本身转场的动画。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-one-shot-to-the-end.html"
    },
    {
        "id": 173,
        "pre": "// src/main/ets/feature/CardLongTakeTransition/CardLongTakeTransitionPageOne.ets\\nprivate onColumnClicked(indexValue: string): void {\\n  let param: Record<string, Object> = {};\\n  let clickedIndex = parseInt(indexValue);\\n  param['indexValue'] = clickedIndex;\\n  this.clickedIndex = clickedIndex;\\n  // 点击卡片后获取对应的卡片截图并保存\\n  componentSnapshot.get('FlowItem_' + indexValue, (error: Error, pixelMap: image.PixelMap) => {\\n    if (error) {\\n      hilog.info(0x0000, 'CardLongTakePageOne', 'componentSnapshot.get error, reason: ' + JSON.stringify(error));\\n      // 截图失败的话，则走默认左右转场。此时弹出页不会收到clickedComponentId参数，就不进行注册流程\\n      // 这时候from和to的animation均为undefined，在customNavContentTransition会走默认转场\\n      this.pageInfos.pushPath({ name: 'CardLongTakeTransitionPageTwo', param: param });\\n      return;\\n    } else {\\n      hilog.info(0x0000, 'CardLongTakePageOne', 'componentSnapshot.get success!');\\n      // 截图成功的话，则走自定义一镜到底转场\\n      param['clickedComponentId'] = CardUtil.getFlowItemIdByIndex(indexValue);\\n      param['doDefaultTransition'] = () => {\\n        this.doFinishTransition();\\n      };\\n      SnapShotImage.pixelMap = pixelMap;\\n      this.pageInfos.pushPath({ name: 'CardLongTakeTransitionPageTwo', param: param });\\n      this.dataSource.getData(this.clickedIndex).isVisible = Visibility.Hidden;\\n    }\\n  })\\n}\\n\\nbuild() {\\n  NavDestination() {\\n    Stack() {\\n      WaterFlow() {\\n        LazyForEach(this.dataSource, (item: CardAttr, index: number) => {\\n          FlowItem() {\\n            CardComponent({\\n              indexValue: index.toString(),\\n              cardAttr: item,\\n              onColumnClicked: (indexValue: string) => {\\n                this.onColumnClicked(indexValue);\\n              }\\n            })\\n          }\\n          .width('100%')\\n          .borderRadius(10)\\n          .clip(true)\\n          .id(CardUtil.getFlowItemIdByIndex(index.toString()))\\n        }, (item: string) => item)\\n      }\\n      .columnsTemplate(this.columnType)\\n      .columnsGap(10)\\n      .rowsGap(10)\\n      .width('100%')\\n      .height('100%')\\n    }\\n    .size({\\n      width: '100%',\\n      height: '100%'\\n    })\\n    .padding({\\n      left: 16,\\n      right: 16\\n    })\\n  }\\n  .backgroundColor('#F1F3F5')\\n  .title(getResourceString($r('app.string.card_title'), this))\\n  .onReady((context: NavDestinationContext) => {\\n    this.pageInfos = context.pathStack;\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "卡片列表页使用WaterFlow和LazyForEach实现页面布局。 ",
        "import_module": null,
        "parent": "<li>卡片列表页使用WaterFlow和LazyForEach实现页面布局。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-one-shot-to-the-end.html"
    },
    {
        "id": 174,
        "pre": "// src/main/ets/feature/BookFlipLongTakeTransition/BookFlipLongTakeTransitionPageOne.ets\\nprivate onColumnClicked(bookId: string, bookCoverUrl: string, toBookId?: string, prePageCallback?: () => void): void {\\n  CustomTransition.getInstance().unRegisterNavParam(this.pageId);\\n  const fromCardItemInfo: RectInfoInPx =\\n    ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), bookId);\\n  let param: Record<string, Object> = {};\\n  param['fromCardItemInfo'] = fromCardItemInfo;\\n  param['bookCoverUrl'] = bookCoverUrl;\\n  if (toBookId) {\\n    const toCardItemInfo: RectInfoInPx =\\n      ComponentAttrUtils.getRectInfoById(WindowUtils.window.getUIContext(), toBookId);\\n    param['toCardItemInfo'] = toCardItemInfo;\\n  }\\n  if (prePageCallback) {\\n    param['prePageCallback'] = prePageCallback;\\n  }\\n  this.pageInfos.pushPath({ name: 'BookFlipLongTakeTransitionPageTwo', param: param });\\n}\\n\\nbuild() {\\n  NavDestination() {\\n    Scroll() {\\n      Column({ space: 12 }) {\\n        // 一镜到底返回至第一个位置\\n        Grid() {\\n          ForEach(this.dataSource, (item: BookItem, index: number) => {\\n            GridItem() {\\n              Image($r(item.coverImageUrl))\\n                .id(item.id)\\n                .width('100%')\\n                .onClick(() => {\\n                  this.onColumnClicked(item.id, item.coverImageUrl, this.dataSource[0].id, () => {\\n                    this.dataSource.sort((a, b) => b.timestamp - a.timestamp);\\n                  })\\n                  this.dataSource[index].timestamp = Number(new Date());\\n                })\\n            }\\n            .width(this.columnWidth)\\n          }, (item: BookItem) => JSON.stringify(item))\\n        }\\n        .padding({\\n          left: 12,\\n          right: 12,\\n          top: 12\\n        })\\n        .columnsTemplate(this.columnType)\\n        .columnsGap(10)\\n        .rowsGap(10)\\n\\n        // 一镜到底返回至原位置\\n        Column({ space: 12 }) {\\n          Text($r('app.string.recent_reading'))\\n            .fontSize(16)\\n            .fontWeight(FontWeight.Medium)\\n            .fontColor(Color.Gray)\\n          Swiper(this.swiperController) {\\n            ForEach(this.recentData, (item: BookItem) => {\\n              GridItem() {\\n                Image($r(item.coverImageUrl))\\n                  .id(item.id)\\n                  .onClick(() => {\\n                    this.onColumnClicked(item.id, item.coverImageUrl);\\n                  })\\n              }\\n            }, (item: BookItem) => JSON.stringify(item))\\n          }\\n          .indicator(false)\\n          .displayCount(3)\\n          .loop(false)\\n          .itemSpace(10)\\n        }\\n        .padding({\\n          left: 12,\\n          right: 12\\n        })\\n        .alignItems(HorizontalAlign.Start)\\n      }\\n    }\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "书架页面通过Grid组件实现书架第一行书籍布局，使用Swiper组件实现书架第一行书籍布局。 ",
        "import_module": null,
        "parent": "<li>书架页面通过Grid组件实现书架第一行书籍布局，使用Swiper组件实现书架第一行书籍布局。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-one-shot-to-the-end.html"
    },
    {
        "id": 175,
        "pre": "// src/main/ets/feature/VideoLongTakeTransition/NodeController.ets\\nexport class MyNodeController extends NodeController {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "创建NodeController节点类。 ",
        "import_module": null,
        "parent": "<li>创建NodeController节点类。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-one-shot-to-the-end.html"
    },
    {
        "id": 176,
        "pre": "getEl2Path() {\\n  let context = getContext(this) as common.UIAbilityContext;\\n  context.area = contextConstant.AreaMode.EL2;\\n  let filePath = context.filesDir + '/health_data.txt';\\n  this.message = filePath;\\n}",
        "type": "Reference",
        "function_call": "getEl1Path()",
        "function_name": "[h2]分级数据保护",
        "parent_text": "[h2]分级数据保护不同的文件路径具备不同的属性和特征。分级数据使用应用沙箱作为保护机制，避免数据受到恶意路径穿越访问。在应用文件目录中，根据不同的文件加密类型，区分了不同的目录。 el1，设备级加密区：设备开机后即可访问的数据区。el2，用户级加密区：设备开机后，需要至少一次解锁对应用户的锁屏界面（密码、指纹、人脸等方式或无密码状态）后，才能够访问的加密数据区。应用如无特殊需要，应将数据存放在el2加密目录下，以尽可能保证数据安全。但是对于某些场景，一些应用文件需要在用户解锁前就可被访问，例如时钟、闹铃、壁纸等，此时应用需要将这些文件存放到设备级加密区（el1）。切换应用文件加密类型目录的方法请参见获取和修改加密分区。  应用文件目录的详细介绍请参考应用文件目录。 分级数据文件路径使用应用通用文件路径，获取路径代码如下：  如果需要获取el1的路径则需要修改AreaMode，代码如下： getEl1Path() {\\n  let context = getContext(this) as common.UIAbilityContext;\\n  context.area = contextConstant.AreaMode.EL1;\\n  let filePath = context.filesDir + '/health_data.txt';\\n  this.message = filePath;\\n} 应用如无特殊需要，应将数据存放在el2加密目录下。 系统的文件级加密提供了4种加密类型实现文件保护，应用可以根据自己的述求，把文件保存到相应的数据目录。下表是各个分级加密区所对应的策略： 表4 分级加密策略分级加密  策略    el4  用户锁定设备后不久（一般为 10 秒钟），解密的数据保护类密钥会被从内存丢弃，此类的所有数据都无法访问，除非用户再次输入密码或使用指纹或面容解锁设备。   el3  用户锁定设备后，如果文件已经被打开，则文件始终可以被继续访问，一旦文件关闭（锁屏），文件将不能被再次访问，除非用户再次输入密码或使用指纹或面容解锁设备   el2  用户开机后首次解锁设备后，即可对文件进行访问。这是未分配给数据保护类的所有第三方应用数据的默认数据保护类   el1  设备在直接启动模式下和用户解锁设备后均可对文件进行访问     ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1433616432387\\\"'><a name='\\\"section1433616432387\\\"'></a><a name='\\\"section1433616432387\\\"'></a><h4>[h2]分级数据保护</h4><p>不同的文件路径具备不同的属性和特征。分级数据使用应用沙箱作为保护机制，避免数据受到恶意路径穿越访问。在应用文件目录中，根据不同的文件加密类型，区分了不同的目录。</p> <ul><li>el1，设备级加密区：设备开机后即可访问的数据区。</li><li>el2，用户级加密区：设备开机后，需要至少一次解锁对应用户的锁屏界面（密码、指纹、人脸等方式或无密码状态）后，才能够访问的加密数据区。<p>应用如无特殊需要，应将数据存放在el2加密目录下，以尽可能保证数据安全。但是对于某些场景，一些应用文件需要在用户解锁前就可被访问，例如时钟、闹铃、壁纸等，此时应用需要将这些文件存放到设备级加密区（el1）。切换应用文件加密类型目录的方法请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-context-stage#获取和修改加密分区\\\"' target='\\\"_blank\\\"'>获取和修改加密分区</a>。</p> </li></ul> <p>应用文件目录的详细介绍请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-sandbox-directory#应用文件目录与应用文件路径\\\"' target='\\\"_blank\\\"'>应用文件目录</a>。</p> <p>分级数据文件路径使用应用通用文件路径，获取路径代码如下：</p>  <p>如果需要获取el1的路径则需要修改AreaMode，代码如下：</p> <pre class='\\\"screen\\\"'>getEl1Path() {\\n  let context = getContext(this) as common.UIAbilityContext;\\n  context.area = contextConstant.AreaMode.EL1;\\n  let filePath = context.filesDir + '/health_data.txt';\\n  this.message = filePath;\\n}</pre> <p>应用如无特殊需要，应将数据存放在el2加密目录下。</p> <p>系统的文件级加密提供了4种加密类型实现文件保护，应用可以根据自己的述求，把文件保存到相应的数据目录。下表是各个分级加密区所对应的策略：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表4 </b>分级加密策略</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.19.11.2.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"10.69%\\\"'><p>分级加密</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.19.11.2.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"89.31%\\\"'><p>策略</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"10.69%\\\"'><p>el4</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"89.31%\\\"'><p>用户锁定设备后不久（一般为 10 秒钟），解密的数据保护类密钥会被从内存丢弃，此类的所有数据都无法访问，除非用户再次输入密码或使用指纹或面容解锁设备。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"10.69%\\\"'><p>el3</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"89.31%\\\"'><p>用户锁定设备后，如果文件已经被打开，则文件始终可以被继续访问，一旦文件关闭（锁屏），文件将不能被再次访问，除非用户再次输入密码或使用指纹或面容解锁设备</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"10.69%\\\"'><p>el2</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"89.31%\\\"'><p>用户开机后首次解锁设备后，即可对文件进行访问。这是未分配给数据保护类的所有第三方应用数据的默认数据保护类</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"10.69%\\\"'><p>el1</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"89.31%\\\"'><p>设备在直接启动模式下和用户解锁设备后均可对文件进行访问</p> </td> </tr> </tbody></table> </div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-data-security.html"
    },
    {
        "id": 177,
        "pre": "function getAgeInfo() {\\n  let age = 20;\\n  let name = 'jack';\\n  if (name) {\\n    return age;\\n  } else {\\n    return -1;\\n  }\\n}\\n\\nconsole.log('' + getAgeInfo());",
        "type": "Reference",
        "function_call": "getAgeInfo()",
        "function_name": "[h2]HarmonyOS资产保护关键技术介绍",
        "parent_text": "[h2]HarmonyOS资产保护关键技术介绍代码混淆 移动应用的代码安全非常重要，为了保护应用开发者的代码，避免应用被恶意逆向分析，提高攻击者分析代码的难度，DevEco Studio中默认提供了代码混淆能力，混淆后的JS、TS、ArkTS代码，不容易被逆向后读懂，混淆功能支持对名称进行混淆，包括对类、方法等做混淆处理。  代码混淆方案是基于源码混淆，将源码转为抽象语法树（AST），在AST上进行作用域分析和符号分析，混淆名称和属性，移除开发期间的日志打印代码，合并语句，压缩代码体积，在保证运行时性能无变化的前提下，有效保护HarmonyOS开发者核心知识产权免受恶意逆向分析。具体混淆效果如下例。 混淆前：  混淆后： function getAgeInfo() {\\n  let c = 0x14;\\n  let b = 'jack';\\n  if (b) {\\n    return c;\\n  } else {\\n    return -0x1;\\n  }\\n}\\n\\nconsole['log']('' + getAgeInfo()); 应用加密 为了保护应用代码安全，保护开发者的核心资产，HarmonyOS系统提供了端到端的应用代码保护机制，该机制以系统安全为基础，构建内核级应用生命周期内的代码安全保护能力。  开发者向应用市场提交上架申请，再经过应用市场审核后，应用市场会对上架应用做代码加密，应用在设备上安装时，安装文件落盘后仍是处于加密状态，有效的保护应用程序；当应用程序启动时，通过内核加载的应用文件是加密状态，因此这些文件会在内核中按页解密执行。应用加密采用标准AES加密算法，有效提高应用程序的安全性。 应用包签名 开发者对应用安装包签名后，上架应用市场。应用市场会对上架应用进行上架检测和质量审核，对于满足上架要求的应用，应用市场会对应用安装包进行重签名；只有经过重签名的上架应用，才允许在设备上安装。 HarmonyOS系统对所有安装的应用都需要进行签名校验，确保应用来源可信和应用完整性；应用安装包签名校验发生在应用安装时，如果签名校验失败，则禁止应用安装。 HarmonyOS系统使用根CA对应用安装包进行签名校验，应用安装包的签名证书都需要从根CA开始采用证书链的方式签署。 对于调试应用的安装，HarmonyOS系统在校验安装包签名基础上，还需要严格匹配应用调试Profile中的设备ID与当前设备ID的匹配，如果不匹配的话禁止安装。 对于发布应用的安装，HarmonyOS系统仅允许经过应用市场审核通过后，由应用市场重签名过的安装包进行安装。 关键资产存储 关键资产存储（Asset Store）提供了关键敏感的隐私数据的本地加密存储，应用可以将用户高安全敏感的关键资产短数据（如用户的APP账号密码，银行卡号等）在本地加密存储，加密这些数据的密钥存储在安全的隔离区，只有合法的应用才能访问并解密这些数据。具体的架构如下：  除此之外，关键资产存储还支持以下安全措施： 基于属主的访问控制： 所有的关键资产都受属主访问控制保护，业务无需设置。基于锁屏状态的访问控制：分为三种保护等级（安全性依次递增），开机后可访问、首次解锁后可访问、解锁时可访问，业务可根据实际情况设置任意一种，若不设置，则默认保护等级为“首次解锁后可访问”。基于锁屏密码设置状态的访问控制：在用户设置了锁屏密码后，关键资产才被允许访问。基于用户认证的访问控制：任意一种认证方式（指纹、人脸、PIN码）通过，均可授权本次关键资产的访问。 密钥管理 HarmonyOS系统通用密钥库系统（英文全称：HarmonyOS Universal KeyStore，以下简称HUKS）是HarmonyOS系统提供的系统级的密钥管理系统服务，提供密钥的全生命周期管理能力，包括密钥生成、密钥存储、密钥使用、密钥销毁等功能，以及对存储在HUKS中的密钥提供合法性证明。HUKS基于系统安全能力，为业务提供密钥全生命周期的安全管理，业务无需自己实现，利用HUKS的系统能力，就能确保业务密钥的安全。 HUKS的核心安全设计包括以下几点。 密钥不出安全环境：HUKS的核心特点是密钥全生命周期明文不出HUKS Core，在有硬件条件的设备上，如有TEE（Trusted Execution Environment)或安全芯片的设备，HUKS Core运行在硬件安全环境中。能确保即使REE（Rich Execution Environment）环境被攻破，密钥明文也不会泄露。 系统级安全加密存储：基于设备根密钥加密业务密钥，在有条件的设备上，叠加用户口令加密保护密钥。 严格的访问控制：只有合法的业务才有权访问密钥，同时支持用户身份认证访问控制以支持业务的高安敏感场景下安全访问密钥的诉求。 密钥的合法性证明：可为业务提供硬件厂商级别的密钥的合法性证明，证明密钥没有被篡改，并确实存在于有硬件保护的HUKS Core中，以及拥有正确的密钥属性。 此外，密钥会话是HUKS中承载密钥使用的基础，它的主要作用是初始化密钥信息、缓存业务数据等。对数据的密码学运算和对密钥密文的加解密都是在HUKS Core中进行，以此保证密钥明文和运算过程的安全。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1883722542418\\\"'><a name='\\\"section1883722542418\\\"'></a><a name='\\\"section1883722542418\\\"'></a><h4>[h2]HarmonyOS资产保护关键技术介绍</h4><p><strong>代码混淆</strong></p> <p>移动应用的代码安全非常重要，为了保护应用开发者的代码，避免应用被恶意逆向分析，提高攻击者分析代码的难度，DevEco Studio中默认提供了代码混淆能力，混淆后的JS、TS、ArkTS代码，不容易被逆向后读懂，混淆功能支持对名称进行混淆，包括对类、方法等做混淆处理。</p> <p><span><img height='\\\"72.81750000000001\\\"' originheight='\\\"127\\\"' originwidth='\\\"1266\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161228.25265775375931625601601835281407:50001231000000:2800:7176C3F8B7DDAC8EFA48620E8F4BD155B0FE25BE8F17B7F253C0AF51C48D5CBB.png\\\"' title='\\\"点击放大\\\"' width='\\\"725.874765\\\"'/></span></p> <p>代码混淆方案是基于源码混淆，将源码转为抽象语法树（AST），在AST上进行作用域分析和符号分析，<strong>混淆名称和属性，移除开发期间的日志打印代码，合并语句，压缩代码体积</strong>，在保证运行时性能无变化的前提下，有效保护HarmonyOS开发者核心知识产权免受恶意逆向分析。具体混淆效果如下例。</p> <p>混淆前：</p>  <p>混淆后：</p> <pre class='\\\"screen\\\"'>function getAgeInfo() {\\n  let c = 0x14;\\n  let b = 'jack';\\n  if (b) {\\n    return c;\\n  } else {\\n    return -0x1;\\n  }\\n}\\n\\nconsole['log']('' + getAgeInfo());</pre> <p><strong>应用加密</strong></p> <p>为了保护应用代码安全，保护开发者的核心资产，HarmonyOS系统提供了端到端的应用代码保护机制，该机制以系统安全为基础，构建内核级应用生命周期内的代码安全保护能力。</p> <p><span><img height='\\\"123.69000000000001\\\"' originheight='\\\"168\\\"' originwidth='\\\"1080\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161228.44917256190113041286821048241348:50001231000000:2800:6A224F69930F35C2C3334B5A113E3A7C8E76BBC9F6F739988D48F63B92AF02D2.png\\\"' title='\\\"点击放大\\\"' width='\\\"795.150209\\\"'/></span></p> <p>开发者向应用市场提交上架申请，再经过应用市场审核后，应用市场会对上架应用做代码加密，应用在设备上安装时，安装文件落盘后仍是处于加密状态，有效的保护应用程序；当应用程序启动时，通过内核加载的应用文件是加密状态，因此这些文件会在内核中按页解密执行。应用加密采用标准AES加密算法，有效提高应用程序的安全性。</p> <p><strong>应用包签名</strong></p> <p>开发者对应用安装包签名后，上架应用市场。应用市场会对上架应用进行上架检测和质量审核，对于满足上架要求的应用，应用市场会对应用安装包进行重签名；只有经过重签名的上架应用，才允许在设备上安装。</p> <p>HarmonyOS系统对所有安装的应用都需要进行签名校验，确保应用来源可信和应用完整性；应用安装包签名校验发生在应用安装时，如果签名校验失败，则禁止应用安装。</p> <p>HarmonyOS系统使用根CA对应用安装包进行签名校验，应用安装包的签名证书都需要从根CA开始采用证书链的方式签署。</p> <p>对于调试应用的安装，HarmonyOS系统在校验安装包签名基础上，还需要严格匹配应用调试Profile中的设备ID与当前设备ID的匹配，如果不匹配的话禁止安装。</p> <p>对于发布应用的安装，HarmonyOS系统仅允许经过应用市场审核通过后，由应用市场重签名过的安装包进行安装。</p> <p><strong>关键资产存储</strong></p> <p>关键资产存储（Asset Store）提供了关键敏感的隐私数据的本地加密存储，应用可以将用户高安全敏感的关键资产短数据（如用户的APP账号密码，银行卡号等）在本地加密存储，加密这些数据的密钥存储在安全的隔离区，只有合法的应用才能访问并解密这些数据。具体的架构如下：</p> <p><span><img height='\\\"580.5450000000001\\\"' originheight='\\\"772\\\"' originwidth='\\\"984\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161228.06171814657938105353401693159549:50001231000000:2800:254129B745EB4A450D52C373D7BDBC27F3FF865F77D31F403DA2946ED253F30C.png\\\"' title='\\\"点击放大\\\"' width='\\\"739.9694400000001\\\"'/></span></p> <p>除此之外，关键资产存储还支持以下安全措施：</p> <ul><li>基于属主的访问控制： 所有的关键资产都受属主访问控制保护，业务无需设置。</li><li>基于锁屏状态的访问控制：分为三种保护等级（安全性依次递增），开机后可访问、首次解锁后可访问、解锁时可访问，业务可根据实际情况设置任意一种，若不设置，则默认保护等级为“首次解锁后可访问”。</li><li>基于锁屏密码设置状态的访问控制：在用户设置了锁屏密码后，关键资产才被允许访问。</li><li>基于用户认证的访问控制：任意一种认证方式（指纹、人脸、PIN码）通过，均可授权本次关键资产的访问。</li></ul> <p><strong>密钥管理</strong></p> <p>HarmonyOS系统通用密钥库系统（英文全称：HarmonyOS Universal KeyStore，以下简称HUKS）是HarmonyOS系统提供的系统级的密钥管理系统服务，提供密钥的全生命周期管理能力，包括密钥生成、密钥存储、密钥使用、密钥销毁等功能，以及对存储在HUKS中的密钥提供合法性证明。HUKS基于系统安全能力，为业务提供密钥全生命周期的安全管理，业务无需自己实现，利用HUKS的系统能力，就能确保业务密钥的安全。</p> <p>HUKS的核心安全设计包括以下几点。</p> <p><strong>密钥不出安全环境：</strong>HUKS的核心特点是密钥全生命周期明文不出HUKS Core，在有硬件条件的设备上，如有TEE（Trusted Execution Environment)或安全芯片的设备，HUKS Core运行在硬件安全环境中。能确保即使REE（Rich Execution Environment）环境被攻破，密钥明文也不会泄露。</p> <p><strong>系统级安全加密存储：</strong>基于设备根密钥加密业务密钥，在有条件的设备上，叠加用户口令加密保护密钥。</p> <p><strong>严格的访问控制：</strong>只有合法的业务才有权访问密钥，同时支持用户身份认证访问控制以支持业务的高安敏感场景下安全访问密钥的诉求。</p> <p><strong>密钥的合法性证明：</strong>可为业务提供硬件厂商级别的密钥的合法性证明，证明密钥没有被篡改，并确实存在于有硬件保护的HUKS Core中，以及拥有正确的密钥属性。</p> <p>此外，密钥会话是HUKS中承载密钥使用的基础，它的主要作用是初始化密钥信息、缓存业务数据等。对数据的密码学运算和对密钥密文的加解密都是在HUKS Core中进行，以此保证密钥明文和运算过程的安全。</p> <p><span><img height='\\\"550.62\\\"' originheight='\\\"760\\\"' originwidth='\\\"1032\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161228.55923275296773495554861476275822:50001231000000:2800:83E8BC496FD992B53AA25ABDD397032CAEDF88743B892E8A57E906BBEB2BB36A.png\\\"' title='\\\"点击放大\\\"' width='\\\"747.672135\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-asset-protection-design.html"
    },
    {
        "id": 178,
        "pre": "// src/main/ets/view/hoverview/HoverUseFolderStack.ets\\n// 使用FolderStack组件全屏播放页UI结构\\nFolderStack({ upperItems: ['upper'] }) {\\n  // 视频播放组件\\n  VideoPlayView({ avPlayerUtil: this.avPlayerUtil })\\n    .id('upper')\\n  // 视频控制组件\\n  VideoControlView({ avPlayerUtil: this.avPlayerUtil })\\n  // 顶部返回组件\\n  BackTitleView({\\n    title: Const.PAGE_TITLES[0]\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]开发步骤",
        "parent_text": "[h2]开发步骤FolderStack组件实现悬停态的代码使用FolderStack作为页面的父容器，同时将视频播放组件的ID注册到upperItem数组里，这样在悬停态时视频播放组件会自动调整到上半屏显示，而视频控制组件和顶部返回组件将在下半屏显示。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1968163465613\\\"'><a name='\\\"section1968163465613\\\"'></a><a name='\\\"section1968163465613\\\"'></a><h4>[h2]开发步骤</h4><p>FolderStack组件实现悬停态的代码使用FolderStack作为页面的父容器，同时将视频播放组件的ID注册到upperItem数组里，这样在悬停态时视频播放组件会自动调整到上半屏显示，而视频控制组件和顶部返回组件将在下半屏显示。</p>  <p><span><img height='\\\"626.5896\\\"' originheight='\\\"2221\\\"' originwidth='\\\"2475\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161307.84492096049812261045597349448315:50001231000000:2800:166F3FDF4F6412CD67413FC11E965FD0C6800A4E696042A91453554F6250ED5D.png\\\"' title='\\\"点击放大\\\"' width='\\\"698.25\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-folded-hover.html"
    },
    {
        "id": 179,
        "pre": "// src/main/ets/view/hoverview/HoverUseFoldSplitContainer.ets\\n// 使用FoldSplitContainer组件全屏播放页UI结构\\nFoldSplitContainer({\\n  primary: () => {\\n    // 上半屏区域的自定义构建函数，内部为游戏画面组件\\n    this.primaryArea();\\n  },\\n  secondary: () => {\\n    // 下半屏区域的自定义构建函数，内部为游戏操作组件\\n    this.secondaryArea();\\n  }\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]开发步骤",
        "parent_text": "[h2]开发步骤使用FoldSplitContainer组件实现悬停态的代码结构是将上下屏的组件分别注册到primary和secondary参数的回调中，这样页面就呈现为上下分栏布局，并且会在悬停态自动避让折痕区域。这里二分栏结构就可以实现页面布局，因此没有实现extra参数对应的侧栏。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section43071044205711\\\"'><a name='\\\"section43071044205711\\\"'></a><a name='\\\"section43071044205711\\\"'></a><h4>[h2]开发步骤</h4><p>使用FoldSplitContainer组件实现悬停态的代码结构是将上下屏的组件分别注册到primary和secondary参数的回调中，这样页面就呈现为上下分栏布局，并且会在悬停态自动避让折痕区域。这里二分栏结构就可以实现页面布局，因此没有实现extra参数对应的侧栏。</p>  <p><span><img height='\\\"626.5896\\\"' originheight='\\\"2221\\\"' originwidth='\\\"2475\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161307.90591583579337347475297101445767:50001231000000:2800:6553970554FE98A2356AA1B97A0A01DF8D842F8FA95C45FE9036240584E279AB.png\\\"' title='\\\"点击放大\\\"' width='\\\"698.25\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-folded-hover.html"
    },
    {
        "id": 180,
        "pre": "// src/main/ets/pages/Index.ets\\nprivate onFoldStatusChange: Callback<display.FoldStatus> = (data: display.FoldStatus) => {\\n  // ...\\n  // 获取当前屏幕横竖屏状态\\n  let orientation: display.Orientation = display.getDefaultDisplaySync().orientation;\\n  if (this.pageID === 0 || this.pageID === 3) {\\n    // 半折叠且横屏状态下为悬停态\\n    if (data === display.FoldStatus.FOLD_STATUS_HALF_FOLDED && this.currentWidthBreakpoint === Const.BREAKPOINT_MD &&\\n      (orientation === display.Orientation.LANDSCAPE || orientation === display.Orientation.LANDSCAPE_INVERTED)) {\\n      this.isHover = true;\\n      // ...\\n    } else {\\n      // 折叠态和展开态以及半折叠非横屏状态为非悬停态\\n      this.isHover = false;\\n    }\\n  }\\n  // ...\\n};",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "定义监听折叠状态变化回调方法。 ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>定义监听折叠状态变化回调方法。 </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-folded-hover.html"
    },
    {
        "id": 181,
        "pre": ".parent {\\n  width: 400px;\\n}\\n.child {\\n  width: 50%; /* 200px */\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": " ",
        "import_module": null,
        "parent": "<td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"35.67643235676432%\\\"'> </td>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-web-adaptation.html"
    },
    {
        "id": 182,
        "pre": "<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n  <meta charset=\\\"UTF-8\\\" />\\n  <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" />\\n  <title>Demo</title>\\n</head>\\n<style>\\n  .container {\\n    display: grid;\\n    gap: 20px;\\n    grid-template-columns: 100px 100px 100px;\\n    grid-template-rows: 100px 100px;\\n  }\\n  .container .grid-item {\\n    background-color: #f6fdf5;\\n    text-align: center;\\n    line-height: 100px;\\n  }\\n</style>\\n<body>\\n  <div class=\\\"container\\\">\\n    <div class=\\\"grid-item\\\">1</div>\\n    <div class=\\\"grid-item\\\">2</div>\\n    <div class=\\\"grid-item\\\">3</div>\\n    <div class=\\\"grid-item\\\">4</div>\\n    <div class=\\\"grid-item\\\">5</div>\\n    <div class=\\\"grid-item\\\">6</div>\\n  </div>\\n</body>\\n</html>",
        "type": "Reference",
        "function_call": "由此需要引入repeat()",
        "function_name": "[h2]宫格布局",
        "parent_text": "[h2]宫格布局CSS中提供了grid布局，与栅格布局类似，它将网页内容划分成一个一个的网格，通过任意组合不同的网格，从而做出各种各样的布局。 图1 宫格布局示意图 关于宫格布局，有许多的概念，此处只介绍其中部分关键概念，更多概念开发者可自行查找CSS grid介绍。 容器和项目：采用网格布局的区域称为容器。容器内部采用网格定位的子元素称为项目。行与列：水平区域称为行，垂直区域称为列。行间距与列间距：两行之间或者两列之间存在的空白区域部分。 使用宫格布局，需参考以下步骤： 设置容器属性：首先要将容器的显示属性设置为display属性设置为grid。确定元素的排列方式：确定列宽与行高：列宽通过grid-template-columns进行定义，传入参数个数即为列数，各个参数的大小即为每一列的宽度，行高通过grid-template-rows进行定义，定义方式类似。确定行列间距：行间距通过row-gap控制，列间距通过column-gap控制。若行列间距相等，可以直接通过gap属性进行控制。  例如希望宫格元素按照两行三列进行排列，列宽行高均为100px，行列间距固定为20px，代码如下所示。  图2 示例代码效果图  可以看到当元素个数较少的时候，还可以通过逐个书写（即grid-template-columns: 100px 100px 100px）的方式进行排列的指定，可是当元素数量较多，如一行有十列时，这种写法可读性就会变差，由此需要引入repeat()函数，该函数接收两个参数，第一个参数为重复的次数，第二个参数为要重复的值。例如刚刚的写法也可以写成grid-template-columns: repeat(3, 100px)的形式，效果是一样的。但是在有多列时，该函数能帮助简化书写。 宫格布局可以结合媒体查询来完成宫格布局在不同设备上的体验，通过设置不同尺寸范围的排列方式来实现不同屏幕尺寸的不同效果，例如希望实现以下宫格效果。 表2 宫格布局效果图断点  sm  md  lg    效果图           在sm断点下，宫格以4列进行显示，同时行间距为12px。@media (320px<=width<600px) {\\n  .grid-functions {\\n    grid-template-columns: repeat(4, 48px);\\n    row-gap: 12px;\\n  }\\n} 在md断点下，宫格以6列进行显示，同时行间距为20px。@media (600px<=width<840px) {\\n  .grid-functions {\\n    grid-template-columns: repeat(6, 48px);\\n    row-gap: 20px;\\n  }\\n} 在lg断点下，宫格以8列进行显示，同时行间距为24px。 @media (840px<=width) {\\n  .grid-functions {\\n    grid-template-columns: repeat(8, 48px);\\n    row-gap: 24px;\\n  }\\n}  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section11134174991811\\\"'><a name='\\\"section11134174991811\\\"'></a><a name='\\\"section11134174991811\\\"'></a><h4>[h2]宫格布局</h4><p>CSS中提供了grid布局，与<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V13/arkts-layout-development-grid-layout-V13\\\"' target='\\\"_blank\\\"'>栅格布局</a>类似，它将网页内容划分成一个一个的网格，通过任意组合不同的网格，从而做出各种各样的布局。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图1 </b>宫格布局示意图</span><br/><span><img height='\\\"397.005\\\"' originheight='\\\"619\\\"' originwidth='\\\"1187\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161311.46947605306800492238198401451297:50001231000000:2800:8B7DDAE56960482B22C8D4E19F1F2E4EBB6FF8CA7258295603AE52C7FBE06F4E.png\\\"' title='\\\"点击放大\\\"' width='\\\"761.29998\\\"'/></span></div> <p>关于宫格布局，有许多的概念，此处只介绍其中部分关键概念，更多概念开发者可自行查找CSS grid介绍。</p> <ul><li>容器和项目：采用网格布局的区域称为容器。容器内部采用网格定位的子元素称为项目。</li><li>行与列：水平区域称为行，垂直区域称为列。</li><li>行间距与列间距：两行之间或者两列之间存在的空白区域部分。</li></ul> <p>使用宫格布局，需参考以下步骤：</p> <ol><li>设置容器属性：首先要将容器的显示属性设置为display属性设置为grid。</li><li>确定元素的排列方式：<ol><li>确定列宽与行高：列宽通过grid-template-columns进行定义，传入参数个数即为列数，各个参数的大小即为每一列的宽度，行高通过grid-template-rows进行定义，定义方式类似。</li><li>确定行列间距：行间距通过row-gap控制，列间距通过column-gap控制。若行列间距相等，可以直接通过gap属性进行控制。</li></ol> </li></ol> <p>例如希望宫格元素按照两行三列进行排列，列宽行高均为100px，行列间距固定为20px，代码如下所示。</p>  <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图2 </b>示例代码效果图</span></div> <p><span><img originheight='\\\"219\\\"' originwidth='\\\"342\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161311.92115636523207858265416128296556:50001231000000:2800:3DC40A0765FFAA5B3EA18CEF3D0B618EC5F4375B18C3970E026D1900432334F1.png\\\"'/></span></p> <p>可以看到当元素个数较少的时候，还可以通过逐个书写（即grid-template-columns: 100px 100px 100px）的方式进行排列的指定，可是当元素数量较多，如一行有十列时，这种写法可读性就会变差，由此需要引入repeat()函数，该函数接收两个参数，第一个参数为重复的次数，第二个参数为要重复的值。例如刚刚的写法也可以写成grid-template-columns: repeat(3, 100px)的形式，效果是一样的。但是在有多列时，该函数能帮助简化书写。</p> <p>宫格布局可以结合媒体查询来完成宫格布局在不同设备上的体验，通过设置不同尺寸范围的排列方式来实现不同屏幕尺寸的不同效果，例如希望实现以下宫格效果。</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表2 </b>宫格布局效果图</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.19.14.2.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.64%\\\"'><p>断点</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.19.14.2.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"20.01%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.19.14.2.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"27.450000000000003%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.19.14.2.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"44.9%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.64%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"20.01%\\\"'><p><span><img height='\\\"607.4908\\\"' originheight='\\\"1607\\\"' originwidth='\\\"774\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161311.35572182518543365897486067999549:50001231000000:2800:F33DBB1A681CE5BAF1C5344115C0D36A60D757C9E8315B6F1394F16215E0D2D7.png\\\"' title='\\\"点击放大\\\"' width='\\\"292.6\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.450000000000003%\\\"'><p><span><img height='\\\"533.5162\\\"' originheight='\\\"639\\\"' originwidth='\\\"573\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161311.16415982568438285029852970803814:50001231000000:2800:DF397985FF07FE650805059B483A5C410C49B4756513020FAF2A026964A686D7.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"44.9%\\\"'><p><span><img height='\\\"542.0016\\\"' originheight='\\\"559\\\"' originwidth='\\\"823\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161311.77105548307844441429146549260063:50001231000000:2800:8EBF9150E6695AC33732094C8FDF258463D0AACF4C0B35E370D20CC7FF42F598.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div> <ul><li>在sm断点下，宫格以4列进行显示，同时行间距为12px。<pre class='\\\"screen\\\"'>@media (320px&lt;=width&lt;600px) {\\n  .grid-functions {\\n    grid-template-columns: repeat(4, 48px);\\n    row-gap: 12px;\\n  }\\n}</pre> </li><li>在md断点下，宫格以6列进行显示，同时行间距为20px。<pre class='\\\"screen\\\"'>@media (600px&lt;=width&lt;840px) {\\n  .grid-functions {\\n    grid-template-columns: repeat(6, 48px);\\n    row-gap: 20px;\\n  }\\n}</pre> <ul><li>在lg断点下，宫格以8列进行显示，同时行间距为24px。</li></ul> <pre class='\\\"screen\\\"'>@media (840px&lt;=width) {\\n  .grid-functions {\\n    grid-template-columns: repeat(8, 48px);\\n    row-gap: 24px;\\n  }\\n}</pre> </li></ul> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-web-adaptation.html"
    },
    {
        "id": 183,
        "pre": "@media (320px<=width<600px) {\\n  .custom-dialog {\\n    width: 328px;\\n    height: 344px;\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在sm断点下，设置弹窗尺寸为328px*344px。 ",
        "import_module": null,
        "parent": "<li>在sm断点下，设置弹窗尺寸为328px*344px。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-web-adaptation.html"
    },
    {
        "id": 184,
        "pre": "const Banner = () => {\\n  const banner = [\\n    {id: \\\"001\\\", url: \\\"assets/banner01.png\\\"},\\n    {id: \\\"002\\\", url: \\\"assets/banner02.png\\\"},\\n    {id: \\\"003\\\", url: \\\"assets/banner03.png\\\"},\\n    {id: \\\"004\\\", url: \\\"assets/banner04.png\\\"},\\n  ];\\n\\n  const [currentIndex, setCurrentIndex] = useState(1);\\n  const [currentDot, setCurrentDot] = useState(0);\\n  const [width, setWidth] = useState<number>(0);\\n  const [singleOffset, setSingleOffset] = useState<number>(0);\\n  const [initOffset, setInitOffset] = useState<number>(0);\\n  const [gap, setGap] = useState(16);\\n  const [animate, setAnimate] = useState(\\\"transform 0.5s ease\\\");\\n  const [dotVisible, setDotVisible] = useState(false);\\n  const wrapperRef = useRef<HTMLDivElement>(null);\\n  const totalItems = banner.length;\\n\\n  useEffect(() => {\\n    const updateLayout = () => {\\n      const winWidth = window.innerWidth;\\n      if (winWidth < 600) {\\n        setGap(0); // set the distance between elements under the sm breakpoint.\\n        setWidth(winWidth - 32); // sets the element width under the sm breakpoint.\\n        setSingleOffset(winWidth - 32);  // sets the single displacement under the sm breakpoint.\\n        setInitOffset(0);  // sets the initial offset under the sm breakpoint.\\n        setDotVisible(true);\\n      } else if (winWidth < 840) {\\n        setGap(12); // set the distance between elements under the md breakpoint.\\n        setWidth((winWidth - 48 - gap) / 2); // sets the element width under the md breakpoint.\\n        setSingleOffset(width + gap); // sets the single displacement under the md breakpoint.\\n        setInitOffset(24); // sets the initial offset under the md breakpoint.\\n        setDotVisible(false);\\n      } else {\\n        setGap(16); // set the distance between elements under the lg breakpoint.\\n        setWidth((winWidth - 250 - gap) / 2); // sets the element width under the lg breakpoint.\\n        setSingleOffset(width + gap);// sets the single displacement under the lg breakpoint.\\n        setInitOffset(125); // sets the initial offset under the lg breakpoint.\\n        setDotVisible(false);\\n      }\\n    };\\n\\n    updateLayout();\\n    window.addEventListener(\\\"resize\\\", updateLayout);\\n    return () => window.removeEventListener(\\\"resize\\\", updateLayout);\\n  }, [gap, width]);\\n\\n  useEffect(() => {\\n    const interval = setInterval(() => {\\n      setCurrentIndex((prev) => prev + 1);\\n      setCurrentDot(p => (p + 1) % banner.length);\\n    }, 3000);\\n    return () => clearInterval(interval);\\n  });\\n\\n  useEffect(() => {\\n    if (currentIndex === totalItems + 1) {\\n      setTimeout(() => {\\n        setAnimate(\\\"none\\\");\\n        setCurrentIndex(1);\\n        setTimeout(() => {\\n          setAnimate(\\\"transform 0.5s ease\\\");\\n        }, 50);\\n      }, 550);\\n    }\\n  }, [currentIndex, totalItems]);\\n\\n  return (\\n    <div className=\\\"banner-container\\\">\\n      <div\\n        className=\\\"banner-wrapper\\\"\\n        ref={wrapperRef}\\n        style={{\\n          transform: `translateX(-${\\n            currentIndex * singleOffset - initOffset\\n          }px)`,\\n          transition: animate,\\n          gap: `${gap}px`,\\n        }}\\n      >\\n        {[banner[banner.length - 1], ...banner, ...banner].map(\\n          (item, index) => (\\n            <div\\n              style={{\\n                width,\\n              }}\\n              key={`${item.id}-${index}`}\\n              className=\\\"banner-item\\\"\\n            >\\n              <img src={item.url} alt={`banner-${item.id}`}/>\\n            </div>\\n          )\\n        )}\\n      </div>\\n      {dotVisible ? <div className=\\\"swiper-dot\\\">\\n        {\\n          banner.map((item, index) => <div key={item.id}\\n                                           className={`dot${currentDot === index ? ' dot-active' : ''}`}></div>)\\n        }\\n      </div> : <></>}\\n    </div>\\n  );\\n};\\n\\nexport default Banner;",
        "type": "Reference",
        "function_call": "那么需要控制translateX()",
        "function_name": "[h2]轮播布局",
        "parent_text": "[h2]轮播布局轮播布局，也就是平常说的轮播图，提供了多张图片轮流播放的功能，虽然原生Web并未提供直接实现轮播图的组件，但是可以通过一些技巧或者直接复用三方组件库，实现轮播图的效果。轮播布局的一多适配关键点如下： 控制轮播元素的尺寸：通过媒体查询结合断点或通过窗口事件，分别设置每个断点尺寸下的轮播图尺寸样式。控制轮播元素的间距：需要根据轮播元素排列方式的实现进行选择，例如如果是使用的flex布局，就可以使用gap属性来定义元素间距，更加通用的也可以使用margin属性来控制间距。控制每次轮播的位移距离：需要根据轮播的实现方案进行选择，例如使用了translateX()进行轮播的，那么需要控制translateX()每次增加的步长来实现控制轮播位移距离，如果是使用绝对定位，就需要根据对应的位移属性来控制。 此处只提供如下常见的轮播图一多效果并进行实现。 表3 轮播布局效果图断点  sm  md  lg    效果图            ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1955733061915\\\"'><a name='\\\"section1955733061915\\\"'></a><a name='\\\"section1955733061915\\\"'></a><h4>[h2]轮播布局</h4><p>轮播布局，也就是平常说的轮播图，提供了多张图片轮流播放的功能，虽然原生Web并未提供直接实现轮播图的组件，但是可以通过一些技巧或者直接复用三方组件库，实现轮播图的效果。轮播布局的一多适配关键点如下：</p> <ul><li>控制轮播元素的尺寸：通过媒体查询结合断点或通过窗口事件，分别设置每个断点尺寸下的轮播图尺寸样式。</li><li>控制轮播元素的间距：需要根据轮播元素排列方式的实现进行选择，例如如果是使用的flex布局，就可以使用gap属性来定义元素间距，更加通用的也可以使用margin属性来控制间距。</li><li>控制每次轮播的位移距离：需要根据轮播的实现方案进行选择，例如使用了translateX()进行轮播的，那么需要控制translateX()每次增加的步长来实现控制轮播位移距离，如果是使用绝对定位，就需要根据对应的位移属性来控制。</li></ul> <p>此处只提供如下常见的轮播图一多效果并进行实现。</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表3 </b>轮播布局效果图</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.5.2.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.630000000000001%\\\"'><p>断点</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.5.2.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"20.16%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.5.2.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"27.37%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.5.2.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"44.84%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.630000000000001%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"20.16%\\\"'><p><span><img height='\\\"607.4908\\\"' originheight='\\\"1607\\\"' originwidth='\\\"774\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161312.02537225802657470809124273381815:50001231000000:2800:40A5C231DB5DCA81C29AD8C5FA54474B0F8E35BA7F619CD20AC94576FF905AEB.png\\\"' title='\\\"点击放大\\\"' width='\\\"292.6\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.37%\\\"'><p><span><img height='\\\"532.6118\\\"' originheight='\\\"639\\\"' originwidth='\\\"574\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161313.19646332978180757326475492685684:50001231000000:2800:5DAA6DC5380706F244CFCF364FB7167AA8D3D2FC948978C26F6ACD17F8EA1E57.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"44.84%\\\"'><p><span><img height='\\\"542.0016\\\"' originheight='\\\"559\\\"' originwidth='\\\"823\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161313.96699324452461272036404123641117:50001231000000:2800:C4691675BBA7A2DE4C064A5B2BBFC7F6F126F9D5207175C214E36E15523AB28F.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-web-adaptation.html"
    },
    {
        "id": 185,
        "pre": "const LARGE_NUMBER = 200000000;\\nconst DELAYED_TIME = 1000;\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n\\n  aboutToAppear(): void {\\n    console.log('aboutToAppear');\\n    this.computeTask();\\n  }\\n\\n  computeTask(): void {\\n    let count = 0;\\n    while (count < LARGE_NUMBER) {\\n      count++;\\n    }\\n  }\\n\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "computeTask()",
        "function_name": "识别启动缓慢问题",
        "parent_text": "  识别启动缓慢问题 如果开发者需要分析启动过程的耗时瓶颈，优化应用或服务的冷启动速度，可使用Profiler提供的Launch场景分析能力，录制启动过程中的关键数据进行分析，从而识别出导致启动缓慢的原因所在。Profiler Launch可以拆解应用冷启动过程，抓取不同阶段的耗时数据，帮助开发者快速分析冷启动过程的耗时瓶颈，Launch的具体使用可以参考冷启动分析：Launch分析。 下面录制了一段Launch任务，具体操作步骤请参见性能问题定位：深度录制。  从上图可以看到Launch将应用的冷启动过程拆解为以下几个阶段：  Create Process：应用进程创建阶段，对应的trace打点为AbilityManagerService::StartAbilityMissionListManager::StartAbilityLocked##{bundleName}。 Application Launching：应用启动阶段，对应的trace打点为AppMgrServiceInner::AttachApplication##{bundleName}。 UI Ability Launching：UIAbility启动阶段，对应的trace打点为MainThread::HandleLaunchAbility##{bundleName}。 UI Ability OnForeground：应用进入前台阶段，对应的trace打点为AbilityThread::HandleAbilityTransaction。 First Frame - App Phase：App首帧渲染提交阶段，对应的trace打点为H:ReceiveVsync，H:MarshRSTransactionData。 First Frame - Render Phase：RS首帧渲染提交阶段，对应的trace打点为H:ReceiveVsync，H:RSMainThread::ProcessCommandUn。 EntryAbility：应用启动之后的阶段，渲染完成，首页显示，与图1中的第5阶段对应。      阶段1对应图1中的第1阶段，阶段2对应图1中的第2阶段，阶段3和4对应图1中的第3阶段，阶段5和6对应图1中的第4阶段，阶段7对应图1中的第5阶段。     冷启动缓慢示例分析 运行如下示例代码，开发者可以明显的感知应用启动比较缓慢。接下来开发者通过这个示例，结合Launch来分析应用冷启动缓慢问题。  首先是创建Launch分析录制，可以看到整个的启动时间比较长，其中UI Ability OnForeground这个阶段占据应用冷启动过程的大部分时间，耗时达到了4.1s，所以开发者需要重点分析这个阶段的耗时。  针对应用冷启动问题的性能分析，有以下两种方式可以选择，一种是分析主线程的Trace数据，另一种则是分析采样得到的函数热点。 分析主线程的Trace数据   单击“Launch”泳道上的UI Ability OnForeground阶段，在下方的“Details”详情面板中，可查看到所选阶段的耗时统计情况； 展开UI Ability OnForeground统计信息折叠表，可以看到各函数的具体耗时信息； 根据Duration找到耗时最长的函数aboutToAppear； 单击图标按钮，可直接跳转至主线程的打点任务中，查看相关Trace数据，如下图所示。   可以看到在UI Ability OnForeground阶段的耗时基本是由aboutToAppear造成的，再看aboutToAppear中的代码逻辑，可以推断是由于计算任务computeTask耗时造成的。 分析采样得到的函数热点 开发者也可以分析采样得到的函数热点直观的显示应用冷启动过程中具体函数的耗时，如下图：   单击“Launch”泳道上的UI Ability OnForeground阶段； 选择“ArkTS Callstack”泳道，其会基于时间轴展示CPU使用率和状态的变化，以及当前调用栈名称和调用类型； 下方“Details”详情面板中查看到这段时间内的函数热点，其会以Top-Down形式的树状列表进行展示。很明显aboutToAppear函数中的；computeTask函数耗时最多，占整个阶段的96.7%，双击该函数可以跳转到源码。 此外，点击底部Flame Chart按钮打开火焰图可以更直观的看出热点函数的耗时情况，如下图所示。   冷启动速度优化 通过前面的分析，冷启动缓慢是由于在aboutToAppear执行了耗时计算任务，开发者可以将该computeTask以异步延时的方式处理，优化后的代码如下： const LARGE_NUMBER = 100000000;\\nconst DELAYED_TIME = 1000;\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n\\n  aboutToAppear(): void {\\n    console.log('aboutToAppear');\\n    this.computeTaskAsync();\\n  }\\n\\n  ...\\n\\n  computeTask(): void {\\n    let count = 0;\\n    while (count < LARGE_NUMBER) {\\n      count++;\\n    }\\n  }\\n\\n  // 运算任务异步处理\\n  private computeTaskAsync(): void {\\n    setTimeout(() => { // 这里使用setTimeout来实现异步延迟运行\\n      this.computeTask();\\n    }, DELAYED_TIME);\\n  }\\n} 然后重新编译运行程序以及录制Launch，可以看到优化后UI Ability OnForeground阶段耗时大幅度缩短，如下图所示：  查看首帧卡顿 为了识别首帧是否卡顿，可以先在Launch的Frame泳道进行查看。应用的首帧渲染提交在First Frame - App Phase阶段，APP侧下面的这一帧表示应用渲染的首帧，如下图所示，此处首帧为36号帧：  如上所示36号帧被标记为了红色，表示首帧出现了卡顿。鼠标左键36号帧，可以看到它的期望提交渲染时间为左边白色竖线区域所示，这里出现了比较严重的延时。发现问题后，开发者可以参考前面讲到的示例进行问题定位和优化。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section8516174361218\\\"'> <a name='\\\"section8516174361218\\\"'></a><a name='\\\"section8516174361218\\\"'></a> <h4>识别启动缓慢问题</h4> <p>如果开发者需要分析启动过程的耗时瓶颈，优化应用或服务的冷启动速度，可使用Profiler提供的Launch场景分析能力，录制启动过程中的关键数据进行分析，从而识别出导致启动缓慢的原因所在。Profiler Launch可以拆解应用冷启动过程，抓取不同阶段的耗时数据，帮助开发者快速分析冷启动过程的耗时瓶颈，Launch的具体使用可以参考<strong><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-launch\\\"' target='\\\"_blank\\\"'>冷启动分析：Launch分析</a></strong>。</p> <p>下面录制了一段Launch任务，具体操作步骤请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/deep-recording\\\"' target='\\\"_blank\\\"'>性能问题定位：深度录制</a>。</p> <p><span><img height='\\\"272.8761\\\"' originheight='\\\"425\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.68464708395988108981473119269229:50001231000000:2800:532969A54B9D04ACEB0D7147C67E4A5976E24DA310AC3AD44D9E534D7EC2FE13.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <p>从上图可以看到Launch将应用的冷启动过程拆解为以下几个阶段：</p> <ol> <li>Create Process：应用进程创建阶段，对应的trace打点为AbilityManagerService::StartAbilityMissionListManager::StartAbilityLocked##{bundleName}。</li> <li>Application Launching：应用启动阶段，对应的trace打点为AppMgrServiceInner::AttachApplication##{bundleName}。</li> <li>UI Ability Launching：UIAbility启动阶段，对应的trace打点为MainThread::HandleLaunchAbility##{bundleName}。</li> <li>UI Ability OnForeground：应用进入前台阶段，对应的trace打点为AbilityThread::HandleAbilityTransaction。</li> <li>First Frame - App Phase：App首帧渲染提交阶段，对应的trace打点为H:ReceiveVsync，H:MarshRSTransactionData。</li> <li>First Frame - Render Phase：RS首帧渲染提交阶段，对应的trace打点为H:ReceiveVsync，H:RSMainThread::ProcessCommandUn。</li> <li>EntryAbility：应用启动之后的阶段，渲染完成，首页显示，与图1中的第5阶段对应。</li> </ol> <div class='\\\"note\\\"'> <img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.64230864252184832474289568519962:50001231000000:2800:B2D6898A749B2DCCA1C4DAD9FC75CD1E66088112B0ACD47B1E45E985363B8F73.png\\\"'/><span class='\\\"notetitle\\\"'> </span> <div class='\\\"notebody\\\"'> <p>阶段1对应图1中的第1阶段，阶段2对应图1中的第2阶段，阶段3和4对应图1中的第3阶段，阶段5和6对应图1中的第4阶段，阶段7对应图1中的第5阶段。</p> </div> </div> <p></p> <p><span><img height='\\\"302.4553\\\"' originheight='\\\"471\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.21927347100048247861628492971759:50001231000000:2800:ABBEE5492B186EF58CBA166AFAD53E0928AD821DD086B9454C78FAC94E50F864.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <p><strong>冷启动缓慢示例分析</strong></p> <p>运行如下示例代码，开发者可以明显的感知应用启动比较缓慢。接下来开发者通过这个示例，结合Launch来分析应用冷启动缓慢问题。</p>  <p>首先是创建Launch分析录制，可以看到整个的启动时间比较长，其中UI Ability OnForeground这个阶段占据应用冷启动过程的大部分时间，耗时达到了4.1s，所以开发者需要重点分析这个阶段的耗时。</p> <p><span><img height='\\\"306.9507\\\"' originheight='\\\"478\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.74845534277629559225328993528099:50001231000000:2800:C5D627C201C92B0C42B2E9BFC9404612617EAB15FFED9FA87AFF211C58AD6C56.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <p>针对应用冷启动问题的性能分析，有以下两种方式可以选择，一种是分析主线程的Trace数据，另一种则是分析采样得到的函数热点。</p> <p><strong>分析主线程的Trace数据</strong></p> <p><span><img height='\\\"430.89340000000004\\\"' originheight='\\\"671\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.42039022267393969057153780901187:50001231000000:2800:F17665889F3110FC30A21947931B50E773CE4274C31DC481ABA7CA5940AE3F66.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <ol> <li>单击“Launch”泳道上的UI Ability OnForeground阶段，在下方的“Details”详情面板中，可查看到所选阶段的耗时统计情况；</li> <li>展开UI Ability OnForeground统计信息折叠表，可以看到各函数的具体耗时信息；</li> <li>根据Duration找到耗时最长的函数aboutToAppear；</li> <li>单击图标按钮，可直接跳转至主线程的打点任务中，查看相关Trace数据，如下图所示。</li> </ol> <p><span><img height='\\\"415.4787\\\"' originheight='\\\"647\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.02914269343803680172235283759489:50001231000000:2800:CD1FEFA482C575C719F06A7674B7EE33A22338CF1EF4A1A459D430A68CCF7D67.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <p>可以看到在UI Ability OnForeground阶段的耗时基本是由aboutToAppear造成的，再看aboutToAppear中的代码逻辑，可以推断是由于计算任务computeTask耗时造成的。</p> <p><strong>分析采样得到的函数热点</strong></p> <p>开发者也可以分析采样得到的函数热点直观的显示应用冷启动过程中具体函数的耗时，如下图：</p> <p><span><img height='\\\"330.70450000000005\\\"' originheight='\\\"515\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.35423960652651520580646488916239:50001231000000:2800:4DAF845FCDC78092B2E68B86FB7608EDEC259D13ED6BF650DF3AD757581AA68A.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <ol> <li>单击“Launch”泳道上的UI Ability OnForeground阶段；</li> <li>选择“ArkTS Callstack”泳道，其会基于时间轴展示CPU使用率和状态的变化，以及当前调用栈名称和调用类型；</li> <li>下方“Details”详情面板中查看到这段时间内的函数热点，其会以Top-Down形式的树状列表进行展示。很明显aboutToAppear函数中的；computeTask函数耗时最多，占整个阶段的96.7%，双击该函数可以跳转到源码。</li> <li>此外，点击底部Flame Chart按钮打开火焰图可以更直观的看出热点函数的耗时情况，如下图所示。</li> </ol> <p><span><img height='\\\"329.4277\\\"' originheight='\\\"513\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.20332013090481708090476090765939:50001231000000:2800:1F01DF3BE9D9C39FEABA4DAB4EC9F079D0ABC32FE7E21A3AB489728AEC8876A0.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <p><strong>冷启动速度优化</strong></p> <p>通过前面的分析，冷启动缓慢是由于在aboutToAppear执行了耗时计算任务，开发者可以将该computeTask以异步延时的方式处理，优化后的代码如下：</p> <pre class='\\\"screen\\\"'>const LARGE_NUMBER = 100000000;\\nconst DELAYED_TIME = 1000;\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n\\n  aboutToAppear(): void {\\n    console.log('aboutToAppear');\\n    this.computeTaskAsync();\\n  }\\n\\n  ...\\n\\n  computeTask(): void {\\n    let count = 0;\\n    while (count &lt; LARGE_NUMBER) {\\n      count++;\\n    }\\n  }\\n\\n  // 运算任务异步处理\\n  private computeTaskAsync(): void {\\n    setTimeout(() =&gt; { // 这里使用setTimeout来实现异步延迟运行\\n      this.computeTask();\\n    }, DELAYED_TIME);\\n  }\\n}</pre> <p>然后重新编译运行程序以及录制Launch，可以看到优化后UI Ability OnForeground阶段耗时大幅度缩短，如下图所示：</p> <p><span><img height='\\\"265.202\\\"' originheight='\\\"413\\\"' originwidth='\\\"1864\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.71088168904791135201445658718334:50001231000000:2800:D458876B983295B6B920DEBC2B3E5E99A32F4C0C8A59879EB4346AE66D8C65C9.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <p><strong>查看首帧卡顿</strong></p> <p>为了识别首帧是否卡顿，可以先在Launch的Frame泳道进行查看。应用的首帧渲染提交在First Frame - App Phase阶段，APP侧下面的这一帧表示应用渲染的首帧，如下图所示，此处首帧为36号帧：</p> <p><span><img height='\\\"311.5525\\\"' originheight='\\\"481\\\"' originwidth='\\\"1848\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161209.76084313574040566997136802547714:50001231000000:2800:2F5EBCD4C1905033E355C3C59BB755429DDB79F7B7A81DE5044145329B590048.png\\\"' title='\\\"点击放大\\\"' width='\\\"1197\\\"'/></span></p> <p>如上所示36号帧被标记为了红色，表示首帧出现了卡顿。鼠标左键36号帧，可以看到它的期望提交渲染时间为左边白色竖线区域所示，这里出现了比较严重的延时。发现问题后，开发者可以参考前面讲到的示例进行问题定位和优化。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-cold-start-optimization.html"
    },
    {
        "id": 186,
        "pre": "// entry/src/main/ets/pages/Index.ets\\nimport { httpRequest } from '../utils/NetRequest';\\nimport { number } from '../utils/Calculator';\\n\\nAppStorage.link('netData');\\nPersistentStorage.persistProp('netData', undefined);\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World' + number; // 为了体现性能收益，引用耗时函数的执行结果number\\n  @StorageLink('netData') netData: PixelMap | undefined = undefined;\\n  build(){\\n    Row(){\\n      Image(this.netData)\\n        .objectFit(ImageFit.Contain)\\n        .width('50%')\\n        .height('50%')\\n    }\\n    .onAppear(() => {\\n      // 发送网络请求\\n      httpRequest();\\n    })\\n  }\\n}\\n\\n// entry/src/main/ets/utils/NetRequest.ets\\nimport { hiTraceMeter } from '@kit.PerformanceAnalysisKit';\\nimport { http } from '@kit.NetworkKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\nimport { image } from '@kit.ImageKit';\\n// 通过http的request方法从网络下载图片资源\\nexport function httpRequest() {\\n  hiTraceMeter.startTrace('Http Request', 1);\\n  http.createHttp()\\n    // 实际开发需要将\\\"https://www.example1.com/POST?e=f&g=h\\\"替换成为真实要访问的网站地址\\n    .request('https://www.example1.com/POST?e=f&g=h',\\n      (error: BusinessError, data: http.HttpResponse) => {\\n        if (error) {\\n          // 下载失败时不执行后续逻辑\\n          return;\\n        }\\n        // 处理网络请求返回的数据\\n        transcodePixelMap(data);\\n      }\\n    )\\n}\\n// 使用createPixelMap将ArrayBuffer类型的图片装换为PixelMap类型\\nfunction transcodePixelMap(data: http.HttpResponse) {\\n  if (http.ResponseCode.OK === data.responseCode) {\\n    const imageData: ArrayBuffer = data.result as ArrayBuffer;\\n    // 通过ArrayBuffer创建图片源实例\\n    const imageSource: image.ImageSource = image.createImageSource(imageData);\\n    const options: image.InitializationOptions = {\\n      'alphaType': 0, // 透明度\\n      'editable': false, // 是否可编辑\\n      'pixelFormat': 3, // 像素格式\\n      'scaleMode': 1, // 缩略值\\n      'size': { height: 100, width: 100 }\\n    }; // 创建图片大小\\n    // 通过属性创建PixelMap\\n    imageSource.createPixelMap(options).then((pixelMap: PixelMap) => {\\n      AppStorage.set('netData', pixelMap);\\n      hiTraceMeter.finishTrace('Http Request', 1);\\n    });\\n  }\\n}\\n\\n// entry/src/main/ets/utils/Calculator.ets\\nconst LARGE_NUMBER = 100000000;\\nfunction computeTask(): number {\\n  let count = 0;\\n  while (count < LARGE_NUMBER) {\\n    count++;\\n  }\\n  return count;\\n}\\nexport let number = computeTask();",
        "type": "Reference",
        "function_call": "在首页根组件的onAppear()",
        "function_name": null,
        "parent_text": "      【优化前】：在首页根组件的onAppear()周期回调中发起网络请求。       ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>      【优化前】：在首页根组件的onAppear()周期回调中发起网络请求。       </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-cold-start-optimization.html"
    },
    {
        "id": 187,
        "pre": "{\\n  \\\"module\\\": {\\n    ...\\n    \\\"abilities\\\": [\\n      {\\n        \\\"name\\\": \\\"EntryAbility\\\",\\n        \\\"srcEntry\\\": \\\"./ets/entryability/EntryAbility.ets\\\",\\n        \\\"description\\\": \\\"$string:EntryAbility_desc\\\",\\n        \\\"icon\\\": \\\"$media:icon\\\",\\n        \\\"label\\\": \\\"$string:EntryAbility_label\\\",\\n        \\\"startWindowIcon\\\": \\\"$media:startIcon\\\", // 在这里修改启动页图标，建议不要超过256像素x256像素\\n        \\\"startWindowBackground\\\": \\\"$color:start_window_background\\\",\\n\\t\\t...\\n      }\\n    ]\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]缩短应用进程创建&初始化阶段耗时",
        "parent_text": "  [h2]缩短应用进程创建&初始化阶段耗时 应用进程创建&初始化阶段主要是系统完成应用进程的创建以及初始化的过程，包含了启动页图标(startWindowIcon)的解码。使用合适分辨率的图标是影响体验的关键，建议使用不超过256*256分辨率的图片作为启动页面图标，以减少图片解码带来的时延。 设置合适分辨率的startWindowIcon 如果启动页图标分辨率过大，解码耗时会影响应用的启动速度，建议启动页图标分辨率不超过256像素*256像素，如下所示：  下面使用Launch分析，对使用优化前的启动页图标（4096像素*4096像素）及使用优化后的启动页图标（144像素*144像素）的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：  图6 优化前使用4096px*4096px启动页图标应用启动耗时   图7 优化后使用144px*144px启动页图标应用启动耗时  可见优化后应用启动时长缩短了37.2ms，故设置合适分辨率的startWindowIcon对缩短应用进程创建&初始化阶段耗时是有效的。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section5953164714132\\\"'> <a name='\\\"section5953164714132\\\"'></a><a name='\\\"section5953164714132\\\"'></a> <h4>[h2]缩短应用进程创建&amp;初始化阶段耗时</h4> <p>应用进程创建&amp;初始化阶段主要是系统完成应用进程的创建以及初始化的过程，包含了启动页图标(startWindowIcon)的解码。使用合适分辨率的图标是影响体验的关键，建议使用不超过256*256分辨率的图片作为启动页面图标，以减少图片解码带来的时延。</p> <p><strong>设置合适分辨率的startWindowIcon</strong></p> <p>如果启动页图标分辨率过大，解码耗时会影响应用的启动速度，建议启动页图标分辨率不超过256像素*256像素，如下所示：</p>  <p>下面使用Launch分析，对使用优化前的启动页图标（4096像素*4096像素）及使用优化后的启动页图标（144像素*144像素）的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图6 </b>优化前使用4096px*4096px启动页图标应用启动耗时</span><br/><span><img originheight='\\\"84\\\"' originwidth='\\\"524\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.14267618427591773717320097332560:50001231000000:2800:11B3AF1DC526DCEEAB2A9317CF783470FA7750CF37998F18C859C7DE82224C15.png\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图7 </b>优化后使用144px*144px启动页图标应用启动耗时</span><br/><span><img originheight='\\\"81\\\"' originwidth='\\\"461\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.41451830779787118672159283195405:50001231000000:2800:B91AE719BE9C8671D2BD386E4FA58B56CC790792334E0FC633887F40AFCF18B4.png\\\"'/></span> </div> <p>可见优化后应用启动时长缩短了37.2ms，故设置合适分辨率的startWindowIcon对缩短应用进程创建&amp;初始化阶段耗时是有效的。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-cold-start-optimization.html"
    },
    {
        "id": 188,
        "pre": "// 优化减少import的模块\\n/*import { ConfigurationConstant, contextConstant, wantConstant } from '@kit.AbilityKit';\\nimport { GesturePath, GesturePoint } from '@kit.AccessibilityKit';\\nimport { distributedAccount, osAccount } from '@kit.BasicServicesKit';\\nimport { Configuration } from '@kit.ArkUI';\\nimport { atomicService } from '@kit.ScenarioFusionKit';\\nimport { sim } from '@kit.TelephonyKit';*/\\n\\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { window } from '@kit.ArkUI';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "MainPage()",
        "function_name": "[h2]缩短Application&Ability初始化阶段耗时",
        "parent_text": "  [h2]缩短Application&Ability初始化阶段耗时 Application&Ability初始化阶主要包含资源加载、虚拟机创建、Application&Ability相关对象的创建与初始化、依赖模块的加载等。 主要耗时点在资源加载阶段，分为以下几个步骤。  文件加载：查找并解析所有的文件到模块中记录。 依赖模块解析（实例化）：分配内存空间来存放模块所有导出的变量，此时内存中并没有分配变量的值。 文件执行：运行.ets文件，将内存中之前未分配值的变量赋为真实的值。  本章节将针对这三个阶段可能存在的优化手段进行详细展开说明。 减少import的模块 应用代码执行前，应用程序必须找到并加载import的模块，应用程序加载的每个额外的第三方框架或者模块都会增加启动时间，耗时长短取决于加载的第三方框架或者模块的数量和大小。推荐开发者尽可能使用系统提供的模块，按需加载，来缩短应用程序的启动耗时。  下面使用Launch分析，对优化import的模块前（模块数量15个）及优化import的模块后（移除不必要的模块剩余5个）的启动性能进行对比分析。分析的trace点为H:SourceTextModule::Evaluate，优化前后的启动耗时如下图：  图8 优化前import 15个模块   图9 优化后import 5个模块  对比数据如下：     方案 阶段时长(微秒)    减少import的模块前 6239.5   减少import的模块后 119.7    可见减少不必要的模块import，可以缩短应用冷启动时间。此外，如果某些必要的模块导入比较耗时的话，可以采取动态导入的方式，具体可以参考动态加载。 减少使用嵌套export */import *的方式  减少使用嵌套export *的方式全量导出应用冷启动过程中，会在HandleLaunchAbility中执行冷启动相关.ets文件，所有被主页面import的.ets文件均会被执行，包括数据结构、变量、全局函数的初始化等。首页需要用到的变量及函数等可能来源于其他.ets文件，通过export的形式提供给首页使用。详细请参见减少使用嵌套export *的方式全量导出。 使用Launch分析，对优化前（嵌套8层export *）及优化后（不存在嵌套export *，从目标文件中直接import）的启动性能进行对比分析。分析阶段的起点为开始加载abc文件（即H:JSPandaFileExecutor::ExecuteFromAbcFile），阶段终点为abc文件加载完成。  图10 优化前，存在8层嵌套export *   图11 优化后，不存在嵌套export *，从目标文件中直接import  对比数据如下：     方案 阶段时长(微秒)    （优化前）存在8层嵌套export * 492.6   （优化后）不存在嵌套export *，从目标文件中直接import 388.7    可见阶段时长已缩短。因此减少多层文件的嵌套导出export *可以提升应用冷启动速度。 减少import *的方式全量引用应用程序加载过程中，需要使用不同模块中的变量或函数，通常开发者会将相同类型的变量或函数放在同一个工具类文件中，使用时通过import的方式引入对应的模块，当工具类中存在较多暴露函数或变量时，推荐按需引用使用到的变量代替import *的方式，可以减少该阶段中.ets文件执行耗时，即减少文件中所有export变量的初始化过程。详细请参见减少import *的方式全量引用。 对优化前（使用import * as nm全量引用2000条数据）和优化后（使用import { One }按需引用）的启动性能进行对比分析。分析阶段的起点为H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility(const std::shared_ptr<AbilityLocalRecord> &)的开始点，阶段终点为H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility(const std::shared_ptr<AbilityLocalRecord> &)的结束点。  图12 优化前，使用import * as nm全量引用2000条数据   图13 优化后，使用import { One }按需引用  优化前后的对比数据如下：     方案 阶段时长(毫秒)    （优化前）使用import * as nm全量引用 16.7   （优化后）使用import { One }按需引用 7.1    可见阶段时长已缩短。因此使用按需引用的方式，可以缩短应用冷启动完成时延。     此优化方案仅可将冷启动阶段耗时缩短，但是可能导致其他场景耗时增长，即变量初始化过程从冷启动阶段分摊至其它使用阶段，例：当二级页面使用到Numbers.ets中Two变量，此方案会使二级页面跳转过程对比优化前耗时更长。    合理拆分导出文件，减少冗余文件执行 应用程序加载模块后，需要执行应用侧的.ets文件，对其进行初始化，并执行全局初始化变量、函数。可以将文件分为两类，一类为冷启动强相关文件（如首页展示界面及组件相关文件），一类为非冷启动强相关文件（如跳转后二级页面），在冷启动过程中仅执行冷启动强相关文件，来缩短应用的启动耗时。 【场景示例】  应用存在两个页面，首页Index和二级页面SecondPage。首页展示为HAR包中MainPage.ets文件的Text组件，该文件中不包含耗时操作。点击首页中的Text组件时，会跳转至二级页面。二级页面引用了HAR包中的SubPage.ets文件，该文件存在全局函数的耗时操作，会在模块加载时执行。 HAR包中的导出文件Index.ets同时导出了MainPage.ets和SubPage.ets两个文件。当首页直接使用 “import { MainPage } from 'library/Index'” 的方式进行导入时，会导致应用在冷启动过程中执行非冷启动强相关文件SubPage.ets，增加了冷启动耗时。  图14 优化前，加载模块时执行了非冷启动相关文件SubPage.ets  以下为示例代码： // entry/src/main/ets/pages/Index.ets\\nimport { MainPage } from 'library/Index'; // 不推荐用法：直接导入了与冷启动非强相关文件SubPage.ets\\nexport struct Index{\\n  @Provide pathStack: NavPathStack = new NavPathStack();\\n  build() {\\n    Navigation(this.pathStack) {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        MainPage()\\n      }\\n    }\\n  }\\n}\\n\\n// library/src/main/ets/components/mainpage/MainPage.ets\\n@Component\\nexport struct MainPage {\\n  @Consume pathStack: NavPathStack;\\n  @State message: string = 'HAR MainPage';\\n  build() {\\n    Row() {\\n      Text(this.message)\\n        .fontSize(32)\\n        .fontWeight(FontWeight.Bold)\\n    }.onClick(() => {\\n      this.pathStack.pushPath({ name: 'SecondPage' });\\n    })\\n  }\\n}\\n\\n// entry/src/main/ets/pages/SecondPage.ets\\nimport { SubPage } from 'library/Index';\\n@Builder\\nexport function SecondPageBuilder() {\\n  SecondPage()\\n}\\n@Entry\\n@Component\\nstruct SecondPage {\\n  pathStack: NavPathStack = new NavPathStack();\\n  build() {\\n    NavDestination() {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        SubPage()\\n      }\\n      .height('100%')\\n    }\\n    .onReady((context: NavDestinationContext) => {\\n      this.pathStack = context.pathStack;\\n    })\\n  }\\n}\\n\\n// library/src/main/ets/components/mainpage/SubPage.ets\\n// SubPage中的全局耗时函数\\nconst LARGE_NUMBER = 10000000;\\nfunction computeTask(): number {\\n  let count = 0;\\n  while (count < LARGE_NUMBER) {\\n    count++;\\n  }\\n  return count;\\n}\\nlet count = computeTask();\\n// ...\\n\\n// library/Index.ets\\nexport { MainPage } from './src/main/ets/components/mainpage/MainPage'; // 冷启动强相关文件\\nexport { SubPage } from './src/main/ets/components/mainpage/SubPage'; // 非冷启动强相关文件 【优化方案一】 将HAR包的导出文件Index.ets进行拆分，IndexAppStart.ets文件仅导出首页相关文件，即MainPage.ets。IndexOthers.ets文件导出非首页相关文件，即SubPage.ets。 优点：使用此种方案优化后可以将冷启阶段（加载首页文件）与非冷启阶段（加载非首页文件）需要执行的.ets文件进行完全拆分，类比其他需优化的场景也可以使用本方案进行拆分。 缺点：需保证拆分后IndexAppStart.ets中的导出文件不存在对于IndexOthers.ets中的导出文件的引用。  图15 优化方案一，拆分HAR导出文件  示例代码如下：  将HAR包的导出文件Index.ets进行拆分，IndexAppStart.ets文件仅导出首页相关文件，IndexOthers.ets文件导出非首页相关文件。// library/IndexAppStart.ets\\nexport { MainPage } from './src/main/ets/components/mainpage/MainPage'; // library/IndexOthers.ets\\nexport { SubPage } from './src/main/ets/components/mainpage/SubPage'; 首页Index从IndexAppStart.ets导入MainPage。// Index.ets\\nimport { MainPage } from 'library/IndexAppStart';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @Provide pathStack: NavPathStack = new NavPathStack();\\n\\n  build() {\\n    Navigation(this.pathStack) {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        MainPage()\\n      }\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n} 跳转后的页面SecondPage从IndexOthers.ets导入SubPage。// SecondPage.ets\\nimport { SubPage } from 'library/IndexOthers';\\n\\n@Builder\\nexport function SecondPageBuilder() {\\n  SecondPage()\\n}\\n\\n@Entry\\n@Component\\nstruct SecondPage {\\n  pathStack: NavPathStack = new NavPathStack();\\n\\n  build() {\\n    NavDestination() {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        SubPage()\\n      }\\n      .height('100%')\\n    }\\n    .onReady((context: NavDestinationContext) => {\\n      this.pathStack = context.pathStack;\\n    })\\n  }\\n}  【优化方案二】 在首页的Index.ets文件中导入MainPage.ets时使用全路径展开。 优点：不需要新增文件来汇总导出所有冷启阶段文件。 缺点：引用时需要对所有冷启阶段文件进行路径展开，增加开发和维护成本。  图16 优化方案二，首页导入冷启动文件时使用全路径展开  示例代码如下： // Index.ets\\nimport { MainPage } from 'library/src/main/ets/components/mainpage/MainPage';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @Provide pathStack: NavPathStack = new NavPathStack();\\n\\n  build() {\\n    Navigation(this.pathStack) {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        MainPage()\\n      }\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n}     1. 上述两种优化方案默认MainPage中不存在对于SubPage中的import。 2. 当存在MainPage对于SubPage的直接import时，需要使用动态import方法来进行优化。 3. 开发者可自行根据优化方案的优缺点权衡选择合适的优化方案。   下面使用Launch分析对优化前后启动性能进行对比分析。阶段起点为UI Ability Launching的开始点，阶段终点为应用首帧即First Frame - App Phase的开始点。  图17 优化前：加载模块时执行了非冷启动相关文件   图18 优化方案一：拆分HAR导出文件   图19 优化方案二：导入冷启动文件时全路径展开  优化前后的对比数据如下：     方案 阶段时长(毫秒)    优化前 140.1   优化方案一（拆分HAR导出文件） 62.9   优化方案二（导入冷启动文件时全路径展开） 61.3    可见阶段时长已缩短，因此可以通过拆分HAR包导出的Index.ets文件或导入冷启动文件时路径全展开的方案，减少应用冷启动中.ets文件执行耗时，从而提升应用冷启动速度。 减少多个HAP/HSP对相同HAR的引用 在应用开发的过程中，可以使用HSP或HAR的共享包方式将同类的模块进行整合，可以实现多个模块或多个工程间共享ArkUI组件、资源等相关代码。同时需要注意避免多个HAP/HSP对相同HAR的引用，详细请参见多HAP/HSP引用相同HAR包的影响。 优化加载HSP时间过长 对于单窗口应用的APP工程而言，其仅包含一个Entry类型的HAP，那么划分的模块如果没有按需加载的需求，则建议业务组件和公共组件采用HAR的打包方式，最终构建应用HAP包时，这些被依赖的HAR，最终都会被编译进HAP包中。HSP是采用动态加载，在启动过程中，会将依赖的HSP加载进来，增加额外的IO与运行耗时。单HAP场景下，模块推荐使用多HAR，不推荐使用HSP。 以下为示例代码： import { add } from 'hsp1';\\nimport { add2 } from 'hsp2';\\nimport { add3 } from 'hsp3';\\nimport { add4 } from 'hsp4';\\nimport { add5 } from 'hsp5';\\nimport { add6 } from 'hsp6';\\nimport { add7 } from 'hsp7';\\nimport { add8 } from 'hsp8';\\nimport { add9 } from 'hsp9';\\nimport { add10 } from 'hsp10';\\nimport { add11 } from 'hsp11';\\nimport { add12 } from 'hsp12';\\nimport { add13 } from 'hsp13';\\nimport { add14 } from 'hsp14';\\nimport { add15 } from 'hsp15';\\nimport { add16 } from 'hsp16';\\nimport { add17 } from 'hsp17';\\nimport { add18 } from 'hsp18';\\nimport { add19 } from 'hsp19';\\nimport { add20 } from 'hsp20'; 下面使用Launch分析，HAP+20个HSP混合打包及将20个HSP包设计成HAR包的启动性能进行对比分析。  图20 HAP+20个HSP混合打包   图21 将20个HSP包设计成HAR包  对比数据如下：     方案 阶段时长(微秒)    HAP+20个HSP混合打包 34643.7   将20个HSP包设计成HAR包 36.4    因此，在单HAP场景下，如果要使用多模块的话，推荐使用多HAR，不推荐使用HSP。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section584818173141\\\"'> <a name='\\\"section584818173141\\\"'></a><a name='\\\"section584818173141\\\"'></a> <h4>[h2]缩短Application&amp;Ability初始化阶段耗时</h4> <p>Application&amp;Ability初始化阶主要包含资源加载、虚拟机创建、Application&amp;Ability相关对象的创建与初始化、依赖模块的加载等。</p> <p>主要耗时点在资源加载阶段，分为以下几个步骤。</p> <ol> <li>文件加载：查找并解析所有的文件到模块中记录。</li> <li>依赖模块解析（实例化）：分配内存空间来存放模块所有导出的变量，此时内存中并没有分配变量的值。</li> <li>文件执行：运行.ets文件，将内存中之前未分配值的变量赋为真实的值。</li> </ol> <p>本章节将针对这三个阶段可能存在的优化手段进行详细展开说明。</p> <p><strong>减少import的模块</strong></p> <p>应用代码执行前，应用程序必须找到并加载import的模块，应用程序加载的每个额外的第三方框架或者模块都会增加启动时间，耗时长短取决于加载的第三方框架或者模块的数量和大小。推荐开发者尽可能使用系统提供的模块，按需加载，来缩短应用程序的启动耗时。</p>  <p>下面使用Launch分析，对优化import的模块前（模块数量15个）及优化import的模块后（移除不必要的模块剩余5个）的启动性能进行对比分析。分析的trace点为H:SourceTextModule::Evaluate，优化前后的启动耗时如下图：</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图8 </b>优化前import 15个模块</span><br/><span><img height='\\\"216.6703\\\"' originheight='\\\"639\\\"' originwidth='\\\"1550\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.34835854483269671226949359848421:50001231000000:2800:A6BD4D27538F2EAF7F237FE95498AC15227A36D649D50FED76549A412DA4972B.png\\\"' title='\\\"点击放大\\\"' width='\\\"522.69\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图9 </b>优化后import 5个模块</span><br/><span><img height='\\\"212.74680000000004\\\"' originheight='\\\"631\\\"' originwidth='\\\"1559\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.49997607540076051312697319607703:50001231000000:2800:C5D303ACDB305BC6BF995EAEC84EF48E5481BBB17BC3E149701D5FB64661F4B1.png\\\"' title='\\\"点击放大\\\"' width='\\\"522.69\\\"'/></span> </div> <p>对比数据如下：</p> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.13.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>方案</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.13.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>阶段时长(微秒)</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>减少import的模块前</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>6239.5</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>减少import的模块后</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>119.7</p></td> </tr> </tbody></table> </div> <p>可见减少不必要的模块import，可以缩短应用冷启动时间。此外，如果某些必要的模块导入比较耗时的话，可以采取动态导入的方式，具体可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dynamic-import\\\"' target='\\\"_blank\\\"'>动态加载</a>。</p> <p><strong>减少使用嵌套export */import *的方式</strong></p> <ul> <li>减少使用嵌套export *的方式全量导出<p>应用冷启动过程中，会在HandleLaunchAbility中执行冷启动相关.ets文件，所有被主页面import的.ets文件均会被执行，包括数据结构、变量、全局函数的初始化等。首页需要用到的变量及函数等可能来源于其他.ets文件，通过export的形式提供给首页使用。详细请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-arkts-high-performance#section866673556\\\"'>减少使用嵌套export *的方式全量导出</a>。</p> <p>使用Launch分析，对优化前（嵌套8层export *）及优化后（不存在嵌套export *，从目标文件中直接import）的启动性能进行对比分析。分析阶段的起点为开始加载abc文件（即H:JSPandaFileExecutor::ExecuteFromAbcFile），阶段终点为abc文件加载完成。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图10 </b>优化前，存在8层嵌套export *</span><br/><span><img height='\\\"91.77000000000001\\\"' originheight='\\\"280\\\"' originwidth='\\\"1590\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.32012390697750244759237436878902:50001231000000:2800:AB5BDEF807E98356A1FA7F6704D44544E0C582EED936E8CB4D47C88FFF9A8455.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图11 </b>优化后，不存在嵌套export *，从目标文件中直接import</span><br/><span><img height='\\\"85.78500000000001\\\"' originheight='\\\"261\\\"' originwidth='\\\"1589\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.81988598424884635032799479572187:50001231000000:2800:40630F2A3C1C827428591C350066AAE0A75760FFBA974BDEE1F9AB0E9D3FB028.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <p>对比数据如下：</p> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.16.1.6.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"55.510000000000005%\\\"'><p>方案</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.16.1.6.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"44.49%\\\"'><p>阶段时长(微秒)</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"55.510000000000005%\\\"'><p>（优化前）存在8层嵌套export *</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"44.49%\\\"'><p>492.6</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"55.510000000000005%\\\"'><p>（优化后）不存在嵌套export *，从目标文件中直接import</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"44.49%\\\"'><p>388.7</p></td> </tr> </tbody></table> </div> <p>可见阶段时长已缩短。因此减少多层文件的嵌套导出export *可以提升应用冷启动速度。</p></li> <li>减少import *的方式全量引用<p>应用程序加载过程中，需要使用不同模块中的变量或函数，通常开发者会将相同类型的变量或函数放在同一个工具类文件中，使用时通过import的方式引入对应的模块，当工具类中存在较多暴露函数或变量时，推荐按需引用使用到的变量代替import *的方式，可以减少该阶段中.ets文件执行耗时，即减少文件中所有export变量的初始化过程。详细请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-arkts-high-performance#section745724616563\\\"'>减少import *的方式全量引用</a>。</p> <p>对优化前（使用import * as nm全量引用2000条数据）和优化后（使用import { One }按需引用）的启动性能进行对比分析。分析阶段的起点为H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility(const std::shared_ptr&lt;AbilityLocalRecord&gt; &amp;)的开始点，阶段终点为H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility(const std::shared_ptr&lt;AbilityLocalRecord&gt; &amp;)的结束点。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图12 </b>优化前，使用import * as nm全量引用2000条数据</span><br/><span><img height='\\\"82.7925\\\"' originheight='\\\"253\\\"' originwidth='\\\"1584\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.26426679365446737717454848426977:50001231000000:2800:6ECC135388A5C9FA7A6B77405C4B92988DEEC62EA647E7B91400AF5C03891375.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图13 </b>优化后，使用import { One }按需引用</span><br/><span><img height='\\\"84.78750000000001\\\"' originheight='\\\"259\\\"' originwidth='\\\"1588\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.35907872239095958097151943575040:50001231000000:2800:442EA5050AA7F9437997D5C687140D9DCBD57594D6F3AD742560038702325CD3.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <p>优化前后的对比数据如下：</p> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.16.2.6.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>方案</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.16.2.6.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>阶段时长(毫秒)</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>（优化前）使用import * as nm全量引用</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>16.7</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>（优化后）使用import { One }按需引用</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>7.1</p></td> </tr> </tbody></table> </div> <p>可见阶段时长已缩短。因此使用按需引用的方式，可以缩短应用冷启动完成时延。</p> <div class='\\\"note\\\"'> <img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.65996270638641820822966679147787:50001231000000:2800:97E15604798BB7228F0D26114EDBFA4BE1D2DE0A1850468B9F5C8FDE681D2B72.png\\\"'/><span class='\\\"notetitle\\\"'> </span> <div class='\\\"notebody\\\"'> <p>此优化方案仅可将冷启动阶段耗时缩短，但是可能导致其他场景耗时增长，即变量初始化过程从冷启动阶段分摊至其它使用阶段，例：当二级页面使用到Numbers.ets中Two变量，此方案会使二级页面跳转过程对比优化前耗时更长。</p> </div> </div></li> </ul> <p><strong>合理拆分导出文件，减少冗余文件执行</strong></p> <p>应用程序加载模块后，需要执行应用侧的.ets文件，对其进行初始化，并执行全局初始化变量、函数。可以将文件分为两类，一类为冷启动强相关文件（如首页展示界面及组件相关文件），一类为非冷启动强相关文件（如跳转后二级页面），在冷启动过程中仅执行冷启动强相关文件，来缩短应用的启动耗时。</p> <p>【场景示例】</p> <p></p> <p>应用存在两个页面，首页Index和二级页面SecondPage。首页展示为HAR包中MainPage.ets文件的Text组件，该文件中不包含耗时操作。点击首页中的Text组件时，会跳转至二级页面。二级页面引用了HAR包中的SubPage.ets文件，该文件存在全局函数的耗时操作，会在模块加载时执行。</p> <p>HAR包中的导出文件Index.ets同时导出了MainPage.ets和SubPage.ets两个文件。当首页直接使用 “import { MainPage } from 'library/Index'” 的方式进行导入时，会导致应用在冷启动过程中执行非冷启动强相关文件SubPage.ets，增加了冷启动耗时。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图14 </b>优化前，加载模块时执行了非冷启动相关文件SubPage.ets</span><br/><span><img height='\\\"440.89500000000004\\\"' originheight='\\\"1232\\\"' originwidth='\\\"1463\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.62345565600516078695446622427547:50001231000000:2800:4A9E4802F13D7B7D7E97DE6B480686FEB9FA57F607F5478DE00FF1437E7A5EBF.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <p>以下为示例代码：</p> <pre class='\\\"screen\\\"'>// entry/src/main/ets/pages/Index.ets\\nimport { MainPage } from 'library/Index'; // 不推荐用法：直接导入了与冷启动非强相关文件SubPage.ets\\nexport struct Index{\\n  @Provide pathStack: NavPathStack = new NavPathStack();\\n  build() {\\n    Navigation(this.pathStack) {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        MainPage()\\n      }\\n    }\\n  }\\n}\\n\\n// library/src/main/ets/components/mainpage/MainPage.ets\\n@Component\\nexport struct MainPage {\\n  @Consume pathStack: NavPathStack;\\n  @State message: string = 'HAR MainPage';\\n  build() {\\n    Row() {\\n      Text(this.message)\\n        .fontSize(32)\\n        .fontWeight(FontWeight.Bold)\\n    }.onClick(() =&gt; {\\n      this.pathStack.pushPath({ name: 'SecondPage' });\\n    })\\n  }\\n}\\n\\n// entry/src/main/ets/pages/SecondPage.ets\\nimport { SubPage } from 'library/Index';\\n@Builder\\nexport function SecondPageBuilder() {\\n  SecondPage()\\n}\\n@Entry\\n@Component\\nstruct SecondPage {\\n  pathStack: NavPathStack = new NavPathStack();\\n  build() {\\n    NavDestination() {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        SubPage()\\n      }\\n      .height('100%')\\n    }\\n    .onReady((context: NavDestinationContext) =&gt; {\\n      this.pathStack = context.pathStack;\\n    })\\n  }\\n}\\n\\n// library/src/main/ets/components/mainpage/SubPage.ets\\n// SubPage中的全局耗时函数\\nconst LARGE_NUMBER = 10000000;\\nfunction computeTask(): number {\\n  let count = 0;\\n  while (count &lt; LARGE_NUMBER) {\\n    count++;\\n  }\\n  return count;\\n}\\nlet count = computeTask();\\n// ...\\n\\n// library/Index.ets\\nexport { MainPage } from './src/main/ets/components/mainpage/MainPage'; // 冷启动强相关文件\\nexport { SubPage } from './src/main/ets/components/mainpage/SubPage'; // 非冷启动强相关文件</pre> <p>【优化方案一】</p> <p>将HAR包的导出文件Index.ets进行拆分，IndexAppStart.ets文件仅导出首页相关文件，即MainPage.ets。IndexOthers.ets文件导出非首页相关文件，即SubPage.ets。</p> <p>优点：使用此种方案优化后可以将冷启阶段（加载首页文件）与非冷启阶段（加载非首页文件）需要执行的.ets文件进行完全拆分，类比其他需优化的场景也可以使用本方案进行拆分。</p> <p>缺点：需保证拆分后IndexAppStart.ets中的导出文件不存在对于IndexOthers.ets中的导出文件的引用。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图15 </b>优化方案一，拆分HAR导出文件</span><br/><span><img height='\\\"439.89750000000004\\\"' originheight='\\\"1243\\\"' originwidth='\\\"1478\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161210.66853121117882745687589386815964:50001231000000:2800:8AA63FD7C1C7D47551A2A2C0CD2219DB751927D8149BA818B84B7F9D269384B6.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <p>示例代码如下：</p> <ol> <li>将HAR包的导出文件Index.ets进行拆分，IndexAppStart.ets文件仅导出首页相关文件，IndexOthers.ets文件导出非首页相关文件。<pre class='\\\"screen\\\"'>// library/IndexAppStart.ets\\nexport { MainPage } from './src/main/ets/components/mainpage/MainPage';</pre> <pre class='\\\"screen\\\"'>// library/IndexOthers.ets\\nexport { SubPage } from './src/main/ets/components/mainpage/SubPage';</pre></li> <li>首页Index从IndexAppStart.ets导入MainPage。<pre class='\\\"screen\\\"'>// Index.ets\\nimport { MainPage } from 'library/IndexAppStart';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @Provide pathStack: NavPathStack = new NavPathStack();\\n\\n  build() {\\n    Navigation(this.pathStack) {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        MainPage()\\n      }\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n}</pre></li> <li>跳转后的页面SecondPage从IndexOthers.ets导入SubPage。<pre class='\\\"screen\\\"'>// SecondPage.ets\\nimport { SubPage } from 'library/IndexOthers';\\n\\n@Builder\\nexport function SecondPageBuilder() {\\n  SecondPage()\\n}\\n\\n@Entry\\n@Component\\nstruct SecondPage {\\n  pathStack: NavPathStack = new NavPathStack();\\n\\n  build() {\\n    NavDestination() {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        SubPage()\\n      }\\n      .height('100%')\\n    }\\n    .onReady((context: NavDestinationContext) =&gt; {\\n      this.pathStack = context.pathStack;\\n    })\\n  }\\n}</pre></li> </ol> <p>【优化方案二】</p> <p>在首页的Index.ets文件中导入MainPage.ets时使用全路径展开。</p> <p>优点：不需要新增文件来汇总导出所有冷启阶段文件。</p> <p>缺点：引用时需要对所有冷启阶段文件进行路径展开，增加开发和维护成本。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图16 </b>优化方案二，首页导入冷启动文件时使用全路径展开</span><br/><span><img height='\\\"400.995\\\"' originheight='\\\"1188\\\"' originwidth='\\\"1548\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.84603649959955322406689131090202:50001231000000:2800:D66BB93E78D052F345DBD4A7333F8E2322B721B9B7AD924D9004C1687338FA98.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <p>示例代码如下：</p> <pre class='\\\"screen\\\"'>// Index.ets\\nimport { MainPage } from 'library/src/main/ets/components/mainpage/MainPage';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @Provide pathStack: NavPathStack = new NavPathStack();\\n\\n  build() {\\n    Navigation(this.pathStack) {\\n      Row() {\\n        // 引用HAR的自定义组件\\n        MainPage()\\n      }\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n}</pre> <div class='\\\"note\\\"'> <img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.07214442319055446044226235250672:50001231000000:2800:E9F1F0135FE51A260E80F9E786273AFA3D2221D8977FB56BFB71CD882FED6947.png\\\"'/><span class='\\\"notetitle\\\"'> </span> <div class='\\\"notebody\\\"'> <p>1. 上述两种优化方案默认MainPage中不存在对于SubPage中的import。</p> <p>2. 当存在MainPage对于SubPage的直接import时，需要使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-dynamic-import\\\"' target='\\\"_blank\\\"'>动态import</a>方法来进行优化。</p> <p>3. 开发者可自行根据优化方案的优缺点权衡选择合适的优化方案。</p> </div> </div> <p>下面使用Launch分析对优化前后启动性能进行对比分析。阶段起点为UI Ability Launching的开始点，阶段终点为应用首帧即First Frame - App Phase的开始点。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图17 </b>优化前：加载模块时执行了非冷启动相关文件</span><br/><span><img height='\\\"35.910000000000004\\\"' originheight='\\\"108\\\"' originwidth='\\\"1538\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.94820593637883835140203209813381:50001231000000:2800:135324713848A06D6F439E27604C3A1303976D0420784279B8D52BC38CA5F14B.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图18 </b>优化方案一：拆分HAR导出文件</span><br/><span><img height='\\\"35.910000000000004\\\"' originheight='\\\"104\\\"' originwidth='\\\"1479\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.32599314523503751536359881196766:50001231000000:2800:04A016360340366F623848C34E0ABA72937B87BCA9A95C270B94469096655818.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图19 </b>优化方案二：导入冷启动文件时全路径展开</span><br/><span><img height='\\\"37.905\\\"' originheight='\\\"105\\\"' originwidth='\\\"1431\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.39720649020853337974547407294272:50001231000000:2800:E5E157B7DBC8AB0D07340A986857C9F7EBE19DE5D54D3BC52CDCA6FD7AD6F905.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <p>优化前后的对比数据如下：</p> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.46.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>方案</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.46.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>阶段时长(毫秒)</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>优化前</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>140.1</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>优化方案一（拆分HAR导出文件）</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>62.9</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>优化方案二（导入冷启动文件时全路径展开）</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>61.3</p></td> </tr> </tbody></table> </div> <p>可见阶段时长已缩短，因此可以通过拆分HAR包导出的Index.ets文件或导入冷启动文件时路径全展开的方案，减少应用冷启动中.ets文件执行耗时，从而提升应用冷启动速度。</p> <p><strong>减少多个HAP/HSP对相同HAR的引用</strong></p> <p>在应用开发的过程中，可以使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp\\\"' target='\\\"_blank\\\"'>HSP</a>或<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package\\\"' target='\\\"_blank\\\"'>HAR</a>的共享包方式将同类的模块进行整合，可以实现多个模块或多个工程间共享ArkUI组件、资源等相关代码。同时需要注意避免多个HAP/HSP对相同HAR的引用，详细请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-modular-design#section9492615385\\\"'>多HAP/HSP引用相同HAR包的影响</a>。</p> <p><strong>优化加载HSP时间过长</strong></p> <p>对于单窗口应用的APP工程而言，其仅包含一个Entry类型的HAP，那么划分的模块如果没有按需加载的需求，则建议业务组件和公共组件采用HAR的打包方式，最终构建应用HAP包时，这些被依赖的HAR，最终都会被编译进HAP包中。HSP是采用动态加载，在启动过程中，会将依赖的HSP加载进来，增加额外的IO与运行耗时。单HAP场景下，模块推荐使用多HAR，不推荐使用HSP。</p> <p>以下为示例代码：</p> <pre class='\\\"screen\\\"'>import { add } from 'hsp1';\\nimport { add2 } from 'hsp2';\\nimport { add3 } from 'hsp3';\\nimport { add4 } from 'hsp4';\\nimport { add5 } from 'hsp5';\\nimport { add6 } from 'hsp6';\\nimport { add7 } from 'hsp7';\\nimport { add8 } from 'hsp8';\\nimport { add9 } from 'hsp9';\\nimport { add10 } from 'hsp10';\\nimport { add11 } from 'hsp11';\\nimport { add12 } from 'hsp12';\\nimport { add13 } from 'hsp13';\\nimport { add14 } from 'hsp14';\\nimport { add15 } from 'hsp15';\\nimport { add16 } from 'hsp16';\\nimport { add17 } from 'hsp17';\\nimport { add18 } from 'hsp18';\\nimport { add19 } from 'hsp19';\\nimport { add20 } from 'hsp20';</pre> <p>下面使用Launch分析，HAP+20个HSP混合打包及将20个HSP包设计成HAR包的启动性能进行对比分析。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图20 </b>HAP+20个HSP混合打包</span><br/><span><img height='\\\"215.6329\\\"' originheight='\\\"638\\\"' originwidth='\\\"1555\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.20117907789166561339577417904902:50001231000000:2800:5AF3AF99A048CD726D7AFCDA8A1EEB6F0972BCF53C039E59E001E63E34828E1B.png\\\"' title='\\\"点击放大\\\"' width='\\\"522.69\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图21 </b>将20个HSP包设计成HAR包</span><br/><span><img height='\\\"190.2831\\\"' originheight='\\\"563\\\"' originwidth='\\\"1557\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.59199698148702116597149594816228:50001231000000:2800:8C1D9D7B1B4A2AE87532CCF3DB497D07C978E0D8595DDAA063FEECEA8ECD9632.png\\\"' title='\\\"点击放大\\\"' width='\\\"522.69\\\"'/></span> </div> <p>对比数据如下：</p> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.58.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>方案</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.9.58.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>阶段时长(微秒)</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>HAP+20个HSP混合打包</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>34643.7</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>将20个HSP包设计成HAR包</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>36.4</p></td> </tr> </tbody></table> </div> <p>因此，在单HAP场景下，如果要使用多模块的话，推荐使用多HAR，不推荐使用HSP。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-cold-start-optimization.html"
    },
    {
        "id": 189,
        "pre": "const LARGE_NUMBER = 100000000;\\nconst DELAYED_TIME = 1000;\\n\\nexport default class MyAbilityStage extends AbilityStage {\\n  onCreate(): void {\\n    // 耗时操作\\n    // this.computeTask(); \\n    this.computeTaskAsync(); // 异步任务\\n  }\\n\\n  onAcceptWant(want: Want): string {\\n    // 仅specified模式下触发\\n    return 'MyAbilityStage';\\n  }\\n\\n  private computeTask(): void {\\n    let count = 0;\\n    while (count < LARGE_NUMBER) {\\n      count++;\\n    }\\n  }\\n\\n  private computeTaskAsync(): void {\\n    setTimeout(() => { // 这里使用setTimeout来实现异步延迟运行\\n      this.computeTask();\\n    }, DELAYED_TIME);\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]缩短AbilityStage生命周期阶段耗时",
        "parent_text": "  [h2]缩短AbilityStage生命周期阶段耗时 AbilityStage生命周期阶段主要是在AbilityStage的启动生命周期，执行相应的生命周期回调。 避免在AbilityStage生命周期回调接口进行耗时操作 在应用启动流程中，系统会执行AbilityStage的生命周期回调函数。因此，不建议在这些回调函数中执行耗时过长的操作，比如onCreate，耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：TaskPool和Worker的对比实践。在这些生命周期回调里，推荐开发者只做必要的操作，关于AbilityStage可以参考：AbilityStage组件容器，以下为示例代码：  下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：  图22 优化前同步执行操作（computeTask），应用冷启动耗时   图23 优化前异步执行操作（computeTaskAsync），应用冷启动耗时  可见使用异步后，应用冷启动时间速度有了较大的提升，耗时从2.2s减少到了220.9ms。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section178661559171413\\\"'> <a name='\\\"section178661559171413\\\"'></a><a name='\\\"section178661559171413\\\"'></a> <h4>[h2]缩短AbilityStage生命周期阶段耗时</h4> <p>AbilityStage生命周期阶段主要是在AbilityStage的启动生命周期，执行相应的生命周期回调。</p> <p><strong>避免在AbilityStage生命周期回调接口进行耗时操作</strong></p> <p>在应用启动流程中，系统会执行AbilityStage的生命周期回调函数。因此，不建议在这些回调函数中执行耗时过长的操作，比如onCreate，耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-comparative_practice_of_taskpool_and_worker\\\"'>TaskPool和Worker的对比实践</a>。在这些生命周期回调里，推荐开发者只做必要的操作，关于AbilityStage可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/abilitystage\\\"' target='\\\"_blank\\\"'>AbilityStage组件容器</a>，以下为示例代码：</p>  <p>下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图22 </b>优化前同步执行操作（computeTask），应用冷启动耗时</span><br/><span><img originheight='\\\"81\\\"' originwidth='\\\"759\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.74959534789003297205486780489287:50001231000000:2800:232CEB69ED17FC83E3AAD63CAEC848E88F8E7EC01544C68D062802609804CD5D.png\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图23 </b>优化前异步执行操作（computeTaskAsync），应用冷启动耗时</span><br/><span><img originheight='\\\"79\\\"' originwidth='\\\"523\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.62301412419547927195156972488323:50001231000000:2800:98CCB1354D53D6AB0840966B113BEAB0DF72095BCD856763A1D7AAA1F9D53FDB.png\\\"'/></span> </div> <p>可见使用异步后，应用冷启动时间速度有了较大的提升，耗时从2.2s减少到了220.9ms。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-cold-start-optimization.html"
    },
    {
        "id": 190,
        "pre": "const LARGE_NUMBER = 100000000;\\nconst DELAYED_TIME = 1000;\\n\\nexport default class EntryAbility extends UIAbility {\\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    // 耗时操作\\n    // this.computeTask();\\n    this.computeTaskAsync(); // 异步任务\\n  }\\n\\n  onWindowStageCreate(windowStage: window.WindowStage): void {\\n    windowStage.loadContent('pages/Index', (err, data) => {\\n      if (err.code) {\\n        logger.error('Failed to load the content. Cause: ' + JSON.stringify(err) ?? '');\\n        return;\\n      }\\n      logger.info('Succeeded in loading the content. Data: ' + JSON.stringify(data) ?? '');\\n    });\\n\\n    // 耗时操作\\n    // this.computeTask();\\n    // this.computeTaskAsync(); // 异步任务\\n  }\\n\\n  onForeground(): void {\\n    // 耗时操作\\n    // this.computeTask();\\n    // this.computeTaskAsync(); // 异步任务\\n  }\\n\\n  private computeTask(): void {\\n    let count = 0;\\n    while (count < LARGE_NUMBER) {\\n      count++;\\n    }\\n  }\\n\\n  private computeTaskAsync(): void {\\n    setTimeout(() => { // 这里使用setTimeout来实现异步延迟运行\\n      this.computeTask();\\n    }, DELAYED_TIME);\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]缩短Ability生命周期阶段耗时",
        "parent_text": "  [h2]缩短Ability生命周期阶段耗时 Ability生命周期阶段主要是在Ability的启动生命周期，执行相应的生命周期回调。 避免在Ability生命周期回调接口进行耗时操作 在应用启动流程中，系统会执行Ability的生命周期回调函数。因此，不建议在这些回调函数中执行耗时过长的操作，耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：TaskPool和Worker的对比实践。 在这些生命周期回调里，推荐开发者只做必要的操作，下面以UIAbility为例进行说明。比如在生命周期回调函数onCreate、onWindowStageCreate、onForeground等中执行耗时操作都会导致启动缓慢问题，关于UIAbility组件生命周期的详细说明，参见UIAbility组件生命周期。  图24 UIAbility生命周期状态  下面示例代码在UIAbility的回调函数onCreate中分别执行了同步和异步操作：  下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：  图25 优化前同步执行操作（computeTask），应用冷启动耗时   图26 优化后异步执行操作（computeTaskAsync），应用冷启动耗时  可见使用延时异步后，应用冷启动时间速度有了较大的提升，耗时从2.1s减少到了220ms。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1161113241512\\\"'> <a name='\\\"section1161113241512\\\"'></a><a name='\\\"section1161113241512\\\"'></a> <h4>[h2]缩短Ability生命周期阶段耗时</h4> <p>Ability生命周期阶段主要是在Ability的启动生命周期，执行相应的生命周期回调。</p> <p><strong>避免在Ability生命周期回调接口进行耗时操作</strong></p> <p>在应用启动流程中，系统会执行Ability的生命周期回调函数。因此，不建议在这些回调函数中执行耗时过长的操作，耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-comparative_practice_of_taskpool_and_worker\\\"'>TaskPool和Worker的对比实践</a>。</p> <p>在这些生命周期回调里，推荐开发者只做必要的操作，下面以UIAbility为例进行说明。比如在生命周期回调函数onCreate、onWindowStageCreate、onForeground等中执行耗时操作都会导致启动缓慢问题，关于UIAbility组件生命周期的详细说明，参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-lifecycle\\\"' target='\\\"_blank\\\"'>UIAbility组件生命周期</a>。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图24 </b>UIAbility生命周期状态</span><br/><span><img height='\\\"452.017125\\\"' originheight='\\\"570\\\"' originwidth='\\\"400\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.86056506475381553015384919603503:50001231000000:2800:9FBF3CF3D9988FC56B29E98C1CDEC811AA7EF6A0B9EE0969D72C19460512784B.png\\\"' title='\\\"点击放大\\\"' width='\\\"317.20500000000004\\\"'/></span> </div> <p>下面示例代码在UIAbility的回调函数onCreate中分别执行了同步和异步操作：</p>  <p>下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase，优化前后的启动耗时如下图：</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图25 </b>优化前同步执行操作（computeTask），应用冷启动耗时</span><br/><span><img originheight='\\\"78\\\"' originwidth='\\\"694\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.15611027830284136277351472528276:50001231000000:2800:11C016A6EB8D898F9D726CB8CED9E46B20204673C905D2452A3B109B952D954F.png\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图26 </b>优化后异步执行操作（computeTaskAsync），应用冷启动耗时</span><br/><span><img originheight='\\\"79\\\"' originwidth='\\\"482\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.66753687043605731597381269246578:50001231000000:2800:B06DBFA877FAF59ED413F623EC4FF44DC4EB84FDD28BF33F203BD9D54E913331.png\\\"'/></span> </div> <p>可见使用延时异步后，应用冷启动时间速度有了较大的提升，耗时从2.1s减少到了220ms。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-cold-start-optimization.html"
    },
    {
        "id": 191,
        "pre": "const LARGE_NUMBER = 100000000;\\nconst DELAYED_TIME = 1000;\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n\\n  aboutToAppear(): void {\\n    // 耗时操作\\n    // this.computeTask();\\n    this.computeTaskAsync(); // 异步任务\\n  }\\n\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n\\n  private computeTask(): void {\\n    let count = 0;\\n    while (count < LARGE_NUMBER) {\\n      count++;\\n    }\\n  }\\n\\n  // 运算任务异步处理\\n  private computeTaskAsync(): void {\\n    setTimeout(() => { // 这里使用setTimeout来实现异步延迟运行\\n      this.computeTask();\\n    }, DELAYED_TIME);\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]缩短加载绘制首页阶段耗时",
        "parent_text": "  [h2]缩短加载绘制首页阶段耗时 首页加载绘制阶段主要包含加载首页内容、测量布局、刷新组件并绘制。同样注意页面生命周期的处理函数，不要进行耗时操作，同时，应优先创建首页需要显示的组件，使用if分支语句，隐藏不需要显示的组件，减少创建过程的耗时。耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：TaskPool和Worker的对比实践。 自定义组件生命周期回调接口里避免耗时操作 自定义组件的生命周期变更会调用相应的回调函数，aboutToAppear函数会在创建自定义组件实例后，页面绘制之前执行，而onPageShow则是在页面进入前台的时候显示，因此避免在这两个回调函数中执行该耗时操作，不阻塞页面绘制。关于自定义组件生命周期的详细说明，参见页面和自定义组件生命周期。  图27 被@Entry装饰的组件（页面）生命周期  以下为示例代码在Page的回调函数aboutToAppear中分别执行了同步和异步操作：  下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase。 优化前后的启动耗时如下图：  图28 优化前同步执行操作（computeTask），应用冷启动耗时   图29 优化后异步执行操作（computeTaskAsync），应用冷启动耗时  可见使用异步后，应用冷启动时间速度有了较大的提升，耗时从2.4s减少到了238.3ms。 使用本地存储首页数据 在应用启动流程中，大部分应用的首页数据信息需要等待网络请求返回的数据解析结果，因此可以将首页数据通过数据库、Preferences、文件、AppStorage等方式进行本地存储，再次冷启动时优先展示已存储数据，网络请求后再次刷新首页数据。  图30 使用本地存储首页数据流程图 使用本地存储优先展示，可以减少首帧展示完成时延，减少用户可见白屏或白块时间，提升用户的冷启动体验。      应用需根据自身对于数据的时效性要求，来决定是否使用本地存储数据。例如时效性要求为一天时，一天前保存的数据就不适合进行展示，需从网络获取新数据进行展示，并更新本地存储数据。   【场景示例】 应用首页需展示一张从网站获取的图片信息，在aboutToAppear()中发起网络请求，待数据返回解析后展示在首页上。之后将图片信息存储至本地应用沙箱内，再次冷启动时首先从沙箱内获取图片信息，若存在即可解析并展示，在网络请求返回时再次更新图片信息。 以下为关键示例代码： // Index.ets\\nimport { http } from '@kit.NetworkKit';\\nimport { image } from '@kit.ImageKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\nimport { abilityAccessCtrl, common, Permissions } from '@kit.AbilityKit';\\nimport { fileIo as fs } from '@kit.CoreFileKit';\\n\\nconst PERMISSIONS: Array<Permissions> = [\\n  'ohos.permission.READ_MEDIA',\\n  'ohos.permission.WRITE_MEDIA'\\n];\\nAppStorage.link('net_picture');\\nPersistentStorage.persistProp('net_picture', '');\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State image: PixelMap | undefined = undefined;\\n  @State imageBuffer: ArrayBuffer | undefined = undefined; // 图片ArrayBuffer\\n\\n  /**\\n   * 通过http的request方法从网络下载图片资源\\n   */\\n  async getPicture() {\\n    http.createHttp()\\n      .request('https://www.example1.com/POST?e=f&g=h',\\n        (error: BusinessError, data: http.HttpResponse) => {\\n          if (error) {\\n            return;\\n          }\\n          // 判断网络获取到的资源是否为ArrayBuffer类型\\n          if (data.result instanceof ArrayBuffer) {\\n            this.imageBuffer = data.result as ArrayBuffer;\\n          }\\n          this.transcodePixelMap(data);\\n        }\\n      )\\n  }\\n\\n  /**\\n   * 使用createPixelMap将ArrayBuffer类型的图片装换为PixelMap类型\\n   * @param data：网络获取到的资源\\n   */\\n  transcodePixelMap(data: http.HttpResponse) {\\n    if (http.ResponseCode.OK === data.responseCode) {\\n      const imageData: ArrayBuffer = data.result as ArrayBuffer;\\n      // 通过ArrayBuffer创建图片源实例。\\n      const imageSource: image.ImageSource = image.createImageSource(imageData);\\n      const options: image.InitializationOptions = {\\n        'alphaType': 0, // 透明度\\n        'editable': false, // 是否可编辑\\n        'pixelFormat': 3, // 像素格式\\n        'scaleMode': 1, // 缩略值\\n        'size': { height: 100, width: 100 }\\n      }; // 创建图片大小\\n\\n      // 通过属性创建PixelMap\\n      imageSource.createPixelMap(options).then((pixelMap: PixelMap) => {\\n        this.image = pixelMap;\\n        setTimeout(() => {\\n          if (this.imageBuffer !== undefined) {\\n            this.saveImage(this.imageBuffer);\\n          }\\n        }, 0)\\n      });\\n    }\\n  }\\n\\n  /**\\n   * 保存ArrayBuffer到沙箱路径\\n   * @param buffer：图片ArrayBuffer\\n   * @returns\\n   */\\n  async saveImage(buffer: ArrayBuffer | string): Promise<void> {\\n    const context = getContext(this) as common.UIAbilityContext;\\n    const filePath: string = context.cacheDir + '/test.jpg';\\n    AppStorage.set('net_picture', filePath);\\n    const file = await fs.open(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\\n    await fs.write(file.fd, buffer);\\n    await fs.close(file.fd);\\n  }\\n\\n  async useCachePic(): Promise<void> {\\n    if (AppStorage.get('net_picture') !== '') {\\n      // 获取图片的ArrayBuffer\\n      const imageSource: image.ImageSource = image.createImageSource(AppStorage.get('net_picture'));\\n      const options: image.InitializationOptions = {\\n        'alphaType': 0, // 透明度\\n        'editable': false, // 是否可编辑\\n        'pixelFormat': 3, // 像素格式\\n        'scaleMode': 1, // 缩略值\\n        'size': { height: 100, width: 100 }\\n      };\\n      imageSource.createPixelMap(options).then((pixelMap: PixelMap) => {\\n        this.image = pixelMap;\\n      });\\n    }\\n  }\\n\\n  async aboutToAppear(): Promise<void> {\\n    const context = getContext(this) as common.UIAbilityContext;\\n    const atManager = abilityAccessCtrl.createAtManager();\\n    await atManager.requestPermissionsFromUser(context, PERMISSIONS);\\n    this.useCachePic(); // 从本地存储获取数据\\n    this.getPicture(); // 从网络端获取数据\\n  }\\n\\n  build() {\\n    Column() {\\n      Image(this.image)\\n        .objectFit(ImageFit.Contain)\\n        .width('50%')\\n        .height('50%')\\n    }\\n  }\\n} 下面对优化前后启动性能进行对比分析。分析阶段的起点为启动Ability（即H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility的开始点），阶段终点为应用首次解析Pixelmap（即H:Napi execute, name:CreatePixelMap, traceid:0x0）后的第一个vsync（即H:ReceiveVsync dataCount:24Bytes now:timestamp expectedEnd:timestamp vsyncId:int的开始点）。  图31 优化前未使用本地存储数据   图32 优化后使用本地存储数据  对比数据如下：     方案 阶段时长(毫秒)    （优化前）未使用本地存储 641.8   （优化后）使用本地存储 68.9    可以看到在使用本地存储后，应用冷启动时从Ability启动到图片显示的阶段耗时明显减少。 针对应用冷启动过程中网络请求耗时久的场景，目前提供了一个三方库供开发者使用，优化方式是首页内容复用，先用本地缓存的数据，三方库链接：首页数据缓存。首页数据缓存来加速应用冷启动的使用可以参考：首页数据缓存加速冷启动。 优化首页显示速度 用户感知的启动是从点击应用入口到首页数据显示在屏幕上的过程，也可以看作是响应用户点击事件的一个过程，开发者可以通过UI优化、并发优化、代码逻辑优化、IPC通信优化等方法来提升首页的响应速度，具体可以参考：点击响应优化。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section46001212168\\\"'> <a name='\\\"section46001212168\\\"'></a><a name='\\\"section46001212168\\\"'></a> <h4>[h2]缩短加载绘制首页阶段耗时</h4> <p>首页加载绘制阶段主要包含加载首页内容、测量布局、刷新组件并绘制。同样注意页面生命周期的处理函数，不要进行耗时操作，同时，应优先创建首页需要显示的组件，使用if分支语句，隐藏不需要显示的组件，减少创建过程的耗时。耗时操作建议通过异步任务延迟处理或者放到其他线程执行，线程并发方案可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-comparative_practice_of_taskpool_and_worker\\\"'>TaskPool和Worker的对比实践</a>。</p> <p><strong>自定义组件生命周期回调接口里避免耗时操作</strong></p> <p>自定义组件的生命周期变更会调用相应的回调函数，aboutToAppear函数会在创建自定义组件实例后，页面绘制之前执行，而onPageShow则是在页面进入前台的时候显示，因此避免在这两个回调函数中执行该耗时操作，不阻塞页面绘制。关于自定义组件生命周期的详细说明，参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-page-custom-components-lifecycle\\\"' target='\\\"_blank\\\"'>页面和自定义组件生命周期</a>。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图27 </b>被@Entry装饰的组件（页面）生命周期</span><br/><span><img height='\\\"390.47137499999997\\\"' originheight='\\\"476\\\"' originwidth='\\\"580\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.87092093875675837881055762017952:50001231000000:2800:C3A531063D65219A4CCBACF9DBC12A586BDCEF3AEEDA0AD4E5DF7F5BEC0E2360.png\\\"' title='\\\"点击放大\\\"' width='\\\"475.8075\\\"'/></span> </div> <p>以下为示例代码在Page的回调函数aboutToAppear中分别执行了同步和异步操作：</p>  <p>下面使用Launch分析，对优化前同步执行耗时操作及优化后异步执行耗时操作的启动性能进行对比分析。分析阶段的起点Process Creating，阶段终点为First Frame - Render Phase。</p> <p>优化前后的启动耗时如下图：</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图28 </b>优化前同步执行操作（computeTask），应用冷启动耗时</span><br/><span><img originheight='\\\"81\\\"' originwidth='\\\"640\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.79890196625526120850625189756956:50001231000000:2800:9DAF965F14FB317439D68C084353985A753455333AC3A6C381E34FAB0C7425B1.png\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图29 </b>优化后异步执行操作（computeTaskAsync），应用冷启动耗时</span><br/><span><img height='\\\"119.50555400000002\\\"' originheight='\\\"83\\\"' originwidth='\\\"442\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.38237829804372816675035459888062:50001231000000:2800:5B7D3A429D76FC7E35135575DDEC937D68BADADE5DEF947390BB3AB208F5580B.png\\\"' title='\\\"点击放大\\\"' width='\\\"636.4050000000001\\\"'/></span> </div> <p>可见使用异步后，应用冷启动时间速度有了较大的提升，耗时从2.4s减少到了238.3ms。</p> <p><strong>使用本地存储首页数据</strong></p> <p>在应用启动流程中，大部分应用的首页数据信息需要等待网络请求返回的数据解析结果，因此可以将首页数据通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/data-persistence-by-rdb-store\\\"' target='\\\"_blank\\\"'>数据库</a>、<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/data-persistence-by-preferences\\\"' target='\\\"_blank\\\"'>Preferences</a>、<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-file-fs\\\"' target='\\\"_blank\\\"'>文件</a>、<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-appstorage#从应用逻辑使用appstorage和localstorage\\\"' target='\\\"_blank\\\"'>AppStorage</a>等方式进行本地存储，再次冷启动时优先展示已存储数据，网络请求后再次刷新首页数据。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图30 </b>使用本地存储首页数据流程图</span><br/><span><img height='\\\"178.66315600000001\\\"' originheight='\\\"247\\\"' originwidth='\\\"1129\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.39851540811166223287641320649670:50001231000000:2800:E73F6885283787BD3A08792AE0C394F5F0467236FBB730AD398A8817C1FC8D42.png\\\"' title='\\\"点击放大\\\"' width='\\\"783.0375\\\"'/></span> <p>使用本地<strong>存储</strong>优先展示，可以减少首帧展示完成时延，减少用户可见白屏或白块时间，提升用户的冷启动体验。</p> </div> <div class='\\\"note\\\"'> <img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161211.56642560638540773279033449615221:50001231000000:2800:B61D054220B212EE2262A366FA3FC00DC3D21C7CD87CA72BA5E9B8F85DC24B04.png\\\"'/><span class='\\\"notetitle\\\"'> </span> <div class='\\\"notebody\\\"'> <p>应用需根据自身对于数据的时效性要求，来决定是否使用<strong>本地存储</strong>数据。例如时效性要求为一天时，一天前保存的数据就不适合进行展示，需从网络获取新数据进行展示，并更新本地存储数据。</p> </div> </div> <p>【场景示例】</p> <p>应用首页需展示一张从网站获取的图片信息，在aboutToAppear()中发起网络请求，待数据返回解析后展示在首页上。之后将图片信息存储至本地应用沙箱内，再次冷启动时首先从沙箱内获取图片信息，若存在即可解析并展示，在网络请求返回时再次更新图片信息。</p> <p>以下为关键示例代码：</p> <pre class='\\\"screen\\\"'>// Index.ets\\nimport { http } from '@kit.NetworkKit';\\nimport { image } from '@kit.ImageKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\nimport { abilityAccessCtrl, common, Permissions } from '@kit.AbilityKit';\\nimport { fileIo as fs } from '@kit.CoreFileKit';\\n\\nconst PERMISSIONS: Array&lt;Permissions&gt; = [\\n  'ohos.permission.READ_MEDIA',\\n  'ohos.permission.WRITE_MEDIA'\\n];\\nAppStorage.link('net_picture');\\nPersistentStorage.persistProp('net_picture', '');\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State image: PixelMap | undefined = undefined;\\n  @State imageBuffer: ArrayBuffer | undefined = undefined; // 图片ArrayBuffer\\n\\n  /**\\n   * 通过http的request方法从网络下载图片资源\\n   */\\n  async getPicture() {\\n    http.createHttp()\\n      .request('https://www.example1.com/POST?e=f&amp;g=h',\\n        (error: BusinessError, data: http.HttpResponse) =&gt; {\\n          if (error) {\\n            return;\\n          }\\n          // 判断网络获取到的资源是否为ArrayBuffer类型\\n          if (data.result instanceof ArrayBuffer) {\\n            this.imageBuffer = data.result as ArrayBuffer;\\n          }\\n          this.transcodePixelMap(data);\\n        }\\n      )\\n  }\\n\\n  /**\\n   * 使用createPixelMap将ArrayBuffer类型的图片装换为PixelMap类型\\n   * @param data：网络获取到的资源\\n   */\\n  transcodePixelMap(data: http.HttpResponse) {\\n    if (http.ResponseCode.OK === data.responseCode) {\\n      const imageData: ArrayBuffer = data.result as ArrayBuffer;\\n      // 通过ArrayBuffer创建图片源实例。\\n      const imageSource: image.ImageSource = image.createImageSource(imageData);\\n      const options: image.InitializationOptions = {\\n        'alphaType': 0, // 透明度\\n        'editable': false, // 是否可编辑\\n        'pixelFormat': 3, // 像素格式\\n        'scaleMode': 1, // 缩略值\\n        'size': { height: 100, width: 100 }\\n      }; // 创建图片大小\\n\\n      // 通过属性创建PixelMap\\n      imageSource.createPixelMap(options).then((pixelMap: PixelMap) =&gt; {\\n        this.image = pixelMap;\\n        setTimeout(() =&gt; {\\n          if (this.imageBuffer !== undefined) {\\n            this.saveImage(this.imageBuffer);\\n          }\\n        }, 0)\\n      });\\n    }\\n  }\\n\\n  /**\\n   * 保存ArrayBuffer到沙箱路径\\n   * @param buffer：图片ArrayBuffer\\n   * @returns\\n   */\\n  async saveImage(buffer: ArrayBuffer | string): Promise&lt;void&gt; {\\n    const context = getContext(this) as common.UIAbilityContext;\\n    const filePath: string = context.cacheDir + '/test.jpg';\\n    AppStorage.set('net_picture', filePath);\\n    const file = await fs.open(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\\n    await fs.write(file.fd, buffer);\\n    await fs.close(file.fd);\\n  }\\n\\n  async useCachePic(): Promise&lt;void&gt; {\\n    if (AppStorage.get('net_picture') !== '') {\\n      // 获取图片的ArrayBuffer\\n      const imageSource: image.ImageSource = image.createImageSource(AppStorage.get('net_picture'));\\n      const options: image.InitializationOptions = {\\n        'alphaType': 0, // 透明度\\n        'editable': false, // 是否可编辑\\n        'pixelFormat': 3, // 像素格式\\n        'scaleMode': 1, // 缩略值\\n        'size': { height: 100, width: 100 }\\n      };\\n      imageSource.createPixelMap(options).then((pixelMap: PixelMap) =&gt; {\\n        this.image = pixelMap;\\n      });\\n    }\\n  }\\n\\n  async aboutToAppear(): Promise&lt;void&gt; {\\n    const context = getContext(this) as common.UIAbilityContext;\\n    const atManager = abilityAccessCtrl.createAtManager();\\n    await atManager.requestPermissionsFromUser(context, PERMISSIONS);\\n    this.useCachePic(); // 从本地存储获取数据\\n    this.getPicture(); // 从网络端获取数据\\n  }\\n\\n  build() {\\n    Column() {\\n      Image(this.image)\\n        .objectFit(ImageFit.Contain)\\n        .width('50%')\\n        .height('50%')\\n    }\\n  }\\n}</pre> <p>下面对优化前后启动性能进行对比分析。分析阶段的起点为启动Ability（即H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility的开始点），阶段终点为应用首次解析Pixelmap（即H:Napi execute, name:CreatePixelMap, traceid:0x0）后的第一个vsync（即H:ReceiveVsync dataCount:24Bytes now:timestamp expectedEnd:timestamp vsyncId:int的开始点）。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图31 </b>优化前未使用本地存储数据</span><br/><span><img height='\\\"111.72\\\"' originheight='\\\"342\\\"' originwidth='\\\"1590\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161212.24901329704235965948831415517720:50001231000000:2800:95A57E47E9DDE1C2E2BE488705A5B6C31B93D5359E2BDB0BB92B1741E70206D4.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图32 </b>优化后使用本地存储数据</span><br/><span><img height='\\\"122.69250000000001\\\"' originheight='\\\"373\\\"' originwidth='\\\"1590\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161212.23787924536299898589315747379659:50001231000000:2800:983A3732B8538F94884B4A4A0D1C196FD6FEC351404FA8A6C3800FD3D574C291.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span> </div> <p>对比数据如下：</p> <div class='\\\"tablenoborder\\\"'> <table> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.25.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>方案</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.25.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>阶段时长(毫秒)</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>（优化前）未使用本地存储</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>641.8</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>（优化后）使用本地存储</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>68.9</p></td> </tr> </tbody></table> </div> <p>可以看到在使用本地存储后，应用冷启动时从Ability启动到图片显示的阶段耗时明显减少。</p> <p>针对应用冷启动过程中网络请求耗时久的场景，目前提供了一个三方库供开发者使用，优化方式是首页内容复用，先用本地缓存的数据，三方库链接：<a href='\\\"https://ohpm.openharmony.cn/#/cn/detail/@hadss%2Fdatacache\\\"' target='\\\"_blank\\\"'>首页数据缓存</a>。首页数据缓存来加速应用冷启动的使用可以参考：<a href='\\\"https://gitee.com/harmonyos_samples/DataCache\\\"' target='\\\"_blank\\\"'>首页数据缓存加速冷启动</a>。</p> <p><strong>优化首页显示速度</strong></p> <p>用户感知的启动是从点击应用入口到首页数据显示在屏幕上的过程，也可以看作是响应用户点击事件的一个过程，开发者可以通过UI优化、并发优化、代码逻辑优化、IPC通信优化等方法来提升首页的响应速度，具体可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-click-to-click-response-optimization\\\"' target='\\\"_blank\\\"'>点击响应优化</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-cold-start-optimization.html"
    },
    {
        "id": 192,
        "pre": "{\\n  \\\"network-security-config\\\": {\\n    ... ...\\n  },\\n  \\\"trust-global-user-ca\\\": false,  //配置是否信任企业MDM系统或设备管理员用户手动安装的CA证书，默认为true\\n  \\\"trust-current-user-ca\\\": false  //配置是否信任当前用户安装的CA证书，默认为true\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]配置不信任用户安装的CA证书",
        "parent_text": "[h2]配置不信任用户安装的CA证书Network Kit和Remote Communication Kit配置不信任用户安装的CA证书：在src/main/resources/base/profile/network_config.json配置文件中进行配置。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section11935814273\\\"'><a name='\\\"section11935814273\\\"'></a><a name='\\\"section11935814273\\\"'></a><h4>[h2]配置不信任用户安装的CA证书</h4><p><strong>Network Kit和Remote Communication Kit配置不信任用户安装的CA证书</strong>：在src/main/resources/base/profile/network_config.json<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#connectionsetapphttpproxy11\\\"' target='\\\"_blank\\\"'>配置文件</a>中进行配置。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-ca-security.html"
    },
    {
        "id": 193,
        "pre": "{\\n  \\\"network-security-config\\\": {\\n    \\\"base-config\\\": {\\n      \\\"trust-anchors\\\": [\\n        {\\n          \\\"certificates\\\": \\\"/res/appCaCert\\\"\\n        }\\n      ]\\n    },\\n    \\\"domain-config\\\": [\\n      {\\n        \\\"domains\\\": [\\n          {\\n            \\\"include-subdomains\\\": true,\\n            \\\"name\\\": \\\"example.com\\\"\\n          }\\n        ],\\n        \\\"trust-anchors\\\": [\\n          {\\n            \\\"certificates\\\": \\\"/res/domainCaCert\\\"\\n          }\\n        ]\\n      }\\n    ]\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "Network Kit和Remote Communication Kit可以使用src/main/resources/base/profile/network_config.json文件进行配置，例如：应用级信任的CA证书预置到/res/appCaCert目录，特定域名信任的CA证书预置到/res/domainCaCert目录。  Network Kit也支持在发起HTTPS请求的代码中指定信任的CA证书路径： httpRequest.request( \\\"EXAMPLE_URL\\\",  {\\n    method: http.RequestMethod.POST, \\n    header: {\\n      'Content-Type': 'application/json'\\n    },\\n    extraData: \\\"data to send\\\",\\n    expectDataType: http.HttpDataType.STRING, \\n    connectTimeout: 60000, \\n    caPath:'/res/domainCaCert', // 指定信任的CA证书路径\\n }, (err: BusinessError, data: http.HttpResponse) => {\\n   ...\\n} Remote Communication Kit也支持在代码中指定信任的CA证书路径： const caPath: rcp.CertificateAuthority = {\\n   folderPath: '/res/appCaCert', // 指定信任的CA证书路径\\n}\\nconst securityConfig: rcp.SecurityConfiguration = {\\n  remoteValidation: caPath\\n};\\n// Use the security configuration in the session creation\\nconst sessionWithSecurityConfig = rcp.createSession({ requestConfiguration: { security: securityConfig } }); ",
        "import_module": null,
        "parent": "<li>Network Kit和Remote Communication Kit可以使用src/main/resources/base/profile/network_config.json文件进行配置，例如：应用级信任的CA证书预置到/res/appCaCert目录，特定域名信任的CA证书预置到/res/domainCaCert目录。 <p></p> <p>Network Kit也支持在发起HTTPS请求的代码中<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-http#httprequestoptions\\\"' target='\\\"_blank\\\"'>指定信任的CA证书路径</a>：</p> <pre class='\\\"screen\\\"'>httpRequest.request( \\\"EXAMPLE_URL\\\",  {\\n    method: http.RequestMethod.POST, \\n    header: {\\n      'Content-Type': 'application/json'\\n    },\\n    extraData: \\\"data to send\\\",\\n    expectDataType: http.HttpDataType.STRING, \\n    connectTimeout: 60000, \\n    caPath:'/res/domainCaCert', // 指定信任的CA证书路径\\n }, (err: BusinessError, data: http.HttpResponse) =&gt; {\\n   ...\\n}</pre> <p>Remote Communication Kit也支持在代码中<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section1597118916425\\\"' target='\\\"_blank\\\"'>指定信任的CA证书路径</a>：</p> <pre class='\\\"screen\\\"'>const caPath: rcp.<strong>CertificateAuthority</strong> = {\\n   folderPath: '/res/appCaCert', // 指定信任的CA证书路径\\n}\\nconst securityConfig: rcp.SecurityConfiguration = {\\n  remoteValidation: caPath\\n};\\n// Use the security configuration in the session creation\\nconst sessionWithSecurityConfig = rcp.createSession({ requestConfiguration: { security: securityConfig } });</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-ca-security.html"
    },
    {
        "id": 194,
        "pre": "{\\n  \\\"network-security-config\\\": {\\n    \\\"domain-config\\\": [\\n      {\\n        \\\"domains\\\": [\\n          {\\n            \\\"include-subdomains\\\": true,\\n            \\\"name\\\": \\\"server.com\\\"\\n          }\\n        ],\\n        \\\"pin-set\\\": {\\n          \\\"expiration\\\": \\\"2024-11-08\\\",\\n          \\\"pin\\\": [\\n            {\\n              \\\"digest-algorithm\\\": \\\"sha256\\\",\\n              \\\"digest\\\": \\\"g8CsdcpyAKxmLoWFvMd2hC7ZDUy7L4E2NYOi1i8qEtE=\\\" //服务器证书公钥的hash\\n            }\\n          ]\\n        }\\n      }\\n    ]\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "静态SSL Pinning配置，通过network_config.json文件进行配置： 具体可参考配置指导的“预置锁定证书PIN”章节。 ",
        "import_module": null,
        "parent": "<li>静态SSL Pinning配置，通过network_config.json文件进行配置： <p>具体可参考配置指导的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#connectionsetapphttpproxy11\\\"' target='\\\"_blank\\\"'>“预置锁定证书PIN”</a>章节。</p> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-ca-security.html"
    },
    {
        "id": 195,
        "pre": "import { wantAgent, common } from '@kit.AbilityKit';\\nimport { backgroundTaskManager } from '@kit.BackgroundTasksKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\nimport { Logger } from './Logger';\\n\\nconst TAG = 'BackgroundUtil';\\n\\nexport class BackgroundUtil {\\n  // 申请长时后台任务\\n  public static startContinuousTask(context?: common.UIAbilityContext): void {\\n    if (!context) {\\n      Logger.error(TAG, 'startContinuousTask failed', `context undefined`);\\n      return;\\n    }\\n    let wantAgentInfo: wantAgent.WantAgentInfo = {\\n      wants: [\\n        {\\n          bundleName: context.abilityInfo.bundleName,\\n          abilityName: context.abilityInfo.name\\n        }\\n      ],\\n      operationType: wantAgent.OperationType.START_ABILITY,\\n      requestCode: 0,\\n      wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]\\n    };\\n\\n    wantAgent.getWantAgent(wantAgentInfo).then((wantAgentObj: Object) => {\\n      try {\\n        backgroundTaskManager.startBackgroundRunning(context,\\n          backgroundTaskManager.BackgroundMode.AUDIO_PLAYBACK, wantAgentObj).then(() => {\\n          Logger.info('this audioRenderer: ', 'startBackgroundRunning succeeded');\\n        }).catch((error: BusinessError) => {\\n          Logger.error('this audioRenderer: ', `startBackgroundRunning failed Cause: code ${error.code}`);\\n        });\\n      } catch (error) {\\n        Logger.error(TAG, `startBackgroundRunning failed.message ${(error as BusinessError).message}`);\\n      }\\n    });\\n  }\\n\\n  // 停止长时后台任务\\n  public static stopContinuousTask(context: common.UIAbilityContext): void {\\n    try {\\n      backgroundTaskManager.stopBackgroundRunning(context).then(() => {\\n        Logger.info('this audioRenderer: ', 'stopBackgroundRunning succeeded');\\n      }).catch((error: BusinessError) => {\\n        Logger.error('this audioRenderer: ', `stopBackgroundRunning failed Cause: code ${error.code}`);\\n      });\\n    } catch (error) {\\n      Logger.error(TAG, `stopBackgroundRunning failed. message ${(error as BusinessError).message}`);\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "stopBackgroundRunning()",
        "function_name": null,
        "parent_text": "创建后台管理类，使用BackgroundTasksKit的startBackgroundRunning()/stopBackgroundRunning()方法分别申请和取消后台运行任务，长时任务类型选择AUDIO_PLAYBACK，表示音视频后台播放。 ",
        "import_module": null,
        "parent": "<li>创建后台管理类，使用BackgroundTasksKit的startBackgroundRunning()/stopBackgroundRunning()方法分别申请和取消后台运行任务，长时任务类型选择AUDIO_PLAYBACK，表示音视频后台播放。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-audio-interaction-practice.html"
    },
    {
        "id": 196,
        "pre": "private setOutputDeviceChangeCallback() {\\n  if (!this.audioRenderer) {\\n    return;\\n  }\\n  this.audioRenderer.on('outputDeviceChangeWithInfo', this.outputDeviceChangeCallback);\\n}\\n\\nprivate outputDeviceChangeCallback: (deviceChangeInfo: audio.AudioStreamDeviceChangeInfo) => void =\\n  (deviceChangeInfo: audio.AudioStreamDeviceChangeInfo) => {\\n    Logger.info(TAG, `DeviceInfo id: ${deviceChangeInfo.devices[0].id}`);\\n    Logger.info(TAG, `DeviceInfo name: ${deviceChangeInfo.devices[0].name}`);\\n    Logger.info(TAG, `DeviceInfo address: ${deviceChangeInfo.devices[0].address}`);\\n    Logger.info(TAG, `Device change reason: ${deviceChangeInfo.changeReason}`);\\n    if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE) {\\n      // 新设备可用，应用按需适配业务逻辑\\n    } else if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE) {\\n      // 旧设备不可用，暂停播放\\n      Logger.info(TAG, `Device change reason: ${deviceChangeInfo.changeReason}`);\\n      this.pause();\\n    } else if (deviceChangeInfo.changeReason === audio.AudioStreamDeviceChangeReason.REASON_OVERRODE) {\\n      // 用户强选设备，应用按需适配业务逻辑\\n    }\\n  }",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]播放设备状态发生改变",
        "parent_text": "[h2]播放设备状态发生改变当应用连接的播放设备状态发生改变时，需要及时做出对应的处理，从音频流输出目标的切换、音频播放状态的改变到应用界面的更新，都应该与系统行为以及用户直觉相符，来保证交互体验的一致性，以下分别对各种变更场景给出适配方案： 新设备可用新设备上线时，会触发播放设备自动切换，切换的优先级按下图所示，个人类设备高于公共类设备，同一优先级遵循后入优先原则。因此如果一开始通过扬声器播放，接入耳机后会自动切换至耳机播放，无需应用主动切换。  应用可以通过监听outputDeviceChangeWithInfo事件来感知外放设备的切换，新设备上线对应的变更原因是AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE，如上所述这种情况切换到新的设备播放的行为是系统行为，应用不需要主动改变输出设备；如果有特殊业务逻辑如接入新设备时暂停播放或者对新接入设备进行管理等，可在此类回调中进行处理。 旧设备不可用正在发声的设备不可用后（有线耳机断开、蓝牙开关关闭、蓝牙耳机入盒、多连接耳机被抢占等），应用需要根据使用场景选择暂停播放或使用新设备继续播放。在此列出一些常用类型场景的处理建议，应用可以根据需要做出调整。 类型  处理建议    游戏场景  不进行暂停   音乐场景  根据回调进行暂停   听书场景  根据回调进行暂停   视频场景  根据回调进行暂停      应用同样可以监听设备变更事件并对AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE的场景进行处理，在回调中根据当前播放设备类型选择后续行为，例如为扬声器时暂停，为其他设备则继续播放。 注意具有佩戴检测能力的蓝牙耳机入耳、摘下时会通过播控中心分别对应用发送播放和暂停的通知，应用可以通过监听播控中心指令而非设备变更事件来适配此类操作。 用户强选当用户通过投播组件主动切换输出设备时，系统会自动切换到新选择的设备播放音频，应用可以对变更原因为AudioStreamDeviceChangeReason.REASON_OVERRODE的事件处理自己的业务逻辑，接入投播组件可以参考主动切换播放设备。  示例代码如下，分别对各种类型的设备状态改变事件做出对应的处理：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section59905283238\\\"'><a name='\\\"section59905283238\\\"'></a><a name='\\\"section59905283238\\\"'></a><h4>[h2]播放设备状态发生改变</h4><p>当应用连接的播放设备状态发生改变时，需要及时做出对应的处理，从音频流输出目标的切换、音频播放状态的改变到应用界面的更新，都应该与系统行为以及用户直觉相符，来保证交互体验的一致性，以下分别对各种变更场景给出适配方案：</p> <ol><li>新设备可用<p>新设备上线时，会触发播放设备自动切换，切换的优先级按下图所示，个人类设备高于公共类设备，同一优先级遵循后入优先原则。因此如果一开始通过扬声器播放，接入耳机后会自动切换至耳机播放，无需应用主动切换。</p> <p><span><img height='\\\"480.235469\\\"' originheight='\\\"1024\\\"' originwidth='\\\"1123\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161045.46714486917862105217767245003230:50001231000000:2800:BE7EE7AC0712AF113EEC54ED0A5DDA805C6B8458E9C828BBCA25EBBB5AC9B708.png\\\"' title='\\\"点击放大\\\"' width='\\\"526.6800000000001\\\"'/></span></p> <p>应用可以通过监听outputDeviceChangeWithInfo事件来感知外放设备的切换，新设备上线对应的变更原因是AudioStreamDeviceChangeReason.REASON_NEW_DEVICE_AVAILABLE，如上所述这种情况切换到新的设备播放的行为是系统行为，应用不需要主动改变输出设备；如果有特殊业务逻辑如接入新设备时暂停播放或者对新接入设备进行管理等，可在此类回调中进行处理。</p> </li><li>旧设备不可用<div class='\\\"p\\\"'>正在发声的设备不可用后（有线耳机断开、蓝牙开关关闭、蓝牙耳机入盒、多连接耳机被抢占等），应用需要根据使用场景选择暂停播放或使用新设备继续播放。在此列出一些常用类型场景的处理建议，应用可以根据需要做出调整。 <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.3.2.1.1.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>类型</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.3.2.1.1.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>处理建议</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>游戏场景</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>不进行暂停</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>音乐场景</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>根据回调进行暂停</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>听书场景</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>根据回调进行暂停</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>视频场景</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>根据回调进行暂停</p> </td> </tr> </tbody></table> </div> </div> <p>应用同样可以监听设备变更事件并对AudioStreamDeviceChangeReason.REASON_OLD_DEVICE_UNAVAILABLE的场景进行处理，在回调中根据当前播放设备类型选择后续行为，例如为扬声器时暂停，为其他设备则继续播放。</p> <p>注意具有佩戴检测能力的蓝牙耳机入耳、摘下时会通过播控中心分别对应用发送播放和暂停的通知，应用可以通过监听播控中心指令而非设备变更事件来适配此类操作。</p> </li><li>用户强选<p>当用户通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-multimedia-avcastpicker#avcastpicker\\\"' target='\\\"_blank\\\"'>投播组件</a>主动切换输出设备时，系统会自动切换到新选择的设备播放音频，应用可以对变更原因为AudioStreamDeviceChangeReason.REASON_OVERRODE的事件处理自己的业务逻辑，接入投播组件可以参考<a href='\\\"#section17613152517110\\\"'>主动切换播放设备</a>。</p> </li></ol> <p>示例代码如下，分别对各种类型的设备状态改变事件做出对应的处理：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-audio-interaction-practice.html"
    },
    {
        "id": 197,
        "pre": "// entry/src/main/ets/utils/ConnectionUtil\\nprivate netCon: connection.NetConnection = connection.createNetConnection();\\n\\nregister() {\\n  this.netCon.register((error: BusinessError) => {\\n    Logger.error('net register:' + JSON.stringify(error));\\n  });\\n}\\n\\nnetCapabilitiesChange() {\\n  this.netCon.on('netCapabilitiesChange', (data: connection.NetCapabilityInfo) => {\\n    let netAvailable = false;\\n    data.netCap.networkCap?.forEach((value) => {\\n      if (value === connection.NetCap.NET_CAPABILITY_INTERNET) {\\n        netAvailable = true;\\n      }\\n    })\\n    Logger.info('ConnectionUtil.netAvailable:' + netAvailable);\\n    AppStorage.setOrCreate('netAvailable', netAvailable);\\n  })\\n\\n  this.netCon.on('netLost', (data: connection.NetHandle) => {\\n    AppStorage.setOrCreate('netAvailable', false);\\n    Logger.info(\\\"WifiChangeListen-- Succeeded to get data: \\\" + JSON.stringify(data));\\n  });\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]开发步骤",
        "parent_text": "[h2]开发步骤调用connection的register方法订阅网络变化通知，同时，订阅netCapabilitiesChange网络能力变化事件，订阅netLost网络丢失事件。在设备从有网络到无网络状态会触发netLost事件，从无网络到有网络会触发netCapabilitiesChange事件。而在网络类型切换时，也会触发netLost事件和netCapabilitiesChange事件，开发者可以根据实际场景需要在netCapabilitiesChange事件中，将网络类型及网络状态存储在AppStorage中。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section78034221254\\\"'><a name='\\\"section78034221254\\\"'></a><a name='\\\"section78034221254\\\"'></a><h4>[h2]开发步骤</h4><p>调用connection的register方法订阅网络变化通知，同时，订阅netCapabilitiesChange网络能力变化事件，订阅netLost网络丢失事件。在设备从有网络到无网络状态会触发netLost事件，从无网络到有网络会触发netCapabilitiesChange事件。而在网络类型切换时，也会触发netLost事件和netCapabilitiesChange事件，开发者可以根据实际场景需要在netCapabilitiesChange事件中，将网络类型及网络状态存储在AppStorage中。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-reconnection.html"
    },
    {
        "id": 198,
        "pre": "// entry/src/main/ets/entryablity/EntryAbility\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n\\n  onForeground(): void {\\n    // Ability has brought to foreground\\n    // ...\\n    AppStorage.setOrCreate('onForeground', true);\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');\\n  }\\n\\n  onBackground(): void {\\n    // Ability has back to background\\n    // ...\\n    AppStorage.setOrCreate('onForeground', false);\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');\\n  }\\n}",
        "type": "Reference",
        "function_call": "tcpSocketDisconnect()",
        "function_name": "[h2]开发步骤",
        "parent_text": "[h2]开发步骤前后台切换时，在UIAbility组件生命周期中存储前后台状态。  使用@StorageProp同步前后台状态，并使用@Watch监听状态变化。 // entry/src/main/ets/pages/SocketReconnection\\n@StorageProp('onForeground') @Watch('onForegroundChange') onForeground: boolean = true;\\n// ...\\nonForegroundChange(): void {\\n  this.onForeground ? this.tcpSocketConnect() : this.tcpSocketDisconnect();\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section194981716769\\\"'><a name='\\\"section194981716769\\\"'></a><a name='\\\"section194981716769\\\"'></a><h4>[h2]开发步骤</h4><p>前后台切换时，在UIAbility组件生命周期中存储前后台状态。</p>  <p>使用@StorageProp同步前后台状态，并使用@Watch监听状态变化。</p> <pre class='\\\"screen\\\"'>// entry/src/main/ets/pages/SocketReconnection\\n@StorageProp('onForeground') @Watch('onForegroundChange') onForeground: boolean = true;\\n// ...\\nonForegroundChange(): void {\\n  this.onForeground ? this.tcpSocketConnect() : this.tcpSocketDisconnect();\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-reconnection.html"
    },
    {
        "id": 199,
        "pre": "// 定义请求头\\nlet headers: rcp.RequestHeaders = {\\n  'accept': 'application/json'\\n};\\n// 定义要修改的内容\\nlet modifiedContent: UserInfo = {\\n  'userName': 'xxxxxx'\\n};\\nconst securityConfig: rcp.SecurityConfiguration = {\\n  tlsOptions: {\\n    tlsVersion: 'TlsV1.3'\\n  }\\n};\\n// 创建通信会话对象\\nconst session = rcp.createSession({ requestConfiguration: { security: securityConfig } });\\n// 定义请求对象rep\\nlet req = new rcp.Request('http://example.com/fetch', 'PATCH', headers, modifiedContent);\\n// 发起请求\\nsession.fetch(req).then((response) => {\\n  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);\\n}).catch((err: BusinessError) => {\\n  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);\\n});",
        "type": "Reference",
        "function_call": "fetch()",
        "function_name": "[h2]发送请求",
        "parent_text": "[h2]发送请求通过RCP模块能够发起基础的网络请求，如GET、POST、HEAD、PUT、DELETE、PATCH、OPTIONS等请求。以PATCH请求为例，开发过程中经常会遇到发送请求修改资源的场景，假设有一个UserInfo，里面有userId、userName、 userGender等10个字段。可编辑功能因为需求，在某个特别的页面里只能修改userName，这时就可以用PATCH请求，来更新局部资源。 实现思路 在创建session会话后，通过创建请求对象并传入第二个参数且指定为PATCH，然后通过session.fetch()发起请求即可。 导入RCP模块。创建headers，设置可接受的数据内容的类型为json字符串；创建modifiedContent，传入想要修改的内容。调用rcp.createSession()创建通信会话对象session。使用new rcp.Request()方法创建请求对象req。调用session.fetch()方法发起请求。获取响应结果。 核心代码  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1915519514303\\\"'><a name='\\\"section1915519514303\\\"'></a><a name='\\\"section1915519514303\\\"'></a><h4>[h2]发送请求</h4><p>通过RCP模块能够发起基础的网络请求，如GET、POST、HEAD、PUT、DELETE、PATCH、OPTIONS等请求。以PATCH请求为例，开发过程中经常会遇到发送请求修改资源的场景，假设有一个UserInfo，里面有userId、userName、 userGender等10个字段。可编辑功能因为需求，在某个特别的页面里只能修改userName，这时就可以用PATCH请求，来更新局部资源。</p> <p><strong>实现思路</strong></p> <p>在创建<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section1671892662116\\\"' target='\\\"_blank\\\"'>session</a>会话后，通过创建请求对象并传入第二个参数且指定为PATCH，然后通过session.fetch()发起请求即可。</p> <ol><li><span>导入RCP模块。</span></li><li><span>创建headers，设置可接受的数据内容的类型为json字符串；创建modifiedContent，传入想要修改的内容。</span></li><li><span>调用rcp.createSession()创建通信会话对象session。</span></li><li><span>使用new rcp.Request()方法创建请求对象req。</span></li><li><span>调用session.fetch()方法发起请求。</span></li><li><span>获取响应结果。</span></li></ol> <p><strong>核心代码</strong></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-based-network-request.html"
    },
    {
        "id": 200,
        "pre": "// 定义sessionConfig对象\\nconst sessionConfig: rcp.SessionConfiguration = {\\n  baseAddress: 'http://api.example.com',\\n  headers: {\\n    'authorization': 'Bearer YOUR_ACCESS_TOKEN',\\n    'content-type': 'application/json'\\n  },\\n  requestConfiguration:{\\n    security:{\\n      tlsOptions: {\\n        tlsVersion: 'TlsV1.3'\\n      }\\n    }\\n  }\\n};\\n// 创建通信会话对象，并传入sessionConfig\\nconst session = rcp.createSession(sessionConfig);",
        "type": "Reference",
        "function_call": "createSession()",
        "function_name": "[h2]设置会话中URL的基地址",
        "parent_text": "[h2]设置会话中URL的基地址会话中URL的基地址是在发起请求时用作请求地址的前缀。 当我们向服务器发起请求时，该请求的最终的请求地址由会话中URL的基地址与请求路径来构建的。 这使得我们可以将服务器的主机地址与公共路径隔离开来，方便管理和维护。 实现思路 会话中URL的基地址可通过RCP模块中的SessionConfiguration来进行设置，在sessionConfig对象中设置“baseAddress：'http://api.example.com' ”即可。 导入RCP模块。设置sessionConfig对象中的baseAddress为http://api.example.com。调用rcp.createSession()传入sessionConfig，创建通信会话对象session。 核心代码  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1415514503012\\\"'><a name='\\\"section1415514503012\\\"'></a><a name='\\\"section1415514503012\\\"'></a><h4>[h2]设置会话中URL的基地址</h4><p>会话中URL的基地址是在发起请求时用作请求地址的前缀。 当我们向服务器发起请求时，该请求的最终的请求地址由会话中URL的基地址与请求路径来构建的。 这使得我们可以将服务器的主机地址与公共路径隔离开来，方便管理和维护。</p> <p><strong>实现思路</strong></p> <p>会话中URL的基地址可通过RCP模块中的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section18613443123412\\\"' target='\\\"_blank\\\"'>SessionConfiguration</a>来进行设置，在sessionConfig对象中设置“baseAddress：'http://api.example.com' ”即可。</p> <ol><li><span>导入RCP模块。</span></li><li><span>设置sessionConfig对象中的baseAddress为http://api.example.com。</span></li><li><span>调用rcp.createSession()传入sessionConfig，创建通信会话对象session。</span></li></ol> <p><strong>核心代码</strong></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-based-network-request.html"
    },
    {
        "id": 201,
        "pre": "// 定义请求头类型\\nlet headers: rcp.RequestHeaders = {\\n  'accept': 'application/json'\\n};\\n// 配置HTTP请求的超时值\\nlet configuration: rcp.Configuration = {\\n  transfer: {\\n    timeout: {\\n      connectMs: 60000,\\n      transferMs: 60000\\n    }\\n  }\\n};\\n// HTTP请求中的Cookie\\nlet cookies: rcp.RequestCookies = {\\n  'name1': 'value1',\\n  'name2': 'value2',\\n};\\n// 设置数据传输范围\\nlet transferRange: rcp.TransferRange = {\\n  from: 100,\\n  to: 200\\n};\\n\\n// 设置multipartFrom数据\\nconst multiForm = new rcp.MultipartForm({\\n  'Form1': this.name, // string\\n  'Form2': this.hobbies, // string\\n  'Form3': {\\n    contentType: 'text/plain',\\n    remoteFileName: 'RemoteFileName',\\n    contentOrPath: '/file/to/Path'\\n  } // object\\n});\\n\\nconst securityConfig: rcp.SecurityConfiguration = {\\n  tlsOptions: {\\n    tlsVersion: 'TlsV1.3'\\n  }\\n};\\n// 创建通信会话对象\\nconst session = rcp.createSession({ requestConfiguration: { security: securityConfig } });\\n// 定义请求对象req\\nlet req =\\n  new rcp.Request('https://www.example.com', 'POST', headers, multiForm, cookies, transferRange, configuration);\\nreq.content = multiForm;\\n\\n// 发起请求\\nsession.fetch(req).then((response) => {\\n  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);\\n}).catch((err: BusinessError) => {\\n  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);\\n});",
        "type": "Reference",
        "function_call": "fetch()",
        "function_name": "实现多表单提交",
        "parent_text": "实现多表单提交开发过程中时常会遇到多表单提交的场景，例如在同页面下tab栏可切换多个Form表单组件，但只有一个提交按钮，各组件下的表单数据需要被一起提交。此时可以使用RCP模块中的MultipartForm来实现多表单提交的场景。 实现思路 在创建session会话后，通过new rcp.Request()的第四个参数传入MultipartForm，然后通过rcp.fetch()发起POST请求将多个表单数据携带上传至服务端。 导入RCP模块。设置请求头类型、配置HTTP请求的超时值、HTTP请求中包含的cookie和设置传输数据范围。调用rcp.createSession()创建通信会话对象。通过new rcp.MultipartForm()设置多表单数据。使用new rcp.Request()创建请求对象，调用session.fetch()方法发起请求。处理响应结果。 核心代码  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section715616553015\\\"'><a name='\\\"section715616553015\\\"'></a><a name='\\\"section715616553015\\\"'></a><h4>实现多表单提交</h4><p>开发过程中时常会遇到多表单提交的场景，例如在同页面下tab栏可切换多个Form表单组件，但只有一个提交按钮，各组件下的表单数据需要被一起提交。此时可以使用RCP模块中的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section1420174317517\\\"' target='\\\"_blank\\\"'>MultipartForm</a>来实现多表单提交的场景。</p> <p><strong>实现思路</strong></p> <p>在创建session会话后，通过new rcp.Request()的第四个参数传入MultipartForm，然后通过rcp.fetch()发起POST请求将多个表单数据携带上传至服务端。</p> <ol><li><span>导入RCP模块。</span></li><li><span>设置请求头类型、配置HTTP请求的超时值、HTTP请求中包含的cookie和设置传输数据范围。</span></li><li><span>调用rcp.createSession()创建通信会话对象。</span></li><li><span>通过new rcp.MultipartForm()设置多表单数据。</span></li><li><span>使用new rcp.Request()创建请求对象，调用session.fetch()方法发起请求。</span></li><li><span>处理响应结果。</span></li></ol> <p><strong>核心代码</strong></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-based-network-request.html"
    },
    {
        "id": 202,
        "pre": "// 配置自定义DNS服务器\\nconst customDnsServers: rcp.DnsServers = [\\n  { ip: '8.8.8.8' },\\n  { ip: '8.8.4.4', port: 53 }\\n];\\n// 创建通信会话对象\\nconst sessionWithCustomDns = rcp.createSession({\\n  requestConfiguration: {\\n    dns: {\\n      dnsRules: customDnsServers\\n    },\\n    security: {\\n      tlsOptions: {\\n        tlsVersion: 'TlsV1.3'\\n      }\\n    }\\n  }\\n});\\n// 发起请求\\nsessionWithCustomDns.get('http://www.example.com').then((response) => {\\n  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);\\n}).catch((err: BusinessError) => {\\n  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);\\n});",
        "type": "Reference",
        "function_call": "createSession()",
        "function_name": "[h2]自定义DNS服务器",
        "parent_text": "[h2]自定义DNS服务器实现思路 先配置自定义的DNS服务器customDnsServers，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsRules为customDnsServers。 导入RCP模块。配置自定义的DNS服务器。调用rcp.createSession()创建通信会话对象时，传入自定义的DNS服务器。 核心代码  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12156155123011\\\"'><a name='\\\"section12156155123011\\\"'></a><a name='\\\"section12156155123011\\\"'></a><h4>[h2]自定义DNS服务器</h4><p><strong>实现思路</strong></p> <p>先配置自定义的DNS服务器customDnsServers，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsRules为customDnsServers。</p> <ol><li><span>导入RCP模块。</span></li><li><span>配置自定义的DNS服务器。</span></li><li><span>调用rcp.createSession()创建通信会话对象时，传入自定义的DNS服务器。</span></li></ol> <p><strong>核心代码</strong></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-based-network-request.html"
    },
    {
        "id": 203,
        "pre": "// 当匹配到hostname时，优先使用指定的地址\\nconst staticDnsRules: rcp.StaticDnsRules = [\\n  {\\n    host: 'example.com',\\n    port: 80,\\n    ipAddresses: ['192.168.1.1', '192.168.1.2']\\n  }\\n];\\n// 创建通信会话对象\\nconst sessionWithCustomDns = rcp.createSession({\\n  requestConfiguration: {\\n    dns: {\\n      dnsRules: staticDnsRules\\n    },\\n    security: {\\n      tlsOptions: {\\n        tlsVersion: 'TlsV1.3'\\n      }\\n    }\\n  }\\n});\\n// 发起请求\\nsessionWithCustomDns.get('http://www.example.com').then((response) => {\\n  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);\\n}).catch((err: BusinessError) => {\\n  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);\\n});",
        "type": "Reference",
        "function_call": "createSession()",
        "function_name": "[h2]自定义静态DNS",
        "parent_text": "[h2]自定义静态DNS实现思路 先配置静态DNS规则staticDnsRules，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsRules为staticDnsRules 。 导入RCP模块。配置静态DNS规则。调用rcp.createSession()创建通信会话对象时，传入静态DNS规则。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section01574520308\\\"'><a name='\\\"section01574520308\\\"'></a><a name='\\\"section01574520308\\\"'></a><h4>[h2]自定义静态DNS</h4><p><strong>实现思路</strong></p> <p>先配置静态DNS规则staticDnsRules，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsRules为staticDnsRules 。</p> <ol><li><span>导入RCP模块。</span></li><li><span>配置静态DNS规则。</span></li><li><span>调用rcp.createSession()创建通信会话对象时，传入静态DNS规则。</span></li></ol>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-based-network-request.html"
    },
    {
        "id": 204,
        "pre": "// DNS over HTTPS配置\\nconst dohConfig: rcp.DnsOverHttpsConfiguration = {\\n  url: 'https://dns.example.com/dns-query',\\n  skipCertificatesValidation: true\\n};\\n// 创建通信会话对象\\nconst sessionWithCustomDns = rcp.createSession({\\n  requestConfiguration: {\\n    dns: {\\n      dnsOverHttps: dohConfig\\n    },\\n    security: {\\n      tlsOptions: {\\n        tlsVersion: 'TlsV1.3'\\n      }\\n    }\\n  }\\n});\\n// 发起请求\\nsessionWithCustomDns.get('http://www.example.com').then((response) => {\\n  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);\\n}).catch((err: BusinessError) => {\\n  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);\\n});",
        "type": "Reference",
        "function_call": "createSession()",
        "function_name": "[h2]配置HTTPS上的DNS",
        "parent_text": "[h2]配置HTTPS上的DNS实现思路 先创建HTTPS上的DNS对象dohConfig，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsOverHttps为dohConfig 。 导入RCP模块。创建HTTPS上的DNS对象dohConfig。调用rcp.createSession()创建通信会话对象时，传入dohConfig。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section915775143020\\\"'><a name='\\\"section915775143020\\\"'></a><a name='\\\"section915775143020\\\"'></a><h4>[h2]配置HTTPS上的DNS</h4><p><strong>实现思路</strong></p> <p>先创建HTTPS上的DNS对象dohConfig，在创建session会话时，通过requestConfiguration传入dns对象，指定dns对象中的dnsOverHttps为dohConfig 。</p> <ol><li><span>导入RCP模块。</span></li><li><span>创建HTTPS上的DNS对象dohConfig。</span></li><li><span>调用rcp.createSession()创建通信会话对象时，传入dohConfig。</span></li></ol>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-based-network-request.html"
    },
    {
        "id": 205,
        "pre": "import { rcp } from '@kit.RemoteCommunicationKit';\\nimport { url } from '@kit.ArkTS';\\nimport Logger from '../common/Logger';\\nimport { NetworkQualityProvider } from './NetworkStateSimulator';\\n\\n// 定义RequestUrlChangeInterceptor拦截器\\nexport class RequestUrlChangeInterceptor implements rcp.Interceptor {\\n  private readonly networkQualityProvider: NetworkQualityProvider;\\n\\n  constructor(networkQualityProvider: NetworkQualityProvider) {\\n    this.networkQualityProvider = networkQualityProvider;\\n  }\\n\\n  // 自定义请求处理逻辑\\n  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {\\n    if (context.request.method === 'GET' && !this.networkQualityProvider.isNetworkFast()) {\\n      Logger.info('[RequestUrlChangeInterceptor]: Slow network is detected');\\n      const parts = context.request.url.pathname.split('.');\\n      if (parts.length === 2) {\\n        const changed = url.URL.parseURL(context.request.url.href);\\n        changed.pathname = parts[0] + '_small.' + parts[1];\\n        Logger.info(`[RequestUrlChangeInterceptor]: Replace URL from \\\"${context.request.url.href}\\\" to \\\"${changed}\\\"`);\\n        AppStorage.setOrCreate('ReplacedInfo',`[RequestUrlChangeInterceptor]: Replace URL from \\\"${context.request.url.href}\\\" to \\\"${changed}\\\"`);\\n        context.request.url = changed;\\n      }\\n    } else {\\n      Logger.info('[RequestUrlChangeInterceptor]: Network is fast');\\n    }\\n    return next.handle(context);\\n  }\\n}\\n\\n// 定义ResponseHeaderRemoveInterceptor拦截器\\nexport class ResponseHeaderRemoveInterceptor implements rcp.Interceptor {\\n  // 自定义响应处理逻辑\\n  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {\\n    const response = await next.handle(context);\\n    const toReturn: rcp.Response = {\\n      request: response.request,\\n      statusCode: response.statusCode,\\n      httpVersion: response.httpVersion,\\n      headers: {\\n        'content-range': response.headers['content-range']\\n      },\\n      effectiveUrl: response.effectiveUrl,\\n      timeInfo: response.timeInfo,\\n      toJSON: () => null\\n    };\\n    Logger.info('[ResponseHeaderRemoveInterceptor]: Response was modified');\\n    return toReturn;\\n  }\\n}",
        "type": "Reference",
        "function_call": "NetworkQualityProvider中定义了isNetWorkFast()",
        "function_name": "[h2]拦截器的定义和使用",
        "parent_text": "[h2]拦截器的定义和使用下面将介绍如何自定义拦截器，定义RequestUrlChangeInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器实现rcp.Interceptor，可在intercept()方法中根据业务需求自定义处理逻辑，实现对请求/响应的修改。 导入RCP模块。定义RequestUrlChangeInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器。在intercept()方法中实现对请求/响应的修改逻辑。 核心代码   NetworkQualityProvider中定义了isNetWorkFast()，isNetWorkFast用于在示例代码中模拟网络质量的好坏，这里仅作为场景模拟，需要开发者自行评估实现。 RequestUrlChangeInterceptor拦截器中，当网络质量较差的时候，修改请求中的URL路径，请求获取分辨率较小的图片，可提升用户体验。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section3158259304\\\"'><a name='\\\"section3158259304\\\"'></a><a name='\\\"section3158259304\\\"'></a><h4>[h2]拦截器的定义和使用</h4><p>下面将介绍如何自定义拦截器，定义RequestUrlChangeInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器实现<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section1385412349596\\\"' target='\\\"_blank\\\"'>rcp.Interceptor</a>，可在<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section527252111410\\\"' target='\\\"_blank\\\"'>intercept()</a>方法中根据业务需求自定义处理逻辑，实现对请求/响应的修改。</p> <ol><li><span>导入RCP模块。</span></li><li><span>定义RequestUrlChangeInterceptor拦截器和ResponseHeaderRemoveInterceptor拦截器。</span></li><li><span>在intercept()方法中实现对请求/响应的修改逻辑。</span></li></ol> <p><strong>核心代码</strong></p>  <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161448.54034358383461517009474719660283:50001231000000:2800:842E99F69B274750DE4C4BF6E756EC671BE7309123A3127DBFEEB636694BB6BA.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>NetworkQualityProvider中定义了isNetWorkFast()，isNetWorkFast用于在示例代码中模拟网络质量的好坏，这里仅作为场景模拟，需要开发者自行评估实现。</p> <p>RequestUrlChangeInterceptor拦截器中，当网络质量较差的时候，修改请求中的URL路径，请求获取分辨率较小的图片，可提升用户体验。</p> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-based-network-request.html"
    },
    {
        "id": 206,
        "pre": "// 定义自定义响应处理程序\\nconst customHttpEventsHandler: rcp.HttpEventsHandler = {\\n  onDataReceive: (incomingData: ArrayBuffer) => {\\n    // 用于处理传入数据的自定义逻辑\\n    Logger.info('Received data:', JSON.stringify(incomingData));\\n    return incomingData.byteLength;\\n  },\\n  onHeaderReceive: (headers: rcp.RequestHeaders) => {\\n    // 处理响应头的自定义逻辑\\n    Logger.info('Received headers:', JSON.stringify(headers));\\n  },\\n  onDataEnd: () => {\\n    // 用于处理数据传输完成的自定义逻辑\\n    Logger.info('Data transfer complete');\\n  }\\n};\\n\\n// 配置跟踪设置\\nconst tracingConfig: rcp.TracingConfiguration = {\\n  verbose: true,\\n  infoToCollect: {\\n    incomingHeader: true, // 收集传入的header信息事件\\n    outgoingHeader: true, // 收集传出的header信息事件\\n    incomingData: true, // 收集传入数据信息事件\\n    outgoingData: true // 收集传出数据信息事件\\n  },\\n  collectTimeInfo: true,\\n  httpEventsHandler: customHttpEventsHandler\\n};\\nconst securityConfig: rcp.SecurityConfiguration = {\\n  tlsOptions: {\\n    tlsVersion: 'TlsV1.3'\\n  }\\n};\\n// 创建通信会话对象，并传入相关配置\\nconst session = rcp.createSession({ requestConfiguration: { tracing: tracingConfig, security: securityConfig } });\\nsession.get('http://developer.huawei.com').then((response) => {\\n  Logger.info(`Request succeeded, message is ${JSON.stringify(response)}`);\\n}).catch((err: BusinessError) => {\\n  Logger.error(`err: err code is ${err.code}, err message is ${JSON.stringify(err)}`);\\n});",
        "type": "Reference",
        "function_call": "createSession()",
        "function_name": "捕获有关HTTP请求/响应流的详细信息",
        "parent_text": "捕获有关HTTP请求/响应流的详细信息当需要采集应用中HTTP请求的详细跟踪信息时，可以使用TracingConfiguration进行相关配置。TracingConfiguration中可以设置verbose（启用详细跟踪）、infoToCollect（配置要收集的特定类型的信息事件）、collectTimeInfo（在跟踪过程中是否应收集与时间相关的信息）、httpEventsHandler（为HTTP请求/响应过程中的特定操作定义响应处理程序的回调）四个参数。 下面将以获取HTTP请求/响应时的数据接收时、请求头接收时、数据传输完成时等详细信息为例，进行介绍。 实现思路 通过配置TracingConfiguration中的参数，来捕获HTTP请求/响应时的详细信息。 导入RCP模块。设置tracingConfig对象中的verbose为true，表示启用详细跟踪。设置tracingConfig对象中的infoToCollect对象中的incomingData为true（收集传入的数据信息事件）、outgoingData为true（收集传出的数据信息事件）、incomingHeader为true（收集传入的header信息事件）、outgoingHeader为true（收集传出的header信息事件）。设置tracingConfig对象中collectTimeInfo为true，表示在跟踪过程中收集与时间相关的信息。可在请求的Response中的timeInfo中查看相关信息。在HttpEventsHandler中设置onDataReceive（当接收到HTTP响应正文的一部分时调用的回调）、onHeaderReceive（用于在响应期间处理接收到的headers的回调）、onDataEnd（数据传输完成时触发的回调）。调用rcp.createSession()传入tracingConfig ，创建通信会话对象session。 核心代码  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section131592516301\\\"'><a name='\\\"section131592516301\\\"'></a><a name='\\\"section131592516301\\\"'></a><h4>捕获有关HTTP请求/响应流的详细信息</h4><p>当需要采集应用中HTTP请求的详细跟踪信息时，可以使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section557714186379\\\"' target='\\\"_blank\\\"'>TracingConfiguration</a>进行相关配置。TracingConfiguration中可以设置verbose（启用详细跟踪）、<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section12292010397\\\"' target='\\\"_blank\\\"'>infoToCollect</a>（配置要收集的特定类型的信息事件）、collectTimeInfo（在跟踪过程中是否应收集与时间相关的信息）、<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section87603011401\\\"' target='\\\"_blank\\\"'>httpEventsHandler</a>（为HTTP请求/响应过程中的特定操作定义响应处理程序的回调）四个参数。</p> <p>下面将以获取HTTP请求/响应时的数据接收时、请求头接收时、数据传输完成时等详细信息为例，进行介绍。</p> <p><strong>实现思路</strong></p> <p>通过配置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section557714186379\\\"' target='\\\"_blank\\\"'>TracingConfiguration</a>中的参数，来捕获HTTP请求/响应时的详细信息。</p> <ol><li>导入RCP模块。</li><li>设置tracingConfig对象中的verbose为true，表示启用详细跟踪。</li><li>设置tracingConfig对象中的infoToCollect对象中的incomingData为true（收集传入的数据信息事件）、outgoingData为true（收集传出的数据信息事件）、incomingHeader为true（收集传入的header信息事件）、outgoingHeader为true（收集传出的header信息事件）。</li><li>设置tracingConfig对象中collectTimeInfo为true，表示在跟踪过程中收集与时间相关的信息。可在请求的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section156381815599\\\"' target='\\\"_blank\\\"'>Response</a>中的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section183911041803\\\"' target='\\\"_blank\\\"'>timeInfo</a>中查看相关信息。</li><li>在<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section87603011401\\\"' target='\\\"_blank\\\"'>HttpEventsHandler</a>中设置onDataReceive（当接收到HTTP响应正文的一部分时调用的回调）、onHeaderReceive（用于在响应期间处理接收到的headers的回调）、onDataEnd（数据传输完成时触发的回调）。</li><li>调用rcp.createSession()传入tracingConfig ，创建通信会话对象session。</li></ol> <p><strong>核心代码</strong></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-based-network-request.html"
    },
    {
        "id": 207,
        "pre": "{\\n  \\\"module\\\": {\\n    // ...\\n    \\\"abilities\\\": [\\n      {\\n        \\\"name\\\": \\\"EntryAbility\\\",\\n        // ...\\n        \\\"preferMultiWindowOrientation\\\": \\\"landscape_auto\\\"\\n      }\\n    ],\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]横向游戏和视频横向悬浮窗适配",
        "parent_text": "[h2]横向游戏和视频横向悬浮窗适配悬浮窗默认是竖向的，但是对于横向游戏和视频应用，横向的悬浮窗体验会更好。开发者可以通过在module.json5配置文件中abilities标签下的preferMultiWindowOrientation属性增加“landscape”或者“landscape_auto”配合API以声明应用支持横向悬浮窗或上下分屏模式。  preferMultiWindowOrientation属性主要标识当前UIAbility组件多窗布局方向，具体可以参考应用声明支持智慧多窗中关于preferMultiWindowOrientation的属性的描述。当设置preferMultiWindowOrientation属性为“landscape_auto”表示多窗布局动态可变为横向，需要配合API（enableLandscapeMultiWindow / disableLandscapeMultiWindow）使用，建议视频类应用配置，视频播放界面适配横屏悬浮窗效果图如下，具体使用可以参考：横向悬浮窗适配问题。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section364215616276\\\"'><a name='\\\"section364215616276\\\"'></a><a name='\\\"section364215616276\\\"'></a><h4>[h2]横向游戏和视频横向悬浮窗适配</h4><p>悬浮窗默认是竖向的，但是对于横向游戏和视频应用，横向的悬浮窗体验会更好。开发者可以通过在module.json5配置文件中abilities标签下的preferMultiWindowOrientation属性增加“landscape”或者“landscape_auto”配合API以声明应用支持横向悬浮窗或上下分屏模式。</p>  <p>preferMultiWindowOrientation属性主要标识当前UIAbility组件多窗布局方向，具体可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multi-window-support#section14646185913211\\\"' target='\\\"_blank\\\"'>应用声明支持智慧多窗</a>中关于preferMultiWindowOrientation的属性的描述<strong>。</strong>当设置preferMultiWindowOrientation属性为“landscape_auto”表示多窗布局动态可变为横向，需要配合API（<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#enablelandscapemultiwindow12\\\"' target='\\\"_blank\\\"'>enableLandscapeMultiWindow</a> / <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#disablelandscapemultiwindow12\\\"' target='\\\"_blank\\\"'>disableLandscapeMultiWindow</a>）使用，建议视频类应用配置，视频播放界面适配横屏悬浮窗效果图如下，具体使用可以参考：<a href='\\\"#section4595191593711\\\"'>横向悬浮窗适配问题</a>。</p> <p></p> <p><span><img height='\\\"545.5261\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161129.45620506976440177890921386348890:50001231000000:2800:C6A86855BCDFC87125D119A51ACFEFF010A5F96AE4BF79750DBCD026CE7FC120.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window-practice.html"
    },
    {
        "id": 208,
        "pre": "@Component\\nexport struct Question1Incorrect {\\n  build() {\\n    NavDestination() {\\n      Column({ space: 12 }) {\\n        Text('Text1')\\n          .fontSize(50)\\n          .width('100%')\\n          .textAlign(TextAlign.Center)\\n          .height(350)\\n          .backgroundColor(Color.Brown)\\n\\n        Text('Text2')\\n          .fontSize(50)\\n          .width('100%')\\n          .textAlign(TextAlign.Center)\\n          .height(350)\\n          .backgroundColor(Color.Orange)\\n      }\\n      // ...\\n    }\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "Scroll()",
        "function_name": null,
        "parent_text": "界面被截断，无法上下滑动。问题现象 应用分屏后内容显示不全，无法通过上下滑动展示未显示的内容。   优化前示例代码如下：  可能原因 应用只适配了全屏大小，当应用分屏/悬浮窗后，窗口会变小，导致页面显示不全，超出窗口的区域无法显示。 解决措施 使用一多的延伸能力，增加Scroll组件，让列表或者文字区域可以按照指定方向滑动，优化后示例代码如下： @Component\\nexport struct Question1Correct {\\n  build() {\\n    NavDestination() {\\n      Scroll() {\\n        Column({ space: 12 }) {\\n          Text('Text1')\\n            .fontSize(50)\\n            .width('100%')\\n            .textAlign(TextAlign.Center)\\n            .height(350)\\n            .backgroundColor(Color.Brown)\\n\\n          Text('Text2')\\n            .fontSize(50)\\n            .width('100%')\\n            .textAlign(TextAlign.Center)\\n            .height(350)\\n            .backgroundColor(Color.Orange)\\n        }\\n      }\\n      // ...\\n    }\\n    // ...\\n  }\\n} 优化后效果如下图所示。   ",
        "import_module": null,
        "parent": "<li>界面被截断，无法上下滑动。<p><strong>问题现象</strong></p> <p>应用分屏后内容显示不全，无法通过上下滑动展示未显示的内容。</p> <p></p> <p><span><img height='\\\"545.5261\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161129.17854695346174092081028854921612:50001231000000:2800:98ABAD32D8E8E55FA8C79A01F695BAB477B7AB23DB2E2AA655EEB5DD87037FB6.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>优化前示例代码如下：</p>  <p><strong>可能原因</strong></p> <p>应用只适配了全屏大小，当应用分屏/悬浮窗后，窗口会变小，导致页面显示不全，超出窗口的区域无法显示。</p> <p><strong>解决措施</strong></p> <p>使用一多的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/adaptive-layout#延伸能力\\\"' target='\\\"_blank\\\"'>延伸能力</a>，增加Scroll组件，让列表或者文字区域可以按照指定方向滑动，优化后示例代码如下：</p> <pre class='\\\"screen\\\"'>@Component\\nexport struct Question1Correct {\\n  build() {\\n    NavDestination() {\\n      Scroll() {\\n        Column({ space: 12 }) {\\n          Text('Text1')\\n            .fontSize(50)\\n            .width('100%')\\n            .textAlign(TextAlign.Center)\\n            .height(350)\\n            .backgroundColor(Color.Brown)\\n\\n          Text('Text2')\\n            .fontSize(50)\\n            .width('100%')\\n            .textAlign(TextAlign.Center)\\n            .height(350)\\n            .backgroundColor(Color.Orange)\\n        }\\n      }\\n      // ...\\n    }\\n    // ...\\n  }\\n}</pre> <p>优化后效果如下图所示。</p> <p></p> <p><span><img height='\\\"545.5261\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161129.47468171260362577284014672674584:50001231000000:2800:8A6E078134C4CFFA21A426E6506BED9245C078970B0A9F5E280ED379D311C15D.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window-practice.html"
    },
    {
        "id": 209,
        "pre": "@Component\\nexport struct Question7Incorrect {\\n  private windowClass = (getContext(this) as common.UIAbilityContext).windowStage.getMainWindowSync();\\n\\n  aboutToAppear(): void {\\n    this.windowClass.setSpecificSystemBarEnabled('status', false);\\n  }\\n\\n  aboutToDisappear(): void {\\n    this.windowClass.setSpecificSystemBarEnabled('status', true);\\n  }\\n\\n  build() {\\n    NavDestination() {\\n      Stack() {\\n        // ...\\n        Row() {\\n          Image($r('app.media.icon_pause'))\\n            // ...\\n            .onClick(() => {\\n              promptAction.showToast({\\n                message: 'Action success'\\n              });\\n            })\\n        }\\n        .height('100%')\\n        .width('100%')\\n        .justifyContent(FlexAlign.End)\\n        .alignItems(VerticalAlign.Top)\\n      }\\n    }\\n    .hideTitleBar(true)\\n  }\\n}",
        "type": "Reference",
        "function_call": "build()",
        "function_name": "[h2]沉浸模式下顶部窗口控制条避让问题",
        "parent_text": "[h2]沉浸模式下顶部窗口控制条避让问题沉浸式应用在悬浮窗场景下顶部操作栏无法操作 问题现象 应用分屏后视图和悬浮窗顶部重合的区域无法响应操作。   优化前示例代码如下：  可能原因 沉浸式应用顶部没有避让，导致悬浮窗顶部bar与应用的顶部区域重叠，重叠区域中的按钮无法响应点击事件。 解决措施 通过getWindowAvoidArea接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让。同时可通过on('avoidAreaChange')监听系统规避区域变化以进行布局的动态调整。具体可以参考顶部窗口控制条避让适配智慧多窗，优化后示例代码如下： @Component\\nexport struct Question7Correct {\\n  private windowClass = (getContext(this) as common.UIAbilityContext).windowStage.getMainWindowSync();\\n  @State topSafeHeight: number = 0;\\n  @State windowStatus: WindowStatusType = window.WindowStatusType.FULL_SCREEN;\\n\\n  aboutToAppear(): void {\\n    this.windowClass.setSpecificSystemBarEnabled('status', false);\\n    this.windowStatus = this.windowClass.getWindowStatus();\\n\\n    if (this.windowStatus === window.WindowStatusType.FLOATING) {\\n      this.topSafeHeight = px2vp(this.windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);\\n    }\\n\\n    this.windowClass.on('windowStatusChange', data => {\\n      if (data === window.WindowStatusType.FLOATING) {\\n        this.topSafeHeight =\\n          px2vp(this.windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);\\n      } else {\\n        this.topSafeHeight = 0;\\n      }\\n    })\\n  }\\n\\n  aboutToDisappear(): void {\\n    this.windowClass.setSpecificSystemBarEnabled('status', true);\\n  }\\n\\n  build() {\\n    // ...\\n  }\\n} 优化后效果如下图所示。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section533165015358\\\"'><a name='\\\"section533165015358\\\"'></a><a name='\\\"section533165015358\\\"'></a><h4>[h2]沉浸模式下顶部窗口控制条避让问题</h4><p><strong>沉浸式应用在悬浮窗场景下顶部操作栏无法操作</strong></p> <p><strong>问题现象</strong></p> <p>应用分屏后视图和悬浮窗顶部重合的区域无法响应操作。</p> <p></p> <p><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161131.26469255339322729595139736713203:50001231000000:2800:E4E11F6D59DC73F671B8F45763930F90DF6586C0C7C5B273906CB8511BE8100C.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>优化前示例代码如下：</p>  <p><strong>可能原因</strong></p> <p>沉浸式应用顶部没有避让，导致悬浮窗顶部bar与应用的顶部区域重叠，重叠区域中的按钮无法响应点击事件。</p> <p><strong>解决措施</strong></p> <p>通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#getwindowavoidarea9\\\"' target='\\\"_blank\\\"'>getWindowAvoidArea</a>接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让。同时可通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#onavoidareachange9\\\"' target='\\\"_blank\\\"'>on('avoidAreaChange')</a>监听系统规避区域变化以进行布局的动态调整。具体可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/multi-window-controlbar-adapt\\\"' target='\\\"_blank\\\"'>顶部窗口控制条避让适配智慧多窗</a>，优化后示例代码如下：</p> <pre class='\\\"screen\\\"'>@Component\\nexport struct Question7Correct {\\n  private windowClass = (getContext(this) as common.UIAbilityContext).windowStage.getMainWindowSync();\\n  @State topSafeHeight: number = 0;\\n  @State windowStatus: WindowStatusType = window.WindowStatusType.FULL_SCREEN;\\n\\n  aboutToAppear(): void {\\n    this.windowClass.setSpecificSystemBarEnabled('status', false);\\n    this.windowStatus = this.windowClass.getWindowStatus();\\n\\n    if (this.windowStatus === window.WindowStatusType.FLOATING) {\\n      this.topSafeHeight = px2vp(this.windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);\\n    }\\n\\n    this.windowClass.on('windowStatusChange', data =&gt; {\\n      if (data === window.WindowStatusType.FLOATING) {\\n        this.topSafeHeight =\\n          px2vp(this.windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);\\n      } else {\\n        this.topSafeHeight = 0;\\n      }\\n    })\\n  }\\n\\n  aboutToDisappear(): void {\\n    this.windowClass.setSpecificSystemBarEnabled('status', true);\\n  }\\n\\n  build() {\\n    // ...\\n  }\\n}</pre> <p>优化后效果如下图所示。</p> <p></p> <p><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161131.05284138606672091824608260585238:50001231000000:2800:4BBA4990C55C8F81D0F1DC87EE40375BC222CFDDEA0F8CD18BA087BBAF07B13B.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window-practice.html"
    },
    {
        "id": 210,
        "pre": "@Component\\nexport struct Question8Incorrect {\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Video({ src: $rawfile('testVideo1.mp4') })\\n          .height('100%')\\n          .width('100%')\\n          .autoPlay(true)\\n          .objectFit(ImageFit.Contain)\\n          .controls(false)\\n      }\\n      .height('100%')\\n      .width('100%')\\n    }\\n    .hideTitleBar(true)\\n  }\\n}",
        "type": "Reference",
        "function_call": "build()",
        "function_name": "[h2]横向悬浮窗适配问题",
        "parent_text": "[h2]横向悬浮窗适配问题视频播放未适配横向悬浮窗 问题现象 视频或者游戏类应用在横屏模式下，开启悬浮窗后，页面没有适配横屏，导致内容显示不全或者观看体验不好。   优化前示例代码如下：  可能原因 悬浮窗默认是竖屏，需要应用主动适配横屏的属性值 解决措施 开发者可以通过在module.json5配置文件中abilities标签下的preferMultiWindowOrientation属性增加“landscape_auto”。 {\\n  \\\"module\\\": {\\n    // ...\\n    \\\"abilities\\\": [\\n      {\\n        \\\"name\\\": \\\"EntryAbility\\\",\\n        // ...\\n        \\\"preferMultiWindowOrientation\\\": \\\"landscape_auto\\\"\\n      }\\n    ],\\n    // ...\\n  }\\n} 该场景下多窗布局动态可变为横向，需要配合API（enableLandscapeMultiWindow / disableLandscapeMultiWindow）使用。 @Component\\nexport struct Question8Correct {\\n  private windowClass = (getContext(this) as common.UIAbilityContext).windowStage.getMainWindowSync();\\n\\n  aboutToAppear(): void {\\n    this.windowClass.enableLandscapeMultiWindow();\\n  }\\n\\n  aboutToDisappear(): void {\\n    this.windowClass.disableLandscapeMultiWindow();\\n  }\\n\\n  build() {\\n    // ...\\n  }\\n} 优化后效果如下图所示。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section4595191593711\\\"'><a name='\\\"section4595191593711\\\"'></a><a name='\\\"section4595191593711\\\"'></a><h4>[h2]横向悬浮窗适配问题</h4><p><strong>视频播放未适配横向悬浮窗</strong></p> <p><strong>问题现象</strong></p> <p>视频或者游戏类应用在横屏模式下，开启悬浮窗后，页面没有适配横屏，导致内容显示不全或者观看体验不好。</p> <p></p> <p><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161131.90867306127747177697565888494094:50001231000000:2800:A4BFB5B98817DB26E8280FA3F905173E96655D30662BBAEE7F2F7D649DA929A5.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>优化前示例代码如下：</p>  <p><strong>可能原因</strong></p> <p>悬浮窗默认是竖屏，需要应用主动适配横屏的属性值</p> <p><strong>解决措施</strong></p> <p>开发者可以通过在module.json5配置文件中abilities标签下的preferMultiWindowOrientation属性增加“landscape_auto”。</p> <pre class='\\\"screen\\\"'>{\\n  \\\"module\\\": {\\n    // ...\\n    \\\"abilities\\\": [\\n      {\\n        \\\"name\\\": \\\"EntryAbility\\\",\\n        // ...\\n        \\\"preferMultiWindowOrientation\\\": \\\"landscape_auto\\\"\\n      }\\n    ],\\n    // ...\\n  }\\n}</pre> <p>该场景下多窗布局动态可变为横向，需要配合API（enableLandscapeMultiWindow / disableLandscapeMultiWindow）使用。</p> <pre class='\\\"screen\\\"'>@Component\\nexport struct Question8Correct {\\n  private windowClass = (getContext(this) as common.UIAbilityContext).windowStage.getMainWindowSync();\\n\\n  aboutToAppear(): void {\\n    this.windowClass.enableLandscapeMultiWindow();\\n  }\\n\\n  aboutToDisappear(): void {\\n    this.windowClass.disableLandscapeMultiWindow();\\n  }\\n\\n  build() {\\n    // ...\\n  }\\n}</pre> <p>优化后效果如下图所示。</p> <p></p> <p><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161131.96469915248025689941898797524027:50001231000000:2800:1DC0C4D9E7CFA2BB5FDCDC0DC9C842D20E546F9D28DDEAE9A2855D8EF446F632.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-window-practice.html"
    },
    {
        "id": 211,
        "pre": "{\\n  \\\"files\\\":   //用于表示配置适用的文件范围的 glob 模式数组。在没有指定的情况下，应用默认配置\\n  [\\n    \\\"**/*.js\\\", //字符串类型\\n    \\\"**/*.ts\\\"\\n  ],\\n  \\\"ignore\\\":  //一个表示配置对象不应适用的文件的 glob 模式数组。如果没有指定，配置对象将适用于所有由 files 匹配的文件\\n  [\\n    \\\"build/**/*\\\",    //字符串类型\\n    \\\"node_modules/**/*\\\"\\n  ],\\n  \\\"ruleSet\\\":       //设置检查待应用的规则集\\n  [\\n    \\\"plugin:@typescript-eslint/recommended\\\"    //快捷批量引入的规则集, 枚举类型：plugin:@typescript-eslint/all, plugin:@typescript-eslint/recommended, plugin:@cross-device-app-dev/all, plugin:@cross-device-app-dev/recommended等\\n  ],\\n  \\\"rules\\\":         //可以对ruleSet配置的规则集中特定的某些规则进行修改、去使能, 或者新增规则集以外的规则；ruleSet和rules共同确定了代码检查所应用的规则\\n  {\\n    \\\"@typescript-eslint/no-explicit-any\\\":  // ruleId后面跟数组时, 第一个元素为告警级别, 后面的对象元素为规则特定开关配置\\n    [\\n      \\\"error\\\",              //告警级别: 枚举类型, 支持配置为suggestion, error, warn, off\\n      {\\n        \\\"ignoreRestArgs\\\": true   //规则特定的开关配置, 为可选项, 不同规则其下层的配置项不同\\n      }\\n    ],\\n    \\\"@typescript-eslint/explicit-function-return-type\\\": 2,   // ruleId后面跟单独一个数字时, 表示仅设置告警级别, 枚举值为: 3(suggestion), 2(error), 1(warn), 0(off)\\n    \\\"@typescript-eslint/no-unsafe-return\\\": \\\"warn\\\"            // ruleId后面跟单独一个字符串时, 表示仅设置告警级别, 枚举值为: suggestion, error, warn, off\\n  },\\n  \\\"overrides\\\":      //针对特定的目录或文件采用定制化的规则配置\\n  [\\n    {\\n      \\\"files\\\":   //指定需要定制化配置规则的文件或目录\\n      [\\n        \\\"entry/**/*.ts\\\"   //字符串类型\\n      ],\\n      \\\"excluded\\\":\\n      [\\n       \\\"entry/**/*.test.js\\\" //指定需要排除的目录或文件, 被排除的目录或文件不会按照定制化的规则配置被检查; 字符串类型\\n      ],\\n      \\\"rules\\\":   //支持对overrides外公共配置的规则进行修改、去使能, 或者新增公共配置以外的规则; 该配置将覆盖公共配置\\n      {\\n        \\\"@typescript-eslint/explicit-function-return-type\\\":  // ruleId: 枚举类型\\n        [\\n          \\\"warn\\\",     //告警级别: 枚举类型, 支持配置为error, warn, off; 覆盖公共配置, explicit-function-return-type告警级别为warn\\n          {\\n             allowExpressions: true    //规则特定的开关配置, 为可选项, 不同规则其下层的配置项不同\\n          }\\n        ],\\n        \\\"@typescript-eslint/no-unsafe-return\\\": \\\"off\\\"   // 覆盖公共配置, 不检查no-unsafe-return规则\\n      }\\n    }\\n  ]\\n}",
        "type": "Reference",
        "function_call": "bar()",
        "function_name": "使用CodeLinter检测",
        "parent_text": "使用CodeLinter检测Code Linter代码检查 Code Linter针对ArkTS/TS代码进行最佳实践/编程规范方面的检查。检查规则支持配置，配置方式请参考配置代码检查规则。 开发者可根据扫描结果中告警提示手工修复代码缺陷，或者执行一键式自动修复，在代码开发阶段，确保代码质量。 检查方法： 在已打开的代码编辑器窗口单击右键点击Code Linter，或在工程管理窗口中鼠标选中单个或多个工程文件/目录，右键选择Code Linter > Full Linter执行代码全量检查。  如只需对Git工程中增量文件（包含新增/修改/重命名）进行检查，可在commit界面右下角点击齿轮图标，选择Incremental Linter执行增量检查。  若未配置代码检查规则文件，直接执行Code Linter，将按照默认的编程规范规则对.ets文件进行检查。Code Linter不对如下文件及目录进行检查：src/ohosTest文件夹src/test文件夹node_modules文件夹oh_modules文件夹build文件夹.preview文件夹hvigorfile.ts文件hvigorfile.js文件    配置代码检查规则 在工程根目录下创建code-linter.json5配置文件，可对于代码检查的范围及对应生效的检查规则进行配置，其中files和ignore配置项共同确定了代码检查范围，ruleSet和rules配置项共同确定了生效的规则范围。具体配置项功能如下： files：配置待检查的文件名单，如未指定目录，将检查当前被选中的文件或文件夹中所有的.ets文件。 ignore：配置无需检查的文件目录，其指定的目录或文件需使用相对路径格式，相对于code-linter.json5所在工程根目录，例如：build/**/*。 ruleSet：配置检查使用的规则集，规则集支持一次导入多条规则。规则详情请参见Code Linter代码检查规则。目前支持的规则集包括： 通用规则@typescript-eslint一次开发多端部署规则@cross-device-app-devArkTS代码风格规则@hw-stylistic安全规则@security性能规则@performance预览规则@previewer  以上规则集均分为all和recommended两种规则集。all规则集是规则全集，包含所有规则；recommended规则集是推荐使用的规则集合。all规则集包含recommended规则集。不在工程根目录新建code-linter.json5文件的情况下，Code Linter默认会检查@performance/recommended和@typescript-eslint/recommended规则集包含的规则。  rules：可以基于ruleSet配置的规则集，新增额外规则项，或修改ruleSet中规则默认配置，例如：将规则集中某条规则告警级别由warn改为error。 overrides：针对工程根目录下部分特定目录或文件，可配置定制化检查的规则。  查看/处理代码检查结果 扫描完成后，在底部工具面板查看检查结果。勾选Defects中不同告警等级，可分别查看对应告警级别的信息。双击某条告警结果，可以跳转到对应代码缺陷位置；选中告警结果时，可以在右侧Defect Description窗口查看告警对应的规则详细说明，其中包含正向和反向示例，并根据其中的建议修改代码；搜索规则时，可设定是否全词匹配和大小写敏感。 单击图标，查看可修复的代码规则，点击代码修复图标，可以一键式批量修复告警，并刷新检查结果。  屏蔽告警信息： 在某些特殊场景下，若扫描结果中出现误报，点击单条告警结果后的Ignore图标，可以忽略对告警所在行的code linter检查；或勾选文件名称或多条待屏蔽的告警，点击左侧工具面板Ignore图标批量执行操作；在文件顶部添加注释/* eslint-disable */可以屏蔽整个文件执行code linter检查，在eslint-disable 后加入一个或多个以逗号分隔的规则Id，可以屏蔽具体检查规则；在需要忽略检查的代码块前后分别添加/* eslint-disable */和/* eslint-enable */添加注释信息，再执行Code Linter，将不再显示该代码块扫描结果；在待屏蔽的代码行前一行添加/* eslint-disable-next-line */，也可屏蔽对该代码行的codelinter检查。 如需恢复忽略的报错信息，可以直接删除该行上方的注释，重新执行Code Linter检查。  导出检查结果：点击工具面板左侧导出按钮，即可导出检查结果到excel文件，包含告警所在行，告警明细，告警级别等信息。  实践说明 以@typescript-eslint/no-restricted-syntax（使用某类语法时，codelinter告警）、@typescript-eslint/naming-convention（命名风格校验）和@hw-stylistic/file-naming-convention（检查代码文件的命名风格）三个规则为例，介绍codelinter配置文件的使用方法。 示例1：调用类Foo下bar方法时，Code Linter告警 在配置文件中定义规则 在ArkTS工程中，pages/Index.ets文件下增加以下用例： class Foo {\\n  static bar() {}\\n}\\n\\nFoo.bar(); 在工程根目录下新建code-linter.json5文件（文件名不可修改），新增以下配置： {\\n  \\\"rules\\\": {\\n    \\\"@typescript-eslint/no-restricted-syntax\\\": [\\n      // 告警级别: 枚举类型, 支持配置为error, warn, off\\n      \\\"error\\\",\\n      {\\n        // selector属性必选，配置要禁用的语法\\n        // 可通过特定DSL筛选待限制的语句，CallExpression表示方法调用表达式，后面的中括号里面是筛选条件（根据语法树Node节点来确定）\\n        // 其中callee.object.name根据指定的名称筛选调用方法的对象（class，namespace或module），以上示例中为\\\"Foo\\\"\\n        // callee.property.name则根据指定的名称筛选被调用的方法，以上示例中为\\\"bar\\\"\\n        \\\"selector\\\": \\\"CallExpression[callee.object.name='Foo'][callee.property.name='bar']\\\",\\n        // message属性可选，配置要展示的报错信息\\n        \\\"message\\\": \\\"Foo.bar() is not allowed\\\"\\n      }\\n    ]\\n  },\\n}  如需在code-linter.json5文件中配置其他字段，请参见配置代码检查规则。  执行代码检查 对pages/Index.ets文件执行代码检查，检查结果如下：  示例2：对类名Foo的命名风格校验 在配置文件中定义规则 在ArkTS工程中，pages/Index.ets文件下增加以下用例： class foo {    //此处构造一个命名风格错误的示例，foo为错误使用类名，正确类名应为Foo\\n  bar() {} \\n} 在工程根目录下新建code-linter.json5文件，新增以下配置： {\\n  \\\"rules\\\": {\\n    \\\"@typescript-eslint/naming-convention\\\": [\\n      \\\"error\\\",\\n      {\\n        // selector属性必选，配置要检查的语法，这里配置的class表示检查自定义组件名\\n        \\\"selector\\\": \\\"class\\\",\\n        // format属性必选，配置期望的命名风格，支持枚举值，这里配置的PascalCase表示大驼峰风格\\n        \\\"format\\\": [\\\"PascalCase\\\"],\\n        // custom属性可选，配置用户自定义的命名风格\\n        \\\"custom\\\": {\\n          // regex属性必选，配置具体的正则\\n          \\\"regex\\\": \\\"^[a-zA-Z]+$\\\",\\n          // match属性必选，配置为true表示正则未命中时报错；配置为false表示正则命中时报错\\n          \\\"match\\\": true\\n        }\\n      }\\n    ]\\n  },\\n} 表1 字段说明字段名称  参数说明  是否必选  类型  支持配置的参数    selector  配置要检查的语法  是  字符串、字符串数组  variable：变量function：函数parameter：参数parameterProperty：参数属性accessor：get/set方法enumMember：枚举成员classMethod：类方法structMethod：自定义组件中的方法objectLiteralMethod：对象方法typeMethod：接口方法classProperty：类属性structProperty：自定义组件中的属性objectLiteralProperty：对象属性typeProperty：接口属性class：类struct：自定义组件interface：接口typeAlias：类型别名enum：枚举typeParameter：泛型参数default：包含以上所有的类型variableLike：包含variable，function，parametermemberLike：包含classProperty，structProperty，objectLiteralProperty，typeProperty，parameterProperty ，enumMember，classMethod，objectLiteralMethod，typeMethod，accessortypeLike：包含class，struct，interface，typeAlias，enum，typeParametermethod：包含classMethod，structMethod，objectLiteralMethod，typeMethodproperty：包含classProperty，objectLiteralProperty，typeProperty   format  配置期望的命名风格  是  字符串数组  camelCase：小驼峰命名风格，比如getName，getID（支持连续大写字母），不支持下划线strictCamelCase：严格小驼峰命名风格，除了不支持连续大写字母（getID），其他的和camelCase相同PascalCase：大驼峰命名风格，比如Foo，CC，除了要求第一个字母大写，其他的和camelCase相同StrictPascalCase：大驼峰命名风格，除了不支持连续大写字母（CC），其他的和PascalCase相同snake_case：小写字母+下划线+小写字母的命名风格，比如a_a，不支持_a，a_a_UPPER_CASE：大写字母+下划线+大写字母的命名风格，比如A_A，不支持_A，A_A_   custom  配置用户自定义的命名风格  否  对象  regex：属性必选，配置具体的正则match：属性必选，配置为true表示正则未命中时报错，配置为false表示正则命中时报错   leadingUnderscore/trailingUnderscore  配置是否允许以下划线开头/以下划线结尾的命名风格  否  字符串  allow：允许以一个下划线开头/结尾的命名风格，比如_nameallowDouble：允许以两个下划线开头/结尾的命名风格，比如__nameallowSingleOrDouble：允许以一个或者两个下划线开头/结尾的命名风格（allow+allowDouble）forbid：禁止以下划线开头/结尾的命名风格，比如_name，__namerequire：必须是以下划线开头/结尾的命名风格，比如_name，__namerequireDouble：必须是以两个下划线开头/结尾的命名风格，比如__name   prefix/suffix  配置固定前缀/后缀的命名风格。如果前缀/后缀未匹配则报错  否  字符串数组  用户自定义前缀/后缀   filter  过滤特定的命名风格，检查或者不检查正则命中的命名  否  对象  配置格式与custom相似 match：设置为true表示只检查正则命中的名字，设置为false表示不检查正则命中的名字 regex：设置过滤的正则 说明 支持直接配置一个字符串，这个字符串配置的是regex，此时match相当于配置的是true。   modifiers  匹配修饰符，只有包含特定修饰符的命名才会检查  否  字符串数组  abstract：匹配abstract关键字override：匹配override关键字private：匹配private关键字protected：匹配protected关键字static：匹配static关键字async：匹配async关键字const：匹配const关键字destructured：匹配解构语法exported：匹配export关键字global：匹配全局声明#private：匹配私有符号#public：匹配public级别的访问修饰符requiresQuotes：匹配字符串类型的命名，并且 字符串中包含特殊字符unused：匹配未使用的声明   types  匹配类型，只有特定类型的名字才会检查  否  字符串数组  array：数组类型boolean：布尔类型function：函数类型number：数字类型string：字符串类型      以上配置的参数有校验优先级：filter > types > modifiers > validate leading underscore > validate trailing underscore > validate prefix > validate suffix > validate custom > validate format。  执行代码检查 对pages/Index.ets文件执行代码检查，检查结果如下：  示例3：检查代码文件的命名风格 在配置文件中定义规则 在ArkTS工程中，pages目录下新建test.ets文件； 在工程根目录下新建code-linter.json5文件，新增以下配置： {\\n  \\\"rules\\\": {\\n    \\\"@hw-stylistic/file-naming-convention\\\": [\\n      // 告警级别：枚举类型，支持配置为error，warn，off\\n      \\\"error\\\",\\n      {\\n        // selector属性可选，支持配置为code或者resources\\n        // code表示检查代码文件的命名风格\\n        // resources表示检查资源文件的命名风格\\n        \\\"selector\\\": \\\"code\\\"\\n      }\\n    ]\\n  },\\n}  如果selector属性不配置，默认检查代码文件和资源文件的命名风格。  执行代码检查 对pages/test.ets文件执行代码检查，检查结果如下：   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1651414520531\\\"'><a name='\\\"section1651414520531\\\"'></a><a name='\\\"section1651414520531\\\"'></a><h4>使用CodeLinter检测</h4><p><strong>Code Linter代码检查</strong></p> <p>Code Linter针对ArkTS/TS代码进行最佳实践/编程规范方面的检查。检查规则支持配置，配置方式请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter#section1782903483817\\\"' target='\\\"_blank\\\"'>配置代码检查规则</a>。</p> <p>开发者可根据扫描结果中告警提示手工修复代码缺陷，或者执行一键式自动修复，在代码开发阶段，确保代码质量。</p> <p>检查方法：</p> <p>在已打开的代码编辑器窗口单击右键点击Code Linter，或在工程管理窗口中鼠标选中单个或多个工程文件/目录，右键选择Code Linter &gt; Full Linter执行代码全量检查。</p> <p><span><img originheight='\\\"437\\\"' originwidth='\\\"792\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.91030433519380755942309013356828:50001231000000:2800:F84C6329650F955D469F3BF61A7B1A77A6517D0271FAA571BC674D1EFEEA10CF.png\\\"'/></span></p> <p>如只需对Git工程中增量文件（包含新增/修改/重命名）进行检查，可在commit界面右下角点击齿轮图标，选择Incremental Linter执行增量检查。</p> <div class='\\\"p\\\"'><span><img originheight='\\\"935\\\"' originwidth='\\\"1118\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.64019794267372837461674295321848:50001231000000:2800:7C7DA6E546DD4523191BA054016F8EB9998D538084FCFBA203596E23283DB2C6.png\\\"'/></span><div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.88140657541743913193316742153425:50001231000000:2800:22A9C2D3E91E75AF1D621C4E14B15ABD7C3A1D1AFFA7B2474565BA0CF6C9F201.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><ul><li>若未配置代码检查规则文件，直接执行Code Linter，将按照默认的编程规范规则对.ets文件进行检查。</li><li>Code Linter不对如下文件及目录进行检查：<ul><li>src/ohosTest文件夹</li><li>src/test文件夹</li><li>node_modules文件夹</li><li>oh_modules文件夹</li><li>build文件夹</li><li>.preview文件夹</li><li>hvigorfile.ts文件</li><li>hvigorfile.js文件</li></ul> </li></ul> </div></div> </div> <p><strong>配置代码检查规则</strong></p> <p>在工程根目录下创建code-linter.json5配置文件，可对于代码检查的范围及对应生效的检查规则进行配置，其中files和ignore配置项共同确定了代码检查范围，ruleSet和rules配置项共同确定了生效的规则范围。具体配置项功能如下：</p> <p>files：配置待检查的文件名单，如未指定目录，将检查当前被选中的文件或文件夹中所有的.ets文件。</p> <p>ignore：配置无需检查的文件目录，其指定的目录或文件需使用相对路径格式，相对于code-linter.json5所在工程根目录，例如：build/**/*。</p> <p>ruleSet：配置检查使用的规则集，规则集支持一次导入多条规则。规则详情请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-codelinter-rule\\\"' target='\\\"_blank\\\"'>Code Linter代码检查规则</a>。目前支持的规则集包括：</p> <ul><li>通用规则@typescript-eslint</li><li>一次开发多端部署规则@cross-device-app-dev</li><li>ArkTS代码风格规则@hw-stylistic</li><li>安全规则@security</li><li>性能规则@performance</li><li>预览规则@previewer</li></ul> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.11920668227300441360202117521285:50001231000000:2800:C1DF455DD0F69A0F4FBCBD96A159A63DB64159FCC0F0629AA30D66450DBD6B66.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><ul><li>以上规则集均分为all和recommended两种规则集。all规则集是规则全集，包含所有规则；recommended规则集是推荐使用的规则集合。all规则集包含recommended规则集。</li><li>不在工程根目录新建code-linter.json5文件的情况下，Code Linter默认会检查@performance/recommended和@typescript-eslint/recommended规则集包含的规则。</li></ul> </div></div> <p>rules：可以基于ruleSet配置的规则集，新增额外规则项，或修改ruleSet中规则默认配置，例如：将规则集中某条规则告警级别由warn改为error。</p> <p>overrides：针对工程根目录下部分特定目录或文件，可配置定制化检查的规则。</p>  <p><strong>查看/处理代码检查结果</strong></p> <p>扫描完成后，在底部工具面板查看检查结果。勾选Defects中不同告警等级，可分别查看对应告警级别的信息。双击某条告警结果，可以跳转到对应代码缺陷位置；选中告警结果时，可以在右侧Defect Description窗口查看告警对应的规则详细说明，其中包含正向和反向示例，并根据其中的建议修改代码；搜索规则时，可设定是否全词匹配和大小写敏感。</p> <p>单击<span><img originheight='\\\"20\\\"' originwidth='\\\"20\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.60338643701652486393018713251342:50001231000000:2800:1966B3DBBF47E2DF6E3EB37A911AB43ACBA5B33E38B883A1B5300E97D703D21E.png\\\"'/></span>图标，查看可修复的代码规则，点击<span><img originheight='\\\"18\\\"' originwidth='\\\"18\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.68729258970630511865183196066126:50001231000000:2800:050199F932DFF91C03D034AE7544D2BC1B19AA3230928EA5502D5946DD5849FE.png\\\"'/></span>代码修复图标，可以一键式批量修复告警，并刷新检查结果。</p> <p><span><img originheight='\\\"277\\\"' originwidth='\\\"1266\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.34852691744174880878715364811089:50001231000000:2800:69CDE9EF1FB6E97FB5FA8CC8F23ADDE3CCFE0669BCEB5132CD11909A92A0AE91.png\\\"'/></span></p> <p>屏蔽告警信息：</p> <ul><li>在某些特殊场景下，若扫描结果中出现误报，点击单条告警结果后的<span><img originheight='\\\"16\\\"' originwidth='\\\"16\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.82357120443364376593563678412155:50001231000000:2800:3CAFAEC9AE366DFB310E78A3D8931B095FDACA456A14EE3FA4E2526CD1FAC287.png\\\"'/></span>Ignore图标，可以忽略对告警所在行的code linter检查；或勾选文件名称或多条待屏蔽的告警，点击左侧工具面板Ignore图标批量执行操作；</li><li>在文件顶部添加注释/* eslint-disable */可以屏蔽整个文件执行code linter检查，在eslint-disable 后加入一个或多个以逗号分隔的规则Id，可以屏蔽具体检查规则；</li><li>在需要忽略检查的代码块前后分别添加/* eslint-disable */和/* eslint-enable */添加注释信息，再执行Code Linter，将不再显示该代码块扫描结果；在待屏蔽的代码行前一行添加/* eslint-disable-next-line */，也可屏蔽对该代码行的codelinter检查。</li></ul> <p>如需恢复忽略的报错信息，可以直接删除该行上方的注释，重新执行Code Linter检查。</p> <p><span><img originheight='\\\"279\\\"' originwidth='\\\"816\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.45956624504551456983765553965315:50001231000000:2800:7936553D54D578A8A23BF630F031A5E4AD16ED1548872467F97D15BD50BA68A9.png\\\"'/></span></p> <p>导出检查结果：点击工具面板左侧<span><img originheight='\\\"16\\\"' originwidth='\\\"16\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.55381127051363929528815647347608:50001231000000:2800:C5AFFA274C71385138AEBA900A1D7E8992A8D1D72752186FD0F5DFFA9B2152EA.png\\\"'/></span>导出按钮，即可导出检查结果到excel文件，包含告警所在行，告警明细，告警级别等信息。</p> <p><span><img originheight='\\\"292\\\"' originwidth='\\\"815\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.20064025842510536980551315597024:50001231000000:2800:73D689A9F04FACDCB59BC18021CFF0C724B2DA726B27DC8A994B346417DAB405.png\\\"'/></span></p> <p><strong>实践说明</strong></p> <p>以@typescript-eslint/no-restricted-syntax（使用某类语法时，codelinter告警）、@typescript-eslint/naming-convention（命名风格校验）和@hw-stylistic/file-naming-convention（检查代码文件的命名风格）三个规则为例，介绍codelinter配置文件的使用方法。</p> <p><strong>示例1：调用类Foo下bar方法时，Code Linter告警</strong></p> <p><strong>在配置文件中定义规则</strong></p> <p>在ArkTS工程中，pages/Index.ets文件下增加以下用例：</p> <pre class='\\\"screen\\\"'>class Foo {\\n  static bar() {}\\n}\\n\\nFoo.bar();</pre> <p>在工程根目录下新建code-linter.json5文件（文件名不可修改），新增以下配置：</p> <pre class='\\\"screen\\\"'>{\\n  \\\"rules\\\": {\\n    \\\"@typescript-eslint/no-restricted-syntax\\\": [\\n      // 告警级别: 枚举类型, 支持配置为error, warn, off\\n      \\\"error\\\",\\n      {\\n        // selector属性必选，配置要禁用的语法\\n        // 可通过特定DSL筛选待限制的语句，CallExpression表示方法调用表达式，后面的中括号里面是筛选条件（根据语法树Node节点来确定）\\n        // 其中callee.object.name根据指定的名称筛选调用方法的对象（class，namespace或module），以上示例中为\\\"Foo\\\"\\n        // callee.property.name则根据指定的名称筛选被调用的方法，以上示例中为\\\"bar\\\"\\n        \\\"selector\\\": \\\"CallExpression[callee.object.name='Foo'][callee.property.name='bar']\\\",\\n        // message属性可选，配置要展示的报错信息\\n        \\\"message\\\": \\\"Foo.bar() is not allowed\\\"\\n      }\\n    ]\\n  },\\n}</pre> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.71347855152415384077321342876560:50001231000000:2800:D8692188A14E95D8A9238403D33783F2B65EC34DD4A8B8672ECF6815AD9E512A.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>如需在code-linter.json5文件中配置其他字段，请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter#section1782903483817\\\"' target='\\\"_blank\\\"'>配置代码检查规则</a>。</p> </div></div> <p>执行代码检查</p> <p>对pages/Index.ets文件执行代码检查，检查结果如下：</p> <p><span><img originheight='\\\"141\\\"' originwidth='\\\"601\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.35693158405400539905401661614106:50001231000000:2800:4B9A13AA72FB0ADE0633E00B6718A72AFCE9C35F4D628E9966F6E80D7FCFD224.png\\\"'/></span></p> <p><strong>示例2：对类名Foo的命名风格校验</strong></p> <p>在配置文件中定义规则</p> <p>在ArkTS工程中，pages/Index.ets文件下增加以下用例：</p> <pre class='\\\"screen\\\"'>class foo {    //此处构造一个命名风格错误的示例，foo为错误使用类名，正确类名应为Foo\\n  bar() {} \\n}</pre> <p>在工程根目录下新建code-linter.json5文件，新增以下配置：</p> <pre class='\\\"screen\\\"'>{\\n  \\\"rules\\\": {\\n    \\\"@typescript-eslint/naming-convention\\\": [\\n      \\\"error\\\",\\n      {\\n        // selector属性必选，配置要检查的语法，这里配置的class表示检查自定义组件名\\n        \\\"selector\\\": \\\"class\\\",\\n        // format属性必选，配置期望的命名风格，支持枚举值，这里配置的PascalCase表示大驼峰风格\\n        \\\"format\\\": [\\\"PascalCase\\\"],\\n        // custom属性可选，配置用户自定义的命名风格\\n        \\\"custom\\\": {\\n          // regex属性必选，配置具体的正则\\n          \\\"regex\\\": \\\"^[a-zA-Z]+$\\\",\\n          // match属性必选，配置为true表示正则未命中时报错；配置为false表示正则命中时报错\\n          \\\"match\\\": true\\n        }\\n      }\\n    ]\\n  },\\n}</pre> <div class='\\\"tablenoborder\\\"'><table><caption><b>表1 </b>字段说明</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.48.2.6.1.1\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>字段名称</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.48.2.6.1.2\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>参数说明</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.48.2.6.1.3\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>是否必选</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.48.2.6.1.4\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>类型</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.22.48.2.6.1.5\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><p>支持配置的参数</p> </th> </tr> </thead> <tbody><tr><td align='\\\"left\\\"' class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>selector</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>配置要检查的语法</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>是</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>字符串、字符串数组</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><ul><li>variable：变量</li><li>function：函数</li><li>parameter：参数</li><li>parameterProperty：参数属性</li><li>accessor：get/set方法</li><li>enumMember：枚举成员</li><li>classMethod：类方法</li><li>structMethod：自定义组件中的方法</li><li>objectLiteralMethod：对象方法</li><li>typeMethod：接口方法</li><li>classProperty：类属性</li><li>structProperty：自定义组件中的属性</li><li>objectLiteralProperty：对象属性</li><li>typeProperty：接口属性</li><li>class：类</li><li>struct：自定义组件</li><li>interface：接口</li><li>typeAlias：类型别名</li><li>enum：枚举</li><li>typeParameter：泛型参数</li><li>default：包含以上所有的类型</li><li>variableLike：包含variable，function，parameter</li><li>memberLike：包含classProperty，structProperty，objectLiteralProperty，typeProperty，parameterProperty ，enumMember，classMethod，objectLiteralMethod，typeMethod，accessor</li><li>typeLike：包含class，struct，interface，typeAlias，enum，typeParameter</li><li>method：包含classMethod，structMethod，objectLiteralMethod，typeMethod</li><li>property：包含classProperty，objectLiteralProperty，typeProperty</li></ul> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>format</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>配置期望的命名风格</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>是</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>字符串数组</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><ul><li>camelCase：小驼峰命名风格，比如getName，getID（支持连续大写字母），不支持下划线</li><li>strictCamelCase：严格小驼峰命名风格，除了不支持连续大写字母（getID），其他的和camelCase相同</li><li>PascalCase：大驼峰命名风格，比如Foo，CC，除了要求第一个字母大写，其他的和camelCase相同</li><li>StrictPascalCase：大驼峰命名风格，除了不支持连续大写字母（CC），其他的和PascalCase相同</li><li>snake_case：小写字母+下划线+小写字母的命名风格，比如a_a，不支持_a，a_a_</li><li>UPPER_CASE：大写字母+下划线+大写字母的命名风格，比如A_A，不支持_A，A_A_</li></ul> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>custom</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>配置用户自定义的命名风格</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>否</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>对象</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><ul><li>regex：属性必选，配置具体的正则</li><li>match：属性必选，配置为true表示正则未命中时报错，配置为false表示正则命中时报错</li></ul> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>leadingUnderscore/trailingUnderscore</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>配置是否允许以下划线开头/以下划线结尾的命名风格</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>否</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>字符串</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><ul><li>allow：允许以一个下划线开头/结尾的命名风格，比如_name</li><li>allowDouble：允许以两个下划线开头/结尾的命名风格，比如__name</li><li>allowSingleOrDouble：允许以一个或者两个下划线开头/结尾的命名风格（allow+allowDouble）</li><li>forbid：禁止以下划线开头/结尾的命名风格，比如_name，__name</li><li>require：必须是以下划线开头/结尾的命名风格，比如_name，__name</li><li>requireDouble：必须是以两个下划线开头/结尾的命名风格，比如__name</li></ul> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>prefix/suffix</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>配置固定前缀/后缀的命名风格。如果前缀/后缀未匹配则报错</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>否</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>字符串数组</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><p>用户自定义前缀/后缀</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>filter</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>过滤特定的命名风格，检查或者不检查正则命中的命名</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>否</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>对象</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><p>配置格式与custom相似</p> <p>match：设置为true表示只检查正则命中的名字，设置为false表示不检查正则命中的名字</p> <p>regex：设置过滤的正则</p> <p>说明</p> <p>支持直接配置一个字符串，这个字符串配置的是regex，此时match相当于配置的是true。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>modifiers</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>匹配修饰符，只有包含特定修饰符的命名才会检查</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>否</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>字符串数组</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><ul><li>abstract：匹配abstract关键字</li><li>override：匹配override关键字</li><li>private：匹配private关键字</li><li>protected：匹配protected关键字</li><li>static：匹配static关键字</li><li>async：匹配async关键字</li><li>const：匹配const关键字</li><li>destructured：匹配解构语法</li><li>exported：匹配export关键字</li><li>global：匹配全局声明</li><li>#private：匹配私有符号#</li><li>public：匹配public级别的访问修饰符</li><li>requiresQuotes：匹配字符串类型的命名，并且 字符串中包含特殊字符</li><li>unused：匹配未使用的声明</li></ul> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"19.77197719771977%\\\"'><p>types</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"18.961896189618958%\\\"'><p>匹配类型，只有特定类型的名字才会检查</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"6.330633063306331%\\\"'><p>否</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"10.36103610361036%\\\"'><p>字符串数组</p> </td> <td class='\\\"cellrowborder\\\"' none;\\\"=\"\" style='\\\"border:' valign='\\\"top\\\"' width='\\\"44.57445744574458%\\\"'><ul><li>array：数组类型</li><li>boolean：布尔类型</li><li>function：函数类型</li><li>number：数字类型</li><li>string：字符串类型</li></ul> </td> </tr> </tbody></table> </div> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.65169121748522516499950422114932:50001231000000:2800:60AA55B1FAE4DAE002FAF67583D722D3C52269DD7A889F39FA060B2B9709EE9F.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>以上配置的参数有校验优先级：filter &gt; types &gt; modifiers &gt; validate leading underscore &gt; validate trailing underscore &gt; validate prefix &gt; validate suffix &gt; validate custom &gt; validate format。</p> </div></div> <p><strong>执行代码检查</strong></p> <p>对pages/Index.ets文件执行代码检查，检查结果如下：</p> <p><span><img originheight='\\\"169\\\"' originwidth='\\\"887\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.12020441057085943200779668521258:50001231000000:2800:5F64CDB521BC6713C30624731984739959E2D613C38F008CD7C903D06688F175.png\\\"'/></span></p> <p><strong>示例3：检查代码文件的命名风格</strong></p> <p><strong>在配置文件中定义规则</strong></p> <p>在ArkTS工程中，pages目录下新建test.ets文件；</p> <p>在工程根目录下新建code-linter.json5文件，新增以下配置：</p> <pre class='\\\"screen\\\"'>{\\n  \\\"rules\\\": {\\n    \\\"@hw-stylistic/file-naming-convention\\\": [\\n      // 告警级别：枚举类型，支持配置为error，warn，off\\n      \\\"error\\\",\\n      {\\n        // selector属性可选，支持配置为code或者resources\\n        // code表示检查代码文件的命名风格\\n        // resources表示检查资源文件的命名风格\\n        \\\"selector\\\": \\\"code\\\"\\n      }\\n    ]\\n  },\\n}</pre> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161255.85135624944363046277798066632013:50001231000000:2800:38B75CB7E7C9FA9B1E8E4B76302B9E61DE4CABBC5C6F8786FF607F53DAA4B138.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>如果selector属性不配置，默认检查代码文件和资源文件的命名风格。</p> </div></div> <p><strong>执行代码检查</strong></p> <p>对pages/test.ets文件执行代码检查，检查结果如下：</p> <p><span><img originheight='\\\"168\\\"' originwidth='\\\"886\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161256.78080355415670742416800169292910:50001231000000:2800:071BA5358BF56EE907159459D66F6A044DDDD49C3383288FCD88D2F20D67EDBD.png\\\"'/></span></p> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-stability-ide-static-detection.html"
    },
    {
        "id": 212,
        "pre": "void EGLCore::Draw()\\n{\\n    // 确定绘制四边形的顶点，使用绘制区域的百分比表示\\n    const GLfloat shapeVertices[] = {\\n        centerX / width_, centerY / height_,\\n        leftX / width_, leftY / height_,\\n        rotateX / width_, rotateY / height_,\\n        rightX / width_, rightY / height_\\n    };\\n    \\n    if (!ExecuteDrawStar(position, DRAW_COLOR, shapeVertices, sizeof(shapeVertices))) {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"EGLCore\\\", \\\"Draw execute draw star failed\\\");\\n        return;\\n    }\\n    \\n    GLfloat rad = M_PI / 180 * 72;\\n    for (int i = 0; i < 4; ++i) \\n    {\\n        // 旋转得其他四个四边形的顶点\\n        rotate2d(centerX, centerY, &rotateX, &rotateY,rad);\\n        rotate2d(centerX, centerY, &leftX, &leftY,rad);\\n        rotate2d(centerX, centerY, &rightX, &rightY,rad);\\n        \\n        // 确定绘制四边形的顶点，使用绘制区域的百分比表示\\n        const GLfloat shapeVertices[] = {\\n                centerX / width_, centerY / height_,\\n                leftX / width_, leftY / height_,\\n                rotateX / width_, rotateY / height_,\\n                rightX / width_, rightY / height_\\n            };\\n        \\n        // 绘制图形\\n        if (!ExecuteDrawStar(position, DRAW_COLOR, shapeVertices, sizeof(shapeVertices))) {\\n            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"EGLCore\\\", \\\"Draw execute draw star failed\\\");\\n            return;\\n        }\\n    }\\n \\n    // 结束绘制\\n    if (!FinishDraw()) {\\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \\\"EGLCore\\\", \\\"Draw FinishDraw failed\\\");\\n        return;\\n    }\\n \\n    flag_ = true;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "开发步骤",
        "parent_text": "开发步骤使用EGL/OpenGLES进行渲染，就是硬件加速，使用GPU绘制。OpenGLES的接口使用方式见Native XComponent的使用指导，以下是EGL/OpenGLES 使用范例。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section7181529165813\\\"'><a name='\\\"section7181529165813\\\"'></a><a name='\\\"section7181529165813\\\"'></a><h4>开发步骤</h4><p>使用EGL/OpenGLES进行渲染，就是硬件加速，使用GPU绘制。OpenGLES的接口使用方式见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/_o_h___native_x_component\\\"' target='\\\"_blank\\\"'>Native XComponent的使用指导</a>，以下是EGL/OpenGLES 使用范例。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-barrage.html"
    },
    {
        "id": 213,
        "pre": "import { geoLocationManager } from '@kit.LocationKit';\\n\\nlet requestInfo: geoLocationManager.LocationRequest = {\\n  'scenario': geoLocationManager.LocationRequestScenario.NO_POWER,\\n  'timeInterval': 0,\\n  'distanceInterval': 0,\\n  'maxAccuracy': 0\\n};",
        "type": "Reference",
        "function_call": null,
        "function_name": "示例",
        "parent_text": "示例新闻类应用可以使用被动定位： 方式1：  方式2： import { geoLocationManager } from '@kit.LocationKit';\\n\\nlet requestInfo: geoLocationManager.LocationRequest = {\\n  'priority': geoLocationManager.LocationRequestPriority.LOW_POWER,\\n  'timeInterval': 0,\\n  'distanceInterval': 0,\\n  'maxAccuracy': 0\\n}; 有关定位服务开发相关接口的使用，详情可以参考Location Kit开发指南。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section889193114222\\\"'><a name='\\\"section889193114222\\\"'></a><a name='\\\"section889193114222\\\"'></a><h4>示例</h4><p>新闻类应用可以使用被动定位：</p> <p>方式1：</p>  <p>方式2：</p> <pre class='\\\"screen\\\"'>import { geoLocationManager } from '@kit.LocationKit';\\n\\nlet requestInfo: geoLocationManager.LocationRequest = {\\n  'priority': geoLocationManager.LocationRequestPriority.LOW_POWER,\\n  'timeInterval': 0,\\n  'distanceInterval': 0,\\n  'maxAccuracy': 0\\n};</pre> <p>有关定位服务开发相关接口的使用，详情可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/location-guidelines\\\"' target='\\\"_blank\\\"'>Location Kit开发指南</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-position-navigation-use.html"
    },
    {
        "id": 214,
        "pre": "// features/detail/src/main/ets/views/ProductDetail.ets\\nImage(this.isSplitMode ? $r('app.media.icon_split') : $r('app.media.ic_mate_pad_2'))\\n  // ...\\n  .onClick(() => {\\n    if (deviceInfo.deviceType === CommonConstants.DEVICE_TYPES[0]) {\\n      return;\\n    }\\n    if (!this.isSplitMode) {\\n      // 设置启动SecondAbility\\n      let want: Want = {\\n        bundleName: 'com.huawei.multishoppingpricecomparison',\\n        abilityName: 'SecondAbility'\\n      };\\n      // 设置分屏的窗口启动模式\\n      let option: StartOptions = { windowMode: AbilityConstant.WindowMode.WINDOW_MODE_SPLIT_PRIMARY };\\n      // 启动分屏\\n      (getContext(this) as common.UIAbilityContext).startAbility(want, option);\\n    } else {\\n      // 关闭分屏\\n      (getContext(this) as common.UIAbilityContext).terminateSelf();\\n    }\\n  })",
        "type": "Reference",
        "function_call": "stopPiP()",
        "function_name": "[h2]商品详情页",
        "parent_text": "[h2]商品详情页商品详情页展示商品大图及详细信息。观察商品详情页在不同设备上的UX设计图，可以进行如下设计： 将商品详情页划分为4个区域，效果图如下：    sm  md  lg    效果图            商品详情页的4个基础区域介绍及实现方案如下表所示： 区域编号  简介  实现方案    1  商品大图  Swiper组件，指定displayCount属性实现延伸能力，设置aspectRatio属性实现缩放能力，代码可参考一多开发实例（长视频）。   2  商品详细信息  商品大图区域与商品详细信息区域在sm和md断点下使用Column组件呈上下布局，在lg断点下使用Row组件呈左右布局，同商品详情侧边面板页。   3  购买工具栏  剩余空间按比例分配给加入购物袋与购买按钮，用layoutWeight属性实现自适应布局占比能力，同首页顶部页签及搜索框。   4  画中画  使用PiPWindow实现画中画功能，启动、停止小窗直播及控制视频播放。      商品详情页在大屏设备上提供分屏功能，满足同时查看两个商品的详细参数进行购物比价的诉求。分屏通过创建一个新的UIAbility，并设置窗口显示为分屏模式实现。分屏后左右屏幕的宽度为1：1，在折叠屏上的效果图如下：  创建新的UIAbility，需要在phone目录下创建SecondAbility.ets，注册与EntryAbility相同的UIAbility生命周期回调。下一步需要在phone目录的module.json5配置文件，修改abilities属性注册SecondAbility，详情可参考源码。启动分屏时，调用UIAbilityContext的StartAbility接口，设置窗口模式为分屏并启动SecondAbility。关闭分屏时，调用UIAbilityContext的terminateSelf接口。  另外，为了增强在大设备上的浏览效率，用户点击全部评论，页面三分栏展示右侧的全部评价页面，使用SideBarContainer组件实现。 效果图如下：  // features/detail/src/main/ets/views/ProductHome.ets\\nSideBarContainer() {\\n  // 右侧全部评论\\n  Column() {\\n    Image($r('app.media.icon_close_4'))\\n      // ...\\n    AllComments()\\n  }\\n  .alignItems(HorizontalAlign.End)\\n  .height(CommonConstants.FULL_PERCENT)\\n  .padding({\\n    top: deviceInfo.deviceType === CommonConstants.DEVICE_TYPES[0] ? 0 : this.topRectHeight,\\n    left: $r('app.float.three_column_page_padding'),\\n    right: $r('app.float.three_column_page_padding')\\n  })\\n\\n  // 左侧商品详情\\n  Row() {\\n    // ...\\n  }\\n  // ...\\n}\\n// 控制全部评论区是否显示\\n.showSideBar(this.isShowingSidebar)\\n.showControlButton(false)\\n.sideBarPosition(SideBarPosition.End)\\n.divider({\\n  strokeWidth: $r('app.float.sidebar_divider_width'),\\n  color: ResourceUtil.getCommonDividerColor()\\n})\\n// 固定右侧全部评论区宽度\\n.minSideBarWidth(px2vp(this.windowWidth) / CommonConstants.THREE)\\n.maxSideBarWidth(px2vp(this.windowWidth) / CommonConstants.THREE)\\n// 设置全部评论区是否跟随窗口宽度自动隐藏\\n.autoHide(false) 为了方便用户浏览其他页面时能够继续观看直播内容，购物直播设计了额外的画中画功能。点击直播间页的关闭按钮，返回上一页并以小窗模式呈现直播内容。画中画功能的实现分为以下步骤：使用@ohos.PiPWindow模块的create接口创建画中画控制器，使用startPiP接口启动画中画，启动后返回上一页。其中画中画播放的视频内容需要使用XComponent+AVPlayer组件实现，读者可以自行查看源码。 // commons/base/src/main/ets/utils/PipWindowUtil.ets\\nasync startPip(navId: string, mXComponentController: XComponentController, context: Context, pageInfos: NavPathStack):\\n  Promise<void> {\\n  if (!PiPWindow.isPiPEnabled()) {\\n    Logger.error(`picture in picture disabled for current OS`);\\n    return;\\n  }\\n  let config: PiPWindow.PiPConfiguration = {\\n    context: context,\\n    // 绑定XComponent直播播放组件\\n    componentController: mXComponentController,\\n    // 当前页面的导航ID\\n    navigationId: navId,\\n    // 画中画直播媒体类型\\n    templateType: PiPWindow.PiPTemplateType.VIDEO_LIVE\\n  };\\n  // 创建画中画控制器\\n  let promise : Promise<PiPWindow.PiPController> = PiPWindow.create(config);\\n  await promise.then((controller: PiPWindow.PiPController) => {\\n    this.pipController = controller;\\n    // 初始化画中画控制器\\n    this.initPipController();\\n    // 通过startPip接口开启画中画功能\\n    this.pipController.startPiP().then(() => {\\n      Logger.info(`Succeeded in starting pip.`);\\n      if (this.avPlayerUtil === undefined) {\\n        return;\\n      }\\n      this.avPlayerUtil.play();\\n      pageInfos.pop();\\n    }).catch((err: BusinessError) => {\\n      Logger.error(`Failed to start pip. Cause: ${err.code}, message: ${err.message}`);\\n    });\\n  }).catch((err: BusinessError) => {\\n    Logger.error(`Failed to create pip controller. Cause: ${err.code}, message: ${err.message}`);\\n  });\\n} 初始化画中画控制器时，分别注册画中画生命周期状态和直播控制事件的监听。 // commons/base/src/main/ets/utils/PipWindowUtil.ets\\ninitPipController(): void {\\n  if (!this.pipController) {\\n    return;\\n  }\\n  // 注册画中画生命周期状态监听\\n  this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {\\n    this.onStateChange(state, reason);\\n  });\\n  // 注册直播控制事件监听\\n  this.pipController.on('controlPanelActionEvent', (event: PiPWindow.PiPActionEventType) => {\\n    this.onActionEvent(event);\\n  });\\n} 使用stopPiP接口关闭画中画。 // commons/base/src/main/ets/utils/PipWindowUtil.ets\\n// 通过调用stopPip来关闭画中画\\nasync stopPip(): Promise<void> {\\n  if (this.pipController) {\\n    let promise : Promise<void> = this.pipController.stopPiP();\\n    promise.then(() => {\\n      this.isShowingPip = false;\\n      Logger.info(`Succeeded in stopping pip.`);\\n      try {\\n        this.pipController?.off('stateChange');\\n        this.pipController?.off('controlPanelActionEvent');\\n      } catch (exception) {\\n        Logger.error('Failed to unregister callbacks. Code: ' + JSON.stringify(exception));\\n      }\\n    }).catch((err: BusinessError) => {\\n      Logger.error(`Failed to stop pip. Cause: ${err.code}, message: ${err.message}`);\\n    });\\n  }\\n}   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section112893356386\\\"'><a name='\\\"section112893356386\\\"'></a><a name='\\\"section112893356386\\\"'></a><h4>[h2]商品详情页</h4><p>商品详情页展示商品大图及详细信息。观察商品详情页在不同设备上的UX设计图，可以进行如下设计：</p> <ul><li>将商品详情页划分为4个区域，效果图如下： <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.10.3.1.1.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"6.830601092896176%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.10.3.1.1.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"15.99336455893833%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.10.3.1.1.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"27.097970335675253%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.10.3.1.1.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"50.078064012490245%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.830601092896176%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"15.99336455893833%\\\"'><p><span><img height='\\\"551.0456\\\"' originheight='\\\"804\\\"' originwidth='\\\"385\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161326.08491542085123837557510485309230:50001231000000:2800:2684AD85D61DDA14BBC51D893318BC95675344939E158A899B8690A086DCAFE1.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.097970335675253%\\\"'><p><span><img height='\\\"534.4339\\\"' originheight='\\\"787\\\"' originwidth='\\\"705\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161326.51867125233486545426520166093390:50001231000000:2800:32EFC1E44828EB40E2343744B6B06E6164339C0E99D85E8EC14A950B09150CB6.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50.078064012490245%\\\"'><p><span><img height='\\\"519.4581000000001\\\"' originheight='\\\"869\\\"' originwidth='\\\"1344\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161326.58738917255727222880675062231587:50001231000000:2800:197691E9D541EF8F626B5BD2D8BC913EC3E904B52D2242A8C091E9DD284B2E15.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div> </li></ul> <div class='\\\"p\\\"'>商品详情页的4个基础区域介绍及实现方案如下表所示： <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.10.4.1.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"6.680664248902462%\\\"'><p>区域编号</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.10.4.1.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"7.940446650124068%\\\"'><p>简介</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.10.4.1.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"85.37888910097345%\\\"'><p>实现方案</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.680664248902462%\\\"'><p>1</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.940446650124068%\\\"'><p>商品大图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"85.37888910097345%\\\"'><p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper\\\"' target='\\\"_blank\\\"'>Swiper组件</a>，指定displayCount属性实现延伸能力，设置aspectRatio属性实现缩放能力，代码可参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/multi-video-app#zh-cn_topic_0000001744653537_li139671645597\\\"'>一多开发实例（长视频）</a>。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.680664248902462%\\\"'><p>2</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.940446650124068%\\\"'><p>商品详细信息</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"85.37888910097345%\\\"'><p>商品大图区域与商品详细信息区域在sm和md断点下使用Column组件呈上下布局，在lg断点下使用Row组件呈左右布局，同<a href='\\\"#section8305102524814\\\"'>商品详情侧边面板页</a>。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.680664248902462%\\\"'><p>3</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.940446650124068%\\\"'><p>购买工具栏</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"85.37888910097345%\\\"'><p>剩余空间按比例分配给加入购物袋与购买按钮，用layoutWeight属性实现自适应布局占比能力，同<a href='\\\"#section1976644133811\\\"'>首页顶部页签及搜索框</a>。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.680664248902462%\\\"'><p>4</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.940446650124068%\\\"'><p>画中画</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"85.37888910097345%\\\"'><p>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-pipwindow\\\"' target='\\\"_blank\\\"'>PiPWindow</a>实现画中画功能，启动、停止小窗直播及控制视频播放。</p> </td> </tr> </tbody></table> </div> </div> <p>商品详情页在大屏设备上提供分屏功能，满足同时查看两个商品的详细参数进行购物比价的诉求。分屏通过创建一个新的UIAbility，并设置窗口显示为分屏模式实现。分屏后左右屏幕的宽度为1：1，在折叠屏上的效果图如下：</p> <p><span><img height='\\\"534.4339\\\"' originheight='\\\"787\\\"' originwidth='\\\"705\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161326.05068557117345479205604313223458:50001231000000:2800:10123C21B7F6965CAE564A67AA1DB7B04C103EE20575DAE4E05440BC4D450D5A.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p>创建新的UIAbility，需要在phone目录下创建SecondAbility.ets，注册与EntryAbility相同的UIAbility生命周期回调。下一步需要在phone目录的module.json5配置文件，修改abilities属性注册SecondAbility，详情可参考源码。启动分屏时，调用UIAbilityContext的StartAbility接口，设置窗口模式为分屏并启动SecondAbility。关闭分屏时，调用UIAbilityContext的terminateSelf接口。</p>  <p>另外，为了增强在大设备上的浏览效率，用户点击全部评论，页面三分栏展示右侧的全部评价页面，使用SideBarContainer组件实现。</p> <p>效果图如下：</p> <p><span><img height='\\\"515.2819000000001\\\"' originheight='\\\"869\\\"' originwidth='\\\"1344\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161326.01977063584113851385750052619216:50001231000000:2800:7B68550700A997206BF4E69E259B897463CEF128C3BC6111396BAB4F113B98D0.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> <pre class='\\\"screen\\\"'>// features/detail/src/main/ets/views/ProductHome.ets\\nSideBarContainer() {\\n  // 右侧全部评论\\n  Column() {\\n    Image($r('app.media.icon_close_4'))\\n      // ...\\n    AllComments()\\n  }\\n  .alignItems(HorizontalAlign.End)\\n  .height(CommonConstants.FULL_PERCENT)\\n  .padding({\\n    top: deviceInfo.deviceType === CommonConstants.DEVICE_TYPES[0] ? 0 : this.topRectHeight,\\n    left: $r('app.float.three_column_page_padding'),\\n    right: $r('app.float.three_column_page_padding')\\n  })\\n\\n  // 左侧商品详情\\n  Row() {\\n    // ...\\n  }\\n  // ...\\n}\\n// 控制全部评论区是否显示\\n.showSideBar(this.isShowingSidebar)\\n.showControlButton(false)\\n.sideBarPosition(SideBarPosition.End)\\n.divider({\\n  strokeWidth: $r('app.float.sidebar_divider_width'),\\n  color: ResourceUtil.getCommonDividerColor()\\n})\\n// 固定右侧全部评论区宽度\\n.minSideBarWidth(px2vp(this.windowWidth) / CommonConstants.THREE)\\n.maxSideBarWidth(px2vp(this.windowWidth) / CommonConstants.THREE)\\n// 设置全部评论区是否跟随窗口宽度自动隐藏\\n.autoHide(false)</pre> <div class='\\\"p\\\"'><ul><li>为了方便用户浏览其他页面时能够继续观看直播内容，购物直播设计了额外的画中画功能。点击直播间页的关闭按钮，返回上一页并以小窗模式呈现直播内容。画中画功能的实现分为以下步骤：<p>使用@ohos.PiPWindow模块的create接口创建画中画控制器，使用startPiP接口启动画中画，启动后返回上一页。其中画中画播放的视频内容需要使用XComponent+AVPlayer组件实现，读者可以自行查看源码。</p> <pre class='\\\"screen\\\"'>// commons/base/src/main/ets/utils/PipWindowUtil.ets\\nasync startPip(navId: string, mXComponentController: XComponentController, context: Context, pageInfos: NavPathStack):\\n  Promise&lt;void&gt; {\\n  if (!PiPWindow.isPiPEnabled()) {\\n    Logger.error(`picture in picture disabled for current OS`);\\n    return;\\n  }\\n  let config: PiPWindow.PiPConfiguration = {\\n    context: context,\\n    // 绑定XComponent直播播放组件\\n    componentController: mXComponentController,\\n    // 当前页面的导航ID\\n    navigationId: navId,\\n    // 画中画直播媒体类型\\n    templateType: PiPWindow.PiPTemplateType.VIDEO_LIVE\\n  };\\n  // 创建画中画控制器\\n  let promise : Promise&lt;PiPWindow.PiPController&gt; = PiPWindow.create(config);\\n  await promise.then((controller: PiPWindow.PiPController) =&gt; {\\n    this.pipController = controller;\\n    // 初始化画中画控制器\\n    this.initPipController();\\n    // 通过startPip接口开启画中画功能\\n    this.pipController.startPiP().then(() =&gt; {\\n      Logger.info(`Succeeded in starting pip.`);\\n      if (this.avPlayerUtil === undefined) {\\n        return;\\n      }\\n      this.avPlayerUtil.play();\\n      pageInfos.pop();\\n    }).catch((err: BusinessError) =&gt; {\\n      Logger.error(`Failed to start pip. Cause: ${err.code}, message: ${err.message}`);\\n    });\\n  }).catch((err: BusinessError) =&gt; {\\n    Logger.error(`Failed to create pip controller. Cause: ${err.code}, message: ${err.message}`);\\n  });\\n}</pre> <p>初始化画中画控制器时，分别注册画中画生命周期状态和直播控制事件的监听。</p> <pre class='\\\"screen\\\"'>// commons/base/src/main/ets/utils/PipWindowUtil.ets\\ninitPipController(): void {\\n  if (!this.pipController) {\\n    return;\\n  }\\n  // 注册画中画生命周期状态监听\\n  this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) =&gt; {\\n    this.onStateChange(state, reason);\\n  });\\n  // 注册直播控制事件监听\\n  this.pipController.on('controlPanelActionEvent', (event: PiPWindow.PiPActionEventType) =&gt; {\\n    this.onActionEvent(event);\\n  });\\n}</pre> <p>使用stopPiP接口关闭画中画。</p> <pre class='\\\"screen\\\"'>// commons/base/src/main/ets/utils/PipWindowUtil.ets\\n// 通过调用stopPip来关闭画中画\\nasync stopPip(): Promise&lt;void&gt; {\\n  if (this.pipController) {\\n    let promise : Promise&lt;void&gt; = this.pipController.stopPiP();\\n    promise.then(() =&gt; {\\n      this.isShowingPip = false;\\n      Logger.info(`Succeeded in stopping pip.`);\\n      try {\\n        this.pipController?.off('stateChange');\\n        this.pipController?.off('controlPanelActionEvent');\\n      } catch (exception) {\\n        Logger.error('Failed to unregister callbacks. Code: ' + JSON.stringify(exception));\\n      }\\n    }).catch((err: BusinessError) =&gt; {\\n      Logger.error(`Failed to stop pip. Cause: ${err.code}, message: ${err.message}`);\\n    });\\n  }\\n}</pre> </li></ul> </div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-shopping-price-comparison.html"
    },
    {
        "id": 215,
        "pre": "// features/detail/src/main/ets/views/ProductMoreDetail.ets\\nRow() {\\n  Column() {\\n    // ...\\n  }\\n  .height(CommonConstants.FULL_PERCENT)\\n  // 设置商品详情与侧边面板宽度比\\n  .layoutWeight(new BreakpointType(0, CommonConstants.THREE, CommonConstants.FIVE)\\n    .getValue(this.currentBreakpoint))\\n  // ...\\n  // 在sm断点下隐藏商品详情页\\n  .visibility(this.currentBreakpoint === BreakpointConstants.BREAKPOINT_SM ? Visibility.None : Visibility.Visible)\\n\\n  Column() {\\n    // 判断侧边面板的辅助信息页面\\n    if (this.isShoppingBag) {\\n      DetailShoppingBagView({ isMoreDetail: this.isMoreDetail })\\n    }\\n    if (this.isCustomerService) {\\n      CustomerServiceView()\\n    }\\n  }\\n  // ...\\n  // 设置商品详情与侧边面板宽度比\\n  .layoutWeight(CommonConstants.THREE)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "观察商品详情侧边面板的设计，在sm断点下只显示侧边辅助面板，在md和lg断点下使用Row组件呈左右布局，设置layoutWeight属性实现自适应布局的占比能力。在md断点时商品详情与侧边面板宽度为1：1，在lg断点时为5：3。 ",
        "import_module": null,
        "parent": "<li>观察商品详情侧边面板的设计，在sm断点下只显示侧边辅助面板，在md和lg断点下使用Row组件呈左右布局，设置layoutWeight属性实现自适应布局的占比能力。在md断点时商品详情与侧边面板宽度为1：1，在lg断点时为5：3。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-shopping-price-comparison.html"
    },
    {
        "id": 216,
        "pre": "// features/detail/src/main/ets/view/ProdutUtilView.ets\\nButton(DetailConstants.BUTTON_NAMES[1])\\n  // ...\\n  // sm断点下绑定底部半模态页面\\n  .bindSheet($$this.isDialogOpen,\\n    this.PayCardBuilder(), {\\n      height: $r('app.float.pay_bind_sheet_height'),\\n      preferType: SheetType.CENTER,\\n      dragBar: false,\\n      enableOutsideInteractive: true,\\n      onDisappear: () => { this.isDialogOpen = false },\\n      showClose: false,\\n      backgroundColor: $r('app.color.pay_bind_sheet_background')\\n    })\\n  .onClick(() => {\\n    if (this.isLivePage || this.isSplitMode) {\\n      return;\\n    }\\n    if (this.currentBreakpoint === BreakpointConstants.BREAKPOINT_SM) {\\n      // sm断点下打开半模态页面\\n      this.isDialogOpen = true;\\n    } else {\\n      if (this.dialogController === null) {\\n        return;\\n      }\\n      // md和lg断点下弹出自定义弹窗\\n      this.dialogController.open();\\n      this.isDialogOpen = false;\\n    }\\n  })",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]商品支付页",
        "parent_text": "[h2]商品支付页商品支付页采用浅层窗口展示商品支付信息。观察商品支付页在不同设备上的UX设计图，效果图如下：    sm  md  lg    设计能力点         效果图            商品支付页的浅层窗口，在sm断点下使用bindSheet为购买按钮绑定底部半模态页面，在md和lg断点下使用居中半模态自定义弹窗居中显示。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1965713469388\\\"'><a name='\\\"section1965713469388\\\"'></a><a name='\\\"section1965713469388\\\"'></a><h4>[h2]商品支付页</h4><div class='\\\"p\\\"'>商品支付页采用浅层窗口展示商品支付信息。观察商品支付页在不同设备上的UX设计图，效果图如下： <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.2.1.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"6.830601092896176%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.2.1.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"15.99336455893833%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.2.1.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"26.424668227946917%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.2.1.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"50.75136612021859%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.830601092896176%\\\"'><p>设计能力点</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"15.99336455893833%\\\"'><p><span><img height='\\\"630.6594\\\"' originheight='\\\"301\\\"' originwidth='\\\"146\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161327.79577930885054158063103568486413:50001231000000:2800:13AC6FEE5FA04085B2A58296E9A3A3C863292B674E377B587822D10EA8BAC948.png\\\"' title='\\\"点击放大\\\"' width='\\\"305.90000000000003\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.424668227946917%\\\"'><p><span><img height='\\\"500.4125\\\"' originheight='\\\"301\\\"' originwidth='\\\"288\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161327.62263982475570634877759278044202:50001231000000:2800:935100814B6A2775ED9326F648C21C01CD3F98A1F4713DA6A6ACEB66285E4055.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50.75136612021859%\\\"'><p><span><img height='\\\"489.2006\\\"' originheight='\\\"301\\\"' originwidth='\\\"491\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161327.58062632375232075826188609871219:50001231000000:2800:E68C29E144AEB743E6F9C83215CC4349B335C06E2C02E687E8859694931244A4.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.830601092896176%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"15.99336455893833%\\\"'><p><span><img height='\\\"551.0456\\\"' originheight='\\\"804\\\"' originwidth='\\\"385\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161328.10164921944853180371338067902058:50001231000000:2800:A75D38BCEBA13CD6C858D8FF917833AB6C78AFD7FC3AEF8EC7312FAD1DD3D719.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"26.424668227946917%\\\"'><p><span><img height='\\\"534.4339\\\"' originheight='\\\"787\\\"' originwidth='\\\"705\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161328.72301782312560833893583525360723:50001231000000:2800:264E3966A611BD5E45F715F77C5365C197DA22A39906FF2EBFB63860392C1FB6.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50.75136612021859%\\\"'><p><span><img height='\\\"519.4581000000001\\\"' originheight='\\\"869\\\"' originwidth='\\\"1344\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161328.40226659665823319989305783826668:50001231000000:2800:8071A154EBD509CB28D18D925E3A61C7967F18CE0EE09EB6734ADD98933CBEDF.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div> </div> <p>商品支付页的浅层窗口，在sm断点下使用bindSheet为购买按钮绑定底部半模态页面，在md和lg断点下使用居中半模态自定义弹窗居中显示。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-shopping-price-comparison.html"
    },
    {
        "id": 217,
        "pre": "// features/detail/src/main/ets/view/LiveMaskLayer.ets\\nFlex({\\n  // 设置子组件在Flex容器的主轴方向，sm和md断点下垂直，lg断点下水平\\n  direction: this.currentBreakpoint === BreakpointConstants.BREAKPOINT_LG ? FlexDirection.Row :\\n    FlexDirection.Column,\\n  // 设置主轴的对齐格式，sm和md断点下均分，lg断点下尾部对齐\\n  justifyContent: this.currentBreakpoint === BreakpointConstants.BREAKPOINT_LG ? FlexAlign.SpaceBetween :\\n    FlexAlign.End\\n}) {\\n  Comment({ currentBreakpoint: this.currentBreakpoint })\\n  LiveShopList({\\n    currentBreakpoint: this.currentBreakpoint,\\n    detailType: this.detailType,\\n    isMoreDetail: this.isMoreDetail\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "直播弹幕及推荐商品Flex组件的direction和justifyContent属性控制子组件在容器主轴上的位置，sm和md断点下在容器底部，lg断点下在容器两侧。List组件控制列表的排列方向，sm和md断点下水平，lg断点下垂直。  // features/detail/src/main/ets/view/LiveShopList.ets\\n// 设置List组件的排列方向，sm和md断点下水平，lg断点下垂直\\n.listDirection(this.currentBreakpoint === BreakpointConstants.BREAKPOINT_LG ? Axis.Vertical :\\n  Axis.Horizontal) ",
        "import_module": null,
        "parent": "<li>直播弹幕及推荐商品<p>Flex组件的direction和justifyContent属性控制子组件在容器主轴上的位置，sm和md断点下在容器底部，lg断点下在容器两侧。List组件控制列表的排列方向，sm和md断点下水平，lg断点下垂直。</p>  <pre class='\\\"screen\\\"'>// features/detail/src/main/ets/view/LiveShopList.ets\\n// 设置List组件的排列方向，sm和md断点下水平，lg断点下垂直\\n.listDirection(this.currentBreakpoint === BreakpointConstants.BREAKPOINT_LG ? Axis.Vertical :\\n  Axis.Horizontal)</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-shopping-price-comparison.html"
    },
    {
        "id": 218,
        "pre": "// entry/src/main/module.json5\\n{\\n  \\\"module\\\": {\\n    \\\"abilities\\\": [\\n      {\\n        \\\"continuable\\\": true\\n      }\\n    ]\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]启用应用接续能力",
        "parent_text": "[h2]启用应用接续能力在module.json5文件的abilities中，将continuable标签配置为“true”，表示该UIAbility可被迁移。配置为false的UIAbility将被系统识别为无法迁移且该配置默认值为false。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section159091533154811\\\"'><a name='\\\"section159091533154811\\\"'></a><a name='\\\"section159091533154811\\\"'></a><h4>[h2]启用应用接续能力</h4><p>在module.json5文件的abilities中，将continuable标签配置为“true”，表示该UIAbility可被迁移。配置为false的UIAbility将被系统识别为无法迁移且该配置默认值为false。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-connection-release.html"
    },
    {
        "id": 219,
        "pre": "// entry/src/main/ets/view/AddPic.ets\\nwriteDistributedFile(buf: ArrayBuffer, displayName: string): void {\\n  // 将资产写入分布式文件目录下\\n  let distributedDir: string = this.context.distributedFilesDir; // 获取分布式文件目录路径\\n  let fileName: string = '/' + displayName; // 文件名\\n  let filePath: string = distributedDir + fileName; // 文件路径\\n  try {\\n    // 在分布式目录下创建文件\\n    let file = fs.openSync(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\\n    hilog.info(0x0000, '[AddPic]', 'Create file success.');\\n    // 向文件中写入内容（由于资产为图片，可将图片转换为buffer后写入）\\n    fs.writeSync(file.fd, buf);\\n    // 关闭文件\\n    fs.closeSync(file.fd);\\n  } catch (error) {\\n    let err: BusinessError = error as BusinessError;\\n    hilog.info(0x0000, '[AddPic]',\\n      `Failed to openSync / writeSync / closeSync. Code: ${err.code}, message: ${err.message}`);\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]基础数据&文件资产迁移",
        "parent_text": "[h2]基础数据&文件资产迁移对于图片、文档等文件类数据，可以转化成ArrayBuffer类型，保存在分布式文件目录下。示例代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section9637938103918\\\"'><a name='\\\"section9637938103918\\\"'></a><a name='\\\"section9637938103918\\\"'></a><h4>[h2]基础数据&amp;文件资产迁移</h4><p>对于图片、文档等文件类数据，可以转化成ArrayBuffer类型，保存在分布式文件目录下。示例代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-connection-release.html"
    },
    {
        "id": 220,
        "pre": "// src/main/ets/view/CustomImageText.ets\\n@Component\\nstruct MyButton {\\n  @Prop text: string = '';\\n  @Prop stateEffect: boolean = true;\\n  // 下面穷举所有Button独有属性\\n  // ...\\n\\n  build() {\\n    Button(this.text)\\n      .fontSize(12)\\n      .fontColor($r('sys.color.comp_background_list_card'))\\n      .stateEffect(this.stateEffect) // stateEffect属性的作用是控制默认点击动画\\n  }\\n}",
        "type": "Reference",
        "function_call": "build()",
        "function_name": "[h2]场景描述",
        "parent_text": "[h2]场景描述在应用开发过程中，不同的业务场景可能需要使用相同功能或样式的ArkUI组件。例如，登录页面登录按钮和购物页面结算按钮可能样式相同。该场景常用方法是抽取相同样式的逻辑部分，并将其封装成一个自定义组件到公共组件库中。在业务场景开发时，统一从公共组件库获取封装好的公用组件。 以Button组件为例，当多处业务场景需要使用相同样式的Button组件时，将通用逻辑封装成一个MyButton自定义组件，并在通用逻辑中定制了公共的fontSize和fontColor属性。当需要把MyButton组件以Button扩展组件的形式集成到公共组件库中，提供给外部其他团队使用时，为了使它具备Button的所有基础能力并支持以链式调用的方式使用Button组件的属性接口，需要在MyButton组件内穷举所有的Button属性。自定义组件的代码如下：  在使用MyButton组件时，若需修改组件显示内容text和点击动画效果stateEffect时（其他Button独有的属性用法相同），需要以参数的形式传入： // src/main/ets/view/CustomImageText.ets\\n@Component\\nstruct Index {\\n  build() {\\n    MyButton({ text: '点击带有动效', stateEffect: true }) // 入参包含MyButton组件中定义的全部 Button独有属性\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section236114513819\\\"'><a name='\\\"section236114513819\\\"'></a><a name='\\\"section236114513819\\\"'></a><h4>[h2]场景描述</h4><p>在应用开发过程中，不同的业务场景可能需要使用相同功能或样式的ArkUI组件。例如，登录页面登录按钮和购物页面结算按钮可能样式相同。该场景常用方法是抽取相同样式的逻辑部分，并将其封装成一个自定义组件到公共组件库中。在业务场景开发时，统一从公共组件库获取封装好的公用组件。</p> <p>以Button组件为例，当多处业务场景需要使用相同样式的Button组件时，将通用逻辑封装成一个MyButton自定义组件，并在通用逻辑中定制了公共的fontSize和fontColor属性。当需要把MyButton组件以Button扩展组件的形式集成到公共组件库中，提供给外部其他团队使用时，为了使它具备Button的所有基础能力并支持以链式调用的方式使用Button组件的属性接口，需要在MyButton组件内穷举所有的Button属性。自定义组件的代码如下：</p>  <p>在使用MyButton组件时，若需修改组件显示内容text和点击动画效果stateEffect时（其他Button独有的属性用法相同），需要以参数的形式传入：</p> <pre class='\\\"screen\\\"'>// src/main/ets/view/CustomImageText.ets\\n@Component\\nstruct Index {\\n  build() {\\n    MyButton({ text: '点击带有动效', stateEffect: true }) // 入参包含MyButton组件中定义的全部 Button独有属性\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-component-encapsulation.html"
    },
    {
        "id": 221,
        "pre": "// src/main/ets/pages/CommonComponent.ets\\n//提供方自定义组件并导出\\n@Component\\nexport struct MyButton {\\n  @Prop text: string = '';\\n  // 接受外部传入的AttributeModifier类实例\\n  @Prop modifier: AttributeModifier<ButtonAttribute> | null = null;\\n\\n  build() {\\n    // AttributeModifier不支持入参为CustomBuilder或Lambda表达式的属性，且不支持事件和手势。此处text只能单独通过入参传递使用。\\n    Button(this.text)\\n      // 将入参的AttributeModifier类实例与系统组件绑定\\n      .attributeModifier(this.modifier)\\n      .fontSize(20)\\n      .width(200)\\n      .height(50)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "提供方在公共组件库中创建公用的自定义组件，该组件支持外部传入attributeModifier属性。 ",
        "import_module": null,
        "parent": "<li>提供方在公共组件库中创建公用的自定义组件，该组件支持外部传入attributeModifier属性。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-component-encapsulation.html"
    },
    {
        "id": 222,
        "pre": "// src/main/ets/view/CustomImageText.ets\\n@Component\\nexport struct CustomImageText {\\n  @Prop imageAttribute: AttributeModifier<ImageAttribute>;\\n  @Prop textAttribute: AttributeModifier<TextAttribute>;\\n  @Prop imageSrc: PixelMap | ResourceStr | DrawableDescriptor;\\n  @Prop text: string;\\n\\n  build() {\\n    Column({ space: CommonConstants.BUTTON_SPACING }) {\\n      Image(this.imageSrc)\\n        .attributeModifier(this.imageAttribute)\\n      Text(this.text)\\n        .attributeModifier(this.textAttribute)\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "提供方封装自定义组件CustomImageText并导出。 ",
        "import_module": null,
        "parent": "<li>提供方封装自定义组件CustomImageText并导出。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-component-encapsulation.html"
    },
    {
        "id": 223,
        "pre": "// src/main/ets/view/FactoryMap.ets\\n// 单选框\\n@Builder\\nfunction myRadio() {\\n  Text($r('app.string.radio'))\\n    .width('100%')\\n    .fontColor($r('sys.color.mask_secondary'))\\n  Row() {\\n    Radio({ value: '1', group: 'radioGroup' })\\n      .margin({ right: $r('app.float.margin_right') })\\n    Text('man')\\n  }\\n  .width(CommonConstants.ONE_HUNDRED_PERCENT)\\n\\n  Row() {\\n    Radio({ value: '0', group: 'radioGroup' })\\n      .margin({ right: $r('app.float.margin_right') })\\n    Text('woman')\\n  }\\n  .width(CommonConstants.ONE_HUNDRED_PERCENT)\\n}\\n// 复选框\\n@Builder\\nfunction myCheckbox() {\\n  Text($r('app.string.checkbox'))\\n    .width('100%')\\n    .fontColor($r('sys.color.mask_secondary'))\\n  Row() {\\n    CheckboxGroup({ group: 'checkboxGroup' })\\n      .checkboxShape(CheckBoxShape.ROUNDED_SQUARE)\\n    Text('all')\\n      .margin({ left: $r('app.float.margin_right') })\\n  }\\n  .width(CommonConstants.ONE_HUNDRED_PERCENT)\\n\\n  Row() {\\n    Checkbox({ name: '1', group: 'checkboxGroup' })\\n      .shape(CheckBoxShape.ROUNDED_SQUARE)\\n      .margin({ right: $r('app.float.margin_right') })\\n    Text('text1')\\n  }\\n  .width(CommonConstants.ONE_HUNDRED_PERCENT)\\n\\n  Row() {\\n    Checkbox({ name: '0', group: 'checkboxGroup' })\\n      .shape(CheckBoxShape.ROUNDED_SQUARE)\\n      .margin({ right: $r('app.float.margin_right') })\\n    Text('text2')\\n  }\\n  .width(CommonConstants.ONE_HUNDRED_PERCENT)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在组件工厂实现方，将需要工厂化的组件通过全局@Builder方法封装。 ",
        "import_module": null,
        "parent": "<li>在组件工厂实现方，将需要工厂化的组件通过全局@Builder方法封装。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-component-encapsulation.html"
    },
    {
        "id": 224,
        "pre": "// xxx.ets\\nexport class Message {\\n  value: string | undefined;\\n\\n  constructor(value: string) {\\n    this.value = value\\n  }\\n}\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State switch: boolean = true\\n  build() {\\n    Column() {\\n      Button('Hello World')\\n        .fontSize(50)\\n        .fontWeight(FontWeight.Bold)\\n        .onClick(() => {\\n          this.switch = !this.switch\\n        })\\n      if (this.switch) {\\n        Child({ message: new Message('Child') })\\n          // 如果只有一个复用的组件，可以不用设置reuseId\\n          .reuseId('Child')\\n      }\\n    }\\n    .height(\\\"100%\\\")\\n    .width('100%')\\n  }\\n}\\n\\n@Reusable\\n@Component\\nstruct Child {\\n  @State message: Message = new Message('AboutToReuse');\\n\\n  aboutToReuse(params: Record<string, ESObject>) {\\n    console.info(\\\"Recycle Child\\\")\\n    this.message = params.message as Message\\n  }\\n\\n  build() {\\n    Column() {\\n      Text(this.message.value)\\n        .fontSize(20)\\n    }\\n    .borderWidth(2)\\n    .height(100)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]使用规则",
        "parent_text": "[h2]使用规则组件复用的示例代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section5923195311402\\\"'><a name='\\\"section5923195311402\\\"'></a><a name='\\\"section5923195311402\\\"'></a><h4>[h2]使用规则</h4><p>组件复用的示例代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-reuse.html"
    },
    {
        "id": 225,
        "pre": "@Entry\\n@Component\\nstruct lessEmbeddedComponent {\\n  aboutToAppear(): void {\\n    getFriendMomentFromRawfile();\\n  }\\n\\n  build() {\\n    Column() {\\n      List({ space: ListConstants.LIST_SPACE }) {\\n        LazyForEach(momentData, (moment: FriendMoment) => {\\n          ListItem() {\\n            OneMomentNoBuilder({moment: moment})\\n          }\\n        }, (moment: FriendMoment) => moment.id)\\n      }\\n      .cachedCount(Constants.CACHED_COUNT)\\n    }\\n  }\\n}\\n\\n@Reusable\\n@Component\\nexport struct OneMomentNoBuilder {\\n  @Prop moment: FriendMoment;\\n\\n  // 无需对@Prop修饰的变量进行aboutToReuse赋值，因为这些变量是由父组件传递给子组件的。如果在子组件中重新赋值这些变量，会导致重用的组件的内容重新触发状态刷新，从而降低组件的复用性能。\\n  build() {\\n    ...\\n    // 在复用组件中嵌套使用自定义组件\\n    Row() {\\n      InteractiveButton({\\n        imageStr: $r('app.media.ic_share'),\\n        text: $r('app.string.friendMomentsPage_share')\\n      })\\n      Blank()\\n      InteractiveButton({\\n        imageStr: $r('app.media.ic_thumbsup'),\\n        text: $r('app.string.friendMomentsPage_thumbsup')\\n      })\\n      Blank()\\n      InteractiveButton({\\n        imageStr: $r('app.media.ic_message'),\\n        text: $r('app.string.friendMomentsPage_message')\\n      })\\n    }\\n    ...\\n  }\\n}\\n\\n@Component\\nexport struct InteractiveButton {\\n  @State imageStr: ResourceStr;\\n  @State text: ResourceStr;\\n\\n  // 嵌套的组件中也需要实现aboutToReuse来进行UI的刷新\\n  aboutToReuse(params: Record<string, Object>): void {\\n    this.imageStr = params.imageStr as ResourceStr;\\n    this.text = params.text as ResourceStr;\\n  }\\n\\n  build() {\\n    Row() {\\n      Image(this.imageStr)\\n      Text(this.text)\\n    }\\n    .alignItems(VerticalAlign.Center)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]减少组件复用的嵌套层级",
        "parent_text": "[h2]减少组件复用的嵌套层级在组件复用场景下，过深的自定义组件的嵌套会增加组件复用的使用难度，比如需要逐个实现所有嵌套组件中aboutToReuse回调实现数据更新；因此推荐优先使用@Builder替代自定义组件，减少嵌套层级，利于维护且能提升页面加载速度。正反例如下： 反例：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section109991333141413\\\"'><a name='\\\"section109991333141413\\\"'></a><a name='\\\"section109991333141413\\\"'></a><h4>[h2]减少组件复用的嵌套层级</h4><p>在组件复用场景下，过深的自定义组件的嵌套会增加组件复用的使用难度，比如需要逐个实现所有嵌套组件中aboutToReuse回调实现数据更新；因此推荐优先使用@Builder替代自定义组件，减少嵌套层级，利于维护且能提升页面加载速度。正反例如下：</p> <p>反例：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-reuse.html"
    },
    {
        "id": 226,
        "pre": "@Entry\\n@Component\\nstruct withoutReuseId {\\n  aboutToAppear(): void {\\n    getFriendMomentFromRawfile();\\n  }\\n\\n  build() {\\n    Column() {\\n      TopBar()\\n      List({ space: ListConstants.LIST_SPACE }) {\\n        LazyForEach(momentData, (moment: FriendMoment) => {\\n          ListItem() {\\n            OneMoment({\\n              moment: moment,\\n              fontSize: moment.size\\n            })\\n          }\\n        }, (moment: FriendMoment) => moment.id)\\n      }\\n      .cachedCount(Constants.CACHED_COUNT)\\n    }\\n  }\\n}\\n\\n\\n@Reusable\\n@Component\\nexport struct OneMoment {\\n  @Prop moment: FriendMoment;\\n\\n  build() {\\n    Column() {\\n      ...\\n      Text(this.moment.text)\\n\\n      if (this.moment.image !== '') {\\n        Flex({ wrap: FlexWrap.Wrap }) {\\n          Image($r(this.moment.image))\\n          Image($r(this.moment.image))\\n          Image($r(this.moment.image))\\n          Image($r(this.moment.image))\\n        }\\n      }\\n      ...\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]复用组件嵌套结构会变更的场景，使用reuseId标记不同结构的组件构成",
        "parent_text": "[h2]复用组件嵌套结构会变更的场景，使用reuseId标记不同结构的组件构成在自定义组件复用的场景中，如果使用if/else条件语句来控制布局的结构，会导致在不同逻辑创建不同布局结构嵌套的组件，从而造成组件树结构的不同。此时我们应该使用reuseId来区分不同结构的组件，确保系统能够根据reuseId缓存各种结构的组件，提升复用性能。正反例如下： 反例：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section4981115441415\\\"'><a name='\\\"section4981115441415\\\"'></a><a name='\\\"section4981115441415\\\"'></a><h4>[h2]复用组件嵌套结构会变更的场景，使用reuseId标记不同结构的组件构成</h4><p>在自定义组件复用的场景中，如果使用if/else条件语句来控制布局的结构，会导致在不同逻辑创建不同布局结构嵌套的组件，从而造成组件树结构的不同。此时我们应该使用reuseId来区分不同结构的组件，确保系统能够根据reuseId缓存各种结构的组件，提升复用性能。正反例如下：</p> <p>反例：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-reuse.html"
    },
    {
        "id": 227,
        "pre": "@Entry\\n@Component\\nstruct withFuncParam {\\n  aboutToAppear(): void {\\n    getFriendMomentFromRawfile();\\n  }\\n  // 真实场景的函数中可能存在未知的耗时操作逻辑，此处用循环函数模拟耗时操作\\n  countAndReturn(): number {\\n    let temp: number = 0;\\n    for (let index = 0; index < 100000; index++) {\\n      temp += index;\\n    }\\n    return temp;\\n  }\\n\\n  build() {\\n    Column() {\\n      TopBar()\\n      List({ space: ListConstants.LIST_SPACE }) {\\n        LazyForEach(momentData, (moment: FriendMoment) => {\\n          ListItem() {\\n            OneMoment({\\n              moment: moment,\\n              sum: this.countAndReturn()\\n            })\\n          }\\n        }, (moment: FriendMoment) => moment.id)\\n      }\\n      .cachedCount(Constants.CACHED_COUNT)\\n    }\\n  }\\n}\\n\\n@Reusable\\n@Component\\nexport struct OneMoment {\\n  @Prop moment: FriendMoment;\\n  @State sum: number = 0;\\n\\n  aboutToReuse(params: Record<string, Object>): void {\\n    this.sum = params.sum as number;\\n  }\\n\\n  build() {\\n    Column() {\\n      ...\\n      Text(`${this.moment.userName} （${this.moment.id} / ${this.sum}）`)\\n      ...\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]使用状态变量替代函数/方法作为复用组件创建时的入参",
        "parent_text": "[h2]使用状态变量替代函数/方法作为复用组件创建时的入参由于在组件复用的场景下，每次复用都需要重新创建组件关联的数据对象，导致重复执行入参中的函数来获取入参结果。如果函数中存在耗时操作，会严重影响性能。正反例如下： 反例：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section18721184816136\\\"'><a name='\\\"section18721184816136\\\"'></a><a name='\\\"section18721184816136\\\"'></a><h4>[h2]使用状态变量替代函数/方法作为复用组件创建时的入参</h4><p>由于在组件复用的场景下，每次复用都需要重新创建组件关联的数据对象，导致重复执行入参中的函数来获取入参结果。如果函数中存在耗时操作，会严重影响性能。正反例如下：</p> <p>反例：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-reuse.html"
    },
    {
        "id": 228,
        "pre": "// 该变量在后续过程并未发生改变，建议声明为常量\\nlet PRICE = 10000;\\n\\nfunction getPrice() {\\n  return PRICE;\\n}\\n\\nclass ClassA {\\n  propA: string = 'propA'\\n} \\n// 该引用类型的变量在后续过程变量地址并未发生改变，仅修改了变量的属性,本例中的let建议改为const\\nlet classA: ClassA = new ClassA();\\nclassA.propA = 'Property A';",
        "type": "Reference",
        "function_call": "new ClassA()",
        "function_name": "[h2]使用const声明常量",
        "parent_text": "[h2]使用const声明常量对于初期明确不会改变的变量，尽量使用const进行初始化，这里的常量包含基础类型和引用类型。通过const保证地址不会发生变化，能够极大减少由于编码时误操作导致的赋值等行为，造成对原有逻辑的改变，声明为const能够在编辑时及时发现错误。其中当const声明的是引用类型时，引用类型内部的属性变化是允许的，对于这种不存在地址变化的情况下，也建议使用const声明。 【反例】  【正例】 const PRICE = 10000; // 常量声明为基础类型时，其内容不可改变\\n\\nfunction getPrice() {\\n  return PRICE;\\n}\\n\\nclass ClassA {\\n  propA: string = 'propA'\\n}\\n\\n// 常量声明为引用类型时，其地址不可改变，但可以改变属性\\nconst classA: ClassA = new ClassA();\\nclassA.propA = 'Property A'; ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section11738469467\\\"'><a name='\\\"section11738469467\\\"'></a><a name='\\\"section11738469467\\\"'></a><h4>[h2]使用const声明常量</h4><p>对于初期明确不会改变的变量，尽量使用const进行初始化，这里的常量包含基础类型和引用类型。通过const保证地址不会发生变化，能够极大减少由于编码时误操作导致的赋值等行为，造成对原有逻辑的改变，声明为const能够在编辑时及时发现错误。其中当const声明的是引用类型时，引用类型内部的属性变化是允许的，对于这种不存在地址变化的情况下，也建议使用const声明。</p> <p>【反例】</p>  <p>【正例】</p> <pre class='\\\"screen\\\"'>const PRICE = 10000; // 常量声明为基础类型时，其内容不可改变\\n\\nfunction getPrice() {\\n  return PRICE;\\n}\\n\\nclass ClassA {\\n  propA: string = 'propA'\\n}\\n\\n// 常量声明为引用类型时，其地址不可改变，但可以改变属性\\nconst classA: ClassA = new ClassA();\\nclassA.propA = 'Property A';</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 229,
        "pre": "function calAddSum(addNum: number): number {\\n  // count预期是int，不要声明成undefined/null或0.0，直接初始化为0\\n  let count = 0;\\n  count += addNum;\\n  return count;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]指定number的类型",
        "parent_text": "[h2]指定number的类型对于number类型，编译器在优化时会区分int和double类型。开发者在初始化number类型的变量时，如果预期是整数类型就初始化为0，小数类型就初始化为0.0，避免将一个number类型初始化为undefined或者null。 【正例】  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section999716366470\\\"'><a name='\\\"section999716366470\\\"'></a><a name='\\\"section999716366470\\\"'></a><h4>[h2]指定number的类型</h4><p>对于number类型，编译器在优化时会区分int和double类型。开发者在初始化number类型的变量时，如果预期是整数类型就初始化为0，小数类型就初始化为0.0，避免将一个number类型初始化为undefined或者null。</p> <p>【正例】</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 230,
        "pre": "// lib.ets\\ninterface TestA {\\n  sum: number\\n}\\n\\nexport function getObject(value: number): TestA {\\n  let obj: TestA = { sum: value };\\n  return obj;\\n}\\n\\n// app.ets\\nimport { getObject } from 'lib';\\nlet obj:ESObject = getObject(123); // 通过ESObject定义接受类型",
        "type": "Reference",
        "function_call": "function getObject(value: number): TestA",
        "function_name": "[h2]减少使用ESObject",
        "parent_text": "[h2]减少使用ESObjectESObject主要用于在ArkTS和TS/JS跨语言调用的场景中作为类型标注，在非跨语言场景中使用ESObject标注类型，会引入不必要的跨语言调用，造成额外的性能开销，建议在非跨语言调用的场景下，避免使用ESObject，引入明确的类型进行注释。 【反例】  【正例】 1、在lib.ets文件中导出对应的接口类型和方法// lib.ets\\nexport interface TestA {\\n  sum: number\\n}\\n\\nexport function getObject(value: number): TestA {\\n  let obj: TestA = { sum: value };\\n  return obj;\\n}  2、在使用该方法的文件app.ets，引入对应的类型 // app.ets\\nimport { getObject, TestA } from './lib';\\n\\nlet obj: TestA = getObject(123); // 显式引入标注类型 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section7831352488\\\"'><a name='\\\"section7831352488\\\"'></a><a name='\\\"section7831352488\\\"'></a><h4>[h2]减少使用ESObject</h4><p>ESObject主要用于在ArkTS和TS/JS跨语言调用的场景中作为类型标注，在非跨语言场景中使用ESObject标注类型，会引入不必要的跨语言调用，造成额外的性能开销，建议在非跨语言调用的场景下，避免使用ESObject，引入明确的类型进行注释。</p> <p>【反例】</p>  <p>【正例】</p> <div class='\\\"p\\\"'>1、在lib.ets文件中导出对应的接口类型和方法<pre class='\\\"screen\\\"'>// lib.ets\\nexport interface TestA {\\n  sum: number\\n}\\n\\nexport function getObject(value: number): TestA {\\n  let obj: TestA = { sum: value };\\n  return obj;\\n}</pre> </div> <p>2、在使用该方法的文件app.ets，引入对应的类型</p> <pre class='\\\"screen\\\"'>// app.ets\\nimport { getObject, TestA } from './lib';\\n\\nlet obj: TestA = getObject(123); // 显式引入标注类型</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 231,
        "pre": "class Time {\\n  static START: number = 1987;\\n  static INFO: number[] = [2001, 2002, 2003, 2004, 2005, 2006]\\n}\\n\\nfunction getDay(year: number): number {\\n  let totalDays: number = 348;\\n  for (let index: number = 0x8000; index > 0x8; index >>= 1) {\\n    // 此处会多次对Time的INFO及START进行查找，并且每次查找出来的值是相同的\\n    totalDays += ((Time.INFO[year - Time.START] & index) !== 0) ? 1 : 0;\\n  }\\n  return totalDays;\\n}",
        "type": "Reference",
        "function_call": "nfunction getDay(year: number): number",
        "function_name": "[h2]减少变量的属性查找",
        "parent_text": "[h2]减少变量的属性查找在要求性能的场景下，建议通过使用将全局变量存储为局部变量的方式来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快。重复的访问同一个变量，将造成不必要的消耗，尤其当类似的访问出现在循环过程中，其对于性能的影响更大。 在实际中可能会遇到在循环中会大量进行一些常量的访问操作，该常量在循环中不会改变，可以提取到循环外部，减少属性访问的次数。例如下面这个用例，Time是一个包含了日期信息的对象，Time.Info是记录日期的数组，示例中对于Time.INFO[year - Time.START]的访问，在每一次循环中，都会执行一次。 【反例】  【正例】 // 优化后代码\\nclass Time {\\n  static START: number = 1987;\\n  static INFO: number[] = [2001, 2002, 2003, 2004, 2005, 2006];\\n}\\n\\nfunction getDay(year: number): number {\\n  let totalDays: number = 348;\\n  // 从循环中提取不变量\\n  const info = Time.INFO[year - Time.START]; \\n  for (let index: number = 0x8000; index > 0x8; index >>= 1) {\\n    if ((info & index) !== 0) {\\n      totalDays++;\\n    }\\n  }\\n  return totalDays;\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1754105654816\\\"'><a name='\\\"section1754105654816\\\"'></a><a name='\\\"section1754105654816\\\"'></a><h4>[h2]减少变量的属性查找</h4><p>在要求性能的场景下，建议通过使用将全局变量存储为局部变量的方式来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快。重复的访问同一个变量，将造成不必要的消耗，尤其当类似的访问出现在循环过程中，其对于性能的影响更大。</p> <p>在实际中可能会遇到在循环中会大量进行一些常量的访问操作，该常量在循环中不会改变，可以提取到循环外部，减少属性访问的次数。例如下面这个用例，Time是一个包含了日期信息的对象，Time.Info是记录日期的数组，示例中对于Time.INFO[year - Time.START]的访问，在每一次循环中，都会执行一次。</p> <p>【反例】</p>  <p>【正例】</p> <pre class='\\\"screen\\\"'>// 优化后代码\\nclass Time {\\n  static START: number = 1987;\\n  static INFO: number[] = [2001, 2002, 2003, 2004, 2005, 2006];\\n}\\n\\nfunction getDay(year: number): number {\\n  let totalDays: number = 348;\\n  // 从循环中提取不变量\\n  const info = Time.INFO[year - Time.START]; \\n  for (let index: number = 0x8000; index &gt; 0x8; index &gt;&gt;= 1) {\\n    if ((info &amp; index) !== 0) {\\n      totalDays++;\\n    }\\n  }\\n  return totalDays;\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 232,
        "pre": "class Counter {\\n  // 没有设置访问修饰符默认为public\\n  count: number = 0;\\n\\n  getCount(): number {\\n    return this.count;\\n  }\\n}\\n// 访问时\\nconst counter:Counter = new Counter();\\nconsole.info(counter.count.toString()); // 可以通过实例访问\\nconsole.info(counter.getCount().toString());",
        "type": "Reference",
        "function_call": "getCount()",
        "function_name": "[h2]给类属性添加访问修饰符",
        "parent_text": "[h2]给类属性添加访问修饰符在ArkTS中，对于类结构的属性提供了private、protected和public可访问修饰符。默认情况下一个属性的可访问修饰符为public。选取适当的可访问修饰符可以提升代码的安全性、可读性。 【反例】  【正例】 class Counter {\\n  // 设置访问修饰符为private\\n  private count: number = 0;\\n\\n  public getCount(): number {\\n    return this.count;\\n  }\\n}\\n// 访问时\\nconst counter:Counter = new Counter();\\nlet res = counter.getCount();  当设置为private时，无法通过对象字面量的方式初始化类，在有需要通过字面量创建、或者直接访问属性时，设置为public。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section743155016482\\\"'><a name='\\\"section743155016482\\\"'></a><a name='\\\"section743155016482\\\"'></a><h4>[h2]给类属性添加访问修饰符</h4><p>在ArkTS中，对于类结构的属性提供了private、protected和public可访问修饰符。默认情况下一个属性的可访问修饰符为public。选取适当的可访问修饰符可以提升代码的安全性、可读性。</p> <p>【反例】</p>  <p>【正例】</p> <pre class='\\\"screen\\\"'>class Counter {\\n  // 设置访问修饰符为private\\n  private count: number = 0;\\n\\n  public getCount(): number {\\n    return this.count;\\n  }\\n}\\n// 访问时\\nconst counter:Counter = new Counter();\\nlet res = counter.getCount();</pre> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161102.63819051069935316228677674841889:50001231000000:2800:D93B0E797D491428055C81DBD866A7717CF088B091C3671D1428B17B21F53BB6.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>当设置为private时，无法通过对象字面量的方式初始化类，在有需要通过字面量创建、或者直接访问属性时，设置为public。</p> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 233,
        "pre": "const array1 = new Array(1, 2, 3);  // 针对这一场景，建议不要使用new Array(1, 2, 3)\\nconst array2 = new Array(4, 5, 6);  // 针对这一场景，建议不要使用new Array(4, 5, 6)\\nconst res = new Array<number>(3);\\nfor (let i = 0; i < 3; i++) {\\n  res[i] = array1[i] + array2[i];\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]数值计算使用TypedArray",
        "parent_text": "[h2]数值计算使用TypedArray如果是纯数值计算的场合，推荐使用TypedArray数据结构。TypedArray类型化数组是一种类似数组的对象，其提供了一种用于在内存缓冲中访问原始二进制数据的机制。在一些图像数据处理、加解密的数据计算过程中使用TypedArray可以提高数据处理的效率，因为TypedArray是基于ArrayBuffer实现，在性能方面也能够进行较大提升。 【反例】  【正例】 const typedArray1 = new Int8Array([1, 2, 3]);  // 针对这一场景，建议不要使用new Array([1, 2, 3])\\nconst typedArray2 = new Int8Array([4, 5, 6]);  // 针对这一场景，建议不要使用new Array([4, 5, 6])\\nconst res = new Int8Array(3);\\nfor (let i = 0; i < 3; i++) {\\n  res[i] = typedArray1[i] + typedArray2[i];\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1169143314502\\\"'><a name='\\\"section1169143314502\\\"'></a><a name='\\\"section1169143314502\\\"'></a><h4>[h2]数值计算使用TypedArray</h4><p>如果是纯数值计算的场合，推荐使用TypedArray数据结构。TypedArray类型化数组是一种类似数组的对象，其提供了一种用于在内存缓冲中访问原始二进制数据的机制。在一些图像数据处理、加解密的数据计算过程中使用TypedArray可以提高数据处理的效率，因为TypedArray是基于ArrayBuffer实现，在性能方面也能够进行较大提升。</p> <p>【反例】</p>  <p>【正例】</p> <pre class='\\\"screen\\\"'>const typedArray1 = new Int8Array([1, 2, 3]);  // 针对这一场景，建议不要使用new Array([1, 2, 3])\\nconst typedArray2 = new Int8Array([4, 5, 6]);  // 针对这一场景，建议不要使用new Array([4, 5, 6])\\nconst res = new Int8Array(3);\\nfor (let i = 0; i &lt; 3; i++) {\\n  res[i] = typedArray1[i] + typedArray2[i];\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 234,
        "pre": "class InfoUtil {\\n  getInfo(t1: string, t2: string): string {\\n    if (t1 === t2) {\\n      return \\\"\\\";\\n    }\\n    // 此处使用Record普通对象作为容器\\n    let info: Record<string, string> = {};\\n    this.setInfo(info);\\n    let t3 = info[t2];\\n    return (t3 != null) ? t3 : \\\"\\\";\\n  }\\n\\n  setInfo(info: Record<string, string>) {\\n    // 接口内部实际上进行的是map的操作\\n    info.aaa = 'aaa';\\n    info.bbb = 'bbb';\\n    info.ccc = 'ccc';\\n  }\\n}",
        "type": "Reference",
        "function_call": "setInfo(info:HashMap&lt;string, string&gt;)",
        "function_name": "[h2]选取合适的数据结构",
        "parent_text": "[h2]选取合适的数据结构有些时候会采用Record的方式作为临时容器来处理属性存取的逻辑，例如如下案例中，对于info执行的操作是set存储以及读取的操作，这里更好的方式是采用标准内置Map以及基础类库提供的高性能容器类如HashMap。HashMap是ArkTS提供的高性能容器类，底层使用红黑树实现，提供了高性能的数据读写操作，可以用来实现快速读写键值。 【反例】  【正例】 import HashMap from '@ohos.util.HashMap';\\n\\nclass InfoUtil {\\n  getInfo(t1: string, t2: string): string {\\n    if (t1 === t2) {\\n      return \\\"\\\";\\n    }\\n    // 此处改为使用HashMap进行读写操作\\n    let info: HashMap<string, string> = new HashMap();\\n    this.setInfo(info);\\n    let t3 = info.get(t2);\\n    return (t3 != null) ? t3 : \\\"\\\";\\n  }\\n  setInfo(info:HashMap<string, string>) {\\n    // ...\\n    info.set('aaa','aaa');\\n    info.set('bbb','bbb');\\n    info.set('ccc','ccc');\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section941819318528\\\"'><a name='\\\"section941819318528\\\"'></a><a name='\\\"section941819318528\\\"'></a><h4>[h2]选取合适的数据结构</h4><p>有些时候会采用Record的方式作为临时容器来处理属性存取的逻辑，例如如下案例中，对于info执行的操作是set存储以及读取的操作，这里更好的方式是采用标准内置Map以及基础类库提供的高性能容器类如HashMap。HashMap是ArkTS提供的高性能容器类，底层使用红黑树实现，提供了高性能的数据读写操作，可以用来实现快速读写键值。</p> <p>【反例】</p>  <p>【正例】</p> <pre class='\\\"screen\\\"'>import HashMap from '@ohos.util.HashMap';\\n\\nclass InfoUtil {\\n  getInfo(t1: string, t2: string): string {\\n    if (t1 === t2) {\\n      return \\\"\\\";\\n    }\\n    // 此处改为使用HashMap进行读写操作\\n    let info: HashMap&lt;string, string&gt; = new HashMap();\\n    this.setInfo(info);\\n    let t3 = info.get(t2);\\n    return (t3 != null) ? t3 : \\\"\\\";\\n  }\\n  setInfo(info:HashMap&lt;string, string&gt;) {\\n    // ...\\n    info.set('aaa','aaa');\\n    info.set('bbb','bbb');\\n    info.set('ccc','ccc');\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 235,
        "pre": "// Index.ets\\nimport * as nm from '../utils/Numbers'; // 不推荐import *的方式\\nhilog.info(0x0000, 'testTag', '%{public}d', nm.One); // 此处仅用到变量One\\n// Numbers.ets\\nexport const One: number = 1;\\nexport const Two: number = 2;\\n// ...\\n// 此处省略100000条数据",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]减少import *的方式全量引用",
        "parent_text": "[h2]减少import *的方式全量引用应用程序加载过程中，需要使用不同模块中的变量或函数，通常开发者会将相同类型的变量或函数放在同一个工具类文件中，使用时通过import的方式引入对应的模块，当工具类中存在较多暴露函数或变量时，推荐按需引用使用到的变量代替“import  *”的方式，可以减少该阶段中.ets文件执行耗时，即减少文件中所有export变量的初始化过程。 【反例】Index.ets中使用“import * as nm from '../utils/Numbers'”。  【正例】Index.ets中使用“import { One } from '../utils/Numbers'”。 // Index.ets\\nimport { One } as nm from '../utils/Numbers'; // 推荐按需引用变量\\nhilog.info(0x0000, 'testTag', '%{public}d', One); // 此处仅用到变量One\\n// Numbers.ets\\nexport const One: number = 1;\\nexport const Two: number = 2;\\n// ...\\n// 此处省略100000条数据 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section745724616563\\\"'><a name='\\\"section745724616563\\\"'></a><a name='\\\"section745724616563\\\"'></a><h4>[h2]减少import *的方式全量引用</h4><p>应用程序加载过程中，需要使用不同模块中的变量或函数，通常开发者会将相同类型的变量或函数放在同一个工具类文件中，使用时通过import的方式引入对应的模块，当工具类中存在较多暴露函数或变量时，推荐按需引用使用到的变量代替“import  *”的方式，可以减少该阶段中.ets文件执行耗时，即减少文件中所有export变量的初始化过程。</p> <p>【反例】Index.ets中使用“import * as nm from '../utils/Numbers'”。</p>  <p>【正例】Index.ets中使用“import { One } from '../utils/Numbers'”。</p> <pre class='\\\"screen\\\"'>// Index.ets\\nimport { One } as nm from '../utils/Numbers'; // 推荐按需引用变量\\nhilog.info(0x0000, 'testTag', '%{public}d', One); // 此处仅用到变量One\\n// Numbers.ets\\nexport const One: number = 1;\\nexport const Two: number = 2;\\n// ...\\n// 此处省略100000条数据</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 236,
        "pre": "// A为任意可以被引入的ets文件\\nimport { A } from \\\"./A\\\"\\n\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    RelativeContainer() {\\n      Button('点击执行A')\\n        .onClick(() => {\\n          console.log('执行A' + A)\\n        })\\n    }\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]使用场景",
        "parent_text": "[h2]使用场景下述例子中A文件被引用，在应用启动到点击按钮的这段时间里，A文件并没有被实际执行，在冷启动阶段加载A文件的行为属于冗余。   通过抓取Trace图查看调用栈可发现，应用在冷启动时加载了A文件。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section118727311451\\\"'><a name='\\\"section118727311451\\\"'></a><a name='\\\"section118727311451\\\"'></a><h4>[h2]使用场景</h4><p>下述例子中A文件被引用，在应用启动到点击按钮的这段时间里，A文件并没有被实际执行，在冷启动阶段加载A文件的行为属于冗余。</p>  <p><span><img height='\\\"335.949089\\\"' originheight='\\\"449\\\"' originwidth='\\\"1551\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161103.88359548645557538008294916798776:50001231000000:2800:B3674004327DD37F44E22B5740EB4FCEFE0435E1795F0CC3CA716AF4D4D79016.png\\\"' title='\\\"点击放大\\\"' width='\\\"1160.501475\\\"'/></span></p> <p>通过抓取Trace图查看调用栈可发现，应用在冷启动时加载了A文件。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkts-high-performance.html"
    },
    {
        "id": 237,
        "pre": "aa start -a {abilityName} -b {bundleName} -R",
        "type": "Import",
        "function_call": null,
        "function_name": "[h2]使能方舟多线程检测",
        "parent_text": "[h2]使能方舟多线程检测可通过以下两种方式使能方舟多线程检测。 方式一 点击Run > Edit Configurations > Diagnostics，勾选Multi Thread Check。  方式二 通过命令行开启。  ",
        "import_module": "aa start -a {abilityName} -b {bundleName} -R",
        "parent": "<div class='\\\"section\\\"' id='\\\"section7199344111510\\\"'><a name='\\\"section7199344111510\\\"'></a><a name='\\\"section7199344111510\\\"'></a><h4>[h2]使能方舟多线程检测</h4><p>可通过以下两种方式使能方舟多线程检测。</p> <ul><li><strong>方式一</strong></li></ul> <p>点击<strong>Run &gt; Edit Configurations &gt;</strong> <strong>Diagnostics</strong>，勾选<strong>Multi Thread Check</strong>。</p> <p><span><img originheight='\\\"257\\\"' originwidth='\\\"689\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161237.06230190618128947449344249276036:50001231000000:2800:3D944210233ABDABFA77A734DB6D927157C839DFE0BA5F1407BE359C79F36B01.png\\\"'/></span></p> <ul><li><strong>方式二</strong></li></ul> <p>通过命令行开启。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-stability-ark-runtime-detection.html"
    },
    {
        "id": 238,
        "pre": "// features/home/src/main/ets/view/Home.ets\\nbuild() {\\n  Navigation(this.navDialogPageInfos) {\\n    // ...\\n  }\\n  .hideTitleBar(true)\\n  .mode(NavigationMode.Stack)\\n  .navDestination(this.NavDialogPageMap)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]弹窗显示",
        "parent_text": "[h2]弹窗显示在视频页面点击消息按钮，弹出评论列表页面弹窗。在评论列表页点击写评论按钮，弹出评论模块弹窗。  基于Navigation的弹窗方案，Navigation的mode属性需要设置为NavigationMode.Stack。弹窗需要全屏显示，Navigation则需要添加在最外层组件上。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section219998399\\\"'><a name='\\\"section219998399\\\"'></a><a name='\\\"section219998399\\\"'></a><h4>[h2]弹窗显示</h4><p>在视频页面点击消息按钮，弹出评论列表页面弹窗。在评论列表页点击写评论按钮，弹出评论模块弹窗。</p> <p><span><img height='\\\"546.7763\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161126.20844483964184715911159870711182:50001231000000:2800:F1AA2B54812169203AEBAF9485D1E224E7D4888B1C18CDE3A916E0EA28D059A1.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>基于Navigation的弹窗方案，Navigation的mode属性需要设置为NavigationMode.Stack。弹窗需要全屏显示，Navigation则需要添加在最外层组件上。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-comment-reply-pop-up-window.html"
    },
    {
        "id": 239,
        "pre": "// features/home/src/main/ets/view/CommentKeyboard.ets\\nRichEditor({ controller: this.richEditorController })\\n  .customKeyboard(this.isEmojiKeyboardVisible ? this.EmojiKeyboard() : undefined)\\n  // ...",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]软键盘和表情面板切换适配",
        "parent_text": "[h2]软键盘和表情面板切换适配点击编辑区域表情按钮，软键盘切换为表情面板，表情按钮图标变成键盘图标。再次点击，表情面板切换回软键盘，按钮图标由键盘变回表情。  本文选择自定义键盘来控制软键盘和表情面板的切换。通过设置RichEditor.customKeyboard为表情面板组件的构建函数EmojiKeyboard，来展示表情面板，设置该属性为undefined，则展示默认软键盘。通过这种方式在软键盘与表情面板切换时也无需手动进行richEditor焦点的处理。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1591923118391\\\"'><a name='\\\"section1591923118391\\\"'></a><a name='\\\"section1591923118391\\\"'></a><h4>[h2]软键盘和表情面板切换适配</h4><p>点击编辑区域表情按钮，软键盘切换为表情面板，表情按钮图标变成键盘图标。再次点击，表情面板切换回软键盘，按钮图标由键盘变回表情。</p> <p><span><img height='\\\"546.7763\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161126.74669095678018323294995941545742:50001231000000:2800:ECDF3218E8D5E78AA9A3B9DCCBEF355BD396E33CB85C820424C021E17CE166F3.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>本文选择自定义键盘来控制软键盘和表情面板的切换。通过设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#customkeyboard\\\"' target='\\\"_blank\\\"'>RichEditor.customKeyboard</a>为表情面板组件的构建函数EmojiKeyboard，来展示表情面板，设置该属性为undefined，则展示默认软键盘。通过这种方式在软键盘与表情面板切换时也无需手动进行richEditor焦点的处理。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-comment-reply-pop-up-window.html"
    },
    {
        "id": 240,
        "pre": "// features/home/src/main/ets/view/CommentKeyboard.ets\\nonEmojiClick: (icon: Resource) => void = icon => {\\n  this.richEditorController.addImageSpan(icon, {\\n    offset: this.richEditorController.getCaretOffset(),\\n    imageStyle: {\\n      size: [20, 20]\\n    }\\n  });\\n  // ...\\n};",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "添加表情在软键盘上方常用表情列表点击表情图片，或者切换到表情面板点击表情图片，会在编辑区域光标后方添加对应的表情内容。  在表情面板或常用表情列表中点击表情时可通过RichEditorController.addImageSpan在编辑区域进行添加图片表情，注意需要设置offset属性为当前光标位置，当前光标的位置可通过RichEditorController.getCaretOffset获取。这样使得表情在当前光标后添加，否则默认在内容的最后方添加，后文类似的添加操作都遵循此规则。  ",
        "import_module": null,
        "parent": "<li>添加表情<p>在软键盘上方常用表情列表点击表情图片，或者切换到表情面板点击表情图片，会在编辑区域光标后方添加对应的表情内容。</p> <p><span><img height='\\\"546.7763\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161127.78417551617099631450353488770713:50001231000000:2800:E0997465AE6908704A749A285386B7B185B7B7927263C99A8794BFE8BB148F26.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>在表情面板或常用表情列表中点击表情时可通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#addimagespan\\\"' target='\\\"_blank\\\"'>RichEditorController.addImageSpan</a>在编辑区域进行添加图片表情，注意需要设置offset属性为当前光标位置，当前光标的位置可通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-richeditor#getcaretoffset10\\\"' target='\\\"_blank\\\"'>RichEditorController.getCaretOffset</a>获取。这样使得表情在当前光标后添加，否则默认在内容的最后方添加，后文类似的添加操作都遵循此规则。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-comment-reply-pop-up-window.html"
    },
    {
        "id": 241,
        "pre": "// module.json5\\n\\\"abilities\\\": [ \\n  { \\n    \\\"name\\\": \\\"PrivacyAbility\\\", \\n    \\\"srcEntry\\\": \\\"./ets/privacyability/PrivacyAbility.ts\\\", \\n    \\\"description\\\": \\\"$string:PrivacyAbility_desc\\\", \\n    \\\"exported\\\": true \\n  } \\n]",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]建议不涉及对外交互业务的应用组件的exported属性设置为false",
        "parent_text": "[h2]建议不涉及对外交互业务的应用组件的exported属性设置为false只在应用程序内部使用的应用组件必须设置为不可见，以防受到其他应用程序的调用。 不对外交互的应用组件应该明确设置该应用组件的exported属性值为false（若未设置exported属性默认为false，建议显式设置防止遗漏和错误配置）。否则，可能会对外暴露内部接口，若被恶意应用利用，则可能会造成应用组件的信息泄露、功能异常、应用拒绝服务等问题。  当应用组件的exported属性设置为false时，使用DevEco Studio在启动调试或运行应用/服务时，或通过命令行拉起会出现安装HAP错误，提示“error: failed to start ability. error: ability visible false deny request”错误信息，出现该信息是由于系统安全权限不允许拉起exported属性设置为false的应用/服务，因此建议开发者在调试阶段exported属性设置为true，在正式上架发布的时候再设置exported属性为false。  错误示例：  PrivacyAbility是一个不期望对外交互的组件，但是设置exported属性为true，导致任何应用都可以访问该组件。 正确示例： // module.json5 \\n\\\"abilities\\\": [ \\n  { \\n    \\\"name\\\": \\\"PrivacyAbility\\\", \\n    \\\"srcEntry\\\": \\\"./ets/privacyability/PrivacyAbility.ts\\\", \\n    \\\"description\\\": \\\"$string:PrivacyAbility_desc\\\", \\n    \\\"exported\\\": false \\n  } \\n]  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section93277172115\\\"'><a name='\\\"section93277172115\\\"'></a><a name='\\\"section93277172115\\\"'></a><h4>[h2]建议不涉及对外交互业务的应用组件的exported属性设置为false</h4><p>只在应用程序内部使用的应用组件必须设置为不可见，以防受到其他应用程序的调用。</p> <p>不对外交互的应用组件应该明确设置该应用组件的exported属性值为false（若未设置exported属性默认为false，建议显式设置防止遗漏和错误配置）。否则，可能会对外暴露内部接口，若被恶意应用利用，则可能会造成应用组件的信息泄露、功能异常、应用拒绝服务等问题。</p> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161228.99333115246320376801575177143170:50001231000000:2800:3D01476CE4A47D5A3D8C9687BB84239F039DFC798FAA8161C8BFB9E2D3BC9BD2.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>当应用组件的exported属性设置为false时，使用DevEco Studio在启动调试或运行应用/服务时，或通过命令行拉起会出现安装HAP错误，提示“error: failed to start ability. error: ability visible false deny request”错误信息，出现该信息是由于系统安全权限不允许拉起exported属性设置为false的应用/服务，因此建议开发者在调试阶段exported属性设置为true，在正式上架发布的时候再设置exported属性为false。</p> </div></div> <p><strong>错误示例：</strong></p>  <p>PrivacyAbility是一个不期望对外交互的组件，但是设置exported属性为true，导致任何应用都可以访问该组件。</p> <p><strong>正确示例：</strong></p> <pre class='\\\"screen\\\"'>// module.json5 \\n\\\"abilities\\\": [ \\n  { \\n    \\\"name\\\": \\\"PrivacyAbility\\\", \\n    \\\"srcEntry\\\": \\\"./ets/privacyability/PrivacyAbility.ts\\\", \\n    \\\"description\\\": \\\"$string:PrivacyAbility_desc\\\", \\n   <span rgb(255,0,0);\\\"=\"\" style='\\\"color:'> \\\"exported\\\": false</span> \\n  } \\n]</pre> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 242,
        "pre": "// module.json5 \\n\\\"abilities\\\": [ \\n  { \\n    \\\"name\\\": \\\"ContactDataAbility\\\", \\n    \\\"srcEntry\\\": \\\"./ets/DataAbility/DataAbility.ts\\\", \\n    \\\"description\\\": \\\"$string: DataAbility_desc\\\", \\n    \\\"exported\\\": true \\n  } \\n]",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]对外交互的应用组件应设置合理的访问权限",
        "parent_text": "[h2]对外交互的应用组件应设置合理的访问权限应用程序的应用组件不只是在应用程序内部使用，很多情况下需要与外部进行交互。以下情况表明应用组件是对外交互的： module.json5文件中显式设置exported属性为true，则表明该Ability允许对外交互的； 程序内应用组件一旦允许对外交互，数据存在跨信任边界进行交互，若被恶意应用程序利用，可能会导致Ability信息泄露、功能异常、应用拒绝服务等问题；因此，应用程序对外交互的应用组件使用permissions属性来设置访问权限。 常见敏感功能、对外提供的Ability利用风险，建议涉及这些情况的组件设置权限进行保护： 1）未经用户操作确认就可执行关键操作，例如：发送短信、拨打电话、拍照、录音、录屏 、截屏、定位等 2）导致个人数据、敏感数据泄露的关键操作，例如：读取短信、读取联系人、读取设备标识符等 3）导致权限提升，例如：可以进行原本system权限才能进行的操作 例外情况：必须对外提供且无利用风险的应用组件，可以不设置权限。 错误示例：  可以看出，任意外部应用都可以访问此ContactDataAbility，恶意应用程序可能利用该组件获取联系人数据。 正确示例： // module.json5 \\n\\\"abilities\\\": [ \\n  { \\n    \\\"name\\\": \\\"ContactDataAbility\\\", \\n    \\\"srcEntry\\\": \\\"./ets/DataAbility/DataAbility.ts\\\", \\n    \\\"description\\\": \\\"$string: DataAbility_desc\\\", \\n    \\\"exported\\\": true, \\n    \\\"permissions\\\": [\\\"ohos.permission.READ_CONTACTS\\\"] \\n  } \\n]  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section16254131183715\\\"'><a name='\\\"section16254131183715\\\"'></a><a name='\\\"section16254131183715\\\"'></a><h4>[h2]对外交互的应用组件应设置合理的访问权限</h4><p>应用程序的应用组件不只是在应用程序内部使用，很多情况下需要与外部进行交互。以下情况表明应用组件是对外交互的：</p> <ul><li>module.json5文件中显式设置exported属性为true，则表明该Ability允许对外交互的；</li></ul> <p>程序内应用组件一旦允许对外交互，数据存在跨信任边界进行交互，若被恶意应用程序利用，可能会导致Ability信息泄露、功能异常、应用拒绝服务等问题；因此，应用程序对外交互的应用组件使用permissions属性来设置访问权限。</p> <p>常见敏感功能、对外提供的Ability利用风险，建议涉及这些情况的组件设置权限进行保护：</p> <p>1）未经用户操作确认就可执行关键操作，例如：发送短信、拨打电话、拍照、录音、录屏 、截屏、定位等</p> <p>2）导致个人数据、敏感数据泄露的关键操作，例如：读取短信、读取联系人、读取设备标识符等</p> <p>3）导致权限提升，例如：可以进行原本system权限才能进行的操作</p> <p><strong>例外情况：</strong>必须对外提供且无利用风险的应用组件，可以不设置权限。</p> <p><strong>错误示例：</strong></p>  <p>可以看出，任意外部应用都可以访问此ContactDataAbility，恶意应用程序可能利用该组件获取联系人数据。</p> <p><strong>正确示例：</strong></p> <pre class='\\\"screen\\\"'>// module.json5 \\n\\\"abilities\\\": [ \\n  { \\n    \\\"name\\\": \\\"ContactDataAbility\\\", \\n    \\\"srcEntry\\\": \\\"./ets/DataAbility/DataAbility.ts\\\", \\n    \\\"description\\\": \\\"$string: DataAbility_desc\\\", \\n    \\\"exported\\\": true, \\n   <span rgb(255,0,0);\\\"=\"\" style='\\\"color:'> \\\"permissions\\\": [\\\"ohos.permission.READ_CONTACTS\\\"]</span> \\n  } \\n]</pre> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 243,
        "pre": "import { Want } from \\\"@kit.AbilityKit\\\";\\n\\nlet wantInfo:Want = { \\n  deviceId: '', \\n  action: \\\"ability.want.test\\\", \\n  parameters: { \\n    \\\"password\\\": \\\"xxxxxxxx\\\" \\n  } \\n} \\ntry{ \\n  let data = this.context.startAbility(wantInfo) \\n  console.info(\\\"startAbility success \\\" + JSON.stringify(data)); \\n} catch (err) { \\n  console.error(\\\"startAbility  with error message: \\\" + err.message + \\\", error code: \\\" + err.code); \\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]建议隐式启动应用组件时避免携带个人数据",
        "parent_text": "[h2]建议隐式启动应用组件时避免携带个人数据隐式want是通过action条件匹配的方式来筛选组件，凡是满足条件的应用组件都有被启动的可能。如果携带个人数据，则恶意应用有可能劫持携带的个人数据。应用程序如果要携带个人数据，需要显式指定目标应用组件（bundle名、ability名）或者将个人数据匿名化。示例中的context的获取方式请参见获取UIAbility的上下文信息。 错误示例:  通过示例代码中的action：\\\"ability.want.test\\\"可以隐式启动组件，如果恶意应用也声明了该action，隐式调用时会出现一个列表让用户选择，如果用户进入了恶意应用，则恶意应用可以获取传递的敏感信息。 正确示例: import { Want } from \\\"@kit.AbilityKit\\\";\\n\\nlet wantInfo:Want = { \\n  deviceId: '', \\n  action: \\\"ability.want.test\\\", \\n  bundleName:'com.example.myapplication10', \\n  abilityName:'MainAbility1', \\n  parameters: { \\n    \\\"password\\\": \\\"xxxxxxxx\\\" \\n  } \\n} \\ntry{ \\n  let data = this.context.startAbility(wantInfo) \\n  console.info(\\\"startAbility success \\\" + JSON.stringify(data)); \\n} catch (err) { \\n  console.error(\\\"startAbility  with error message: \\\" + err.message + \\\", error code: \\\" + err.code); \\n} 这里显式指定了需要拉起的应用组件的bundleName和abilityName，只会拉起指定的目标组件。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section143261097385\\\"'><a name='\\\"section143261097385\\\"'></a><a name='\\\"section143261097385\\\"'></a><h4>[h2]建议隐式启动应用组件时避免携带个人数据</h4><p>隐式want是通过action条件匹配的方式来筛选组件，凡是满足条件的应用组件都有被启动的可能。如果携带个人数据，则恶意应用有可能劫持携带的个人数据。应用程序如果要携带个人数据，需要显式指定目标应用组件（bundle名、ability名）或者将个人数据匿名化。示例中的context的获取方式请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-usage#获取uiability的上下文信息\\\"' target='\\\"_blank\\\"'>获取UIAbility的上下文信息</a>。</p> <p><strong>错误示例:</strong></p>  <p>通过示例代码中的action：\\\"ability.want.test\\\"可以隐式启动组件，如果恶意应用也声明了该action，隐式调用时会出现一个列表让用户选择，如果用户进入了恶意应用，则恶意应用可以获取传递的敏感信息。</p> <p><strong>正确示例:</strong></p> <pre class='\\\"screen\\\"'>import { Want } from \\\"@kit.AbilityKit\\\";\\n\\nlet wantInfo:Want = { \\n  deviceId: '', \\n  action: \\\"ability.want.test\\\", \\n<span rgb(255,0,0);\\\"=\"\" style='\\\"color:'>  bundleName:'com.example.myapplication10', </span>\\n<span rgb(255,0,0);\\\"=\"\" style='\\\"color:'>  abilityName:'MainAbility1',</span> \\n  parameters: { \\n    \\\"password\\\": \\\"xxxxxxxx\\\" \\n  } \\n} \\ntry{ \\n  let data = this.context.startAbility(wantInfo) \\n  console.info(\\\"startAbility success \\\" + JSON.stringify(data)); \\n} catch (err) { \\n  console.error(\\\"startAbility  with error message: \\\" + err.message + \\\", error code: \\\" + err.code); \\n}</pre> <p>这里显式指定了需要拉起的应用组件的bundleName和abilityName，只会拉起指定的目标组件。</p> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 244,
        "pre": "import { router, window } from '@kit.ArkUI';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n\\n  onPageShow(): void {\\n    window.getLastWindow(getContext(this)).then((windowStage: window.Window) => {\\n      windowStage.setWindowPrivacyMode(true);\\n    });\\n  }\\n  onPageHide(): void {\\n    window.getLastWindow(getContext(this)).then((windowStage: window.Window) => {\\n      windowStage.setWindowPrivacyMode(false);\\n    });\\n  }\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n        Button('click to start Succ Page')\\n          .onClick(async () => {\\n            router.pushUrl({ url: 'pages/loginSuccPage' })\\n          })\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]避免涉及口令输入的应用界面可以被截屏或录屏",
        "parent_text": "[h2]避免涉及口令输入的应用界面可以被截屏或录屏口令输入界面主要涉及账号密码输入框及输入法弹出框，在用户输入口令时，应避免截屏或录屏操作。否则，一旦恶意软件骗取用户信任获得授权，窃取到用户操作的账号和密码，即可在其他设备中登录，造成用户隐私泄露。 实施指导： 在需要保护的Page页面调用setWindowPrivacyMode禁止截屏/录屏。 注意：此接口需要申请ohos.permission.PRIVACY_WINDOW权限。 正确示例: 在口令输入、转账支付页面中设置隐私属性，防止截屏/录屏：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section18516943133816\\\"'><a name='\\\"section18516943133816\\\"'></a><a name='\\\"section18516943133816\\\"'></a><h4>[h2]避免涉及口令输入的应用界面可以被截屏或录屏</h4><p>口令输入界面主要涉及账号密码输入框及输入法弹出框，在用户输入口令时，应避免截屏或录屏操作。否则，一旦恶意软件骗取用户信任获得授权，窃取到用户操作的账号和密码，即可在其他设备中登录，造成用户隐私泄露。</p> <p><strong>实施指导：</strong></p> <p>在需要保护的Page页面调用setWindowPrivacyMode禁止截屏/录屏。</p> <p>注意：此接口需要申请ohos.permission.PRIVACY_WINDOW权限。</p> <p><strong>正确示例:</strong></p> <p>在口令输入、转账支付页面中设置隐私属性，防止截屏/录屏：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 245,
        "pre": "import { commonEventManager } from '@kit.BasicServicesKit';\\n\\nfunction publishEventWithData() {\\n  let options: commonEventManager.CommonEventPublishData = {\\n    code: 1,\\n    data: \\\"ContactData\\\", // 带敏感数据发送\\n  }\\n  commonEventManager.publish(\\\"MyCommonEvent\\\", options, (err) => {\\n    if (err.code) {\\n      console.error(\\\"publish event error: \\\" + err.code + \\\", \\\" + err.message + \\\", \\\" + err.name + \\\", \\\" + err.stack);\\n    } else {\\n      console.info(\\\"publish event with data Succeeded\\\");\\n    }\\n  })\\n}",
        "type": "Reference",
        "function_call": "nfunction publishEventWithData()",
        "function_name": "[h2]避免使用携带个人数据未设置权限的动态公共事件",
        "parent_text": "[h2]避免使用携带个人数据未设置权限的动态公共事件 不同应用程序间可以使用公共事件进行进程间通信，如果公共事件发送权限设置不当，且携带个人数据，任意应用就可以读取该个人数据，造成用户数据泄露。 对于携带个人数据的公共事件，需要设置公共事件发送权限或者将个人数据加密。 错误示例:  发送了一个带个人数据（示例中假设是联系人数据）的公共事件，但是没有设置接收方接受此公共事件所需要的权限。 正确示例:import { commonEventManager } from '@kit.BasicServicesKit';\\n\\nfunction publishEventWithData() {\\n  let options: commonEventManager.CommonEventPublishData = {\\n    code: 1,\\n    data: \\\"ContactData\\\", // 带敏感数据发送\\n    subscriberPermissions: [\\\"ohos.permission.READ_CONTACTS\\\"], // 设置权限\\n  }\\n  commonEventManager.publish(\\\"MyCommonEvent\\\", options, (err) => {\\n    if (err.code) {\\n      console.error(\\\"publish event error: \\\" + err.code + \\\", \\\" + err.message + \\\", \\\" + err.name + \\\", \\\" + err.stack);\\n    } else {\\n      console.info(\\\"publish event with data Succeeded\\\");\\n    }\\n  })\\n}  通过subscriberPermissions字段设置了接收公共事件的权限，这样，发布者要求订阅者必须具有“ohos.permission.READ_CONTACTS”权限，才能接收该携带联系人数据的公共事件。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section190521394018\\\"'><a name='\\\"section190521394018\\\"'></a><a name='\\\"section190521394018\\\"'></a><h4>[h2]避免使用携带个人数据未设置权限的动态公共事件</h4><p></p> <p>不同应用程序间可以使用公共事件进行进程间通信，如果公共事件发送权限设置不当，且携带个人数据，任意应用就可以读取该个人数据，造成用户数据泄露。</p> <p>对于携带个人数据的公共事件，需要设置公共事件发送权限或者将个人数据加密。</p> <p><strong>错误示例:</strong></p>  <p>发送了一个带个人数据（示例中假设是联系人数据）的公共事件，但是没有设置接收方接受此公共事件所需要的权限。</p> <div class='\\\"p\\\"'><strong>正确示例:</strong><pre class='\\\"screen\\\"'>import { commonEventManager } from '@kit.BasicServicesKit';\\n\\nfunction publishEventWithData() {\\n  let options: commonEventManager.CommonEventPublishData = {\\n    code: 1,\\n    data: \\\"ContactData\\\", // 带敏感数据发送\\n    subscriberPermissions: [\\\"ohos.permission.READ_CONTACTS\\\"], // 设置权限\\n  }\\n  commonEventManager.publish(\\\"MyCommonEvent\\\", options, (err) =&gt; {\\n    if (err.code) {\\n      console.error(\\\"publish event error: \\\" + err.code + \\\", \\\" + err.message + \\\", \\\" + err.name + \\\", \\\" + err.stack);\\n    } else {\\n      console.info(\\\"publish event with data Succeeded\\\");\\n    }\\n  })\\n}</pre> </div> <p>通过subscriberPermissions字段设置了接收公共事件的权限，这样，发布者要求订阅者必须具有“ohos.permission.READ_CONTACTS”权限，才能接收该携带联系人数据的公共事件。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 246,
        "pre": "import { commonEventManager } from '@kit.BasicServicesKit';\\n\\nlet subscriber: commonEventManager.CommonEventSubscriber;\\n// 订阅者信息\\nlet subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {\\n  events: [\\\"event\\\"]\\n};\\n\\n// 创建订阅者\\ntry {\\n  commonEventManager.createSubscriber(subscribeInfo, (err, commonEventSubscriber) => {\\n    if (!err) {\\n      console.info(\\\"createSubscriber Succeed\\\");\\n      subscriber = commonEventSubscriber;\\n      // 订阅公共事件\\n      try {\\n        commonEventManager.subscribe(subscriber, (err, data) => {\\n          if (err) {\\n            console.error(`subscribe failed, code is ${err.code}, message is ${err.message}`);\\n          } else {\\n            // 接收公共事件后事件处理\\n            // doSomeDangerousThing(data)\\n          }\\n        });\\n      } catch (err) {\\n        console.error(`subscribe failed, code is ${err.code}, message is ${err.message}`);\\n      }\\n    } else {\\n      console.error(`createSubscriber failed, code is ${err.code}, message is ${err.message}`);\\n    }\\n  });\\n} catch (err) {\\n  console.error(`createSubscriber failed, code is ${err.code}, message is ${err.message}`);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]建议对涉及敏感功能的公共事件进行访问权限控制",
        "parent_text": "[h2]建议对涉及敏感功能的公共事件进行访问权限控制每个应用都支持订阅自定义的公共事件，并在接收到公共事件后执行一定的功能。应用在订阅公共事件后，通过publisherPermission设置订阅公共事件接收的权限。如果订阅的是自定义的公共事件且未设置权限，任意应用可以发送同名的自定义的公共事件，从而可能导致接收公共事件的应用拒绝服务甚至敏感功能泄露。 对于涉及敏感数据/操作的公共事件：订阅方需要设置权限且权限等级足够高。 错误示例:  正确示例:import { commonEventManager } from '@kit.BasicServicesKit';\\n\\nlet subscriber: commonEventManager.CommonEventSubscriber;\\n// 订阅者信息\\nlet subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {\\n  events: [\\\"event\\\"],\\n  publisherPermission: \\\"ohos.permission.publisherPermission1\\\", // 设置订阅权限\\n};\\n\\n// 创建订阅者\\ntry {\\n  commonEventManager.createSubscriber(subscribeInfo, (err, commonEventSubscriber) => {\\n    if (!err) {\\n      console.info(\\\"createSubscriber\\\");\\n      subscriber = commonEventSubscriber;\\n      // 订阅公共事件\\n      try {\\n        commonEventManager.subscribe(subscriber, (err, data) => {\\n          if (err) {\\n            console.error(`subscribe failed, code is ${err.code}, message is ${err.message}`);\\n          } else {\\n            // 接收公共事件后事件处理\\n            // doSomeDangerousThing(data)\\n          }\\n        });\\n      } catch (err) {\\n        console.error(`subscribe failed, code is ${err.code}, message is ${err.message}`);\\n      }\\n    } else {\\n      console.error(`createSubscriber failed, code is ${err.code}, message is ${err.message}`);\\n    }\\n  });\\n} catch (err) {\\n  console.error(`createSubscriber failed, code is ${err.code}, message is ${err.message}`);\\n}  常见敏感功能、对外提供的公共事件利用风险，建议涉及这些情况的公共事件设置权限进行保护： 1）未经用户操作确认就可执行关键操作，例如：发送短信、拨打电话、拍照、录音、录屏 、截屏、定位等 2）导致个人数据、敏感数据泄露的关键操作，例如：读取短信、读取联系人、读取设备标识符等 3）导致权限提升，例如：可以进行原本system权限才能进行的操作 例外情况：必须对外提供且无利用风险的应用公共事件，可以不设置权限。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section74546012413\\\"'><a name='\\\"section74546012413\\\"'></a><a name='\\\"section74546012413\\\"'></a><h4>[h2]建议对涉及敏感功能的公共事件进行访问权限控制</h4><p>每个应用都支持订阅自定义的公共事件，并在接收到公共事件后执行一定的功能。应用在订阅公共事件后，通过publisherPermission设置订阅公共事件接收的权限。如果订阅的是自定义的公共事件且未设置权限，任意应用可以发送同名的自定义的公共事件，从而可能导致接收公共事件的应用拒绝服务甚至敏感功能泄露。</p> <p>对于涉及敏感数据/操作的公共事件：订阅方需要设置权限且权限等级足够高。</p> <p><strong>错误示例:</strong></p>  <div class='\\\"p\\\"'><strong>正确示例:</strong><pre class='\\\"screen\\\"'>import { commonEventManager } from '@kit.BasicServicesKit';\\n\\nlet subscriber: commonEventManager.CommonEventSubscriber;\\n// 订阅者信息\\nlet subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {\\n  events: [\\\"event\\\"],\\n  publisherPermission: \\\"ohos.permission.publisherPermission1\\\", // 设置订阅权限\\n};\\n\\n// 创建订阅者\\ntry {\\n  commonEventManager.createSubscriber(subscribeInfo, (err, commonEventSubscriber) =&gt; {\\n    if (!err) {\\n      console.info(\\\"createSubscriber\\\");\\n      subscriber = commonEventSubscriber;\\n      // 订阅公共事件\\n      try {\\n        commonEventManager.subscribe(subscriber, (err, data) =&gt; {\\n          if (err) {\\n            console.error(`subscribe failed, code is ${err.code}, message is ${err.message}`);\\n          } else {\\n            // 接收公共事件后事件处理\\n            // doSomeDangerousThing(data)\\n          }\\n        });\\n      } catch (err) {\\n        console.error(`subscribe failed, code is ${err.code}, message is ${err.message}`);\\n      }\\n    } else {\\n      console.error(`createSubscriber failed, code is ${err.code}, message is ${err.message}`);\\n    }\\n  });\\n} catch (err) {\\n  console.error(`createSubscriber failed, code is ${err.code}, message is ${err.message}`);\\n}</pre> </div> <p>常见敏感功能、对外提供的公共事件利用风险，建议涉及这些情况的公共事件设置权限进行保护：</p> <p>1）未经用户操作确认就可执行关键操作，例如：发送短信、拨打电话、拍照、录音、录屏 、截屏、定位等</p> <p>2）导致个人数据、敏感数据泄露的关键操作，例如：读取短信、读取联系人、读取设备标识符等</p> <p>3）导致权限提升，例如：可以进行原本system权限才能进行的操作</p> <p><strong>例外情况：</strong>必须对外提供且无利用风险的应用公共事件，可以不设置权限。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 247,
        "pre": "import { uri } from '@kit.ArkTS';\\nimport { webview } from '@kit.ArkWeb';\\n\\n// 校验函数\\nfunction checkUrl(str: string): boolean {\\n  let tmpUri = new uri.URI(str);\\n  let res = tmpUri.normalize(); // 注意，需要先对tmpUri进行normalize，否则会绕过安全校验  \\n  console.info(\\\"res.scheme:\\\" + res.scheme) // 协议  \\n  console.info(\\\"res.host:\\\" + res.host) // 域名\\n  console.info(\\\"res.port:\\\" + res.port) // 端口  \\n  console.info(\\\"res.path:\\\" + res.path) // 路径 \\n  console.info(\\\"res.ssp:\\\" + res.ssp)   \\n  // 获取到scheme、host、port、path等参数值后，根据业务实际进行安全校验  \\n  // 此处省略部分，根据业务需要进行校验  \\n  if (\\\"校验成功\\\") {\\n    return true;\\n  }\\n  return false\\n}\\n\\n@Entry\\n@Component\\nstruct WebComponent {\\n  controller: webview.WebviewController = new webview.WebviewController();\\n\\n  build() {\\n    Column() {\\n      Button(\\\"loadUrl\\\")\\n        .onClick(() => {\\n          this.controller.loadUrl('www.huawei.com')\\n        })\\n        .margin({ top: 50 })\\n      Web({ src: 'www.huawei.com', controller: this.controller })\\n        .onLoadIntercept((event) => {\\n          console.info('onLoadIntercept:' + event.data.toString())\\n          let tempUrl = event.data.toString()\\n          return checkUrl(tempUrl) // 返回true表示阻止此次加载，否则允许此次加载\\n        })\\n    }\\n  }\\n} ",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]避免加载不安全的URL或页面",
        "parent_text": "[h2]避免加载不安全的URL或页面Web组件或WebController均可以加载URL或页面。如果加载的URL或页面可被攻击者控制，则可加载恶意JS代码，使得恶意代码可以调用ArkTS开放的敏感JS接口，获取用户个人数据，或者对应用进行攻击等。 因此，需要在加载URL之前，通过Web组件的onLoadIntercept方法拦截到要加载的URL，准确获取URL各个字段值，并校验获取的值是否在业务预置的白名单内。 正确示例：  例外：如果应用本身是提供URL加载能力的，譬如浏览器等，可以例外。但是要注意，如果应用也提供了敏感的JS接口，要注意防范可能的被恶意调用的风险。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1113104054110\\\"'><a name='\\\"section1113104054110\\\"'></a><a name='\\\"section1113104054110\\\"'></a><h4>[h2]避免加载不安全的URL或页面</h4><p>Web组件或WebController均可以加载URL或页面。如果加载的URL或页面可被攻击者控制，则可加载恶意JS代码，使得恶意代码可以调用ArkTS开放的敏感JS接口，获取用户个人数据，或者对应用进行攻击等。</p> <p>因此，需要在加载URL之前，通过Web组件的onLoadIntercept方法拦截到要加载的URL，准确获取URL各个字段值，并校验获取的值是否在业务预置的白名单内<strong>。</strong></p> <p><strong>正确示例：</strong></p>  <p><strong>例外：</strong>如果应用本身是提供URL加载能力的，譬如浏览器等，可以例外。但是要注意，如果应用也提供了敏感的JS接口，要注意防范可能的被恶意调用的风险。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 248,
        "pre": "import { webview } from '@kit.ArkWeb';\\n\\n@Entry\\n@Component\\nstruct WebComponent {\\n  controller: webview.WebviewController = new webview.WebviewController();\\n\\n  build() {\\n    Column() {\\n      Web({ src:\\\"www.huawei.com\\\", controller: this.controller })\\n        .mixedMode(MixedMode.All)\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]避免将mixedMode属性配置成All",
        "parent_text": "[h2]避免将mixedMode属性配置成AllmixedMode设置是否允许加载超文本传输协议（HTTP）和超文本传输安全协议（HTTPS）混合内容，默认不允许加载HTTP和HTTPS混合内容。支持三种模式，其中All是允许混合内容加载，存在中间人攻击的风险，默认不允许配置成All。 错误示例：  应该去掉此配置项，或者选择MixedMode.None模式。 例外：对于提供特定业务的应用可以例外，譬如浏览器。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section4947114114317\\\"'><a name='\\\"section4947114114317\\\"'></a><a name='\\\"section4947114114317\\\"'></a><h4>[h2]避免将mixedMode属性配置成All</h4><p>mixedMode设置是否允许加载超文本传输协议（HTTP）和超文本传输安全协议（HTTPS）混合内容，默认不允许加载HTTP和HTTPS混合内容。支持三种模式，其中All是允许混合内容加载，存在中间人攻击的风险，默认不允许配置成All。</p> <p><strong>错误示例：</strong></p>  <p>应该去掉此配置项，或者选择MixedMode.None模式。</p> <p><strong>例外：</strong>对于提供特定业务的应用可以例外，譬如浏览器。</p> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 249,
        "pre": "import { webview } from '@kit.ArkWeb';\\n\\n@Entry\\n@Component\\nstruct WebComponent {\\n  controller: webview.WebviewController = new webview.WebviewController()\\n  build() {\\n    Column() {\\n      Web({ src: 'www.example.com', controller: this.controller })\\n        .onSslErrorEventReceive((event) => {\\n          console.info('ssl check failed,error is : ' + event.error.toString())\\n          event.handler.handleCancel();\\n        })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "handleConfirm()",
        "function_name": "[h2]避免在SSL校验出错时继续加载页面",
        "parent_text": "[h2]避免在SSL校验出错时继续加载页面onSslErrorEventReceive回调函数用于通知用户加载资源时发生SSL错误。 当Web组件通过SSL协议进行网络请求时，底层Web组件校验服务端返回的证书或者协议等错误时，默认情况下要cancel请求，否则存在中间人攻击风险。  错误示例： import { webview } from '@kit.ArkWeb';\\n\\n@Entry\\n@Component\\nstruct WebComponent {\\n  controller: webview.WebviewController = new webview.WebviewController()\\n\\n  build() {\\n    Column() {\\n      Web({ src: 'www.example.com', controller: this.controller })\\n        .onSslErrorEventReceive((event) => {\\n          event.handler.handleConfirm();\\n        })\\n    }\\n  }\\n} 如果在SSL校验出错时，直接调用handleConfirm函数，则页面会忽略SSL错误继续加载，会导致中间人攻击等风险。 例外：对于浏览器等用于加载URL的应用可以例外，但是也需要在页面显式告知用户待加载页面存在安全风险。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1256314434316\\\"'><a name='\\\"section1256314434316\\\"'></a><a name='\\\"section1256314434316\\\"'></a><h4>[h2]避免在SSL校验出错时继续加载页面</h4><p>onSslErrorEventReceive回调函数用于通知用户加载资源时发生SSL错误。</p> <p>当Web组件通过SSL协议进行网络请求时，底层Web组件校验服务端返回的证书或者协议等错误时，默认情况下要cancel请求，否则存在中间人攻击风险。</p>  <p><strong>错误示例：</strong></p> <pre class='\\\"screen\\\"'>import { webview } from '@kit.ArkWeb';\\n\\n@Entry\\n@Component\\nstruct WebComponent {\\n  controller: webview.WebviewController = new webview.WebviewController()\\n\\n  build() {\\n    Column() {\\n      Web({ src: 'www.example.com', controller: this.controller })\\n        .onSslErrorEventReceive((event) =&gt; {\\n          event.handler.handleConfirm();\\n        })\\n    }\\n  }\\n}</pre> <p>如果在SSL校验出错时，直接调用handleConfirm函数，则页面会忽略SSL错误继续加载，会导致中间人攻击等风险。</p> <p><strong>例外：</strong>对于浏览器等用于加载URL的应用可以例外，但是也需要在页面显式告知用户待加载页面存在安全风险。</p> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 250,
        "pre": "import { webview } from '@kit.ArkWeb';\\n\\n@Entry\\n@Component\\nstruct WebComponent {\\n  controller: webview.WebviewController = new webview.WebviewController()\\n\\n  build() {\\n    Column() {\\n      Web({ src: 'www.example.com', controller: this.controller })\\n        .geolocationAccess(true)\\n        .onGeolocationShow((event) => {\\n          if (event === undefined) {\\n            return\\n          }\\n          AlertDialog.show({\\n            title: 'title',\\n            message: 'text',\\n            confirm: {\\n              value: 'onConfirm',\\n              action: () => {\\n                event.geolocation.invoke(event.origin, true, true);\\n              }\\n            },\\n            cancel: () => {\\n              event.geolocation.invoke(event.origin, false, true);\\n            }\\n          })\\n        })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]避免在用户同意前返回位置信息",
        "parent_text": "[h2]避免在用户同意前返回位置信息geolocationAccess开关用于配置是否开启地理位置权限，默认开启。onGeolocationShow回调函数用于通知用户收到地理位置信息获取请求。H5页面请求获取地理位置信息时，Web组件通过上述两个API进行配置。 无使用场景时，需要显式禁用geolocationAccess。存在使用场景时，需要在onGeolocationShow回调内先弹框提示用户，并经过用户确认和同意才可以返回位置信息，否则存在隐私泄露风险。  错误示例： import { webview } from '@kit.ArkWeb';\\n\\n@Entry\\n@Component\\nstruct WebComponent {\\n  controller: webview.WebviewController = new webview.WebviewController()\\n\\n  build() {\\n    Column() {\\n      Web({ src: 'www.example.com', controller: this.controller })\\n        .geolocationAccess(true)\\n        .onGeolocationShow((event) => {\\n          if (event === undefined) {\\n            return\\n          }\\n          event.geolocation.invoke(event.origin, true, true);\\n        })\\n    }\\n  }\\n} 在有位置权限的使用场景时，不能直接返回位置信息。需要明示给用户且用户同意后，方可返回。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12671987440\\\"'><a name='\\\"section12671987440\\\"'></a><a name='\\\"section12671987440\\\"'></a><h4>[h2]避免在用户同意前返回位置信息</h4><p>geolocationAccess开关用于配置是否开启地理位置权限，默认开启。onGeolocationShow回调函数用于通知用户收到地理位置信息获取请求。H5页面请求获取地理位置信息时，Web组件通过上述两个API进行配置。</p> <p>无使用场景时，需要显式禁用geolocationAccess。存在使用场景时，需要在onGeolocationShow回调内先弹框提示用户，并经过用户确认和同意才可以返回位置信息，否则存在隐私泄露风险。</p>  <p><strong>错误示例：</strong></p> <pre class='\\\"screen\\\"'>import { webview } from '@kit.ArkWeb';\\n\\n@Entry\\n@Component\\nstruct WebComponent {\\n  controller: webview.WebviewController = new webview.WebviewController()\\n\\n  build() {\\n    Column() {\\n      Web({ src: 'www.example.com', controller: this.controller })\\n        .geolocationAccess(true)\\n        .onGeolocationShow((event) =&gt; {\\n          if (event === undefined) {\\n            return\\n          }\\n          event.geolocation.invoke(event.origin, true, true);\\n        })\\n    }\\n  }\\n}</pre> <p>在有位置权限的使用场景时，不能直接返回位置信息。需要明示给用户且用户同意后，方可返回。</p> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 251,
        "pre": "import { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { UIAbility, Want, AbilityConstant } from '@kit.AbilityKit';\\n\\n// 校验函数\\nfunction checkWant(want: Want) {\\n  if (want === null || want.parameters === null\\n    || want === undefined || want.parameters === undefined) {\\n    return false;\\n  }\\n  return true;\\n}\\n\\nexport default class EntryAbility extends UIAbility {\\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\\n    if (checkWant(want)) {\\n      console.info(\\\"invalid want\\\");\\n    } else {\\n      console.info(\\\"correct want\\\");\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "1.  使用Want的数据属性前判null，判undefined，确保访问的对象属性存在。 ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>1.  使用Want的数据属性前判null，判undefined，确保访问的对象属性存在。 </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 252,
        "pre": "import { BusinessError } from '@kit.BasicServicesKit';\\n\\nimport { relationalStore } from '@kit.ArkData'\\n\\n// sql参数来自外部输入\\nfunction exesql(sql: string) {\\n  const STORE_CONFIG: relationalStore.StoreConfig = {\\n    name: \\\"RdbTest.db\\\",\\n    securityLevel: relationalStore.SecurityLevel.S1\\n  };\\n  let store: relationalStore.RdbStore | undefined = undefined;\\n  relationalStore.getRdbStore(this.context, STORE_CONFIG, (err: BusinessError, rdbStore: relationalStore.RdbStore) => {\\n    store = rdbStore;\\n    if (err) {\\n      console.error(`Get RdbStore failed, code is ${err.code},message is ${err.message}`);\\n      return;\\n    }\\n    console.info('Get RdbStore successfully.');\\n  })\\n  // 使用外部输入直接拼接sql语句，未校验\\n  let SQL_DELETE_TABLE = \\\"DELETE FROM test WHERE name = \\\" + sql;\\n  if (store != undefined) {\\n    (store as relationalStore.RdbStore).executeSql(SQL_DELETE_TABLE, (err) => {\\n      if (err) {\\n        console.error(`ExecuteSql failed, code is ${err.code},message is ${err.message}`);\\n        return;\\n      }\\n      console.info('Delete table done.');\\n    })\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]避免直接使用不可信数据来拼接SQL语句",
        "parent_text": "[h2]避免直接使用不可信数据来拼接SQL语句SQL注入是指对用户输入数据的合法性没有判断或过滤不严，攻击者可以传入特定内容将应用事先定义好的语句变成含义完全不同的SQL语句，导致信息泄露或者数据篡改。 任何外部的输入包括用户的输入都是不安全的，需要对外部输入的数据进行过滤处理。 HarmonyOS系统提供的关系型数据库是一款基于SQLite组件的数据库，可以直接运行用户输入的SQL语句。如果不可信的数据会被用于拼接SQL语句，就存在SQL注入的风险。应该使用参数化查询的方式或者对不可信内容做过滤。 HarmonyOS上querySql、executeSql会被用于拼接SQL语句的执行。 示例中的context的获取方式请参见获取UIAbility的上下文信息。 错误示例：  如果直接使用用户输入作为查询的参数，恶意用户可以输入类似 1' OR 'a' = 'a 的字符串，使sql语句拼接变成select *from book where name='1' OR 'a' = 'a'，从而导致SQL注入攻击。因此禁止直接使用外部输入作为查询字符串的一部分，或者在拼接SQL语句之前，对外部输入进行字符输入校验。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1927111334714\\\"'><a name='\\\"section1927111334714\\\"'></a><a name='\\\"section1927111334714\\\"'></a><h4>[h2]避免直接使用不可信数据来拼接SQL语句</h4><p>SQL注入是指对用户输入数据的合法性没有判断或过滤不严，攻击者可以传入特定内容将应用事先定义好的语句变成含义完全不同的SQL语句，导致信息泄露或者数据篡改。</p> <p>任何外部的输入包括用户的输入都是不安全的，需要对外部输入的数据进行过滤处理。</p> <p>HarmonyOS系统提供的关系型数据库是一款基于SQLite组件的数据库，可以直接运行用户输入的SQL语句。如果不可信的数据会被用于拼接SQL语句，就存在SQL注入的风险。应该使用参数化查询的方式或者对不可信内容做过滤。</p> <p>HarmonyOS上querySql、executeSql会被用于拼接SQL语句的执行。</p> <p>示例中的context的获取方式请参见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-usage#获取uiability的上下文信息\\\"' target='\\\"_blank\\\"'>获取UIAbility的上下文信息</a>。</p> <div class='\\\"p\\\"'><strong>错误示例：</strong> </div> <p>如果直接使用用户输入作为查询的参数，恶意用户可以输入类似 1' OR 'a' = 'a 的字符串，使sql语句拼接变成select *from book where name='1' OR 'a' = 'a'，从而导致SQL注入攻击。因此禁止直接使用外部输入作为查询字符串的一部分，或者在拼接SQL语句之前，对外部输入进行字符输入校验。</p> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 253,
        "pre": "// fileName来自外部\\nfunction readFile(fileName: string) {\\n  let filePath = \\\"/data/storage/\\\";\\n  if (fileName.indexOf(\\\"..\\\") === -1) { // 防拼接校验  \\n    let fileAllPath: string = filePath + fileName\\n    // 业务处理  \\n  } else {\\n    console.info(\\\"be attacked\\\")\\n    return\\n  }\\n}  ",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]避免使用未校验的外部数据拼接文件路径",
        "parent_text": "[h2]避免使用未校验的外部数据拼接文件路径HarmonyOS系统对文件存储进行了沙箱隔离，内部存储的文件只有应用程序有权限读取，且只能读取本应用内部存储目录；而对外部共享存储进行读取，则需要添加读取权限 在对文件进行读、写、下载、删除等操作时，如果使用了外部输入来拼接文件路径，攻击者可以注入../等恶意字符进行跨目录攻击，可导致数据泄露、应用拒绝服务等安全问题。因此在拼接路径之前，需要校验不可信数据是否包含了恶意的攻击字符。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1798510289507\\\"'><a name='\\\"section1798510289507\\\"'></a><a name='\\\"section1798510289507\\\"'></a><h4>[h2]避免使用未校验的外部数据拼接文件路径</h4><p>HarmonyOS系统对文件存储进行了沙箱隔离，内部存储的文件只有应用程序有权限读取，且只能读取本应用内部存储目录；而对外部共享存储进行读取，则需要添加读取权限</p> <p>在对文件进行读、写、下载、删除等操作时，如果使用了外部输入来拼接文件路径，攻击者可以注入../等恶意字符进行跨目录攻击，可导致数据泄露、应用拒绝服务等安全问题。因此在拼接路径之前，需要校验不可信数据是否包含了恶意的攻击字符。</p>  <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 254,
        "pre": "// app.json5   \\n{  \\n    \\\"app\\\": {  \\n        \\\"bundleName\\\": \\\"com.application.music\\\",  \\n        \\\"vendor\\\": \\\"application\\\",  \\n        \\\"versionCode\\\": 1,  \\n        \\\"versionName\\\": \\\"1.0\\\",  \\n        \\\"minCompatibleVersionCode\\\": 1,  \\n        \\\"minAPIVersion\\\": 7,  \\n        \\\"targetAPIVersion\\\": 8,  \\n        \\\"apiReleaseType\\\": \\\"Release\\\",  \\n        \\\"debug\\\": true, // debug字段设置 \\n        \\\"icon\\\": \\\"$media:app_icon\\\",  \\n        \\\"label\\\": \\\"$string:app_name\\\",  \\n        \\\"description\\\": \\\"$string:description_application\\\",  \\n        \\\"distributedNotificationEnabled\\\": true,  \\n        \\\"entityType\\\": \\\"game\\\",  \\n        \\\"car\\\": {  \\n            \\\"apiCompatibleVersion\\\": 8  \\n        }  \\n    }  \\n} ",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]建议正确设置发布版本应用调试属性",
        "parent_text": "[h2]建议正确设置发布版本应用调试属性\\\"debug\\\"属性是为了方便开发人员对应用进行调试，但对于正式发布版本，如果应用设置为可调式模式，方便了攻击者对应用进行更深入的分析调试，不利于对应用的保护，因此要求正式版本须设置为不可调试模式。 对\\\"debug\\\"的设置需要在app.json5文件中进行配置。其中\\\"debug\\\"属性缺省值为false。 错误示例：  正确示例： // app.json5   \\n{  \\n    \\\"app\\\": {  \\n        \\\"bundleName\\\": \\\"com.application.music\\\",  \\n        \\\"vendor\\\": \\\"application\\\",  \\n        \\\"versionCode\\\": 1,  \\n        \\\"versionName\\\": \\\"1.0\\\",  \\n        \\\"minCompatibleVersionCode\\\": 1,  \\n        \\\"minAPIVersion\\\": 7,  \\n        \\\"targetAPIVersion\\\": 8,  \\n        \\\"apiReleaseType\\\": \\\"Release\\\",  \\n        \\\"debug\\\": false,  \\n        \\\"icon\\\": \\\"$media:app_icon\\\",  \\n        \\\"label\\\": \\\"$string:app_name\\\",  \\n        \\\"description\\\": \\\"$string:description_application\\\",  \\n        \\\"distributedNotificationEnabled\\\": true,  \\n        \\\"entityType\\\": \\\"game\\\",  \\n        \\\"car\\\": {  \\n            \\\"apiCompatibleVersion\\\": 8  \\n        }  \\n    }  \\n}    ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section469175205113\\\"'><a name='\\\"section469175205113\\\"'></a><a name='\\\"section469175205113\\\"'></a><h4>[h2]建议正确设置发布版本应用调试属性</h4><p>\\\"debug\\\"属性是为了方便开发人员对应用进行调试，但对于正式发布版本，如果应用设置为可调式模式，方便了攻击者对应用进行更深入的分析调试，不利于对应用的保护，因此要求正式版本须设置为不可调试模式。</p> <p>对\\\"debug\\\"的设置需要在app.json5文件中进行配置。其中\\\"debug\\\"属性缺省值为false。</p> <p><strong>错误示例：</strong></p>  <p><strong>正确示例：</strong></p> <pre class='\\\"screen\\\"'>// app.json5   \\n{  \\n    \\\"app\\\": {  \\n        \\\"bundleName\\\": \\\"com.application.music\\\",  \\n        \\\"vendor\\\": \\\"application\\\",  \\n        \\\"versionCode\\\": 1,  \\n        \\\"versionName\\\": \\\"1.0\\\",  \\n        \\\"minCompatibleVersionCode\\\": 1,  \\n        \\\"minAPIVersion\\\": 7,  \\n        \\\"targetAPIVersion\\\": 8,  \\n        \\\"apiReleaseType\\\": \\\"Release\\\",  \\n        <span rgb(255,0,0);\\\"=\"\" style='\\\"color:'>\\\"debug\\\": false,</span>  \\n        \\\"icon\\\": \\\"$media:app_icon\\\",  \\n        \\\"label\\\": \\\"$string:app_name\\\",  \\n        \\\"description\\\": \\\"$string:description_application\\\",  \\n        \\\"distributedNotificationEnabled\\\": true,  \\n        \\\"entityType\\\": \\\"game\\\",  \\n        \\\"car\\\": {  \\n            \\\"apiCompatibleVersion\\\": 8  \\n        }  \\n    }  \\n}  </pre> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-harmony-application-security.html"
    },
    {
        "id": 255,
        "pre": "// products\\\\phone\\\\src\\\\main\\\\ets\\\\pages\\\\MainPage.ets\\n\\nTabs({ index: this.currentIndex }) {\\n  // ...\\n}\\n.layoutWeight(1)\\n.barHeight(0)\\n.scrollable(false)\\n.onChange((index) => {\\n  this.currentIndex = index;\\n  ContinueModel.getInstance().data.mainTabIndex = index;\\n  if (AppStorage.get('audioPlayerStatus') !== AudioPlayerStatus.IDLE) {\\n    AudioPlayerService.getInstance().stop().then(() => {\\n      AudioPlayerService.destroy();\\n    });\\n  }\\n})",
        "type": "Reference",
        "function_call": "static instanceIsNotNull(): boolean",
        "function_name": "[h2]ArkTS Callstack泳道分析ArkTS侧耗时函数",
        "parent_text": "[h2]ArkTS Callstack泳道分析ArkTS侧耗时函数ArkTS Callstack子泳道ArkVM是需要优先查看耗时情况的泳道，可以看到ArkTS侧一些方法的耗时,优先分析耗时最长的调用栈（program除外，program代表程序执行进入纯Native代码阶段，该阶段无Ark TS代码执行，也无Ark TS调用Native或者Native调用Ark TS情况，需要切换到Callstack泳道看具体的调用栈信息，一般很难通过这里分析出有效的信息），逐级展开,可以看到具体耗时的文件。基于 “HMOS世界”切换tab页场景，抓取Trace信息。 图6 ArkTS Callstack泳道图 观察发现MainPage文件中匿名函数耗时350ms，展开该节点。 图7 ArkTS Callstack泳道耗时函数详情 展开节点后发现函数调用链中AudioPlayerService中getInstance函数调用耗时327ms，接下来定位源代码。  AudioPlayerService.ets相关代码如下 // commons\\\\audioplayer\\\\src\\\\main\\\\ets\\\\service\\\\AudioPlayerService.ets\\n\\nexport class AudioPlayerService {\\n  private static instance: AudioPlayerService | null = null;\\n  // ...\\n\\n  public static getInstance(): AudioPlayerService {\\n    if (!AudioPlayerService.instance) {\\n      AudioPlayerService.instance = new AudioPlayerService();\\n    }\\n    return AudioPlayerService.instance;\\n  }\\n\\n  public static destroy() {\\n    AudioPlayerService.getInstance().releaseAudioPlayer();\\n    AudioPlayerService.instance = null;\\n  }\\n  // ...\\n} 观察源代码发现AudioPlayerService调用getInstance创建单例对象耗费大量时间，随即又调用destroy方法销毁对象。优化方式如下：获取单例对象前，先判断单例对象是否被实例化，若没有实例化则直接跳过获取与销毁，避免实例对象的无效创建与销毁，参考如下代码。 // products\\\\phone\\\\src\\\\main\\\\ets\\\\pages\\\\MainPage.ets\\n\\nTabs({ index: this.currentIndex }) {\\n  // ...\\n}\\n.layoutWeight(1)\\n.barHeight(0)\\n.scrollable(false)\\n.onChange((index) => {\\n  this.currentIndex = index;\\n  ContinueModel.getInstance().data.mainTabIndex = index;\\n  if (AppStorage.get('audioPlayerStatus') !== AudioPlayerStatus.IDLE &&\\n  AudioPlayerService.instanceIsNotNull()) {\\n    AudioPlayerService.getInstance().stop().then(() => {\\n      AudioPlayerService.destroy();\\n    });\\n  }\\n}) 优化后AudioPlayerService.ets代码如下： // commons\\\\audioplayer\\\\src\\\\main\\\\ets\\\\service\\\\AudioPlayerService.ets\\n\\nexport class AudioPlayerService {\\n  private static instance: AudioPlayerService | null = null;\\n  // ...\\n\\n  public static getInstance(): AudioPlayerService {\\n    if (!AudioPlayerService.instance) {\\n      AudioPlayerService.instance = new AudioPlayerService();\\n    }\\n    return AudioPlayerService.instance;\\n  }\\n\\n  public static destroy() {\\n    AudioPlayerService.getInstance().releaseAudioPlayer();\\n    AudioPlayerService.instance = null;\\n  }\\n\\n  public static instanceIsNotNull(): boolean {\\n    return AudioPlayerService.instance !== null;\\n  }\\n  // ...\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section11133935155810\\\"'><a name='\\\"section11133935155810\\\"'></a><a name='\\\"section11133935155810\\\"'></a><h4>[h2]ArkTS Callstack泳道分析ArkTS侧耗时函数</h4><p>ArkTS Callstack子泳道ArkVM是需要优先查看耗时情况的泳道，可以看到ArkTS侧一些方法的耗时,优先分析耗时最长的调用栈（program除外，program代表程序执行进入纯Native代码阶段，该阶段无Ark TS代码执行，也无Ark TS调用Native或者Native调用Ark TS情况，需要切换到Callstack泳道看具体的调用栈信息，一般很难通过这里分析出有效的信息），逐级展开,可以看到具体耗时的文件。基于 <a href='\\\"https://gitee.com/harmonyos_samples/hmosworld\\\"' target='\\\"_blank\\\"'>“HMOS世界”</a>切换tab页场景，抓取Trace信息。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图6 </b>ArkTS Callstack泳道图</span><br/><span><img height='\\\"381.01840000000004\\\"' originheight='\\\"549\\\"' originwidth='\\\"1533\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161158.52361402211976647174407344570771:50001231000000:2800:61BD8E49B4AAF2279B87FEB298BBC27AE712752C0E6B6DA944FA93D03B4AFD1B.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></div> <p>观察发现MainPage文件中匿名函数耗时350ms，展开该节点。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图7 </b>ArkTS Callstack泳道耗时函数详情</span><br/><span><img height='\\\"571.5143\\\"' originheight='\\\"838\\\"' originwidth='\\\"1556\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161158.88499718995357940621839709259177:50001231000000:2800:F95929D3C5F9B9EBAA4B7130AF9A6D669BF5CED9A57E89CAB9CC46A8F40F6883.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></div> <p>展开节点后发现函数调用链中AudioPlayerService中getInstance函数调用耗时327ms，接下来定位源代码。</p>  <p>AudioPlayerService.ets相关代码如下</p> <pre class='\\\"screen\\\"'>// commons\\\\audioplayer\\\\src\\\\main\\\\ets\\\\service\\\\AudioPlayerService.ets\\n\\nexport class AudioPlayerService {\\n  private static instance: AudioPlayerService | null = null;\\n  // ...\\n\\n  public static getInstance(): AudioPlayerService {\\n    if (!AudioPlayerService.instance) {\\n      AudioPlayerService.instance = new AudioPlayerService();\\n    }\\n    return AudioPlayerService.instance;\\n  }\\n\\n  public static destroy() {\\n    AudioPlayerService.getInstance().releaseAudioPlayer();\\n    AudioPlayerService.instance = null;\\n  }\\n  // ...\\n}</pre> <p>观察源代码发现AudioPlayerService调用getInstance创建单例对象耗费大量时间，随即又调用destroy方法销毁对象。优化方式如下：获取单例对象前，先判断单例对象是否被实例化，若没有实例化则直接跳过获取与销毁，避免实例对象的无效创建与销毁，参考如下代码。</p> <pre class='\\\"screen\\\"'>// products\\\\phone\\\\src\\\\main\\\\ets\\\\pages\\\\MainPage.ets\\n\\nTabs({ index: this.currentIndex }) {\\n  // ...\\n}\\n.layoutWeight(1)\\n.barHeight(0)\\n.scrollable(false)\\n.onChange((index) =&gt; {\\n  this.currentIndex = index;\\n  ContinueModel.getInstance().data.mainTabIndex = index;\\n  if (AppStorage.get('audioPlayerStatus') !== AudioPlayerStatus.IDLE &amp;&amp;\\n  AudioPlayerService.instanceIsNotNull()) {\\n    AudioPlayerService.getInstance().stop().then(() =&gt; {\\n      AudioPlayerService.destroy();\\n    });\\n  }\\n})</pre> <p>优化后AudioPlayerService.ets代码如下：</p> <pre class='\\\"screen\\\"'>// commons\\\\audioplayer\\\\src\\\\main\\\\ets\\\\service\\\\AudioPlayerService.ets\\n\\nexport class AudioPlayerService {\\n  private static instance: AudioPlayerService | null = null;\\n  // ...\\n\\n  public static getInstance(): AudioPlayerService {\\n    if (!AudioPlayerService.instance) {\\n      AudioPlayerService.instance = new AudioPlayerService();\\n    }\\n    return AudioPlayerService.instance;\\n  }\\n\\n  public static destroy() {\\n    AudioPlayerService.getInstance().releaseAudioPlayer();\\n    AudioPlayerService.instance = null;\\n  }\\n\\n  public static instanceIsNotNull(): boolean {\\n    return AudioPlayerService.instance !== null;\\n  }\\n  // ...\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-click-to-complete-delay-analysis.html"
    },
    {
        "id": 256,
        "pre": "@Entry\\n@Component\\nstruct TabsPositiveExample {\\n  @State currentIndex: number = 0;\\n  private controller: TabsController = new TabsController();\\n  private list: string[] = ['green', 'blue', 'yellow', 'pink'];\\n\\n  @Builder\\n  customContent(color: Color) {\\n    Column()\\n      .width('100%')\\n      .height('100%')\\n      .backgroundColor(color)\\n  }\\n\\n  build() {\\n    Column() {\\n      Row({ space: 10 }) {\\n        ForEach(this.list, (item: string, index: number) => {\\n          Text(item)\\n            .textAlign(TextAlign.Center)\\n            .fontSize(16)\\n            .height(32)\\n            .layoutWeight(1)\\n            .fontColor(this.currentIndex === index ? Color.White : Color.Black)\\n            .backgroundColor(this.currentIndex === index ? Color.Blue : '#f2f2f2')\\n            .borderRadius(16)\\n            .onClick(() => {\\n              this.currentIndex = index;\\n              this.controller.changeIndex(index);\\n            })\\n        }, (item: string, index: number) => JSON.stringify(item) + index)\\n      }\\n      .margin(10)\\n\\n      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) {\\n        TabContent() {\\n          this.customContent(Color.Green)\\n        }\\n\\n        TabContent() {\\n          this.customContent(Color.Blue)\\n        }\\n\\n        TabContent() {\\n          this.customContent(Color.Yellow)\\n        }\\n\\n        TabContent() {\\n          this.customContent(Color.Pink)\\n        }\\n      }\\n      .animationDuration(100)\\n      .layoutWeight(1)\\n      .barHeight(0)\\n      .scrollable(false)\\n    }\\n    .width('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]动画时延耗时",
        "parent_text": "[h2]动画时延耗时页面的转场动画是提升用户体验的重要环节。然而，当动画时延耗时较长时，它会对用户的点击完成时延产生显著影响。动画的完成时间直接关系到用户何时能够开始与应用进行交互。动画时延影响点击完成时延的根因主要为动画时长设置过长。 常见的页面转场动画时长参数有： Tabs组件设置TabContent切换动画时长，即animationDuration属性。Swiper组件设置子组件切换动画时长，即duration属性。页面间转场（pageTransition）设置转场动画时长，即PageTransitionOptions对象中的duration字段。 使用Tabs组件进行页面切换时，当不设置BottomTabBarStyle时默认animationDuration属性有300ms的动画时长，当该属性值设置过长时会导致完成时延变大。接下来将该属性值分别设置为100ms与1000ms来探究animationDuration属性对完成时延的影响。 实验一：设置animationDuration为100ms   实验二：设置animationDuration为1000ms@Entry\\n@Component\\nstruct TabsNegativeExample {\\n  // ...\\n  private controller: TabsController = new TabsController();\\n\\n  // ...\\n\\n  build() {\\n    Column() {\\n      // ...\\n\\n      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) {\\n        // ...\\n\\n      }\\n      .barHeight(0)\\n      .layoutWeight(1)\\n      .animationDuration(1000)\\n      .scrollable(false)\\n    }\\n    .width('100%')\\n  }\\n}   表1 运行效果图设置animationDuration为100ms  设置animationDuration为1000ms           表2 animationDuration属性值对比animationDuration属性值  完成时延    100ms  99ms39μs   1000ms  1s7ms693μs     上述示例通过减少animationDuration属性的数值，减小了Tabs组件切换动画的完成时延。当不设置BottomTabBarStyle样式时，动画时长默认为300ms，开发者可根据实际业务场景需要适当降低该动画时长，提高应用性能。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section486611519017\\\"'><a name='\\\"section486611519017\\\"'></a><a name='\\\"section486611519017\\\"'></a><h4>[h2]动画时延耗时</h4><p>页面的转场动画是提升用户体验的重要环节。然而，当动画时延耗时较长时，它会对用户的点击完成时延产生显著影响。动画的完成时间直接关系到用户何时能够开始与应用进行交互。动画时延影响点击完成时延的根因主要为动画时长设置过长。</p> <p>常见的页面转场动画时长参数有：</p> <ol><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs\\\"' target='\\\"_blank\\\"'>Tabs</a>组件设置TabContent切换动画时长，即<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs#animationduration\\\"' target='\\\"_blank\\\"'>animationDuration</a>属性。</li><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper\\\"' target='\\\"_blank\\\"'>Swiper</a>组件设置子组件切换动画时长，即<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#duration\\\"' target='\\\"_blank\\\"'>duration</a>属性。</li><li>页面间转场（<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-page-transition-animation\\\"' target='\\\"_blank\\\"'>pageTransition</a>）设置转场动画时长，即<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-page-transition-animation#pagetransitionoptions对象说明\\\"' target='\\\"_blank\\\"'>PageTransitionOptions</a>对象中的duration字段。</li></ol> <p>使用Tabs组件进行页面切换时，当不设置BottomTabBarStyle时默认<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs#animationduration\\\"' target='\\\"_blank\\\"'>animationDuration</a>属性有300ms的动画时长，当该属性值设置过长时会导致完成时延变大。接下来将该属性值分别设置为100ms与1000ms来探究animationDuration属性对完成时延的影响。</p> <p>实验一：设置animationDuration为100ms</p>  <p><span><img height='\\\"447.9041\\\"' originheight='\\\"924\\\"' originwidth='\\\"2195\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161159.23108473430703934006588115042384:50001231000000:2800:485CE1EB2A750844D93B8A0363996756C135729834C5A2315ACBDFE1CD57CE92.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></p> <div class='\\\"p\\\"'>实验二：设置animationDuration为1000ms<pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct TabsNegativeExample {\\n  // ...\\n  private controller: TabsController = new TabsController();\\n\\n  // ...\\n\\n  build() {\\n    Column() {\\n      // ...\\n\\n      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) {\\n        // ...\\n\\n      }\\n      .barHeight(0)\\n      .layoutWeight(1)\\n      .animationDuration(1000)\\n      .scrollable(false)\\n    }\\n    .width('100%')\\n  }\\n}</pre> </div> <p><span><img height='\\\"448.10360000000003\\\"' originheight='\\\"924\\\"' originwidth='\\\"2194\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161159.14554503481465453160553555268657:50001231000000:2800:E9F4777C854EDDBC0C3656E1C37721B815D296CA6F3F9FBF042D1CBB1D8486F4.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表1 </b>运行效果图</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.11.2.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>设置animationDuration为100ms</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.11.2.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>设置animationDuration为1000ms</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p><span><img height='\\\"551.806094\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161159.57601189892455698829407907038461:50001231000000:2800:E24E5D0898DB778D8FC396B9C12BD0B8BBD80843BBCD04ECAF1C3B10A8276C19.gif\\\"' title='\\\"点击放大\\\"' width='\\\"272.3175\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p><span><img height='\\\"565.9176600000001\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161159.60941848956093973355710035364081:50001231000000:2800:1C058B69209F5781D334C8F471DA7C174AC10D130B9696148D2701B27DA74B6D.gif\\\"' title='\\\"点击放大\\\"' width='\\\"275.31\\\"'/></span></p> </td> </tr> </tbody></table> </div> <div class='\\\"tablenoborder\\\"'><table><caption><b>表2 </b>animationDuration属性值对比</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.12.2.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>animationDuration属性值</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.17.12.2.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>完成时延</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>100ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>99ms39μs</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>1000ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>1s7ms693μs</p> </td> </tr> </tbody></table> </div> <p>上述示例通过减少animationDuration属性的数值，减小了Tabs组件切换动画的完成时延。当不设置BottomTabBarStyle样式时，动画时长默认为300ms，开发者可根据实际业务场景需要适当降低该动画时长，提高应用性能。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-click-to-complete-delay-analysis.html"
    },
    {
        "id": 257,
        "pre": "{\\n  \\\"insightIntents\\\": [\\n    {\\n      \\\"intentName\\\": \\\"PlayMusic\\\",\\n      \\\"domain\\\": \\\"MusicDomain\\\",\\n      \\\"intentVersion\\\": \\\"1.0.1\\\",\\n      \\\"srcEntry\\\": \\\"./ets/entryability/InsightIntentExecutorImpl.ets\\\",\\n      \\\"uiAbility\\\": {\\n        \\\"ability\\\": \\\"EntryAbility\\\",\\n        \\\"executeMode\\\": [\\n          \\\"background\\\",\\n          \\\"foreground\\\"\\n        ]\\n      }\\n    },\\n    {\\n      \\\"intentName\\\": \\\"PlayMusicList\\\",\\n      \\\"domain\\\": \\\"MusicDomain\\\",\\n      \\\"intentVersion\\\": \\\"1.0.1\\\",\\n      \\\"srcEntry\\\": \\\"./ets/entryability/InsightIntentExecutorImpl.ets\\\",\\n      \\\"uiAbility\\\": {\\n        \\\"ability\\\": \\\"EntryAbility\\\",\\n        \\\"executeMode\\\": [\\n          \\\"background\\\",\\n          \\\"foreground\\\"\\n        ]\\n      }\\n    }\\n  ]\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在应用工程中新增PROJECT_HOME/entry/src/main/resources/base/profile/insight_intent.json文件注册意图，指定意图名称和所属垂域，并且指定一个意图调用逻辑入口。比如在本示例中将调用逻辑放在了EntryAbility下的InsightIntentExecutorImpl文件中。 ",
        "import_module": null,
        "parent": "<li>在应用工程中新增PROJECT_HOME/entry/src/main/resources/base/profile/insight_intent.json文件注册意图，指定意图名称和所属垂域，并且指定一个意图调用逻辑入口。比如在本示例中将调用逻辑放在了EntryAbility下的InsightIntentExecutorImpl文件中。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-intent-recommend-practice.html"
    },
    {
        "id": 258,
        "pre": "// Key point: Reuse custom video playback components by using the @Reusable decorator.\\n@Reusable\\n@Component\\nexport struct VideoPlayView {\\n  @Prop @Watch('onIndexChange') curIndex: number = -1;",
        "type": "Reference",
        "function_call": "initAVPlayer()",
        "function_name": null,
        "parent_text": "通过组件复用的形式实现单个视频播放的自定义组件VideoPlayView。 在自定义组件VideoPlayView中设置XComponent组件用于视频流渲染，获取并设置SurfaceID用于设置显示画面。在onLoad时异步创建并初始化AVPlayer播放器使其提前进入prepared状态以实现视频的异步预加载。  XComponent({\\n    id: 'player',\\n    type: XComponentType.SURFACE,\\n    controller: this.xComponentController\\n  })\\n  .width(this.XComponentWidth)\\n  .height(this.XComponentHeight)\\n  .onLoad(async () => {\\n\\tthis.surfaceID = this.xComponentController.getXComponentSurfaceId();\\n\\thilog.info(0x0000, TAG,\\n\\t  `surfaceID: ${this.surfaceID}, curIndex: ${this.curIndex}, index: ${this.index}.`);\\n\\t// Key point: Initialize the AVPlayer asynchronously so that the AVPlayer enters the prepared state in advance to implement asynchronous video preloading.\\n\\tthis.initAVPlayer();\\n  }) ",
        "import_module": null,
        "parent": "<li>通过组件复用的形式实现单个视频播放的自定义组件VideoPlayView。 <p>在自定义组件VideoPlayView中设置XComponent组件用于视频流渲染，获取并设置SurfaceID用于设置显示画面。在onLoad时异步创建并初始化AVPlayer播放器使其提前进入prepared状态以实现视频的异步预加载。</p> <pre class='\\\"screen\\\"'> XComponent({\\n    id: 'player',\\n    type: XComponentType.SURFACE,\\n    controller: this.xComponentController\\n  })\\n  .width(this.XComponentWidth)\\n  .height(this.XComponentHeight)\\n  .onLoad(async () =&gt; {\\n\\tthis.surfaceID = this.xComponentController.getXComponentSurfaceId();\\n\\thilog.info(0x0000, TAG,\\n\\t  `surfaceID: ${this.surfaceID}, curIndex: ${this.curIndex}, index: ${this.index}.`);\\n\\t// Key point: Initialize the AVPlayer asynchronously so that the AVPlayer enters the prepared state in advance to implement asynchronous video preloading.\\n\\tthis.initAVPlayer();\\n  })</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-smooth-switching.html"
    },
    {
        "id": 259,
        "pre": "Swiper(this.swiperController) {\\n  LazyForEach(this.data, (item: PhotoData, index: number) => {\\n    Image($r(`app.media.` + item.id))\\n      .width(this.foldStatus === 2 ? '100%' : '70%')\\n      .height('100%')\\n  }, (item: PhotoData) => JSON.stringify(item))\\n}\\n.loop(!this.slide ? true : false)\\n.autoPlay(!this.slide ? true : false)\\n.interval(3000)\\n.indicator(false)",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]图片区域实现",
        "parent_text": "[h2]图片区域实现图片区域需要使用Swiper组件来实现。将图片合集的数据传入Swiper组件后，需要对Swiper组件设置一些属性，来完成图片自动轮播效果： 通过设置loop属性控制是否循环播放，该属性默认值为true。当loop为true时，在显示第一页或最后一页时，可以继续往前切换到前一页或者往后切换到后一页。如果loop为false，则在第一页或最后一页时，无法继续向前或者向后切换页面。通过设置autoPlay属性，控制是否自动轮播子组件。该属性默认值为false。autoPlay为true时，会自动切换播放子组件。通过设置interval属性，控制子组件与子组件之间的播放间隔。interval属性默认值为3000，单位毫秒。通过设置indicator属性为false，来关闭Swiper组件自带的导航点指示器样式  示意效果如下图所示。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section17193467911\\\"'><a name='\\\"section17193467911\\\"'></a><a name='\\\"section17193467911\\\"'></a><h4>[h2]图片区域实现</h4><p>图片区域需要使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper\\\"' target='\\\"_blank\\\"'>Swiper</a>组件来实现。将图片合集的数据传入Swiper组件后，需要对Swiper组件设置一些属性，来完成图片自动轮播效果：</p> <ol><li>通过设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#loop\\\"' target='\\\"_blank\\\"'>loop</a>属性控制是否循环播放，该属性默认值为true。当loop为true时，在显示第一页或最后一页时，可以继续往前切换到前一页或者往后切换到后一页。如果loop为false，则在第一页或最后一页时，无法继续向前或者向后切换页面。</li><li>通过设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#autoplay\\\"' target='\\\"_blank\\\"'>autoPlay</a>属性，控制是否自动轮播子组件。该属性默认值为false。autoPlay为true时，会自动切换播放子组件。</li><li>通过设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#interval\\\"' target='\\\"_blank\\\"'>interval</a>属性，控制子组件与子组件之间的播放间隔。interval属性默认值为3000，单位毫秒。</li><li>通过设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#indicator\\\"' target='\\\"_blank\\\"'>indicator</a>属性为false，来关闭Swiper组件自带的导航点指示器样式</li></ol>  <p>示意效果如下图所示。</p> <p><span><img originheight='\\\"335\\\"' originwidth='\\\"352\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161125.63674733132515800669495761340199:50001231000000:2800:39BE9969F506EBB16F068B5D8BA3C04CB7787CE1A6B319E382D785B988EF5113.gif\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-carousel-graphic-works.html"
    },
    {
        "id": 260,
        "pre": "@Builder\\nprogressComponent() {\\n  Row({ space: 5 }) {\\n    ForEach(this.progressData, (item: PhotoData, index: number) => {\\n      Stack({ alignContent: Alignment.Start }) {\\n        Row()\\n          .zIndex(1)\\n          .width(this.currentIndex >= index && !this.slide ? '100%' : '0')\\n          .height(2)\\n          .borderRadius(2)\\n          .backgroundColor(Color.White)\\n          .animation(!this.slide ? {\\n            duration: this.duration - 400,\\n            curve: Curve.Linear,\\n            iterations: 1,\\n            playMode: PlayMode.Normal,\\n            onFinish: () => {\\n              if (this.currentIndex === this.progressData.length - 1) {\\n                this.duration = 400;\\n                this.currentIndex = -1;\\n              }\\n            }\\n          } : { duration: 0, iterations: 1 })\\n      }\\n      .width('100%')\\n      .height(2)\\n      .borderRadius(2)\\n      .backgroundColor(this.currentIndex >= index && this.slide ? Color.White : Color.Grey)\\n      .layoutWeight(1)\\n    }, (item: PhotoData) => JSON.stringify(item))\\n  }\\n  .width('100%')\\n  .height(50)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]底部导航点设计",
        "parent_text": "[h2]底部导航点设计底部导航点（进度条）有三种样式：未完成状态的样式、已完成状态的样式和正在进行进度增长的样式。 开发者可以使用层叠布局 (Stack)，配合Row容器来实现进度条的布局。要实现进度条缓慢增长至完成状态且用时与图片播放时间相匹配的效果，可以给Row容器组件添加属性动画 (animation)，设置duration（动画持续时间）与图片播放时间匹配即可。进度条状态切换：通过播放图片的currentIndex与进度条的index进行比较，当currentIndex大于或等于index时，需要将进度条样式设置成已完成状态，否则是未完成状态。可以通过设置完成时进度条的背景颜色为Color.White或Color.Grey来实现两种样式的进度条切换。 创建自定义组件progressComponent。  示意效果如下图所示。  上述代码中，this.progressData为图片集合的数组，this.currentIndex为当前播放的图片在图片集合数组中的索引，index为进度条对应的图片在图片集合数组中的索引。当this.currentIndex >= index时，表示图片集合数组中索引0-index的进度条都是已完成状态。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12429123771014\\\"'><a name='\\\"section12429123771014\\\"'></a><a name='\\\"section12429123771014\\\"'></a><h4>[h2]底部导航点设计</h4><p>底部导航点（进度条）有三种样式：未完成状态的样式、已完成状态的样式和正在进行进度增长的样式。</p> <ol><li>开发者可以使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-stack-layout\\\"' target='\\\"_blank\\\"'>层叠布局 (Stack)</a>，配合Row容器来实现进度条的布局。</li><li>要实现进度条缓慢增长至完成状态且用时与图片播放时间相匹配的效果，可以给Row容器组件添加<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-animatorproperty\\\"' target='\\\"_blank\\\"'>属性动画 (animation)</a>，设置duration（动画持续时间）与图片播放时间匹配即可。</li><li>进度条状态切换：通过播放图片的currentIndex与进度条的index进行比较，当currentIndex大于或等于index时，需要将进度条样式设置成已完成状态，否则是未完成状态。可以通过设置完成时进度条的背景颜色为Color.White或Color.Grey来实现两种样式的进度条切换。</li></ol> <p>创建自定义组件progressComponent。</p>  <p>示意效果如下图所示。</p> <p><span><img originheight='\\\"39\\\"' originwidth='\\\"353\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161126.60159778772339134712786825921165:50001231000000:2800:34B9D88F59DB4EB2B9A0832E89F946248B2A7363B1E87848EF8659AAE95D1148.gif\\\"'/></span></p> <p>上述代码中，this.progressData为图片集合的数组，this.currentIndex为当前播放的图片在图片集合数组中的索引，index为进度条对应的图片在图片集合数组中的索引。当this.currentIndex &gt;= index时，表示图片集合数组中索引0-index的进度条都是已完成状态。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-carousel-graphic-works.html"
    },
    {
        "id": 261,
        "pre": "// entry/src/main/ets/pages/Index.ets\\nColumn() {\\n  // ...\\n  List() {\\n    ForEach(this.directory, (item: DirectoryItem, index: number) => {\\n      ListItem() {\\n        Column() {\\n          // ...\\n        }\\n        // ...\\n        .onClick(() => {\\n          if (index === CommonConstants.COMMON_ZERO) {\\n            let want: Want = {\\n              bundleName: 'com.example.businessoffice',\\n              abilityName: 'SecondAbility'\\n            };\\n            let option: StartOptions = { displayId: CommonConstants.COMMON_ZERO };\\n            (getContext(this) as common.UIAbilityContext).startAbility(want, option);\\n          } else {\\n            let want: Want = {\\n              bundleName: 'com.example.businessoffice',\\n              abilityName: 'ThirdAbility'\\n            };\\n            let option: StartOptions = { displayId: CommonConstants.COMMON_ZERO };\\n            (getContext(this) as common.UIAbilityContext).startAbility(want, option);\\n          }\\n        })\\n      }\\n      // ...\\n      })\\n    }, (item: DirectoryItem) => JSON.stringify(item))\\n  }\\n  // ...\\n  .listDirection(this.breakPoint === CommonConstants.BREAK_POINT_SM ? Axis.Vertical : Axis.Horizontal)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "监听断点变化，设置List组件的listDirection属性在断点为sm时为Vertical纵向展示，其余断点为Horizontal横向展示，实现入口组件根据不同断点横纵排列不同的效果。使用startAbility实现点击子组件时拉起新实例的效果。 ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>监听断点变化，设置<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list\\\"' target='\\\"_blank\\\"'>List组件</a>的listDirection属性在断点为sm时为Vertical纵向展示，其余断点为Horizontal横向展示，实现入口组件根据不同断点横纵排列不同的效果。使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-uiabilitycontext#uiabilitycontextstartability\\\"' target='\\\"_blank\\\"'>startAbility</a>实现点击子组件时拉起新实例的效果。 </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-business-office.html"
    },
    {
        "id": 262,
        "pre": "import { photoAccessHelper } from '@kit.MediaLibraryKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\n\\nconst photoSelectOptions = new photoAccessHelper.PhotoSelectOptions();\\nphotoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE;\\nphotoSelectOptions.maxSelectNumber = 5;\\nconst photoViewPicker = new photoAccessHelper.PhotoViewPicker();\\nphotoViewPicker.select(photoSelectOptions).then((photoSelectResult) => {\\n  this.imageUri = photoSelectResult.photoUris[0];\\n  Logger.info(`PhotoViewPicker.select successfully, uris: ${JSON.stringify(photoSelectResult)}`);\\n}).catch((err: BusinessError) => {\\n  Logger.error(`PhotoViewPicker.select failed with err: ${JSON.stringify(err)}`);\\n});",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]减少使用存储权限",
        "parent_text": "[h2]减少使用存储权限一般应用获取“存储”权限后，就能读取到手机内部存储上所有的文件，包含所有的照片，这就产生了隐私风险：它就可以在用户毫无感知的情况下，分析用户的文件和图片，将隐私“偷走“。 但是，用户通常不希望授予应用对其所有照片和视频的访问权限，因此，HarmonyOS在API9以后引入了Picker选择器，在保证用户正常的数据访问述求的同时，最小化减少应用的数据泄露。避免全量数据的授权，降低授权的颗粒度，例如用户在发送图片时，只想让应用访问到用户想要发送的。    示例代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section994451875414\\\"'><a name='\\\"section994451875414\\\"'></a><a name='\\\"section994451875414\\\"'></a><h4>[h2]减少使用存储权限</h4><p>一般应用获取“存储”权限后，就能读取到手机内部存储上所有的文件，包含所有的照片，这就产生了隐私风险：它就可以在用户毫无感知的情况下，分析用户的文件和图片，将隐私“偷走“。</p> <p>但是，用户通常不希望授予应用对其所有照片和视频的访问权限，因此，HarmonyOS在API9以后引入了Picker选择器，在保证用户正常的数据访问述求的同时，最小化减少应用的数据泄露。避免全量数据的授权，降低授权的颗粒度，例如用户在发送图片时，只想让应用访问到用户想要发送的。</p> <p></p> <p></p> <p><span><img height='\\\"548.4654\\\"' originheight='\\\"1027\\\"' originwidth='\\\"495\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161228.56726999260405827870835993110946:50001231000000:2800:C68221D0D6BBCCE53500922A71E44824FCBA3E89387993192DC6241E74654C7A.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>示例代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-privacy-protection.html"
    },
    {
        "id": 263,
        "pre": "{\\n  \\\"module\\\": {\\n    // ...\\n    \\\"requestPermissions\\\": [\\n      {\\n        \\\"name\\\": \\\"ohos.permission.CAMERA\\\",\\n        \\\"reason\\\": \\\"$string:camera_reason\\\",\\n        \\\"usedScene\\\": {\\n          \\\"abilities\\\": [\\n            \\\"EntryAbility\\\"\\n          ],\\n          \\\"when\\\": \\\"inuse\\\"\\n        }\\n      }\\n    ],\\n  }\\n}",
        "type": "Reference",
        "function_call": "createAtManager()",
        "function_name": "[h2]动态申请敏感权限",
        "parent_text": "[h2]动态申请敏感权限敏感权限涉及访问个人数据（如：照片、通讯录、日历、本机号码、短信等）和操作敏感能力（如：相机、麦克风等）的权限，所以对于敏感权限的申请需要特别注意。 合理的权限范围：应用程序应该仅请求其所需的敏感权限范围，并且把权限的范围限制在必要的最小范围内。这样做可以减少权限的滥用和数据泄露的风险。最小化权限申请：应用程序只应该请求必要的敏感权限，而不是请求所有敏感权限。如果应用程序不需要某些敏感权限来执行其功能，则不应该请求这些权限。明确解释权限用途：应用程序应该清楚、明确地解释它所请求的每个敏感权限的用途。应用程序也应该在隐私政策和应用程序的其他位置提供此信息。 例如商品扫码的功能，我们需要首先在module.json5配置文件中声明相机权限，在reason字段中说明相机权限的使用用途。  // string.json\\n{\\n  \\\"string\\\": [\\n    {\\n      \\\"name\\\": \\\"camera_reason\\\",\\n      \\\"value\\\": \\\"扫描二维码功能需要使用相机权限来获图片\\\"\\n    }\\n  ]\\n} 然后在扫码组件的点击事件中添加相机权限的动态申请。 let atManager = abilityAccessCtrl.createAtManager();\\natManager.requestPermissionsFromUser(getContext(this), ['ohos.permission.CAMERA'])\\n  .then((data) => {\\n    let grantStatus: Array<number> = data.authResults;\\n    if (grantStatus.length > 0 && grantStatus[0] === 0) {\\n      // The user is authorized to continue to access the target operation\\n      Logger.info('request permissions granted');\\n      // ...\\n    } else {\\n      // The user rejects the authorization\\n      Logger.info('request permissions denied');\\n      // ...\\n    }\\n  }) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section16469165913549\\\"'><a name='\\\"section16469165913549\\\"'></a><a name='\\\"section16469165913549\\\"'></a><h4>[h2]动态申请敏感权限</h4><p>敏感权限涉及访问个人数据（如：照片、通讯录、日历、本机号码、短信等）和操作敏感能力（如：相机、麦克风等）的权限，所以对于敏感权限的申请需要特别注意。</p> <ol><li>合理的权限范围：应用程序应该仅请求其所需的敏感权限范围，并且把权限的范围限制在必要的最小范围内。这样做可以减少权限的滥用和数据泄露的风险。</li><li>最小化权限申请：应用程序只应该请求必要的敏感权限，而不是请求所有敏感权限。如果应用程序不需要某些敏感权限来执行其功能，则不应该请求这些权限。</li><li>明确解释权限用途：应用程序应该清楚、明确地解释它所请求的每个敏感权限的用途。应用程序也应该在隐私政策和应用程序的其他位置提供此信息。</li></ol> <p>例如商品扫码的功能，我们需要首先在module.json5配置文件中声明相机权限，在reason字段中说明相机权限的使用用途。</p>  <pre class='\\\"screen\\\"'>// string.json\\n{\\n  \\\"string\\\": [\\n    {\\n      \\\"name\\\": \\\"camera_reason\\\",\\n      \\\"value\\\": \\\"扫描二维码功能需要使用相机权限来获图片\\\"\\n    }\\n  ]\\n}</pre> <p>然后在扫码组件的点击事件中添加相机权限的动态申请。</p> <pre class='\\\"screen\\\"'>let atManager = abilityAccessCtrl.createAtManager();\\natManager.requestPermissionsFromUser(getContext(this), ['ohos.permission.CAMERA'])\\n  .then((data) =&gt; {\\n    let grantStatus: Array&lt;number&gt; = data.authResults;\\n    if (grantStatus.length &gt; 0 &amp;&amp; grantStatus[0] === 0) {\\n      // The user is authorized to continue to access the target operation\\n      Logger.info('request permissions granted');\\n      // ...\\n    } else {\\n      // The user rejects the authorization\\n      Logger.info('request permissions denied');\\n      // ...\\n    }\\n  })</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-privacy-protection.html"
    },
    {
        "id": 264,
        "pre": "{\\n  \\\"module\\\": {\\n    // ...\\n    \\\"abilities\\\": [\\n      {\\n        // ...\\n        \\\"continuable\\\": true\\n      }\\n    ]\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "启用接续在module.json5文件的abilities中，将continuable标签配置为“true”，表示该UIAbility可被迁移。配置为false的UIAbility将被系统识别为无法迁移且该配置默认值为false。  ",
        "import_module": null,
        "parent": "<li id='\\\"li6149192715494\\\"'><a name='\\\"ZH-CN_TOPIC_0000002229335473__li6149192715494\\\"'></a><a name='\\\"li6149192715494\\\"'></a>启用接续<p><a name='\\\"ZH-CN_TOPIC_0000002229335473__li6149192715494\\\"'></a><a name='\\\"li6149192715494\\\"'></a>在module.json5文件的abilities中，将continuable标签配置为“true”，表示该UIAbility可被迁移。配置为false的UIAbility将被系统识别为无法迁移且该配置默认值为false。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-continue-progess.html"
    },
    {
        "id": 265,
        "pre": "WaterFlow() {\\n  // ...\\n}\\n.restoreId(1)",
        "type": "Import",
        "function_call": "onDidBuild(): void",
        "function_name": "长列表进度接续",
        "parent_text": "长列表进度接续长列表通常用于存储大量信息，使用List、Grid、Scroll、WaterFlow进行封装，系统提供了分布式迁移标识用于这些组件恢复进度状态，在使用时可以轻松的调用，使用方法如下：  使用分布式迁移标识可以快速的实现接续。但该方法具有局限性，其支持场景和版本见分布式迁移标识API，如果想在开发中做更多自定义设置以提供更好的体验，可以参照如下步骤，完整工程参见示例代码。 启用接续使用onDidScroll()接口监听长列表浏览进度变化。Scroll(this.scroller) {\\n  // ...\\n.onDidScroll((xOffset: number, yOffset: number, scrollState: ScrollState)=>{\\n  if(!this.setcurrentOffset){\\n    this.currentOffset = this.scroller.currentOffset().yOffset;\\n  }\\n}) 将this.WaterFlowIndex在onContinue()回调中保存到分布式对象中，参考保存迁移数据。在onNewWant()回调/onCreate()回调中从分布式对象中恢复数据，参考恢复数据。在onDidBuild()事件中恢复浏览状态。onDidBuild(): void {\\n  if(this.setcurrentOffset){\\n    this.scroller.scrollTo({xOffset:0, yOffset:this.currentOffset})\\n    this.setcurrentOffset = false;\\n  }\\n}  ",
        "import_module": "WaterFlow() {\\n  // ...\\n}\\n.restoreId(1)",
        "parent": "<div class='\\\"section\\\"' id='\\\"section16702516134216\\\"'><a name='\\\"section16702516134216\\\"'></a><a name='\\\"section16702516134216\\\"'></a><h4>长列表进度接续</h4><p>长列表通常用于存储大量信息，使用List、Grid、Scroll、WaterFlow进行封装，系统提供了分布式迁移标识用于这些组件恢复进度状态，在使用时可以轻松的调用，使用方法如下：</p>  <p>使用分布式迁移标识可以快速的实现接续。但该方法具有局限性，其支持场景和版本见<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-restoreid\\\"' target='\\\"_blank\\\"'>分布式迁移标识API</a>，如果想在开发中做更多自定义设置以提供更好的体验，可以参照如下步骤，完整工程参见<a href='\\\"#section2065945415163\\\"'>示例代码</a>。</p> <ol><li><a href='\\\"#li6149192715494\\\"'>启用接续</a></li><li>使用onDidScroll()接口监听长列表浏览进度变化。<pre class='\\\"screen\\\"'>Scroll(this.scroller) {\\n  // ...\\n.onDidScroll((xOffset: number, yOffset: number, scrollState: ScrollState)=&gt;{\\n  if(!this.setcurrentOffset){\\n    this.currentOffset = this.scroller.currentOffset().yOffset;\\n  }\\n})</pre> </li><li>将this.WaterFlowIndex在onContinue()回调中保存到分布式对象中，参考<a href='\\\"#li1745816354491\\\"'>保存迁移数据</a>。</li><li>在onNewWant()回调/onCreate()回调中从分布式对象中恢复数据，参考<a href='\\\"#li631218439498\\\"'>恢复数据</a>。</li><li>在onDidBuild()事件中恢复浏览状态。<pre class='\\\"screen\\\"'>onDidBuild(): void {\\n  if(this.setcurrentOffset){\\n    this.scroller.scrollTo({xOffset:0, yOffset:this.currentOffset})\\n    this.setcurrentOffset = false;\\n  }\\n}</pre> </li></ol> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-continue-progess.html"
    },
    {
        "id": 266,
        "pre": "this.avPlayer.on('timeUpdate', (time: number) => {\\n  this.currentTime = time;\\n});",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用avPlayer.on('timeUpdate')接口监听媒体播放进度的变化。 ",
        "import_module": "WaterFlow() {\\n  // ...\\n}\\n.restoreId(1)",
        "parent": "<li>使用avPlayer.on('timeUpdate')接口监听媒体播放进度的变化。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-continue-progess.html"
    },
    {
        "id": 267,
        "pre": "build() {\\n  Column({ space: 2 }) {\\n    WaterFlow() {\\n      LazyForEach(this.datasource, (item: number) => {\\n        FlowItem() {\\n          Column() {\\n            Text(\\\"N\\\" + item).fontSize(12).height('16')\\n            Image('res/waterFlowTest (' + item % 5 + ').jpg')\\n              .objectFit(ImageFit.Fill)\\n              .width('100%')\\n              .layoutWeight(1)\\n          }\\n        }\\n        .width('100%')         \\n        .height(this.itemHeightArray[item])\\n        .backgroundColor(this.colors[item % 5])\\n      }, (item: string) => item)\\n    }\\n    .columnsTemplate(\\\"1fr 1fr\\\")\\n    .columnsGap(10)\\n    .rowsGap(5)\\n    .backgroundColor(0xFAEEE0)\\n    .width('100%')\\n    .height('80%')\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "懒加载",
        "parent_text": "  懒加载 先看一下组件示例代码中瀑布流的基本用法：  示例代码已经使用了LazyForEach进行数据懒加载，WaterFlow布局时会根据可视区域按需创建FlowItem组件，并在FlowItem滑出可视区域外时销毁以降低内存占用。 瀑布流的开发，也属于长列表加载的一种场景，其LazyForEach懒加载原理及性能分析可参考：《长列表加载性能优化-懒加载》 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section125201667329\\\"'> <a name='\\\"section125201667329\\\"'></a><a name='\\\"section125201667329\\\"'></a> <h4>懒加载</h4> <p><span rgb(36,41,46);\\\"=\"\" style='\\\"color:'>先看一下组件示例代码中瀑布流的基本用法：</span></p>  <p><span rgb(36,41,46);\\\"=\"\" style='\\\"color:'>示例代码已经使用了LazyForEach进行数据懒加载，WaterFlow布局时会根据可视区域按需创建FlowItem组件，并在FlowItem滑出可视区域外时销毁以降低内存占用。</span></p> <p>瀑布流的开发，也属于长列表加载的一种场景，其LazyForEach懒加载原理及性能分析可参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list#section182645364229\\\"'>《长列表加载性能优化-懒加载》</a></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-waterflow-performance-optimization.html"
    },
    {
        "id": 268,
        "pre": "@Component\\nexport struct TransitionScene {\\n  private productData: ProductDetailSource = new ProductDetailSource();\\n\\n  aboutToAppear() {\\n    this.productData.getProductData();\\n  }\\n\\n  build() {\\n    WaterFlow() {\\n      LazyForEach(this.productData, (item: ProductDetailModel) => {\\n        FlowItem() {\\n          // ...\\n        }\\n      }, (item: ProductDetailModel) => item.id.toString())\\n    }\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]常规代码",
        "parent_text": "[h2]常规代码通常情况下，在自定义列表组件中一次性加载全部数据，更新所有的列表项。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section275354112319\\\"'><a name='\\\"section275354112319\\\"'></a><a name='\\\"section275354112319\\\"'></a><h4>[h2]常规代码</h4><p>通常情况下，在自定义列表组件中一次性加载全部数据，更新所有的列表项。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-dispose-highly-loaded-component-render.html"
    },
    {
        "id": 269,
        "pre": "@Entry\\n@Component\\nstruct TransitionScene {\\n  @State currentIndex: number = 0;\\n  private readonly LIST_SPACE: number = 10;\\n  private readonly FRAME_60: number = 60;\\n  private readonly FRAME_120: number = 120;\\n  private readonly SWIPER_CACHE: number = 2;\\n  private readonly HORIZONTAL_LIST_CACHE: number = 2;\\n  private swiperDataSource: SwiperDataSource = new SwiperDataSource();\\n  private midListDataSource: MidListDataSource = new MidListDataSource();\\n  private productDetailSource: ProductDetailSource = new ProductDetailSource();\\n  private displaySync: displaySync.DisplaySync | undefined = undefined;\\n  private frame: number = 1;\\n\\n  aboutToAppear(): void {\\n    this.swiperDataSource.getProductData();\\n    this.midListDataSource.getProductData();\\n\\n    // Creating a DisplaySync Object\\n    this.displaySync = displaySync.create();\\n\\n    // Set the expected frame rate\\n    let range: ExpectedFrameRateRange = {\\n      expected: this.FRAME_120,\\n      min: this.FRAME_60,\\n      max: this.FRAME_120\\n    };\\n    this.displaySync.setExpectedFrameRateRange(range);\\n\\n    // Add Frame Callback\\n    this.displaySync.on('frame', () => {\\n      if (this.frame === 1) {\\n        hiTraceMeter.startTrace('firstFrame', 1);\\n        this.productDetailSource.getProductData(0, 2);\\n        this.frame += 1;\\n        hiTraceMeter.finishTrace('firstFrame', 1);\\n      } else if (this.frame === 2) {\\n        hiTraceMeter.startTrace('secondFrame', 2);\\n        this.productDetailSource.getProductData(2, 10);\\n        hiTraceMeter.finishTrace('secondFrame', 2);\\n        this.frame += 1;\\n        this.displaySync?.stop();\\n      }\\n    });\\n\\n    // Enable frame callback listening\\n    this.displaySync.start();\\n  }\\n\\n  aboutToDisappear(): void {\\n    this.displaySync?.stop();\\n  }\\n\\n  build() {\\n    Column() {\\n      Search({ placeholder: $r('app.string.search_title') })\\n      this.typeSwiper();\\n      this.typeList();\\n      this.typeWaterFlow();\\n    }\\n    .padding({\\n      left: 16,\\n      right: 16\\n    })\\n  }",
        "type": "Reference",
        "function_call": "在aboutToAppear()",
        "function_name": "[h2]优化代码",
        "parent_text": "[h2]优化代码在aboutToAppear()接口中添加displaySync的帧回调，并将数据拆分进行加载。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section91425781510\\\"'><a name='\\\"section91425781510\\\"'></a><a name='\\\"section91425781510\\\"'></a><h4>[h2]优化代码</h4><p>在aboutToAppear()接口中添加displaySync的帧回调，并将数据拆分进行加载。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-dispose-highly-loaded-component-render.html"
    },
    {
        "id": 270,
        "pre": "@Reusable\\n@Component\\nstruct DateItemView {\\n  @State monthItem: Month = {\\n    month: '',\\n    num: 0,\\n    days: [],\\n    lunarDays: [],\\n    year: 0\\n  };\\n  // ...\\n  aboutToReuse(params: Record<string, Object>): void {\\n    hiTraceMeter.startTrace('reuse_' + (params.monthItem as Month).month, 1);\\n    this.monthItem = params.monthItem as Month;\\n    hiTraceMeter.finishTrace('reuse_' + (params.monthItem as Month).month, 1);\\n  }\\n\\n  build() {\\n    Flex({ wrap: FlexWrap.Wrap }) {\\n      // ...\\n      // 日期信息\\n      ForEach(this.monthItem.days, (day: number, index: number) => {\\n        // ...\\n      }, (index: number): string => index.toString())\\n    }\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "会在aboutToReuse()",
        "function_name": "[h2]常规代码",
        "parent_text": "[h2]常规代码通常情况下，会在aboutToReuse()中设置新的数据，并一次性绘制所有的组件。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section14704163352\\\"'><a name='\\\"section14704163352\\\"'></a><a name='\\\"section14704163352\\\"'></a><h4>[h2]常规代码</h4><p>通常情况下，会在aboutToReuse()中设置新的数据，并一次性绘制所有的组件。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-dispose-highly-loaded-component-render.html"
    },
    {
        "id": 271,
        "pre": "// staticModule\\\\src\\\\main\\\\cpp\\\\napi_har.cpp\\n#include \\\"napi/native_api.h\\\"\\n#include \\\"napi_har.h\\\"\\n\\ndouble harNativeAdd(double a, double b) {\\n    return a + b;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在Module2中新建C++文件napi_har.cpp，再新建其头文件napi_har.h，并定义Native方法。napi_har.cpp代码如下所示。  napi_har.h代码如下所示。 // staticModule\\\\src\\\\main\\\\cpp\\\\napi_har.h\\n#ifndef CROSSMODULEREFERENCE_NAPI_HAR_H\\n#define CROSSMODULEREFERENCE_NAPI_HAR_H\\n#include <js_native_api_types.h>\\ndouble harNativeAdd(double a, double b);\\n#endif //CROSSMODULEREFERENCE_NAPI_HAR_H ",
        "import_module": null,
        "parent": "<li>在Module2中新建C++文件napi_har.cpp，再新建其头文件napi_har.h，并定义Native方法。<p>napi_har.cpp代码如下所示。</p>  <p>napi_har.h代码如下所示。</p> <pre class='\\\"screen\\\"'>// staticModule\\\\src\\\\main\\\\cpp\\\\napi_har.h\\n#ifndef CROSSMODULEREFERENCE_NAPI_HAR_H\\n#define CROSSMODULEREFERENCE_NAPI_HAR_H\\n#include &lt;js_native_api_types.h&gt;\\ndouble harNativeAdd(double a, double b);\\n#endif //CROSSMODULEREFERENCE_NAPI_HAR_H</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-cross-module-reference.html"
    },
    {
        "id": 272,
        "pre": "XComponent({\\n  type: XComponentType.SURFACE,\\n  controller: this.mXComponentController,\\n  imageAIOptions: this.options\\n})\\n  .onLoad(async () => {\\n    Logger.info(TAG, 'onLoad is called');\\n    this.surfaceId = this.mXComponentController.getXComponentSurfaceId();\\n    GlobalContext.get().setObject('cameraDeviceIndex', this.defaultCameraDeviceIndex);\\n    GlobalContext.get().setObject('xComponentSurfaceId', this.surfaceId);\\n    Logger.info(TAG, `onLoad surfaceId: ${this.surfaceId}`);\\n    await CameraService.initCamera(this.surfaceId, this.defaultCameraDeviceIndex);\\n  })\\n  .border({\\n    width: {\\n      top: Constants.X_COMPONENT_BORDER_WIDTH,\\n      bottom: Constants.X_COMPONENT_BORDER_WIDTH\\n    },\\n    color: Color.Black\\n  })\\n  .width('100%')\\n  .height(523)\\n  .margin({ top: 75, bottom: 72 })",
        "type": "Reference",
        "function_call": "get()",
        "function_name": "场景示例",
        "parent_text": "场景示例下面以应用中相机Shot2See（拍照之后自动跳转到照片编辑界面）为例，通过单段式拍照和分段式拍照的性能功耗对比，来展示两者的性能差异。 单段式拍照： 单段式拍照使用了on(type: 'photoAvailable', callback: AsyncCallback<Photo>): void接口注册了高质量图的监听，默认不使能分段式拍照。具体操作步骤如下所示： 1.相机媒体数据写入XComponent组件中，用来显示图像效果。具体代码如下所示：  2.initCamera函数完成一个相机生命周期初始化的过程。 (1) getCameraManager获取CameraMananger相机管理器类。 (2) getSupportedCameras 和getSupportedOutputCapability方法获取支持的camera设备以及设备能力集。 (3) createPreviewOutput和createPhotoOutput方法创建预览输出和拍照输出对象。 (4) CameraInput的open方法打开相机输入。 (5) onCameraStatusChange函数创建CameraManager注册回调。 (6) 最后调用sessionFlowFn函数创建并开启Session。具体代码如下所示： /**\\n * Initialize Camera Functions\\n * @param surfaceId - Surface ID\\n * @param cameraDeviceIndex - Camera Device Index\\n * @returns No return value\\n */\\nasync initCamera(surfaceId: string, cameraDeviceIndex: number): Promise<void> {\\n  Logger.debug(TAG, `initCamera cameraDeviceIndex: ${cameraDeviceIndex}`);\\n  this.photoMode = AppStorage.get('photoMode');\\n  if (!this.photoMode) {\\n    return;\\n  }\\n  try {\\n    await this.releaseCamera();\\n    // Get Camera Manager Instance\\n    this.cameraManager = this.getCameraManagerFn();\\n    if (this.cameraManager === undefined) {\\n      Logger.error(TAG, 'cameraManager is undefined');\\n      return;\\n    }\\n    // Gets the camera device object that supports the specified\\n    this.cameras = this.getSupportedCamerasFn(this.cameraManager);\\n    if (this.cameras.length < 1 || this.cameras.length < cameraDeviceIndex + 1) {\\n      return;\\n    }\\n    this.curCameraDevice = this.cameras[cameraDeviceIndex];\\n    let isSupported = this.isSupportedSceneMode(this.cameraManager, this.curCameraDevice);\\n    if (!isSupported) {\\n      Logger.error(TAG, 'The current scene mode is not supported.');\\n      return;\\n    }\\n    let cameraOutputCapability =\\n      this.cameraManager.getSupportedOutputCapability(this.curCameraDevice, this.curSceneMode);\\n    let previewProfile = this.getPreviewProfile(cameraOutputCapability);\\n    if (previewProfile === undefined) {\\n      Logger.error(TAG, 'The resolution of the current preview stream is not supported.');\\n      return;\\n    }\\n    this.previewProfileObj = previewProfile;\\n    // Creates the previewOutput output object\\n    this.previewOutput = this.createPreviewOutputFn(this.cameraManager, this.previewProfileObj, surfaceId);\\n    if (this.previewOutput === undefined) {\\n      Logger.error(TAG, 'Failed to create the preview stream.');\\n      return;\\n    }\\n    // Listening for preview events\\n    this.previewOutputCallBack(this.previewOutput);\\n    let photoProfile = this.getPhotoProfile(cameraOutputCapability);\\n    if (photoProfile === undefined) {\\n      Logger.error(TAG, 'The resolution of the current photo stream is not supported.');\\n      return;\\n    }\\n    this.photoProfileObj = photoProfile;\\n    // Creates a photoOutPut output object\\n    this.photoOutput = this.createPhotoOutputFn(this.cameraManager, this.photoProfileObj);\\n    if (this.photoOutput === undefined) {\\n      Logger.error(TAG, 'Failed to create the photo stream.');\\n      return;\\n    }\\n    // Creates a cameraInput output object\\n    this.cameraInput = this.createCameraInputFn(this.cameraManager, this.curCameraDevice);\\n    if (this.cameraInput === undefined) {\\n      Logger.error(TAG, 'Failed to create the camera input.');\\n      return;\\n    }\\n    // Turn on the camera\\n    let isOpenSuccess = await this.cameraInputOpenFn(this.cameraInput);\\n    if (!isOpenSuccess) {\\n      Logger.error(TAG, 'Failed to open the camera.');\\n      return;\\n    }\\n    // Camera status callback\\n    this.onCameraStatusChange(this.cameraManager);\\n    // Listens to CameraInput error events\\n    this.onCameraInputChange(this.cameraInput, this.curCameraDevice);\\n    // Session Process\\n    await this.sessionFlowFn(this.cameraManager, this.cameraInput, this.previewOutput, this.photoOutput);\\n  } catch (error) {\\n    let err = error as BusinessError;\\n    Logger.error(TAG, `initCamera fail: ${JSON.stringify(err)}`);\\n  }\\n} 3.确定拍照输出流。通过cameraManager.createPhotoOutput方法创建拍照输出流，参数为CameraOutputCapability类中的photoProfiles属性。 /**\\n * Creates a photoOutPut output object\\n */\\ncreatePhotoOutputFn(cameraManager: camera.CameraManager,\\n  photoProfileObj: camera.Profile): camera.PhotoOutput | undefined {\\n  let photoOutput: camera.PhotoOutput;\\n  try {\\n    photoOutput = cameraManager.createPhotoOutput(photoProfileObj);\\n    Logger.info(TAG, `createPhotoOutputFn success: ${photoOutput}`);\\n    return photoOutput;\\n  } catch (error) {\\n    let err = error as BusinessError;\\n    Logger.error(TAG, `createPhotoOutputFn failed: ${JSON.stringify(err)}`);\\n    return undefined;\\n  }\\n} 4.触发拍照。通过photoOutput类的capture方法，执行拍照任务。该方法有两个参数，分别为拍照设置参数的setting以及回调函数，setting中可以设置照片的质量和旋转角度。具体代码如下所示： /**\\n * Trigger a photo taking based on the specified parameters\\n */\\nasync takePicture(): Promise<void> {\\n  Logger.info(TAG, 'takePicture start');\\n  let cameraDeviceIndex = GlobalContext.get().getT<number>('cameraDeviceIndex');\\n  let photoSettings: camera.PhotoCaptureSetting = {\\n    quality: camera.QualityLevel.QUALITY_LEVEL_HIGH,\\n    mirror: cameraDeviceIndex ? true : false\\n  };\\n  await this.photoOutput?.capture(photoSettings);\\n  Logger.info(TAG, 'takePicture end');\\n} 5.设置拍照photoAvailable的回调来获取Photo对象，点击拍照按钮，触发此回调函数，调用getComponent方法根据图像的组件类型从图像中获取组件缓存ArrayBuffer，使用createImageSource方法来创建图片源实例，最后通过createPixelMap获取PixelMap对象。注意:如果已经注册了photoAssetAvailable回调，并且在Session开始之后又注册了photoAvailable回调，会导致流被重启。不建议开发者同时注册photoAvailable和photoAssetAvailable。 photoOutput.on('photoAvailable', (err: BusinessError, photo: camera.Photo) => {\\n  Logger.info(TAG, 'photoAvailable begin');\\n  if (err) {\\n    Logger.error(TAG, `photoAvailable err:${err.code}`);\\n    return;\\n  }\\n  let imageObj: image.Image = photo.main;\\n  imageObj.getComponent(image.ComponentType.JPEG, (err: BusinessError, component: image.Component) => {\\n    Logger.info(TAG, `getComponent start`);\\n    if (err) {\\n      Logger.error(TAG, `getComponent err:${err.code}`);\\n      return;\\n    }\\n    let buffer: ArrayBuffer = component.byteBuffer;\\n    let imageSource: image.ImageSource = image.createImageSource(buffer);\\n    imageSource.createPixelMap((err: BusinessError, pixelMap: image.PixelMap) => {\\n      if (err) {\\n        Logger.error(TAG, `createPixelMap err:${err.code}`);\\n        return;\\n      }\\n      this.handlePhotoAssetCb(pixelMap);\\n    });\\n\\n  });\\n}) 以上代码中执行handleImageInfo函数来对PixelMap进行全局存储并跳转到预览页面。具体代码如下所示： handleSavePicture = (photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void => {\\n  Logger.info(TAG, 'handleSavePicture');\\n  this.setImageInfo(photoAsset);\\n  AppStorage.set<boolean>('isOpenEditPage', true);\\n  Logger.info(TAG, 'setImageInfo end');\\n}\\n\\nsetImageInfo(photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void {\\n  Logger.info(TAG, 'setImageInfo');\\n  GlobalContext.get().setObject('photoAsset', photoAsset);\\n} 6.进入到预览界面，通过GlobalContext.get().getT<image.PixelMap>('imageInfo')方法获取PixelMap信息，并通过Image组件进行渲染显示。 分段式拍照： 分段式拍照是应用下发拍照任务后，系统将分多阶段上报不同质量的图片。在一阶段，系统快速上报低质量图，应用通过on(type: 'photoAssetAvailable', callback: AsyncCallback<photoAccessHelper.PhotoAsset>): void接口会收到一个PhotoAsset对象，通过该对象可调用媒体库接口，读取图片或落盘图片。在二阶段，分段式子服务会根据系统压力以及定制化场景进行调度，将后处理好的原图回传给媒体库，替换低质量图。具体操作步骤如下所示： 由于分段式拍照和单段式拍照步骤1-步骤4相同，就不再进行赘述。 5.设置拍照photoAssetAvailable的回调来获取photoAsset，点击拍照按钮，触发此回调函数，然后执行handlePhotoAssetCb函数来完成photoAsset全局的存储并跳转到预览页面。 photoOutput.on('photoAssetAvailable', (err: BusinessError, photoAsset: photoAccessHelper.PhotoAsset) => {\\n  Logger.info(TAG, 'photoAssetAvailable begin');\\n  if (err) {\\n    Logger.error(TAG, `photoAssetAvailable err:${err.code}`);\\n    return;\\n  }\\n  this.handlePhotoAssetCb(photoAsset);\\n}); 以上代码中执行handleImageInfo函数来对photoAsset进行全局存储并跳转到预览页面。具体代码如下所示： handleSavePicture = (photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void => {\\n  Logger.info(TAG, 'handleSavePicture');\\n  this.setImageInfo(photoAsset);\\n  AppStorage.set<boolean>('isOpenEditPage', true);\\n  Logger.info(TAG, 'setImageInfo end');\\n}\\n\\nsetImageInfo(photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void {\\n  Logger.info(TAG, 'setImageInfo');\\n  GlobalContext.get().setObject('photoAsset', photoAsset);\\n} 6.进入预览界面通过GlobalContext.get().getT<image.PixelMap>('imageInfo')方法获取PhotoAsset信息，执行requestImage函数中的photoAccessHelper.MediaAssetManager.requestImageData方法根据不同的策略模式，请求图片资源数据，这里的请求策略为均衡模式BALANCE_MODE， 最后分段式子服务会根据系统压力以及定制化场景进行调度，将后处理好的原图回传给媒体库来替换低质量图。具体代码如下所示： photoBufferCallback: (arrayBuffer: ArrayBuffer) => void = (arrayBuffer: ArrayBuffer) => {\\n  Logger.info(TAG, 'photoBufferCallback is called');\\n  let imageSource = image.createImageSource(arrayBuffer);\\n  imageSource.createPixelMap((err: BusinessError, data: image.PixelMap) => {\\n    if (err) {\\n      Logger.info(TAG, `createPixelMap err:${err.code}`);\\n      return;\\n    }\\n    Logger.info(TAG, 'createPixelMap is called');\\n    this.curPixelMap = data;\\n  });\\n};\\n\\nrequestImage(requestImageParams: RequestImageParams): void {\\n  try {\\n    class MediaDataHandler implements photoAccessHelper.MediaAssetDataHandler<ArrayBuffer> {\\n      onDataPrepared(data: ArrayBuffer, map: Map<string, string>): void {\\n        Logger.info(TAG, 'onDataPrepared map' + JSON.stringify(map));\\n        requestImageParams.callback(data);\\n        Logger.info(TAG, 'onDataPrepared end');\\n      }\\n    };\\n    let requestOptions: photoAccessHelper.RequestOptions = {\\n      deliveryMode: photoAccessHelper.DeliveryMode.BALANCE_MODE,\\n    };\\n    const handler = new MediaDataHandler();\\n    photoAccessHelper.MediaAssetManager.requestImageData(requestImageParams.context, requestImageParams.photoAsset,\\n      requestOptions, handler);\\n  } catch (error) {\\n    Logger.error(TAG, `Failed in requestImage, error code: ${error.code}`);\\n  }\\n}\\n\\naboutToAppear() {\\n  Logger.info(TAG, 'aboutToAppear begin');\\n  if (this.photoMode === Constants.SUBSECTION_MODE) {\\n    let curPhotoAsset = GlobalContext.get().getT<photoAccessHelper.PhotoAsset>('photoAsset');\\n    this.photoUri = curPhotoAsset.uri;\\n    let requestImageParams: RequestImageParams = {\\n      context: getContext(),\\n      photoAsset: curPhotoAsset,\\n      callback: this.photoBufferCallback\\n    };\\n    this.requestImage(requestImageParams);\\n    Logger.info(TAG, `aboutToAppear photoUri: ${this.photoUri}`);\\n  } else if (this.photoMode === Constants.SINGLE_STAGE_MODE) {\\n    this.curPixelMap = GlobalContext.get().getT<image.PixelMap>('photoAsset');\\n  }\\n} 7.将步骤6获取的PixelMap对象数据通过Image组件进行渲染显示。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section099811487293\\\"'><a name='\\\"section099811487293\\\"'></a><a name='\\\"section099811487293\\\"'></a><h4>场景示例</h4><p>下面以应用中相机Shot2See（拍照之后自动跳转到照片编辑界面）为例，通过单段式拍照和分段式拍照的性能功耗对比，来展示两者的性能差异。</p> <p><strong>单段式拍照：</strong></p> <p>单段式拍照使用了<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#onphotoavailable11\\\"' target='\\\"_blank\\\"'>on(type: 'photoAvailable', callback: AsyncCallback&lt;Photo&gt;): void</a>接口注册了高质量图的监听，默认不使能分段式拍照。具体操作步骤如下所示：</p> <p>1.相机媒体数据写入<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-xcomponent\\\"' target='\\\"_blank\\\"'>XComponent组件</a>中，用来显示图像效果。具体代码如下所示：</p>  <p>2.initCamera函数完成一个相机生命周期初始化的过程。</p> <p>(1) <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#cameragetcameramanager\\\"' target='\\\"_blank\\\"'>getCameraManager</a>获取CameraMananger相机管理器类。</p> <p>(2) <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#getsupportedcameras\\\"' target='\\\"_blank\\\"'>getSupportedCameras</a> 和<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#getsupportedoutputcapability11\\\"' target='\\\"_blank\\\"'>getSupportedOutputCapability</a>方法获取支持的camera设备以及设备能力集。</p> <p>(3) <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#createpreviewoutput\\\"' target='\\\"_blank\\\"'>createPreviewOutput</a>和<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#createphotooutput11\\\"' target='\\\"_blank\\\"'>createPhotoOutput</a>方法创建预览输出和拍照输出对象。</p> <p>(4) CameraInput的open方法打开相机输入。</p> <p>(5) onCameraStatusChange函数创建CameraManager注册回调。</p> <p>(6) 最后调用sessionFlowFn函数创建并开启Session。具体代码如下所示：</p> <pre class='\\\"screen\\\"'>/**\\n * Initialize Camera Functions\\n * @param surfaceId - Surface ID\\n * @param cameraDeviceIndex - Camera Device Index\\n * @returns No return value\\n */\\nasync initCamera(surfaceId: string, cameraDeviceIndex: number): Promise&lt;void&gt; {\\n  Logger.debug(TAG, `initCamera cameraDeviceIndex: ${cameraDeviceIndex}`);\\n  this.photoMode = AppStorage.get('photoMode');\\n  if (!this.photoMode) {\\n    return;\\n  }\\n  try {\\n    await this.releaseCamera();\\n    // Get Camera Manager Instance\\n    this.cameraManager = this.getCameraManagerFn();\\n    if (this.cameraManager === undefined) {\\n      Logger.error(TAG, 'cameraManager is undefined');\\n      return;\\n    }\\n    // Gets the camera device object that supports the specified\\n    this.cameras = this.getSupportedCamerasFn(this.cameraManager);\\n    if (this.cameras.length &lt; 1 || this.cameras.length &lt; cameraDeviceIndex + 1) {\\n      return;\\n    }\\n    this.curCameraDevice = this.cameras[cameraDeviceIndex];\\n    let isSupported = this.isSupportedSceneMode(this.cameraManager, this.curCameraDevice);\\n    if (!isSupported) {\\n      Logger.error(TAG, 'The current scene mode is not supported.');\\n      return;\\n    }\\n    let cameraOutputCapability =\\n      this.cameraManager.getSupportedOutputCapability(this.curCameraDevice, this.curSceneMode);\\n    let previewProfile = this.getPreviewProfile(cameraOutputCapability);\\n    if (previewProfile === undefined) {\\n      Logger.error(TAG, 'The resolution of the current preview stream is not supported.');\\n      return;\\n    }\\n    this.previewProfileObj = previewProfile;\\n    // Creates the previewOutput output object\\n    this.previewOutput = this.createPreviewOutputFn(this.cameraManager, this.previewProfileObj, surfaceId);\\n    if (this.previewOutput === undefined) {\\n      Logger.error(TAG, 'Failed to create the preview stream.');\\n      return;\\n    }\\n    // Listening for preview events\\n    this.previewOutputCallBack(this.previewOutput);\\n    let photoProfile = this.getPhotoProfile(cameraOutputCapability);\\n    if (photoProfile === undefined) {\\n      Logger.error(TAG, 'The resolution of the current photo stream is not supported.');\\n      return;\\n    }\\n    this.photoProfileObj = photoProfile;\\n    // Creates a photoOutPut output object\\n    this.photoOutput = this.createPhotoOutputFn(this.cameraManager, this.photoProfileObj);\\n    if (this.photoOutput === undefined) {\\n      Logger.error(TAG, 'Failed to create the photo stream.');\\n      return;\\n    }\\n    // Creates a cameraInput output object\\n    this.cameraInput = this.createCameraInputFn(this.cameraManager, this.curCameraDevice);\\n    if (this.cameraInput === undefined) {\\n      Logger.error(TAG, 'Failed to create the camera input.');\\n      return;\\n    }\\n    // Turn on the camera\\n    let isOpenSuccess = await this.cameraInputOpenFn(this.cameraInput);\\n    if (!isOpenSuccess) {\\n      Logger.error(TAG, 'Failed to open the camera.');\\n      return;\\n    }\\n    // Camera status callback\\n    this.onCameraStatusChange(this.cameraManager);\\n    // Listens to CameraInput error events\\n    this.onCameraInputChange(this.cameraInput, this.curCameraDevice);\\n    // Session Process\\n    await this.sessionFlowFn(this.cameraManager, this.cameraInput, this.previewOutput, this.photoOutput);\\n  } catch (error) {\\n    let err = error as BusinessError;\\n    Logger.error(TAG, `initCamera fail: ${JSON.stringify(err)}`);\\n  }\\n}</pre> <p>3.确定拍照输出流。通过cameraManager.createPhotoOutput方法创建拍照输出流，参数为<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#cameraoutputcapability\\\"' target='\\\"_blank\\\"'>CameraOutputCapability</a>类中的photoProfiles属性。</p> <pre class='\\\"screen\\\"'>/**\\n * Creates a photoOutPut output object\\n */\\ncreatePhotoOutputFn(cameraManager: camera.CameraManager,\\n  photoProfileObj: camera.Profile): camera.PhotoOutput | undefined {\\n  let photoOutput: camera.PhotoOutput;\\n  try {\\n    photoOutput = cameraManager.createPhotoOutput(photoProfileObj);\\n    Logger.info(TAG, `createPhotoOutputFn success: ${photoOutput}`);\\n    return photoOutput;\\n  } catch (error) {\\n    let err = error as BusinessError;\\n    Logger.error(TAG, `createPhotoOutputFn failed: ${JSON.stringify(err)}`);\\n    return undefined;\\n  }\\n}</pre> <p>4.触发拍照。通过photoOutput类的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#capture-2\\\"' target='\\\"_blank\\\"'>capture</a>方法，执行拍照任务。该方法有两个参数，分别为拍照设置参数的setting以及回调函数，setting中可以设置照片的质量和旋转角度。具体代码如下所示：</p> <pre class='\\\"screen\\\"'>/**\\n * Trigger a photo taking based on the specified parameters\\n */\\nasync takePicture(): Promise&lt;void&gt; {\\n  Logger.info(TAG, 'takePicture start');\\n  let cameraDeviceIndex = GlobalContext.get().getT&lt;number&gt;('cameraDeviceIndex');\\n  let photoSettings: camera.PhotoCaptureSetting = {\\n    quality: camera.QualityLevel.QUALITY_LEVEL_HIGH,\\n    mirror: cameraDeviceIndex ? true : false\\n  };\\n  await this.photoOutput?.capture(photoSettings);\\n  Logger.info(TAG, 'takePicture end');\\n}</pre> <p>5.设置拍照photoAvailable的回调来获取Photo对象，点击拍照按钮，触发此回调函数，调用getComponent方法根据图像的组件类型从图像中获取组件缓存ArrayBuffer，使用createImageSource方法来创建图片源实例，最后通过createPixelMap获取PixelMap对象。注意:如果已经注册了photoAssetAvailable回调，并且在Session开始之后又注册了photoAvailable回调，会导致流被重启。不建议开发者同时注册photoAvailable和photoAssetAvailable。</p> <pre class='\\\"screen\\\"'>photoOutput.on('photoAvailable', (err: BusinessError, photo: camera.Photo) =&gt; {\\n  Logger.info(TAG, 'photoAvailable begin');\\n  if (err) {\\n    Logger.error(TAG, `photoAvailable err:${err.code}`);\\n    return;\\n  }\\n  let imageObj: image.Image = photo.main;\\n  imageObj.getComponent(image.ComponentType.JPEG, (err: BusinessError, component: image.Component) =&gt; {\\n    Logger.info(TAG, `getComponent start`);\\n    if (err) {\\n      Logger.error(TAG, `getComponent err:${err.code}`);\\n      return;\\n    }\\n    let buffer: ArrayBuffer = component.byteBuffer;\\n    let imageSource: image.ImageSource = image.createImageSource(buffer);\\n    imageSource.createPixelMap((err: BusinessError, pixelMap: image.PixelMap) =&gt; {\\n      if (err) {\\n        Logger.error(TAG, `createPixelMap err:${err.code}`);\\n        return;\\n      }\\n      this.handlePhotoAssetCb(pixelMap);\\n    });\\n\\n  });\\n})</pre> <p>以上代码中执行handleImageInfo函数来对PixelMap进行全局存储并跳转到预览页面。具体代码如下所示：</p> <pre class='\\\"screen\\\"'>handleSavePicture = (photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void =&gt; {\\n  Logger.info(TAG, 'handleSavePicture');\\n  this.setImageInfo(photoAsset);\\n  AppStorage.set&lt;boolean&gt;('isOpenEditPage', true);\\n  Logger.info(TAG, 'setImageInfo end');\\n}\\n\\nsetImageInfo(photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void {\\n  Logger.info(TAG, 'setImageInfo');\\n  GlobalContext.get().setObject('photoAsset', photoAsset);\\n}</pre> <p>6.进入到预览界面，通过GlobalContext.get().getT&lt;image.PixelMap&gt;('imageInfo')方法获取PixelMap信息，并通过Image组件进行渲染显示。</p> <p><strong>分段式拍照：</strong></p> <p>分段式拍照是应用下发拍照任务后，系统将分多阶段上报不同质量的图片。在一阶段，系统快速上报低质量图，应用通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-camera#onphotoassetavailable12\\\"' target='\\\"_blank\\\"'>on(type: 'photoAssetAvailable', callback: AsyncCallback&lt;photoAccessHelper.PhotoAsset&gt;): void</a>接口会收到一个PhotoAsset对象，通过该对象可调用媒体库接口，读取图片或落盘图片。在二阶段，分段式子服务会根据系统压力以及定制化场景进行调度，将后处理好的原图回传给媒体库，替换低质量图。具体操作步骤如下所示：</p> <p>由于分段式拍照和单段式拍照步骤1-步骤4相同，就不再进行赘述。</p> <p>5.设置拍照photoAssetAvailable的回调来获取photoAsset，点击拍照按钮，触发此回调函数，然后执行handlePhotoAssetCb函数来完成photoAsset全局的存储并跳转到预览页面。</p> <pre class='\\\"screen\\\"'>photoOutput.on('photoAssetAvailable', (err: BusinessError, photoAsset: photoAccessHelper.PhotoAsset) =&gt; {\\n  Logger.info(TAG, 'photoAssetAvailable begin');\\n  if (err) {\\n    Logger.error(TAG, `photoAssetAvailable err:${err.code}`);\\n    return;\\n  }\\n  this.handlePhotoAssetCb(photoAsset);\\n});</pre> <p>以上代码中执行handleImageInfo函数来对photoAsset进行全局存储并跳转到预览页面。具体代码如下所示：</p> <pre class='\\\"screen\\\"'>handleSavePicture = (photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void =&gt; {\\n  Logger.info(TAG, 'handleSavePicture');\\n  this.setImageInfo(photoAsset);\\n  AppStorage.set&lt;boolean&gt;('isOpenEditPage', true);\\n  Logger.info(TAG, 'setImageInfo end');\\n}\\n\\nsetImageInfo(photoAsset: photoAccessHelper.PhotoAsset | image.PixelMap): void {\\n  Logger.info(TAG, 'setImageInfo');\\n  GlobalContext.get().setObject('photoAsset', photoAsset);\\n}</pre> <p>6.进入预览界面通过GlobalContext.get().getT&lt;image.PixelMap&gt;('imageInfo')方法获取PhotoAsset信息，执行requestImage函数中的photoAccessHelper.MediaAssetManager.requestImageData方法根据不同的策略模式，请求图片资源数据，这里的请求策略为均衡模式BALANCE_MODE， 最后分段式子服务会根据系统压力以及定制化场景进行调度，将后处理好的原图回传给媒体库来替换低质量图。具体代码如下所示：</p> <pre class='\\\"screen\\\"'>photoBufferCallback: (arrayBuffer: ArrayBuffer) =&gt; void = (arrayBuffer: ArrayBuffer) =&gt; {\\n  Logger.info(TAG, 'photoBufferCallback is called');\\n  let imageSource = image.createImageSource(arrayBuffer);\\n  imageSource.createPixelMap((err: BusinessError, data: image.PixelMap) =&gt; {\\n    if (err) {\\n      Logger.info(TAG, `createPixelMap err:${err.code}`);\\n      return;\\n    }\\n    Logger.info(TAG, 'createPixelMap is called');\\n    this.curPixelMap = data;\\n  });\\n};\\n\\nrequestImage(requestImageParams: RequestImageParams): void {\\n  try {\\n    class MediaDataHandler implements photoAccessHelper.MediaAssetDataHandler&lt;ArrayBuffer&gt; {\\n      onDataPrepared(data: ArrayBuffer, map: Map&lt;string, string&gt;): void {\\n        Logger.info(TAG, 'onDataPrepared map' + JSON.stringify(map));\\n        requestImageParams.callback(data);\\n        Logger.info(TAG, 'onDataPrepared end');\\n      }\\n    };\\n    let requestOptions: photoAccessHelper.RequestOptions = {\\n      deliveryMode: photoAccessHelper.DeliveryMode.BALANCE_MODE,\\n    };\\n    const handler = new MediaDataHandler();\\n    photoAccessHelper.MediaAssetManager.requestImageData(requestImageParams.context, requestImageParams.photoAsset,\\n      requestOptions, handler);\\n  } catch (error) {\\n    Logger.error(TAG, `Failed in requestImage, error code: ${error.code}`);\\n  }\\n}\\n\\naboutToAppear() {\\n  Logger.info(TAG, 'aboutToAppear begin');\\n  if (this.photoMode === Constants.SUBSECTION_MODE) {\\n    let curPhotoAsset = GlobalContext.get().getT&lt;photoAccessHelper.PhotoAsset&gt;('photoAsset');\\n    this.photoUri = curPhotoAsset.uri;\\n    let requestImageParams: RequestImageParams = {\\n      context: getContext(),\\n      photoAsset: curPhotoAsset,\\n      callback: this.photoBufferCallback\\n    };\\n    this.requestImage(requestImageParams);\\n    Logger.info(TAG, `aboutToAppear photoUri: ${this.photoUri}`);\\n  } else if (this.photoMode === Constants.SINGLE_STAGE_MODE) {\\n    this.curPixelMap = GlobalContext.get().getT&lt;image.PixelMap&gt;('photoAsset');\\n  }\\n}</pre> <p>7.将步骤6获取的PixelMap对象数据通过Image组件进行渲染显示。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-camera-shot2see.html"
    },
    {
        "id": 273,
        "pre": "@Entry\\n@Component\\nstruct ArkUISample {\\n  @State message: string = 'Hello World';\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "直接调用ArkUI接口定义的控件，例如Row、Column、Text等。 该内容将由系统根据组件定义及布局进行绘制，用户应用程序不感知具体的绘制过程。 ",
        "import_module": null,
        "parent": "<li>直接调用ArkUI接口定义的控件，例如Row、Column、Text等。 <p>该内容将由系统根据组件定义及布局进行绘制，用户应用程序不感知具体的绘制过程。</p> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-utilize-hwc-efficiently.html"
    },
    {
        "id": 274,
        "pre": "@Entry\\n@Component\\nstruct VideoWithBlur {\\n  build() {\\n    Stack() {\\n      // 视频图层\\n      Video({\\n        src: $r('app.media.test_video')\\n      })\\n        .height('100%')\\n        .width('100%')\\n        .loop(true)\\n        .autoPlay(true)\\n        .controls(false)\\n\\n      RelativeContainer() {\\n        Row() {\\n          // 返回按钮带有模糊效果\\n          Image($r('app.media.chevron_left'))\\n            .padding(12)\\n            .width(40)\\n            .height(40)\\n            .borderRadius('50%')\\n            .fillColor('rgba(255, 255, 255, 0.9)')\\n            .backgroundColor('rgba(0, 0, 0, 0.1)')\\n            .backdropBlur(40) // 组件背景模糊\\n            .backgroundBlurStyle(BlurStyle.BACKGROUND_REGULAR) // 设置背景模糊材质\\n          // ...\\n        }\\n        // ...\\n      }\\n      .height('100%')\\n      .width('100%')\\n      .padding({ left: 16, right: 16, top: 36, bottom: 36 })\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "Row()",
        "function_name": "[h2]场景一：在视频区域上方合理使用模糊控件",
        "parent_text": "[h2]场景一：在视频区域上方合理使用模糊控件效果图   如上图，视频区域左上角的返回按钮控件带有模糊效果，需要进行视频图层的采样动作，无法使用HWC叠加能力。对此可以通过控件去除模糊效果或者移动控件至非视频相交区域来完成对HWC的使能。 此处采用去除控件的模糊效果的方式使能HWC，优化场景功耗。相应对比代码如下： 视频上方叠加带有模糊效果的Image组件  视频上方Image组件去除模糊效果 @Entry\\n@Component\\nstruct NormalVideo {\\n  build() {\\n    Stack() {\\n      Video({\\n        src: $r('app.media.test_video')\\n      })\\n        .height('100%')\\n        .width('100%')\\n        .loop(true)\\n        .autoPlay(true)\\n        .controls(false)\\n\\n      RelativeContainer() {\\n        Row() {\\n          // 返回按钮没有模糊效果\\n          Image($r('app.media.chevron_left'))\\n            .padding(12)\\n            .width(40)\\n            .height(40)\\n            .borderRadius('50%')\\n            .fillColor('rgba(255, 255, 255, 0.9)')\\n            .backgroundColor('rgba(0, 0, 0, 0.1)')\\n            // ...\\n        }\\n        // ...\\n      }\\n      .height('100%')\\n      .width('100%')\\n      .padding({ left: 16, right: 16, top: 36, bottom: 36 })\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section137998513411\\\"'><a name='\\\"section137998513411\\\"'></a><a name='\\\"section137998513411\\\"'></a><h4>[h2]场景一：在视频区域上方合理使用模糊控件</h4><p><strong>效果图</strong></p> <p><span><img height='\\\"550.12125\\\"' originheight='\\\"657\\\"' originwidth='\\\"318\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161224.19421624070021950904324975277213:50001231000000:2800:E85A23FD9EC5099600A320E61107B84A5739082F286655C0F0B55F16B4D289F5.png\\\"' title='\\\"点击放大\\\"' width='\\\"268.3275\\\"'/></span></p> <p></p> <p>如上图，视频区域左上角的返回按钮控件带有模糊效果，需要进行视频图层的采样动作，无法使用HWC叠加能力。对此可以通过控件去除模糊效果或者移动控件至非视频相交区域来完成对HWC的使能。</p> <p>此处采用去除控件的模糊效果的方式使能HWC，优化场景功耗。相应对比代码如下：</p> <p><strong>视频上方叠加带有模糊效果的Image组件</strong></p>  <p><strong>视频上方Image组件去除模糊效果</strong></p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct NormalVideo {\\n  build() {\\n    Stack() {\\n      Video({\\n        src: $r('app.media.test_video')\\n      })\\n        .height('100%')\\n        .width('100%')\\n        .loop(true)\\n        .autoPlay(true)\\n        .controls(false)\\n\\n      RelativeContainer() {\\n        Row() {\\n          // 返回按钮没有模糊效果\\n          Image($r('app.media.chevron_left'))\\n            .padding(12)\\n            .width(40)\\n            .height(40)\\n            .borderRadius('50%')\\n            .fillColor('rgba(255, 255, 255, 0.9)')\\n            .backgroundColor('rgba(0, 0, 0, 0.1)')\\n            // ...\\n        }\\n        // ...\\n      }\\n      .height('100%')\\n      .width('100%')\\n      .padding({ left: 16, right: 16, top: 36, bottom: 36 })\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-utilize-hwc-efficiently.html"
    },
    {
        "id": 275,
        "pre": "TextInput({ placeholder: '请输入联系人姓名' })\\n  .id('input1')\\n\\nButton('登录')\\n  .onClick(() => {\\n    this.getUIContext().getFocusController().requestFocus('input1');\\n  })",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]代码控制弹出软键盘",
        "parent_text": "[h2]代码控制弹出软键盘开发者可以使用全局的焦点控制对象FocusController的requestFocus方法，通过组件的id将焦点转移到组件树对应的实体节点，并且弹出软键盘。例如下面这个新增地址的示例，当用户未输入信息的时候，点击保存按钮，提示用户输入信息，并且弹出输入框，便于用户直接输入。   示例如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section16845103043113\\\"'><a name='\\\"section16845103043113\\\"'></a><a name='\\\"section16845103043113\\\"'></a><h4>[h2]代码控制弹出软键盘</h4><p>开发者可以使用全局的焦点控制对象FocusController的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-uicontext#requestfocus12\\\"' target='\\\"_blank\\\"'>requestFocus</a>方法，通过组件的id将焦点转移到组件树对应的实体节点，并且弹出软键盘。例如下面这个新增地址的示例，当用户未输入信息的时候，点击保存按钮，提示用户输入信息，并且弹出输入框，便于用户直接输入。</p> <p></p> <p><span><img height='\\\"563.0156000000001\\\"' originheight='\\\"720\\\"' originwidth='\\\"337\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161147.90034935342763297633043230351027:50001231000000:2800:AA3659342FA0D901B115F4345ECE96D13DB61907C4D8F1FED070220F653BCC3F.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>示例如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-keyboard-layout-adapt.html"
    },
    {
        "id": 276,
        "pre": "Button('搜索')\\n  .onClick(() => {\\n    this.getUIContext().getFocusController().clearFocus();\\n  })",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]代码控制收起软键盘",
        "parent_text": "[h2]代码控制收起软键盘通过全局的焦点控制对象FocusController的clearFocus方法，软键盘收起，例如下面的商品列表页面，点击搜索会收起软键盘。   示例代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section19809195110316\\\"'><a name='\\\"section19809195110316\\\"'></a><a name='\\\"section19809195110316\\\"'></a><h4>[h2]代码控制收起软键盘</h4><p>通过全局的焦点控制对象FocusController的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-uicontext#clearfocus12\\\"' target='\\\"_blank\\\"'>clearFocus</a>方法，软键盘收起，例如下面的商品列表页面，点击搜索会收起软键盘。</p> <p></p> <p><span><img height='\\\"563.0156000000001\\\"' originheight='\\\"720\\\"' originwidth='\\\"337\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161147.93869434807558315096294864121441:50001231000000:2800:C2E5A6FD4279AA1D35EE84C06D5563FBC263F4183622CD0F00298B3FFEF4C178.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>示例代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-keyboard-layout-adapt.html"
    },
    {
        "id": 277,
        "pre": "import { window } from '@kit.ArkUI';\\n\\n@Entry\\n@Component\\nstruct GetKeyboardHeightDemo {\\n  @State keyboardHeight: number = 0; // 软键盘高度\\n\\n  aboutToAppear(): void {\\n    window.getLastWindow(getContext(this)).then(currentWindow => {\\n      currentWindow.on('keyboardHeightChange', (data: number) => {\\n        this.keyboardHeight = px2vp(data);\\n      })\\n    })\\n  }\\n\\n  build() {\\n    Column() {\\n      // ...\\n\\n      TextInput()\\n\\n      if (this.keyboardHeight > 0) {\\n        Row() { // 表情栏\\n          // ...\\n        }\\n        // ...\\n      }\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]监听获取软键盘高度",
        "parent_text": "[h2]监听获取软键盘高度开发者还可以通过获取软键盘高度、监听软键盘的弹出和收起状态，来调整组件的位置来适配界面或者显示隐藏某些组件。通过window模块的on('keyboardHeightChange')方法开启固定态软键盘高度变化的监听，实时获取软键盘宽高。例如下面这个示例软键盘弹起后显示表情栏，软键盘收起后隐藏表情栏。    上面效果图的实现示例代码如下，通过on('keyboardHeightChange')方法实时获取软键盘高度赋值给变量keyboardHeight，当keyboardHeight为0的时候表示软键盘处于收起状态，此时隐藏表情栏；keyboardHeight不为0的时候表示软键盘处于弹出状态，此时显示表情栏。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section3471932193214\\\"'><a name='\\\"section3471932193214\\\"'></a><a name='\\\"section3471932193214\\\"'></a><h4>[h2]监听获取软键盘高度</h4><p>开发者还可以通过获取软键盘高度、监听软键盘的弹出和收起状态，来调整组件的位置来适配界面或者显示隐藏某些组件。通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window\\\"' target='\\\"_blank\\\"'>window</a>模块的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#onkeyboardheightchange7\\\"' target='\\\"_blank\\\"'>on('keyboardHeightChange')</a>方法开启固定态软键盘高度变化的监听，实时获取软键盘宽高。例如下面这个示例软键盘弹起后显示表情栏，软键盘收起后隐藏表情栏。</p> <p></p> <p><span><img height='\\\"417.9791\\\"' originheight='\\\"695\\\"' originwidth='\\\"797\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161148.45876534649598403757274252775369:50001231000000:2800:F0F67EFCC4B13941DAAC9B9F75F506329D7D12C6740FE80FDCA38EB2FC9AE544.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p></p> <p>上面效果图的实现示例代码如下，通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#onkeyboardheightchange7\\\"' target='\\\"_blank\\\"'>on('keyboardHeightChange')</a>方法实时获取软键盘高度赋值给变量keyboardHeight，当keyboardHeight为0的时候表示软键盘处于收起状态，此时隐藏表情栏；keyboardHeight不为0的时候表示软键盘处于弹出状态，此时显示表情栏。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-keyboard-layout-adapt.html"
    },
    {
        "id": 278,
        "pre": "import { window } from '@kit.ArkUI';\\n\\n@Entry\\n@Component\\nstruct GetSafeAreaHeightDemo {\\n  @State screenHeight: number = 0; // 安全区域高度\\n  @State isKeyBoardHidden: boolean = false; // 软键盘是否隐藏\\n\\n  aboutToAppear(): void {\\n    window.getLastWindow(getContext(this)).then(currentWindow => {\\n      let property = currentWindow.getWindowProperties();\\n      let avoidArea = currentWindow.getWindowAvoidArea(window.AvoidAreaType.TYPE_KEYBOARD);\\n      // 初始化显示区域高度\\n      this.screenHeight = px2vp(property.windowRect.height - avoidArea.topRect.height - avoidArea.bottomRect.height);\\n      // 开启当前窗口系统规避区变化的监听\\n      currentWindow.on('avoidAreaChange', data => {\\n        if (data.type !== window.AvoidAreaType.TYPE_KEYBOARD) {\\n          return;\\n        }\\n        if (data.area.bottomRect.height <= 0) {\\n          this.isKeyBoardHidden = true;\\n        } else {\\n          this.isKeyBoardHidden = false;\\n        }\\n        this.screenHeight = px2vp(property.windowRect.height -data.area.topRect.height - data.area.bottomRect.height);\\n        console.info(`screen height is: ${this.screenHeight}`);\\n      })\\n    })\\n  }\\n\\n  build() {\\n    Column() {\\n      TextInput()\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]监听获取安全区域高度",
        "parent_text": "[h2]监听获取安全区域高度通过window模块的on('avoidAreaChange')方法开启当前窗口系统规避区变化的监听，获取内容可视区域大小，同时也可以监听软键盘的弹出收起。开发者可以根据软键盘弹出之后的可视区域大小去动态的调整布局中组件的高度去适配界面。具体运用可以参考软键盘避让常见问题中通过监听软键盘弹出，实现软键盘避让示例。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section02922813811\\\"'><a name='\\\"section02922813811\\\"'></a><a name='\\\"section02922813811\\\"'></a><h4>[h2]监听获取安全区域高度</h4><p>通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window\\\"' target='\\\"_blank\\\"'>window</a>模块的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#onavoidareachange9\\\"' target='\\\"_blank\\\"'>on('avoidAreaChange')</a>方法开启当前窗口系统规避区变化的监听，获取内容可视区域大小，同时也可以监听软键盘的弹出收起。开发者可以根据软键盘弹出之后的可视区域大小去动态的调整布局中组件的高度去适配界面。具体运用可以参考<a href='\\\"#section085404710246\\\"'>软键盘避让常见问题</a>中<strong>通过监听软键盘弹出，实现软键盘避让</strong>示例。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-keyboard-layout-adapt.html"
    },
    {
        "id": 279,
        "pre": "import { KeyboardAvoidMode, window } from '@kit.ArkUI';\\nimport { UIAbility } from '@kit.AbilityKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  onWindowStageCreate(windowStage: window.WindowStage): void {\\n    windowStage.loadContent('pages/GetSafeAreaHeightDemo', (err) => {\\n      // 上抬模式\\n      windowStage.getMainWindowSync().getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.OFFSET);\\n    });\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "上抬模式（KeyboardAvoidMode.OFFSET）：为了避让软键盘，Page内容会整体上抬。如下示例代码，软键盘弹出时，页面整体上抬： 示意效果如下，上抬整个页面实现软键盘避让：   ",
        "import_module": null,
        "parent": "<li>上抬模式（KeyboardAvoidMode.OFFSET）：为了避让软键盘，Page内容会整体上抬。如下示例代码，软键盘弹出时，页面整体上抬： <p>示意效果如下，上抬整个页面实现软键盘避让：</p> <p></p> <p><span><img height='\\\"424.536\\\"' originheight='\\\"706\\\"' originwidth='\\\"797\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161148.73997375028407105862363722029522:50001231000000:2800:DEC676EAE738C1ED3020ACB7D90001A9493E6F06373C560AAD8E678BDB1EEA6E.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-keyboard-layout-adapt.html"
    },
    {
        "id": 280,
        "pre": "@Component\\nexport struct MailPage {\\n  // ...\\n  build() {\\n    Column() {\\n      this.NavigationTitle()\\n      this.EmailContent()\\n      this.BottomToolbar()\\n    }\\n    // ...\\n  }\\n\\n  @Builder\\n  NavigationTitle() {\\n    Row() {\\n      // ...\\n    }\\n    .width('100%')\\n    .height(56)\\n    // ...\\n  }\\n\\n  @Builder\\n  BottomToolbar() {\\n    Row({ space: 12 }) {\\n      // ...\\n    }\\n    .width('100%')\\n    .height(56)\\n    // ...\\n  }\\n\\n  @Builder\\n  EmailContent() {\\n    Column() {\\n      // ...\\n    }\\n    .width('100%')\\n    .layoutWeight(1)\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "BottomToolbar()",
        "function_name": "[h2]重要信息被软键盘遮挡",
        "parent_text": "[h2]重要信息被软键盘遮挡例如下面这个电子邮件的示例，内容由三部分组成：标题栏、内容区域和底部操作栏。当点击输入内容的输入框，软键盘会挡住底部的操作栏，影响用户体验，如下图所示：   对应的示例代码如下，其中标题栏和底部操作栏都是固定的高度56，内容区域高度是非固定高度layoutWeight(1)，自适应高度。  开发者可以通过设置软键盘的避让模式为KeyboardAvoidMode.RESIZE（压缩模式），来解决底部操作栏被遮挡的问题，设置该属性后，软键盘的避让会通过压缩内容区域的高度来实现。示例代码如下： // src/main/ets/pages/MailPage.ets\\naboutToAppear(): void {\\n  this.getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE);\\n}\\n\\naboutToDisappear(): void {\\n  this.getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.OFFSET);\\n} 需要注意的是内容区域高度的设置需要用百分比的方式实现，效果图如下：    通过监听软键盘弹出，实现软键盘避让 上面这个示例开发者还可以通过window模块的getWindowAvoidArea方法，监听获取软键盘弹出，获取安全显示区域高度动态设置页面高度。示例代码如下： import { window } from '@kit.ArkUI';\\n\\n@Entry\\n@Component\\nstruct MailHomePage2 {\\n  @State message: string = 'Hello World';\\n  @State screenHeight: number = 0;\\n  @State isKeyBoardHidden: boolean = false;\\n\\n  aboutToAppear(): void {\\n    window.getLastWindow(getContext(this)).then(currentWindow => {\\n      let property = currentWindow.getWindowProperties();\\n      let avoidArea = currentWindow.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);\\n      // 初始化显示区域高度\\n      this.screenHeight = px2vp(property.windowRect.height - avoidArea.topRect.height - avoidArea.bottomRect.height);\\n      // 监视软键盘的弹出和收起\\n      currentWindow.on('avoidAreaChange', async data => {\\n        if (data.type !== window.AvoidAreaType.TYPE_KEYBOARD) {\\n          return;\\n        }\\n        if (data.area.bottomRect.height <= 0) {\\n          this.isKeyBoardHidden = true;\\n        } else {\\n          this.isKeyBoardHidden = false;\\n        }\\n        this.screenHeight = px2vp(property.windowRect.height - avoidArea.topRect.height - data.area.bottomRect.height);\\n      })\\n    })\\n  }\\n\\n  build() {\\n    Column() {\\n      this.NavigationTitle()\\n      this.EmailContent()\\n      this.BottomToolbar()\\n    }\\n    .width('100%')\\n    .height(this.screenHeight) // 动态设置可视区域高度\\n    .expandSafeArea([SafeAreaType.KEYBOARD])\\n    .backgroundColor('#F1F3F5')\\n  }\\n\\n  // ...\\n} 当系统的避让机制可能满足不了开发者的一些需求的时候，开发者可以尝试监听软键盘弹出，根据获取的安全区域或者软键盘高度，来调整布局大小和位置来避让软键盘。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section175930125314\\\"'><a name='\\\"section175930125314\\\"'></a><a name='\\\"section175930125314\\\"'></a><h4>[h2]重要信息被软键盘遮挡</h4><p>例如下面这个电子邮件的示例，内容由三部分组成：标题栏、内容区域和底部操作栏。当点击输入内容的输入框，软键盘会挡住底部的操作栏，影响用户体验，如下图所示：</p> <p></p> <p><span><img height='\\\"423.206\\\"' originheight='\\\"702\\\"' originwidth='\\\"795\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161148.43785198798743222779294471660187:50001231000000:2800:4DA6AF0E69F4E7C09243CA35E8E0DD46257B6DB003EC66C6CBF8C7F9DAC95F62.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p>对应的示例代码如下，其中标题栏和底部操作栏都是固定的高度56，内容区域高度是非固定高度layoutWeight(1)，自适应高度。</p>  <p>开发者可以通过设置软键盘的避让模式为KeyboardAvoidMode.RESIZE（压缩模式），来解决底部操作栏被遮挡的问题，设置该属性后，软键盘的避让会通过压缩内容区域的高度来实现。示例代码如下：</p> <pre class='\\\"screen\\\"'>// src/main/ets/pages/MailPage.ets\\naboutToAppear(): void {\\n  this.getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE);\\n}\\n\\naboutToDisappear(): void {\\n  this.getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.OFFSET);\\n}</pre> <p>需要注意的是内容区域高度的设置需要用百分比的方式实现，效果图如下：</p> <p></p> <p><span><img height='\\\"423.2858\\\"' originheight='\\\"726\\\"' originwidth='\\\"822\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161148.26312373757752086731120354254773:50001231000000:2800:77EF23757188DE1A82DF3BB1606089D7E2010A69F3C3DCBAEE9AD807482BF2D3.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p></p> <p><strong>通过监听软键盘弹出，实现软键盘避让</strong></p> <p>上面这个示例开发者还可以通过window模块的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#getwindowavoidarea9\\\"' target='\\\"_blank\\\"'>getWindowAvoidArea</a>方法，监听获取软键盘弹出，获取安全显示区域高度动态设置页面高度。示例代码如下：</p> <pre class='\\\"screen\\\"'>import { window } from '@kit.ArkUI';\\n\\n@Entry\\n@Component\\nstruct MailHomePage2 {\\n  @State message: string = 'Hello World';\\n  @State screenHeight: number = 0;\\n  @State isKeyBoardHidden: boolean = false;\\n\\n  aboutToAppear(): void {\\n    window.getLastWindow(getContext(this)).then(currentWindow =&gt; {\\n      let property = currentWindow.getWindowProperties();\\n      let avoidArea = currentWindow.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);\\n      // 初始化显示区域高度\\n      this.screenHeight = px2vp(property.windowRect.height - avoidArea.topRect.height - avoidArea.bottomRect.height);\\n      // 监视软键盘的弹出和收起\\n      currentWindow.on('avoidAreaChange', async data =&gt; {\\n        if (data.type !== window.AvoidAreaType.TYPE_KEYBOARD) {\\n          return;\\n        }\\n        if (data.area.bottomRect.height &lt;= 0) {\\n          this.isKeyBoardHidden = true;\\n        } else {\\n          this.isKeyBoardHidden = false;\\n        }\\n        this.screenHeight = px2vp(property.windowRect.height - avoidArea.topRect.height - data.area.bottomRect.height);\\n      })\\n    })\\n  }\\n\\n  build() {\\n    Column() {\\n      this.NavigationTitle()\\n      this.EmailContent()\\n      this.BottomToolbar()\\n    }\\n    .width('100%')\\n    .height(this.screenHeight) // 动态设置可视区域高度\\n    .expandSafeArea([SafeAreaType.KEYBOARD])\\n    .backgroundColor('#F1F3F5')\\n  }\\n\\n  // ...\\n}</pre> <p>当系统的避让机制可能满足不了开发者的一些需求的时候，开发者可以尝试监听软键盘弹出，根据获取的安全区域或者软键盘高度，来调整布局大小和位置来避让软键盘。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-keyboard-layout-adapt.html"
    },
    {
        "id": 281,
        "pre": "@Entry\\n@Component\\nstruct ContactPage {\\n  build() {\\n    Column() {\\n      Row() { // 顶部自定义标题栏\\n        // ...\\n      }\\n      .width('100%')\\n      .height('12%')\\n\\n      List() { // 聊天消息区域\\n        // ...\\n      }\\n      .width('100%')\\n      .height('76%')\\n\\n      Column() { // 底部消息输入框\\n        // ...\\n      }\\n      .width('100%')\\n      .height('12%')\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]软键盘弹出导致布局错位",
        "parent_text": "[h2]软键盘弹出导致布局错位内容向上滚动避让，顶部固定 例如下面这样的一个聊天界面，顶部是一个自定义的标题，下方为可滚动聊天消息区域，底部是消息输入框，示例代码如下：  但是由于软键盘避让默认是上抬模式，会把整个页面向上抬起，所以标题也会被顶上去，如下图所示。   现在需求希望顶部标题固定，点击底部输入框软键盘弹起的时候，标题不上抬，只有内容区域上抬。效果图如下：   想要顶部标题不被软键盘向上抬，需要给对应的组件设置 .expandSafeArea([SafeAreaType.KEYBOARD])}属性，使标题组件不避让键盘，示例代码如下： @Component\\nexport struct ContactPage {\\n  // ...\\n  build() {\\n    Row() {\\n      Column() {\\n        Row() { // 顶部自定义标题栏\\n          // ...\\n        }\\n        .height('12%')\\n        .expandSafeArea([SafeAreaType.KEYBOARD])\\n        .zIndex(1)\\n        // ...\\n\\n        List() { // 聊天消息区域\\n          // ...\\n        }\\n        .height('76%')\\n        // ...\\n\\n        Column(){ // 底部消息输入框\\n          // ...\\n        }\\n        .height('12%')\\n        // ...\\n      }\\n      .width('100%')\\n      // ...\\n    }\\n    .height('100%')\\n  }\\n} 具体实现可以参考Sample代码Keyboard。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section20196428133211\\\"'><a name='\\\"section20196428133211\\\"'></a><a name='\\\"section20196428133211\\\"'></a><h4>[h2]软键盘弹出导致布局错位</h4><p><strong>内容向上滚动避让，顶部固定</strong></p> <p>例如下面这样的一个聊天界面，顶部是一个自定义的标题，下方为可滚动聊天消息区域，底部是消息输入框，示例代码如下：</p>  <p>但是由于软键盘避让默认是上抬模式，会把整个页面向上抬起，所以标题也会被顶上去，如下图所示。</p> <p></p> <p><span><img height='\\\"423.41880000000003\\\"' originheight='\\\"728\\\"' originwidth='\\\"824\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161148.20144376596871398530495325864342:50001231000000:2800:55C4A25118F6B490A4D072B09464FF760F42E13D1730DBA1E215E9668B76D691.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p>现在需求希望顶部标题固定，点击底部输入框软键盘弹起的时候，标题不上抬，只有内容区域上抬。效果图如下：</p> <p></p> <p><span><img height='\\\"424.5094\\\"' originheight='\\\"729\\\"' originwidth='\\\"823\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161148.79320223708312323787092912264861:50001231000000:2800:AAA844B1C1AB9D1644DFE972A23168697E48B244A180C3EBB58D7B93D4D6310E.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p>想要顶部标题不被软键盘向上抬，需要给对应的组件设置 .expandSafeArea([SafeAreaType.KEYBOARD])}属性，使标题组件不避让键盘，示例代码如下：</p> <pre class='\\\"screen\\\"'>@Component\\nexport struct ContactPage {\\n  // ...\\n  build() {\\n    Row() {\\n      Column() {\\n        Row() { // 顶部自定义标题栏\\n          // ...\\n        }\\n        .height('12%')\\n        .expandSafeArea([SafeAreaType.KEYBOARD])\\n        .zIndex(1)\\n        // ...\\n\\n        List() { // 聊天消息区域\\n          // ...\\n        }\\n        .height('76%')\\n        // ...\\n\\n        Column(){ // 底部消息输入框\\n          // ...\\n        }\\n        .height('12%')\\n        // ...\\n      }\\n      .width('100%')\\n      // ...\\n    }\\n    .height('100%')\\n  }\\n}</pre> <p>具体实现可以参考Sample代码<a href='\\\"https://gitee.com/harmonyos_samples/keyboard\\\"' target='\\\"_blank\\\"'>Keyboard</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-keyboard-layout-adapt.html"
    },
    {
        "id": 282,
        "pre": "@CustomDialog\\nstruct CommentDialog {\\n  listData: string[] = ['评论1', '评论2', '评论3', '评论4', '评论5', '评论6', '评论7', '评论8'];\\n  controller?: CustomDialogController;\\n\\n  build() {\\n    Column() {\\n      Text('评论')\\n        .fontSize(20)\\n        .fontWeight(FontWeight.Medium)\\n\\n      List() {\\n        ForEach(this.listData, (item: string) => {\\n          ListItem() {\\n            Text(item)\\n              .height(80)\\n              .fontSize(20)\\n          }\\n        }, (item: string) => item)\\n      }\\n      .scrollBar(BarState.Off)\\n      .width('100%')\\n      .layoutWeight(1)\\n\\n      TextInput({ placeholder: 'Please input content' })\\n        .height(40)\\n        .width('100%')\\n    }\\n    .padding(12)\\n  }\\n}\\n\\n@Entry\\n@Component\\nstruct CustomDialogDemo {\\n  dialogController: CustomDialogController | null = new CustomDialogController({\\n    builder: CommentDialog(),\\n    alignment: DialogAlignment.Bottom,\\n    cornerRadius: 0,\\n    width: '100%',\\n    height: '80%'\\n  })\\n\\n  build() {\\n    Column() {\\n      Button('click me')\\n        .onClick(() => {\\n          if (this.dialogController !== null) {\\n            this.dialogController.open();\\n          }\\n        })\\n    }\\n    .height('100%')\\n    .width('100%')\\n    .justifyContent(FlexAlign.Center)\\n  }\\n}",
        "type": "Reference",
        "function_call": "getUIContext()",
        "function_name": "[h2]软键盘弹出导致弹窗过度上抬",
        "parent_text": "[h2]软键盘弹出导致弹窗过度上抬自定义弹窗被键盘顶起 ，影响用户体验 在软键盘系统避让机制中介绍过，弹窗为避让软键盘会进行避让，整体向上抬，这样可能会影响用户体验。比如下面这个评论里列表的弹窗，使用@CustomDialog实现的，示例代码如下：  当用户点击弹窗底部的输入框的时候，弹窗会整体上抬，输入框上抬的距离也过多。   为了解决以上问题，可以使用Navigation.Dialog，通过设置NavDestination的mode为NavDestinationMode.DIALOG弹窗类型，此时整个NavDestination默认透明显示，示例代码如下： @Entry\\n@Component\\nstruct NavDestinationModeDemo {\\n  @Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack()\\n\\n  @Builder\\n  PagesMap(name: string) {\\n    if (name === 'DialogPage') {\\n      DialogPage()\\n    }\\n  }\\n\\n  build() {\\n    Navigation(this.pageStack) {\\n      Column() {\\n        Button('click me')\\n          .onClick(() => {\\n            this.pageStack.pushPathByName('DialogPage', '');\\n          })\\n      }\\n      .height('100%')\\n      .width('100%')\\n      .justifyContent(FlexAlign.Center)\\n    }\\n    .mode(NavigationMode.Stack)\\n    .navDestination(this.PagesMap)\\n  }\\n}\\n\\n@Component\\nexport struct DialogPage {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n  listData: string[] = ['评论1', '评论2', '评论3', '评论4', '评论5', '评论6', '评论7', '评论8'];\\n\\n  build() {\\n    NavDestination() {\\n      Stack({ alignContent: Alignment.Bottom }) {\\n        Column() {\\n          Text('评论')\\n            .fontSize(20)\\n            .fontWeight(FontWeight.Medium)\\n\\n          List() {\\n            ForEach(this.listData, (item: string) => {\\n              ListItem() {\\n                Text(item)\\n                  .height(80)\\n                  .fontSize(20)\\n              }\\n            }, (item: string) => item)\\n          }\\n          .scrollBar(BarState.Off)\\n          .width('100%')\\n          .layoutWeight(1)\\n\\n          TextInput({ placeholder: 'Please input content' })\\n            .height(40)\\n            .width('100%')\\n        }\\n        .backgroundColor(Color.White)\\n        .height('75%')\\n        .width('100%')\\n        .padding(12)\\n      }\\n      .height('100%')\\n      .width('100%')\\n    }\\n    .backgroundColor('rgba(0,0,0,0.2)')\\n    .hideTitleBar(true)\\n    .mode(NavDestinationMode.DIALOG)\\n  }\\n} 此外还需要设置软键盘避让模式为压缩模式，示例代码如下： import { KeyboardAvoidMode, window } from '@kit.ArkUI';\\nimport { UIAbility } from '@kit.AbilityKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  onWindowStageCreate(windowStage: window.WindowStage): void {\\n    windowStage.loadContent('pages/GetSafeAreaHeightDemo', (err) => {\\n      // 压缩模式\\n      windowStage.getMainWindowSync().getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE);\\n    });\\n  }\\n} 运行效果如下，点击输入框后，内容区域会进行压缩，弹窗整体不会发生上抬。     ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section381324419328\\\"'><a name='\\\"section381324419328\\\"'></a><a name='\\\"section381324419328\\\"'></a><h4>[h2]软键盘弹出导致弹窗过度上抬</h4><p><strong>自定义弹窗被键盘顶起</strong><strong> ，影响用户体验</strong></p> <p>在软键盘系统避让机制中介绍过，弹窗为避让软键盘会进行避让，整体向上抬，这样可能会影响用户体验。比如下面这个评论里列表的弹窗，使用@CustomDialog实现的，示例代码如下：</p>  <p>当用户点击弹窗底部的输入框的时候，弹窗会整体上抬，输入框上抬的距离也过多。</p> <p></p> <p><span><img height='\\\"424.9616\\\"' originheight='\\\"728\\\"' originwidth='\\\"821\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.81514274775163159776212155864842:50001231000000:2800:A6D5DB578EB84A8332319CF6FFE0819988B10322DF3C02202D6C9CEE05DAAFA2.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p>为了解决以上问题，可以使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#页面显示类型\\\"' target='\\\"_blank\\\"'>Navigation.Dialog</a>，通过设置NavDestination的mode为NavDestinationMode.DIALOG弹窗类型，此时整个NavDestination默认透明显示，示例代码如下：</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct NavDestinationModeDemo {\\n  @Provide('NavPathStack') pageStack: NavPathStack = new NavPathStack()\\n\\n  @Builder\\n  PagesMap(name: string) {\\n    if (name === 'DialogPage') {\\n      DialogPage()\\n    }\\n  }\\n\\n  build() {\\n    Navigation(this.pageStack) {\\n      Column() {\\n        Button('click me')\\n          .onClick(() =&gt; {\\n            this.pageStack.pushPathByName('DialogPage', '');\\n          })\\n      }\\n      .height('100%')\\n      .width('100%')\\n      .justifyContent(FlexAlign.Center)\\n    }\\n    .mode(NavigationMode.Stack)\\n    .navDestination(this.PagesMap)\\n  }\\n}\\n\\n@Component\\nexport struct DialogPage {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n  listData: string[] = ['评论1', '评论2', '评论3', '评论4', '评论5', '评论6', '评论7', '评论8'];\\n\\n  build() {\\n    NavDestination() {\\n      Stack({ alignContent: Alignment.Bottom }) {\\n        Column() {\\n          Text('评论')\\n            .fontSize(20)\\n            .fontWeight(FontWeight.Medium)\\n\\n          List() {\\n            ForEach(this.listData, (item: string) =&gt; {\\n              ListItem() {\\n                Text(item)\\n                  .height(80)\\n                  .fontSize(20)\\n              }\\n            }, (item: string) =&gt; item)\\n          }\\n          .scrollBar(BarState.Off)\\n          .width('100%')\\n          .layoutWeight(1)\\n\\n          TextInput({ placeholder: 'Please input content' })\\n            .height(40)\\n            .width('100%')\\n        }\\n        .backgroundColor(Color.White)\\n        .height('75%')\\n        .width('100%')\\n        .padding(12)\\n      }\\n      .height('100%')\\n      .width('100%')\\n    }\\n    .backgroundColor('rgba(0,0,0,0.2)')\\n    .hideTitleBar(true)\\n    .mode(NavDestinationMode.DIALOG)\\n  }\\n}</pre> <p>此外还需要设置软键盘避让模式为压缩模式，示例代码如下：</p> <pre class='\\\"screen\\\"'>import { KeyboardAvoidMode, window } from '@kit.ArkUI';\\nimport { UIAbility } from '@kit.AbilityKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  onWindowStageCreate(windowStage: window.WindowStage): void {\\n    windowStage.loadContent('pages/GetSafeAreaHeightDemo', (err) =&gt; {\\n      // 压缩模式\\n      windowStage.getMainWindowSync().getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE);\\n    });\\n  }\\n}</pre> <p>运行效果如下，点击输入框后，内容区域会进行压缩，弹窗整体不会发生上抬。</p> <p></p> <p><span><img height='\\\"421.92920000000004\\\"' originheight='\\\"721\\\"' originwidth='\\\"819\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161149.47867037722359115592657601380737:50001231000000:2800:329C8E708CFB2B2B65B054D89C2DCD13268C65D2A73EEB8587BC22DC5830B604.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> <p></p> <p></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-keyboard-layout-adapt.html"
    },
    {
        "id": 283,
        "pre": "{\\n  \\\"name\\\": \\\"entry\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"Please describe the basic information.\\\",\\n  \\\"main\\\": \\\"\\\",\\n  \\\"author\\\": \\\"\\\",\\n  \\\"license\\\": \\\"\\\",\\n  \\\"dependencies\\\": {\\n    // 依赖的so\\n    \\\"libentry.so\\\": \\\"file:./src/main/cpp/types/libentry\\\"\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "import本模块的so",
        "parent_text": "import本模块的so配置依赖： 模块根目录 > oh-package.json5。  依赖文件中的so名称要与CMakests.txt文件中的模块名称一致。 模块根目录 > src > main > cpp > CMakeLists.txt # the minimum version of CMake.\\ncmake_minimum_required(VERSION 3.4.1)\\nproject(MyApplication14)\\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\\nif(DEFINED PACKAGE_FIND_FILE)\\n    include(${PACKAGE_FIND_FILE})\\nendif()\\ninclude_directories(${NATIVERENDER_ROOT_PATH}\\n                    ${NATIVERENDER_ROOT_PATH}/include)\\n\\n# 声明一个产物libentry.so，SHARED表示产物为动态库，hello.cpp为产物的源代码              \\nadd_library(entry SHARED napi_init.cpp)\\n\\n# 声明产物entry链接时需要的三方库libace_napi.z.so\\ntarget_link_libraries(entry PUBLIC libace_napi.z.so) 引用native方法： 引用依赖的so，名称要与oh-package.json5中的一致。 import { hilog } from '@kit.PerformanceAnalysisKit';\\n// import依赖的so\\nimport testNapi from 'libentry.so';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n          .onClick(() => {\\n            // 调用native方法\\n            hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.add(2, 3));\\n          })\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n} 调用的方法名称要和.d.ts中导出的方法名一致。 模块根目录 > src > main > cpp > types > libentry > index.d.ts export const add: (a: number, b: number) => number; ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section3822175519414\\\"'><a name='\\\"section3822175519414\\\"'></a><a name='\\\"section3822175519414\\\"'></a><h4>import本模块的so</h4><p><strong>配置依赖</strong>：</p> <p>模块根目录 &gt; oh-package.json5。</p>  <p>依赖文件中的so名称要与CMakests.txt文件中的模块名称一致。</p> <p>模块根目录 &gt; src &gt; main &gt; cpp &gt; CMakeLists.txt</p> <pre class='\\\"screen\\\"'># the minimum version of CMake.\\ncmake_minimum_required(VERSION 3.4.1)\\nproject(MyApplication14)\\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\\nif(DEFINED PACKAGE_FIND_FILE)\\n    include(${PACKAGE_FIND_FILE})\\nendif()\\ninclude_directories(${NATIVERENDER_ROOT_PATH}\\n                    ${NATIVERENDER_ROOT_PATH}/include)\\n\\n# 声明一个产物libentry.so，SHARED表示产物为动态库，hello.cpp为产物的源代码              \\nadd_library(entry SHARED napi_init.cpp)\\n\\n# 声明产物entry链接时需要的三方库libace_napi.z.so\\ntarget_link_libraries(entry PUBLIC libace_napi.z.so)</pre> <p><strong>引用native方法</strong>：</p> <p>引用依赖的so，名称要与oh-package.json5中的一致。</p> <pre class='\\\"screen\\\"'>import { hilog } from '@kit.PerformanceAnalysisKit';\\n// import依赖的so\\nimport testNapi from 'libentry.so';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n          .onClick(() =&gt; {\\n            // 调用native方法\\n            hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', testNapi.add(2, 3));\\n          })\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}</pre> <p>调用的方法名称要和.d.ts中导出的方法名一致。</p> <p>模块根目录 &gt; src &gt; main &gt; cpp &gt; types &gt; libentry &gt; index.d.ts</p> <pre class='\\\"screen\\\"'>export const add: (a: number, b: number) =&gt; number;</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-stability-coding-standard-ndk-arkts.html"
    },
    {
        "id": 284,
        "pre": "{\\n  \\\"name\\\": \\\"entry\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"Please describe the basic information.\\\",\\n  \\\"main\\\": \\\"\\\",\\n  \\\"author\\\": \\\"\\\",\\n  \\\"license\\\": \\\"\\\",\\n  \\\"dependencies\\\": {\\n    // 依赖当前工程下的其它模块\\n    \\\"library\\\": \\\"file:../library\\\"\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]引用方模块",
        "parent_text": "[h2]引用方模块本地依赖： 模块根目录 > oh-package.json5  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1369811291443\\\"'><a name='\\\"section1369811291443\\\"'></a><a name='\\\"section1369811291443\\\"'></a><h4>[h2]引用方模块</h4><p><strong>本地依赖</strong>：</p> <p>模块根目录 &gt; oh-package.json5</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-stability-coding-standard-ndk-arkts.html"
    },
    {
        "id": 285,
        "pre": "Swiper() {\\n  LazyForEach(this.bannerDataSource, (item: Banner, index: number) => {\\n    // ...\\n    Image(item.getBannerImg().getImgSrc())\\n      .objectFit(ImageFit.Fill)\\n      .borderRadius(16)\\n      .height('100%')\\n      .width('100%')\\n      .focusable(true)\\n      .zIndex(1)\\n    // ...\\n  }, (item: Banner, index: number) => index + JSON.stringify(item))\\n}\\n.tabIndex(getTabIndex('Banner'))",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]焦点导航事件适配",
        "parent_text": "[h2]焦点导航事件适配当用户使用键盘、电视遥控器、车机摇杆/旋钮等非指向性输入设备与应用程序进行间接交互时，为保证交互体验，建议设置页面中可操作元素为可获焦状态，并为其配置获焦视觉效果。 获焦：当组件获焦时，遵循子组件优先原则。若子组件需要获焦，其祖先组件均需处于可获焦状态。若容器组件需要获焦，其子组件需处于不可获焦状态，并给容器组件配置点击事件。部分组件默认可获焦，如Button、TextInput等基础组件和Column、Row等大部分的容器组件；若组件有获焦能力但默认不可获焦，如Text、Image等组件，可以设置通用属性focusable(true)使其可获焦。 走焦：触发走焦时，系统会遍历组件树中可走焦的组件，在走焦时，不同按键触发不同的走焦逻辑。如TAB键走焦遵循Z字型遍历逻辑；方向键遵循十字型移动逻辑。除了系统默认的走焦逻辑外，开发者可以通过tabIndex自定义走焦逻辑。 更多焦点事件的能力和规范请参考焦点事件，自定义组件的走焦效果请参考焦点控制。 走焦常用属性  参数  描述    focusable  boolean  设置当前组件是否可以获焦   tabIndex  number  自定义组件Tab键走焦顺序值   defaultFocus  boolean  设置当前组件是否为当前页面上的默认焦点      ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1080384943819\\\"'><a name='\\\"section1080384943819\\\"'></a><a name='\\\"section1080384943819\\\"'></a><h4>[h2]焦点导航事件适配</h4><p>当用户使用键盘、电视遥控器、车机摇杆/旋钮等非指向性输入设备与应用程序进行间接交互时，为保证交互体验，建议设置页面中可操作元素为可获焦状态，并为其配置获焦视觉效果。</p> <ul><li>获焦：当组件获焦时，遵循子组件优先原则。若子组件需要获焦，其祖先组件均需处于可获焦状态。若容器组件需要获焦，其子组件需处于不可获焦状态，并给容器组件配置点击事件。<p>部分组件默认可获焦，如Button、TextInput等基础组件和Column、Row等大部分的容器组件；若组件有获焦能力但默认不可获焦，如Text、Image等组件，可以设置通用属性focusable(true)使其可获焦。</p> </li><li>走焦：触发走焦时，系统会遍历组件树中可走焦的组件，在走焦时，不同按键触发不同的走焦逻辑。如TAB键走焦遵循Z字型遍历逻辑；方向键遵循十字型移动逻辑。除了系统默认的走焦逻辑外，开发者可以通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#tabindex9\\\"' target='\\\"_blank\\\"'>tabIndex</a>自定义走焦逻辑。</li></ul> <p>更多焦点事件的能力和规范请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-events-focus-event\\\"' target='\\\"_blank\\\"'>焦点事件</a>，自定义组件的走焦效果请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus\\\"' target='\\\"_blank\\\"'>焦点控制</a>。</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.5.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"19.68%\\\"'><p><strong>走焦常用属性</strong></p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.5.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"22.33%\\\"'><p><strong>参数</strong></p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.5.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"57.989999999999995%\\\"'><p><strong>描述</strong></p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.68%\\\"'><p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#focusable\\\"' target='\\\"_blank\\\"'>focusable</a></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.33%\\\"'><p>boolean</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"57.989999999999995%\\\"'><p>设置当前组件是否可以获焦</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.68%\\\"'><p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#tabindex9\\\"' target='\\\"_blank\\\"'>tabIndex</a></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.33%\\\"'><p>number</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"57.989999999999995%\\\"'><p>自定义组件Tab键走焦顺序值</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.68%\\\"'><p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-focus#defaultfocus9\\\"' target='\\\"_blank\\\"'>defaultFocus</a></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.33%\\\"'><p>boolean</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"57.989999999999995%\\\"'><p>设置当前组件是否为当前页面上的默认焦点</p> </td> </tr> </tbody></table> </div>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-interaction.html"
    },
    {
        "id": 286,
        "pre": "import { util } from '@kit.ArkTS';\\n\\nexport class LRUCacheUtil {\\n  private static instance: LRUCacheUtil;\\n  private lruCache: util.LRUCache<string, Object>;\\n\\n  private constructor() {\\n    this.lruCache = new util.LRUCache(64);\\n  }\\n\\n  // 获取LRUCacheUtil的单例\\n  public static getInstance(): LRUCacheUtil {\\n    if (!LRUCacheUtil.instance) {\\n      LRUCacheUtil.instance = new LRUCacheUtil();\\n    }\\n    return LRUCacheUtil.instance;\\n  }\\n\\n  // 判断lruCache缓存是否为空\\n  public isEmpty(): boolean {\\n    return this.lruCache.isEmpty();\\n  }\\n\\n  // 获取lruCache的容量\\n  public getCapacity(): number {\\n    return this.lruCache.getCapacity();\\n  }\\n\\n  // 重新设置lruCache的容量\\n  public updateCapacity(newCapacity: number) {\\n    this.lruCache.updateCapacity(newCapacity);\\n  }\\n\\n  // 添加缓存到lruCache中\\n  public putCache(key: string, value: Object) {\\n    this.lruCache.put(key, value);\\n  }\\n\\n  // 删除key对应的缓存\\n  public remove(key: string) {\\n    this.lruCache.remove(key);\\n  }\\n\\n  // 获取key对应的缓存\\n  public getCache(key: string): Object | undefined {\\n    return this.lruCache.get(key);\\n  }\\n\\n  // 判断是否包含key对应的缓存\\n  public contains(key: string): boolean {\\n    return this.lruCache.contains(key);\\n  }\\n\\n  // 清除缓存数据，并重置lruCache的大小\\n  public clearCache() {\\n    this.lruCache.clear();\\n    this.lruCache.updateCapacity(64);\\n  }\\n}",
        "type": "Reference",
        "function_call": "onDestroy(): void",
        "function_name": "[h2]参考案例",
        "parent_text": "[h2]参考案例缓存工具类可以被设计成一个工具类，其中包含LRUCache单例以及一些操作LRUCache的方法，如添加数据、获取数据、删除数据等。通过创建一个静态方法来获取LRUCache实例，并在内部进行实例化，可以保证全局只有一个LRUCache对象。通过缓存工具类，各组件之间可以方便地共享缓存数据，避免重复创建缓存实例和数据冗余。这样不仅可以提高系统的性能和效率，还可以减少内存占用和提升数据访问速度。  在对应的组件中设置缓存，示例代码如下所示： import { LRUCacheUtil } from '../utils/LRUCacheUtil';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n\\n  aboutToAppear(): void {\\n    let lruCache = LRUCacheUtil.getInstance();\\n    // 添加一个<key, value>到lrucache\\n    lruCache.putCache('nation',10); \\n    // 再添加一个<key, value>到lrucache\\n    lruCache.putCache('menu',8); \\n    // 通过key查询value\\n    let result0 = lruCache.getCache('2') as number;  \\n    console.log('result0:' + result0);\\n    // 从当前缓冲区中删除指定的键及其关联的值\\n    let result1 = lruCache.remove('2');  \\n    console.log('result1:' + result1);\\n    // 检查当前缓冲区是否包含指定的对象\\n    let result2 = lruCache.contains('1');  \\n    console.log('result2:' + result2);\\n    // 设置新的容量大小\\n    let result4 = lruCache.updateCapacity(110);  \\n    console.log('result4:' + result4);\\n  }\\n\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n} 同时，可以通过onMemoryLevel监听内存的变化，进而设置对应清理缓存的机制，示例代码如下所示： import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { window } from '@kit.ArkUI';\\nimport { LRUCacheUtil } from '../utils/LRUCacheUtil';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // 监听内存的变化\\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\\n    // 根据内存的变化执行内存管理策略\\n    if (level === AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL) {\\n      console.log('The memory of device is critical, release memory.');\\n      if (!LRUCacheUtil.getInstance().isEmpty()) {\\n        LRUCacheUtil.getInstance().clearCache();\\n      }\\n    }\\n  }\\n  \\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\\n  }\\n\\n  onDestroy(): void {\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');\\n  }\\n  ...\\n}; ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section9416157970\\\"'><a name='\\\"section9416157970\\\"'></a><a name='\\\"section9416157970\\\"'></a><h4>[h2]参考案例</h4><p>缓存工具类可以被设计成一个工具类，其中包含LRUCache单例以及一些操作LRUCache的方法，如添加数据、获取数据、删除数据等。通过创建一个静态方法来获取LRUCache实例，并在内部进行实例化，可以保证全局只有一个LRUCache对象。通过缓存工具类，各组件之间可以方便地共享缓存数据，避免重复创建缓存实例和数据冗余。这样不仅可以提高系统的性能和效率，还可以减少内存占用和提升数据访问速度。</p>  <p>在对应的组件中设置缓存，示例代码如下所示：</p> <pre class='\\\"screen\\\"'>import { LRUCacheUtil } from '../utils/LRUCacheUtil';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State message: string = 'Hello World';\\n\\n  aboutToAppear(): void {\\n    let lruCache = LRUCacheUtil.getInstance();\\n    // 添加一个&lt;key, value&gt;到lrucache\\n    lruCache.putCache('nation',10); \\n    // 再添加一个&lt;key, value&gt;到lrucache\\n    lruCache.putCache('menu',8); \\n    // 通过key查询value\\n    let result0 = lruCache.getCache('2') as number;  \\n    console.log('result0:' + result0);\\n    // 从当前缓冲区中删除指定的键及其关联的值\\n    let result1 = lruCache.remove('2');  \\n    console.log('result1:' + result1);\\n    // 检查当前缓冲区是否包含指定的对象\\n    let result2 = lruCache.contains('1');  \\n    console.log('result2:' + result2);\\n    // 设置新的容量大小\\n    let result4 = lruCache.updateCapacity(110);  \\n    console.log('result4:' + result4);\\n  }\\n\\n  build() {\\n    Row() {\\n      Column() {\\n        Text(this.message)\\n          .fontSize(50)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}</pre> <p>同时，可以通过onMemoryLevel监听内存的变化，进而设置对应清理缓存的机制，示例代码如下所示：</p> <pre class='\\\"screen\\\"'>import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { window } from '@kit.ArkUI';\\nimport { LRUCacheUtil } from '../utils/LRUCacheUtil';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // 监听内存的变化\\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\\n    // 根据内存的变化执行内存管理策略\\n    if (level === AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL) {\\n      console.log('The memory of device is critical, release memory.');\\n      if (!LRUCacheUtil.getInstance().isEmpty()) {\\n        LRUCacheUtil.getInstance().clearCache();\\n      }\\n    }\\n  }\\n  \\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\\n  }\\n\\n  onDestroy(): void {\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');\\n  }\\n  ...\\n};</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-memory-optimization.html"
    },
    {
        "id": 287,
        "pre": "import { connection } from '@kit.NetworkKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\nimport { CommonConstant as Const } from '../common/Constant';\\nimport { promptAction } from '@kit.ArkUI';\\nimport { Logger } from '../utils/Logger';\\n\\n@Entry\\n@Component\\nstruct Index {\\n  @State networkId: string = Const.NETWORK_ID;\\n  @State netMessage: string = Const.INIT_NET_MESSAGE;\\n  @State connectionMessage: string = Const.INIT_CONNECTION_MESSAGE;\\n  @State netStateMessage: string = '';\\n  @State hostName: string = '';\\n  @State ip: string = '';\\n  private controller: TabsController = new TabsController();\\n  private netHandle: connection.NetHandle | null = null;\\n  private netCon: connection.NetConnection | null = null;\\n  scroller: Scroller = new Scroller();\\n\\n  aboutToDisappear(): void {\\n    // unregister NetConnection\\n    this.unUseNetworkRegister;\\n  }\\n\\n  build() {\\n    Column() {\\n      Text($r('app.string.network_title'))\\n        .fontSize($r('app.float.title_font_size'))\\n        .fontWeight(FontWeight.Bold)\\n        .textAlign(TextAlign.Start)\\n        .margin({ left: Const.WebConstant_TEN_PERCENT })\\n        .width(Const.WebConstant_FULL_WIDTH)\\n\\n      Column() {\\n        Row() {\\n          Text(Const.MONITOR_TITLE)\\n            .fontSize($r('app.float.font_size'))\\n            .margin($r('app.float.md_padding_margin'))\\n            .fontWeight(FontWeight.Medium)\\n          Blank()\\n          Toggle({ type: ToggleType.Switch, isOn: false })\\n            .selectedColor(Color.Blue)\\n            .margin({ right: $r('app.float.md_padding_margin') })\\n            .width($r('app.float.area_width'))\\n            .height(Const.WebConstant_BUTTON_HEIGHT)\\n            .onChange((isOn) => {\\n              if (isOn) {\\n                this.useNetworkRegister();\\n              } else {\\n                this.unUseNetworkRegister();\\n              }\\n            })\\n        }\\n        .height($r('app.float.button_height'))\\n        .borderRadius($r('app.float.md_border_radius'))\\n        .margin({ left: $r('app.float.md_padding_margin'), right: $r('app.float.md_padding_margin') })\\n        .width(Const.WebConstant_NINETY_PERCENT)\\n        .backgroundColor($r('app.color.text_background'))\\n\\n        TextArea({ text: this.netStateMessage })\\n          .fontSize($r('app.float.font_size'))\\n          .width(Const.WebConstant_NINETY_PERCENT)\\n          .height(Const.WebConstant_FIVE_HUNDRED)\\n          .margin($r('app.float.md_padding_margin'))\\n          .borderRadius($r('app.float.md_border_radius'))\\n          .textAlign(TextAlign.Start)\\n          .focusOnTouch(false)\\n\\n        Button($r('app.string.clear'))\\n          .fontSize($r('app.float.font_size'))\\n          .width(Const.WebConstant_NINETY_PERCENT)\\n          .height($r('app.float.area_height'))\\n          .margin({\\n            left: $r('app.float.md_padding_margin'),\\n            right: $r('app.float.md_padding_margin'),\\n            bottom: $r('app.float.xxl_padding_margin')\\n          })\\n          .onClick(() => {\\n            this.netStateMessage = '';\\n          })\\n        Blank()\\n      }\\n      .height(Const.WebConstant_FULL_HEIGHT)\\n      .justifyContent(FlexAlign.Start)\\n    }\\n    .width(Const.WebConstant_FULL_WIDTH)\\n  }\\n\\n  getConnectionProperties() {\\n    connection.getDefaultNet().then((netHandle: connection.NetHandle) => {\\n      connection.getConnectionProperties(netHandle, (error: BusinessError, connectionProperties: connection.ConnectionProperties) => {\\n        if (error) {\\n          this.connectionMessage = Const.CONNECTION_PROPERTIES_ERROR;\\n          Logger.error('getConnectionProperties error:' + error.code + error.message);\\n          return;\\n        }\\n        this.connectionMessage = Const.CONNECTION_PROPERTIES_INTERFACE_NAME + connectionProperties.interfaceName\\n          + Const.CONNECTION_PROPERTIES_DOMAINS + connectionProperties.domains\\n          + Const.CONNECTION_PROPERTIES_LINK_ADDRESSES + JSON.stringify(connectionProperties.linkAddresses)\\n          + Const.CONNECTION_PROPERTIES_ROUTES + JSON.stringify(connectionProperties.routes)\\n          + Const.CONNECTION_PROPERTIES_LINK_ADDRESSES + JSON.stringify(connectionProperties.dnses)\\n          + Const.CONNECTION_PROPERTIES_MTU + connectionProperties.mtu + '\\\\n';\\n      })\\n    });\\n  }\\n\\n  useNetworkRegister() {\\n    this.netCon = connection.createNetConnection();\\n    this.netStateMessage += Const.REGISTER_NETWORK_LISTENER;\\n    this.netCon.register((error) => {\\n      if (error) {\\n        Logger.error('register error:' + error.message);\\n        return;\\n      }\\n      promptAction.showToast({\\n        message: Const.REGISTER_NETWORK_LISTENER_MESSAGE,\\n        duration: 1000\\n      });\\n    })\\n    this.netCon.on('netAvailable', (netHandle) => {\\n      this.netStateMessage += Const.NET_AVAILABLE + netHandle.netId + '\\\\n';\\n    })\\n    this.netCon.on('netBlockStatusChange', (data) => {\\n      this.netStateMessage += Const.NET_BLOCK_STATUS_CHANGE + data.netHandle.netId + '\\\\n';\\n    })\\n    this.netCon.on('netCapabilitiesChange', (data) => {\\n      this.netStateMessage += Const.NET_CAPABILITIES_CHANGE_ID + data.netHandle.netId\\n        + Const.NET_CAPABILITIES_CHANGE_CAP + JSON.stringify(data.netCap) + '\\\\n';\\n    })\\n    this.netCon.on('netConnectionPropertiesChange', (data) => {\\n      this.netStateMessage += Const.NET_CONNECTION_PROPERTIES_CHANGE_ID + data.netHandle.netId\\n        + Const.NET_CONNECTION_PROPERTIES_CHANGE_CONNECTION_PROPERTIES + JSON.stringify(data.connectionProperties) + '\\\\n';\\n    })\\n  }\\n\\n  unUseNetworkRegister() {\\n    if (this.netCon) {\\n      this.netCon.unregister((error: BusinessError) => {\\n        if (error) {\\n          Logger.error('unregister error:' + error.message);\\n          return;\\n        }\\n        promptAction.showToast({\\n          message: Const.UNREGISTER_NETWORK_LISTENER_MESSAGE,\\n          duration: 1000\\n        });\\n        this.netStateMessage += Const.UNREGISTER_NETWORK_LISTENER;\\n      })\\n    } else {\\n      this.netStateMessage += Const.UNREGISTER_NETWORK_LISTENER_FAIL;\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]aboutToDisappear中销毁订阅事件",
        "parent_text": "[h2]aboutToDisappear中销毁订阅事件aboutToDisappear函数会在组件析构销毁之前执行。如下案例所示，在使用完网络管理的网络连接模块后，取消订阅默认网络状态变化的通知。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section9442572819\\\"'><a name='\\\"section9442572819\\\"'></a><a name='\\\"section9442572819\\\"'></a><h4>[h2]aboutToDisappear中销毁订阅事件</h4><p>aboutToDisappear函数会在组件析构销毁之前执行。如下案例所示，在使用完网络管理的网络连接模块后，取消订阅默认网络状态变化的通知。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-memory-optimization.html"
    },
    {
        "id": 288,
        "pre": "# the minimum version of CMake.\\ncmake_minimum_required(VERSION 3.4.1)\\nproject(MyNativeApplication)\\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\\nif(DEFINED PACKAGE_FIND_FILE)\\n    include(${PACKAGE_FIND_FILE})\\nendif()\\ninclude_directories(${NATIVERENDER_ROOT_PATH}\\n                    ${NATIVERENDER_ROOT_PATH}/include)\\nadd_library(entry SHARED napi_init.cpp)\\n# 引入libpurgeable_memory_ndk.z.so动态链接库\\ntarget_link_libraries(entry PUBLIC libace_napi.z.so libpurgeable_memory_ndk.z.so)",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]参考案例",
        "parent_text": "[h2]参考案例在CMakeLists.txt文件中引入Purgeable对应的动态链接库libpurgeable_memory_ndk.z.so，具体如下所示：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section173236818225\\\"'><a name='\\\"section173236818225\\\"'></a><a name='\\\"section173236818225\\\"'></a><h4>[h2]参考案例</h4><p>在CMakeLists.txt文件中引入Purgeable对应的动态链接库libpurgeable_memory_ndk.z.so，具体如下所示：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-memory-optimization.html"
    },
    {
        "id": 289,
        "pre": "    Column() {\\n      Image($r('app.media.image'))\\n        .width(\\\"500px\\\")\\n        .height(\\\"500px\\\")\\n    }",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]避免加载超过显示尺寸的图片",
        "parent_text": "[h2]避免加载超过显示尺寸的图片 如上代码示例中，使用500*500尺寸大小的Image组件加载一张尺寸为4032*3024的RGBA格式图片时（每个像素占用4个字节），图片申请了约46.5M的内存。这是因为图片的原始尺寸较大，加载到Image组件中时需要将其缩放到500*500的尺寸，这个过程会占用一定的内存空间。 可使用公式计算出来纹理图片内存大小 = imageWidth x imageHeight x format（4032*3024 * 4 = 48771072 bytes ≈ 46.5M）。 但是实际上，组件只需要500*500的尺寸。也就是说，实际需要的内存 = 500*500*4 ≈ 1M。  因此当一张图片比控件显示的区域要大，最终会被裁剪或者缩放。大量的裁剪和缩放不仅导致视图效果变差，还会浪费内存，引起严重的功耗问题。为了最大程度地节省内存，开发者可以手动调整源文件的尺寸大小，使其与组件的大小保持一致。这样可以避免不必要的内存浪费，并提高应用程序的性能和效率。开发者可以使用图像处理工具来调整图像的尺寸大小，从而进一步节省内存空间。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section932653132411\\\"'><a name='\\\"section932653132411\\\"'></a><a name='\\\"section932653132411\\\"'></a><h4>[h2]避免加载超过显示尺寸的图片</h4> <p>如上代码示例中，使用500*500尺寸大小的Image组件加载一张尺寸为4032*3024的RGBA格式图片时（每个像素占用4个字节），图片申请了约46.5M的内存。这是因为图片的原始尺寸较大，加载到Image组件中时需要将其缩放到500*500的尺寸，这个过程会占用一定的内存空间。</p> <p>可使用公式计算出来纹理图片内存大小 = imageWidth x imageHeight x format（4032*3024 * 4 = 48771072 bytes ≈ 46.5M）。</p> <p>但是实际上，组件只需要500*500的尺寸。也就是说，实际需要的内存 = 500*500*4 ≈ 1M。</p> <p><span><img height='\\\"345.93300000000005\\\"' originheight='\\\"891\\\"' originwidth='\\\"1336\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161218.00317281746197321753381909146585:50001231000000:2800:FF8A39A777935B868071A1AA5E7C61ACE4F4F28AE92FABBAAAD06CD447ED7DDC.png\\\"' title='\\\"点击放大\\\"' width='\\\"518.7\\\"'/></span></p> <p>因此当一张图片比控件显示的区域要大，最终会被裁剪或者缩放。大量的裁剪和缩放不仅导致视图效果变差，还会浪费内存，引起严重的功耗问题。为了最大程度地节省内存，开发者可以手动调整源文件的尺寸大小，使其与组件的大小保持一致。这样可以避免不必要的内存浪费，并提高应用程序的性能和效率。开发者可以使用图像处理工具来调整图像的尺寸大小，从而进一步节省内存空间。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-memory-optimization.html"
    },
    {
        "id": 290,
        "pre": "// src/main/ets/view/ScrollSnapshot.ets\\n@Component\\nexport struct ScrollSnapshot {\\n  private scroller: Scroller = new Scroller();\\n  private listComponentWidth: number = 0;\\n  private listComponentHeight: number = 0;\\n  // The current offset of the List component\\n  private curYOffset: number = 0;\\n  // Value of each scroll\\n  private scrollHeight: number = 0;\\n\\n  // ...\\n  build() {\\n    // ...\\n    Stack() {\\n      // ...\\n      // 1.1 Bind the Scroller controller to the list scrolling component and define the customized ID.\\n      List({\\n        scroller: this.scroller\\n      })// ...\\n        .id(LIST_ID)\\n          // 1.2 Obtains the scrolling offset.\\n        .onDidScroll(() => {\\n          this.curYOffset = this.scroller.currentOffset().yOffset;\\n        })\\n        .onAreaChange((oldValue, newValue) => {\\n          // 1.3 Obtains the width and height of a component.\\n          this.listComponentWidth = newValue.width as number;\\n          this.listComponentHeight = newValue.height as number;\\n        })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "利用onAreaChange()",
        "function_name": null,
        "parent_text": "给List绑定滚动控制器，添加监听事件。1.1 为List滚动组件绑定Scroller控制器，以控制其滚动行为，并给List组件绑定自定义的id。 1.2 通过onDidScroll()方法实时监听并获取滚动偏移量，确保截图拼接位置的准确性。 1.3 同时，利用onAreaChange()事件获取List组件的尺寸，以便精确计算截图区域的大小。  ",
        "import_module": null,
        "parent": "<li>给List绑定滚动控制器，添加监听事件。<p>1.1 为List滚动组件绑定Scroller控制器，以控制其滚动行为，并给List组件绑定自定义的id。</p> <p>1.2 通过onDidScroll()方法实时监听并获取滚动偏移量，确保截图拼接位置的准确性。</p> <p>1.3 同时，利用onAreaChange()事件获取List组件的尺寸，以便精确计算截图区域的大小。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-long-snapshot-practice.html"
    },
    {
        "id": 291,
        "pre": "// src/main/ets/view/ScrollSnapshot.ets\\n@Component\\nexport struct ScrollSnapshot {\\n  // The current offset of the List component\\n  private curYOffset: number = 0;\\n  // Backup component location before screenshot\\n  private yOffsetBefore: number = 0;\\n  // is click to stop scroll\\n  private isClickStop: boolean = false;\\n  @State isEnableScroll: boolean = true;\\n  // ...\\n  // Scrolling Screenshot Entry Function\\n  async scrollSnapshot() {\\n    // The settings list cannot be manually scrolled during the screenshot process\\n    // to avoid interference with the screenshot\\n    this.isEnableScroll = false;\\n    // Saves the current location of the component for recovery\\n    this.yOffsetBefore = this.curYOffset;\\n    await this.scrollSnapAndMerge();\\n    // ...\\n    this.isEnableScroll = true;\\n    this.isClickStop = false;\\n  }\\n\\n  build() {\\n    // ...\\n    List({\\n      scroller: this.scroller\\n    })//...\\n      .id(LIST_ID)\\n      .onClick(() => {\\n        // Click on the list to stop scrolling\\n        if (!this.isEnableScroll) {\\n          this.scroller.scrollBy(0, 0);\\n          this.isClickStop = true;\\n        }\\n      })\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在截图滚动的过程中，为了防止用户手动滚动对截图产生干扰，应禁用列表的手动滚动功能。可以通过设置List组件的enableScrollInteraction属性来控制是否允许手动滚动。当准备开始截图时，将isEnableScroll设置为false以禁用滚动交互。而当用户点击列表项以确定截图结束位置时，使用scroller.scrollBy(0, 0)方法确保列表立即停止滑动。  ",
        "import_module": null,
        "parent": "<li>在截图滚动的过程中，为了防止用户手动滚动对截图产生干扰，应禁用列表的手动滚动功能。可以通过设置List组件的enableScrollInteraction属性来控制是否允许手动滚动。<p>当准备开始截图时，将isEnableScroll设置为false以禁用滚动交互。而当用户点击列表项以确定截图结束位置时，使用scroller.scrollBy(0, 0)方法确保列表立即停止滑动。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-long-snapshot-practice.html"
    },
    {
        "id": 292,
        "pre": "import { window } from '@kit.ArkUI';\\n\\n@Component\\nexport struct MotionBlur {\\n  @Consume('navPathStack') navPathStack: NavPathStack;\\n  @State isShowMotionBlur: boolean = false;\\n  @State bottomSafeHeight: number = 0; // bottom navigation bar height\\n\\n  aboutToAppear() {\\n    window.getLastWindow(getContext(this), (err, windowBar) => {\\n      if (err.code) {\\n        return;\\n      }\\n      // get the height of the bottom navigation bar\\n      this.bottomSafeHeight =\\n        px2vp(windowBar.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR).bottomRect.height);\\n      windowBar.setWindowLayoutFullScreen(true);\\n    });\\n  }\\n\\n  // modal page with dynamically blurred image settings\\n  @Builder\\n  motionBlurBuilder() {\\n    Stack({ alignContent: Alignment.Bottom }) {\\n      Image($r('app.media.test'))\\n        .width('100%')\\n        .height('100%')\\n        .objectFit(ImageFit.Fill)\\n        .blur(13) // add motion blur effect\\n      Button('close')\\n        .width('90%')\\n        .height(40)\\n        .margin({ bottom: this.bottomSafeHeight + 16 })\\n        .onClick(() => {\\n          this.isShowMotionBlur = false;\\n        })\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Button('motion blur')\\n          .width('90%')\\n          .height(40)\\n          .onClick(() => {\\n            this.isShowMotionBlur = true;\\n          })\\n          .bindContentCover(this.isShowMotionBlur, this.motionBlurBuilder(), {\\n            modalTransition: ModalTransition.DEFAULT\\n          })\\n      }\\n      .padding({ bottom: this.bottomSafeHeight + 16 })\\n      .width('100%')\\n      .height('100%')\\n      .justifyContent(FlexAlign.End)\\n    }\\n    .hideTitleBar(true)\\n  }\\n}",
        "type": "Reference",
        "function_call": "staticBlurBuilder()",
        "function_name": "场景示例",
        "parent_text": "场景示例下面将在常见的“转场结合图片模糊”的应用场景下（全屏模态转场拉起一个图片设置模糊的模态页面)，分别采用动态模糊和静态模糊，进行性能分析对比。需要说明，由于静态模糊和动态模糊底层采用的算法不同，动态模糊blur和静态模糊blur设置的模糊半径数值并不等效。为了从效果一致性的维度来更准确的比较两者的性能差异，这里将动态模糊和静态模糊场景的模糊半径的数值尽可能的调整到类似的模糊效果来进行对比。动态模糊blur设置13，静态模糊blur设置3的图片模糊效果较为接近，作为本例中效果一致性较为近似的等效条件。 下面是使用动态模糊对图片进行模糊处理的场景示例。通过直接对Image组件设置blur，为Image添加模糊效果。  图1 动态模糊 下面是使用静态模糊对图片进行模糊处理的场景示例。主要步骤如下： 通过createPixelMap创建图片的PixelMap。通过createEffect创建Filter实例。通过Filter图像效果类中的blur，为Image添加模糊效果。 import { image } from '@kit.ImageKit';\\nimport { effectKit } from '@kit.ArkGraphics2D';\\nimport { window } from '@kit.ArkUI';\\n\\n@Component\\nexport struct StaticBlur {\\n  @Consume('navPathStack') navPathStack: NavPathStack;\\n  @State isShowStaticBlur: boolean = false;\\n  @State pixelMap: image.PixelMap | undefined = undefined;\\n  @State imgSource: image.ImageSource | undefined = undefined;\\n  @State bottomSafeHeight: number = 0; // bottom navigation bar height\\n\\n  aboutToAppear() {\\n    window.getLastWindow(getContext(this), (err, windowBar) => {\\n      if (err.code) {\\n        return;\\n      }\\n      // get the height of the bottom navigation bar\\n      this.bottomSafeHeight =\\n        px2vp(windowBar.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR).bottomRect.height);\\n      windowBar.setWindowLayoutFullScreen(true);\\n    });\\n  }\\n\\n  async staticBlur() {\\n    let context = getContext(this);\\n    let resourceMgr = context.resourceManager; // retrieve the resourceManager object\\n    const fileData = await resourceMgr.getRawFileContent('test.png'); // retrieve images from the rawfile directory\\n    let buffer: ArrayBuffer = fileData.buffer.slice(0); // create an ArrayBuffer instance\\n    this.imgSource = image.createImageSource(buffer); // create an image source instance\\n    // create attributes for pixels\\n    let opts: image.InitializationOptions = {\\n      editable: true, // is it editable\\n      pixelFormat: 3, // pixel format. 3 represents RGBA_8888\\n      size: {\\n        // create image size\\n        height: 4,\\n        width: 6\\n      }\\n    };\\n    // create PixelMap\\n    await this.imgSource.createPixelMap(opts).then((pixelMap: image.PixelMap) => {\\n      const blurRadius = 3;\\n      let headFilter = effectKit.createEffect(pixelMap); // create Filter Instance\\n      if (headFilter !== null) {\\n        headFilter.blur(blurRadius); // set static blur. Add the blur effect to the effect list\\n        // retrieve the image of the source image with the added linked list effect PixelMap\\n        headFilter.getEffectPixelMap().then((pixelMap: image.PixelMap) => {\\n          this.pixelMap = pixelMap;\\n        });\\n      }\\n    })\\n  }\\n\\n  @Builder\\n  staticBlurBuilder() {\\n    Stack({ alignContent: Alignment.Bottom }) {\\n      Image(this.pixelMap)\\n        .width('100%')\\n        .height('100%')\\n        .objectFit(ImageFit.Fill)\\n      Button('close')\\n        .width('90%')\\n        .height(40)\\n        .margin({ bottom: this.bottomSafeHeight + 16 })\\n        .onClick(() => {\\n          this.isShowStaticBlur = false;\\n        })\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Button('static blur')\\n          .width('90%')\\n          .height(40)\\n          .onClick(() => {\\n            this.isShowStaticBlur = true;\\n            // set static blur\\n            this.staticBlur();\\n          })\\n          .bindContentCover(this.isShowStaticBlur, this.staticBlurBuilder(), {\\n            modalTransition: ModalTransition.DEFAULT\\n          })\\n      }\\n      .padding({ bottom: this.bottomSafeHeight + 16 })\\n      .width('100%')\\n      .height('100%')\\n      .justifyContent(FlexAlign.End)\\n    }\\n    .hideTitleBar(true)\\n  }\\n} 图2 静态模糊  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section12935191712615\\\"'><a name='\\\"section12935191712615\\\"'></a><a name='\\\"section12935191712615\\\"'></a><h4>场景示例</h4><p>下面将在常见的“转场结合图片模糊”的应用场景下（全屏模态转场拉起一个图片设置模糊的模态页面)，分别采用动态模糊和静态模糊，进行性能分析对比。需要说明，由于静态模糊和动态模糊底层采用的算法不同，动态模糊blur和静态模糊blur设置的模糊半径数值并不等效。为了从效果一致性的维度来更准确的比较两者的性能差异，这里将动态模糊和静态模糊场景的模糊半径的数值尽可能的调整到类似的模糊效果来进行对比。动态模糊blur设置13，静态模糊blur设置3的图片模糊效果较为接近，作为本例中效果一致性较为近似的等效条件。</p> <p>下面是使用动态模糊对图片进行模糊处理的场景示例。通过直接对Image组件设置blur，为Image添加模糊效果。</p>  <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图1 </b>动态模糊</span><br/><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161038.61765766538445028843088901369863:50001231000000:2800:A244B91A520471492ACA2537C7C694D028B8D5E3D8911D0E3AE201C139FFAD13.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></div> <p>下面是使用静态模糊对图片进行模糊处理的场景示例。主要步骤如下：</p> <ol><li>通过createPixelMap创建图片的PixelMap。</li><li>通过createEffect创建Filter实例。</li><li>通过Filter图像效果类中的blur，为Image添加模糊效果。</li></ol> <pre class='\\\"screen\\\"'>import { image } from '@kit.ImageKit';\\nimport { effectKit } from '@kit.ArkGraphics2D';\\nimport { window } from '@kit.ArkUI';\\n\\n@Component\\nexport struct StaticBlur {\\n  @Consume('navPathStack') navPathStack: NavPathStack;\\n  @State isShowStaticBlur: boolean = false;\\n  @State pixelMap: image.PixelMap | undefined = undefined;\\n  @State imgSource: image.ImageSource | undefined = undefined;\\n  @State bottomSafeHeight: number = 0; // bottom navigation bar height\\n\\n  aboutToAppear() {\\n    window.getLastWindow(getContext(this), (err, windowBar) =&gt; {\\n      if (err.code) {\\n        return;\\n      }\\n      // get the height of the bottom navigation bar\\n      this.bottomSafeHeight =\\n        px2vp(windowBar.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR).bottomRect.height);\\n      windowBar.setWindowLayoutFullScreen(true);\\n    });\\n  }\\n\\n  async staticBlur() {\\n    let context = getContext(this);\\n    let resourceMgr = context.resourceManager; // retrieve the resourceManager object\\n    const fileData = await resourceMgr.getRawFileContent('test.png'); // retrieve images from the rawfile directory\\n    let buffer: ArrayBuffer = fileData.buffer.slice(0); // create an ArrayBuffer instance\\n    this.imgSource = image.createImageSource(buffer); // create an image source instance\\n    // create attributes for pixels\\n    let opts: image.InitializationOptions = {\\n      editable: true, // is it editable\\n      pixelFormat: 3, // pixel format. 3 represents RGBA_8888\\n      size: {\\n        // create image size\\n        height: 4,\\n        width: 6\\n      }\\n    };\\n    // create PixelMap\\n    await this.imgSource.createPixelMap(opts).then((pixelMap: image.PixelMap) =&gt; {\\n      const blurRadius = 3;\\n      let headFilter = effectKit.createEffect(pixelMap); // create Filter Instance\\n      if (headFilter !== null) {\\n        headFilter.blur(blurRadius); // set static blur. Add the blur effect to the effect list\\n        // retrieve the image of the source image with the added linked list effect PixelMap\\n        headFilter.getEffectPixelMap().then((pixelMap: image.PixelMap) =&gt; {\\n          this.pixelMap = pixelMap;\\n        });\\n      }\\n    })\\n  }\\n\\n  @Builder\\n  staticBlurBuilder() {\\n    Stack({ alignContent: Alignment.Bottom }) {\\n      Image(this.pixelMap)\\n        .width('100%')\\n        .height('100%')\\n        .objectFit(ImageFit.Fill)\\n      Button('close')\\n        .width('90%')\\n        .height(40)\\n        .margin({ bottom: this.bottomSafeHeight + 16 })\\n        .onClick(() =&gt; {\\n          this.isShowStaticBlur = false;\\n        })\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Button('static blur')\\n          .width('90%')\\n          .height(40)\\n          .onClick(() =&gt; {\\n            this.isShowStaticBlur = true;\\n            // set static blur\\n            this.staticBlur();\\n          })\\n          .bindContentCover(this.isShowStaticBlur, this.staticBlurBuilder(), {\\n            modalTransition: ModalTransition.DEFAULT\\n          })\\n      }\\n      .padding({ bottom: this.bottomSafeHeight + 16 })\\n      .width('100%')\\n      .height('100%')\\n      .justifyContent(FlexAlign.End)\\n    }\\n    .hideTitleBar(true)\\n  }\\n}</pre> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图2 </b>静态模糊</span></div> <p><span><img height='\\\"545.965\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161038.60592100597972281013619926352329:50001231000000:2800:81107A54A2DA9A5516B79D1EBB62E7410C1681E58E28463AA4719C264CFE7D5A.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-fuzzy-scene-performance-optimization.html"
    },
    {
        "id": 293,
        "pre": "@HMRouter({ pageUrl: 'ProductContent' })\\n@Component\\nexport struct ProductContent {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "为需要跳转的页面添加@HMRouter注解，并配置其中的pageUrl参数，例如此处配置为ProductContent。 ",
        "import_module": null,
        "parent": "<li>为需要跳转的页面添加@HMRouter注解，并配置其中的pageUrl参数，例如此处配置为ProductContent。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 294,
        "pre": "HMRouterMgr.pop({ navigationId: 'mainNavigationId', pageUrl: 'HomePage', param: this.param })",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]多次页面跳转，返回指定页面",
        "parent_text": "[h2]多次页面跳转，返回指定页面当页面跳转路径如HomePage->PageA->PageB->PageC，开发者希望在PageC的页面逻辑中直接返回到HomePage并携带参数，开发者仅需使用HMRouterMgr提供的pop方法，传入要返回目标页面的pageUrl、传递的参数param，即可直接带参返回到指定页面。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section833531118581\\\"'><a name='\\\"section833531118581\\\"'></a><a name='\\\"section833531118581\\\"'></a><h4>[h2]多次页面跳转，返回指定页面</h4><p>当页面跳转路径如HomePage-&gt;PageA-&gt;PageB-&gt;PageC，开发者希望在PageC的页面逻辑中直接返回到HomePage并携带参数，开发者仅需使用HMRouterMgr提供的pop方法，传入要返回目标页面的pageUrl、传递的参数param，即可直接带参返回到指定页面。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 295,
        "pre": "@HMInterceptor({ interceptorName: 'LoginCheckInterceptor' })\\nexport class LoginCheckInterceptor implements IHMInterceptor {\\n  handle(info: HMInterceptorInfo): HMInterceptorAction {\\n    // ...\\n      if (!!AppStorage.get('isLogin')) {\\n        return HMInterceptorAction.DO_NEXT;\\n      } else {\\n        info.context.getPromptAction().showToast({ message: '请先登录' })\\n        HMRouterMgr.push({\\n          pageUrl: 'loginPage',\\n          param: info.targetName,\\n          skipAllInterceptor: true\\n        })\\n        return HMInterceptorAction.DO_REJECT;\\n      }\\n      // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "当用户未登录，通过Toast弹窗向用户提示登录，然后跳转到登录页面，最后通过HMInterceptorAction.DO_REJECT来拦截此次跳转请求。 ",
        "import_module": null,
        "parent": "<li>当用户未登录，通过Toast弹窗向用户提示登录，然后跳转到登录页面，最后通过HMInterceptorAction.DO_REJECT来拦截此次跳转请求。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 296,
        "pre": "@HMRouter({\\n  pageUrl: 'liveHome',\\n  singleton: true,\\n  animator: 'liveInteractiveAnimator',\\n  lifecycle: 'liveHomeLifecycle'\\n})\\n@Component\\nexport struct LiveHome {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]实现单例页面的跳转",
        "parent_text": "[h2]实现单例页面的跳转当应用中存在初始化加载资源消耗大且有复用需求的页面时，就可以使用单例页面。典型的业务场景如视频类应用中的视频播放页面，此类页面通常需要加载视频解码器资源并对其初始化，且该页面在视频类应用中会频繁出现。实现上开发者只需要配置@HMRouter注解参数中的singleton参数为true即可。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section133201725105816\\\"'><a name='\\\"section133201725105816\\\"'></a><a name='\\\"section133201725105816\\\"'></a><h4>[h2]实现单例页面的跳转</h4><p>当应用中存在初始化加载资源消耗大且有复用需求的页面时，就可以使用单例页面。典型的业务场景如视频类应用中的视频播放页面，此类页面通常需要加载视频解码器资源并对其初始化，且该页面在视频类应用中会频繁出现。实现上开发者只需要配置@HMRouter注解参数中的singleton参数为true即可。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 297,
        "pre": "@HMRouter({ pageUrl: 'privacyDialog', dialog: true })\\n@Component\\nexport struct PrivacyDialogContent {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]实现弹窗类型的页面",
        "parent_text": "[h2]实现弹窗类型的页面在HMRouter路由框架中，开发者只需要设置@HMRouter注解的dialog配置为true即可将当前页面作为弹窗使用。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section88121519162011\\\"'><a name='\\\"section88121519162011\\\"'></a><a name='\\\"section88121519162011\\\"'></a><h4>[h2]实现弹窗类型的页面</h4><p>在HMRouter路由框架中，开发者只需要设置@HMRouter注解的dialog配置为true即可将当前页面作为弹窗使用。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 298,
        "pre": "@HMRouter({ pageUrl: 'PayCancel', dialog: true })\\n@Component\\nexport struct PayCancel {\\n  // ...\\n  build() {\\n    Stack({ alignContent: Alignment.Center }) {\\n      // ...\\n      ConfirmDialog({\\n        title: '取消订单',\\n        content: '您确认要取消此订单吗?',\\n        leftButtonName: '再看看',\\n        rightButtonName: '取消订单',\\n        leftButtonFunc: () => {\\n          HMRouterMgr.pop({\\n            navigationId: this.queryNavigationInfo()?.navigationId\\n          })\\n        },\\n        rightButtonFunc: () => {\\n          // ...\\n        }\\n      })\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "开发者首先需要根据自己的业务需求，来进行自定义弹窗的开发。 ",
        "import_module": null,
        "parent": "<li>开发者首先需要根据自己的业务需求，来进行自定义弹窗的开发。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 299,
        "pre": "@HMLifecycle({ lifecycleName: 'ExitAppLifecycle' })\\nexport class ExitAppLifecycle implements IHMLifecycle {\\n  lastTime: number = 0;\\n\\n  onBackPressed(ctx: HMLifecycleContext): boolean  {\\n    let time = new Date().getTime();\\n    if (time - this.lastTime > 1000) {\\n      this.lastTime = time;\\n      ctx.uiContext.getPromptAction().showToast({\\n        message: '再次返回退出应用',\\n        duration: 1000,\\n      });\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "重写其中的onBackPressed方法（此处是由于上述业务场景需要，实际开发中根据实际业务场景按需重写方法），通过判断上次返回操作与当前返回操作的时间间隔，按如下逻辑处理：当两次返回操作的时间间隔大于设置值时（此处为1000ms），重新弹窗对用户进行提示，此处返回true，表示不执行默认返回逻辑。当两次返回操作的时间间隔小于设置值时（此处为1000ms），返回为false表示执行默认返回逻辑，退出应用。  ",
        "import_module": null,
        "parent": "<li>重写其中的onBackPressed方法（此处是由于上述业务场景需要，实际开发中根据实际业务场景按需重写方法），通过判断上次返回操作与当前返回操作的时间间隔，按如下逻辑处理：<ol><li>当两次返回操作的时间间隔大于设置值时（此处为1000ms），重新弹窗对用户进行提示，此处返回true，表示不执行默认返回逻辑。</li><li>当两次返回操作的时间间隔小于设置值时（此处为1000ms），返回为false表示执行默认返回逻辑，退出应用。</li></ol>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 300,
        "pre": "const globalPageTransitionEffect: IHMAnimator.Effect = new IHMAnimator.Effect({\\n  direction: IHMAnimator.Direction.BOTTOM_TO_TOP,\\n  opacity: { opacity: 0.5 },\\n  scale: { x: 0.5, y: 0.2 }\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "定义全局页面转场效果。开发者只需要创建出IHMAnimator.Effect实例，在参数中按照业务需求对动画方向direction，透明度opacity，横纵方向页面缩放效果scale进行配置即可。 定义完成后，只需要将实例传入HMNavigation组件的standardAnimator参数即可。 HMNavigation({\\n  navigationId: 'mainNavigationId', homePageUrl: 'HomeContent', options: {\\n    standardAnimator: globalPageTransitionEffect,\\n  }\\n}) ",
        "import_module": null,
        "parent": "<li>定义全局页面转场效果。开发者只需要创建出IHMAnimator.Effect实例，在参数中按照业务需求对动画方向direction，透明度opacity，横纵方向页面缩放效果scale进行配置即可。 <p>定义完成后，只需要将实例传入HMNavigation组件的standardAnimator参数即可。</p> <pre class='\\\"screen\\\"'>HMNavigation({\\n  navigationId: 'mainNavigationId', homePageUrl: 'HomeContent', options: {\\n    standardAnimator: globalPageTransitionEffect,\\n  }\\n})</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 301,
        "pre": "@HMAnimator({ animatorName: 'CustomAnimator' })\\nexport class CustomAnimator implements IHMAnimator {\\n  effect(enterHandle: HMAnimatorHandle, exitHandle: HMAnimatorHandle): void {\\n    // 入场动画\\n    enterHandle.start((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.y = '100%'\\n      scaleOption.x = 0.7;\\n      opacityOption.opacity = 0.3;\\n    })\\n    enterHandle.finish((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.y = '0'\\n      scaleOption.x = 1;\\n      opacityOption.opacity = 1;\\n    })\\n    enterHandle.duration = 400;\\n    enterHandle.curve = Curve.Linear;\\n\\n    // 出场动画\\n    exitHandle.start((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.y = '0'\\n      scaleOption.x = 1;\\n      opacityOption.opacity = 1;\\n    })\\n    exitHandle.finish((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.y = '100%'\\n      scaleOption.x = 0.7;\\n      opacityOption.opacity = 0.3;\\n    })\\n    exitHandle.duration = 400;\\n    enterHandle.curve = Curve.Linear;\\n  }\\n}",
        "type": "Reference",
        "function_call": "new CustomAnimator()",
        "function_name": "[h2]特定页面设置自定义转场",
        "parent_text": "[h2]特定页面设置自定义转场开发者可以自定义动画类并实现IHMAnimator接口中的effect方法，该方法会将页面进出场的效果对象enterHandle与exitHandle作为参数传入，可通过参数对象上的start、finish方法，设置对应效果的起止状态，支持设置的常用属性还有： curve：设置动画速度曲线，支持通过Curve枚举传入值，默认Curve.EaseInOut。duration：动画持续时长，单位ms。 start/finish方法参数说明如下：translateOption：坐标位置，以屏幕左上角为原点，水平向右为x轴正方向，竖直向下为y轴正方向。百分比相对于屏幕宽度。例如希望从右侧进入可以设置translateOption.x从100%变到0。scaleOption：页面缩放，可通过scaleOption.x、scaleOption.y单独设置横纵方向的缩放比例。opacityOption：跳转页面的透明度。  以下代码示例表示入场时由屏幕底部以线性速度向屏幕顶部运动，入场动画持续时长为400ms。出场时从屏幕顶部以线性速度向屏幕底部运动，出场动画持续时长也为400ms。  自定义动画定义完成后，其实例可以作为push/replace方法的animator参数进行传入。 HMRouterMgr.push({ pageUrl: 'ProductContent', animator: new CustomAnimator() }) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section27681826217\\\"'><a name='\\\"section27681826217\\\"'></a><a name='\\\"section27681826217\\\"'></a><h4>[h2]特定页面设置自定义转场</h4><p>开发者可以自定义动画类并实现IHMAnimator接口中的effect方法，该方法会将页面进出场的效果对象enterHandle与exitHandle作为参数传入，可通过参数对象上的start、finish方法，设置对应效果的起止状态，支持设置的常用属性还有：</p> <ul><li>curve：设置动画速度曲线，支持通过Curve枚举传入值，默认Curve.EaseInOut。</li><li>duration：动画持续时长，单位ms。</li></ul> <div class='\\\"p\\\"'>start/finish方法参数说明如下：<ul><li>translateOption：坐标位置，以屏幕左上角为原点，水平向右为x轴正方向，竖直向下为y轴正方向。百分比相对于屏幕宽度。例如希望从右侧进入可以设置translateOption.x从100%变到0。</li><li>scaleOption：页面缩放，可通过scaleOption.x、scaleOption.y单独设置横纵方向的缩放比例。</li><li>opacityOption：跳转页面的透明度。</li></ul> </div> <p>以下代码示例表示入场时由屏幕底部以线性速度向屏幕顶部运动，入场动画持续时长为400ms。出场时从屏幕顶部以线性速度向屏幕底部运动，出场动画持续时长也为400ms。</p>  <p>自定义动画定义完成后，其实例可以作为push/replace方法的animator参数进行传入。</p> <pre class='\\\"screen\\\"'>HMRouterMgr.push({ pageUrl: 'ProductContent', animator: new CustomAnimator() })</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 302,
        "pre": "@HMAnimator({ animatorName: 'myAnimator1' })\\nexport class MyAnimator1 implements IHMAnimator {\\n  effect(enterHandle: HMAnimatorHandle, exitHandle: HMAnimatorHandle): void {\\n    enterHandle.start((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.y = '100%';\\n    }).finish((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.y = 0;\\n    })\\n\\n    exitHandle.start((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.y = 0;\\n    }).finish((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.y = '100%';\\n    })\\n  }\\n}",
        "type": "Reference",
        "function_call": "queryNavigationInfo()",
        "function_name": "[h2]根据条件呈现不同转场动效",
        "parent_text": "[h2]根据条件呈现不同转场动效相同的页面可能在不同情况下出现不同的转场效果，常见的有短视频播放时的评论页面弹出时的转场： 当短视频横屏播放时，评论页面由右至左弹出，视频向左缩放。当短视频竖屏播放时，评论页面由下至上弹出，视频向上缩放。 此处以评论区组件打开的视角进行动画定义，定义竖屏播放时评论区进出场动画如下：  定义短视频横屏播放时评论区进出场动画如下： @HMAnimator({ animatorName: 'myAnimator2' })\\nexport class MyAnimator2 implements IHMAnimator {\\n  effect(enterHandle: HMAnimatorHandle, exitHandle: HMAnimatorHandle): void {\\n    enterHandle.start((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.x = '100%';\\n      translateOption.y = 0;\\n    }).finish((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.x = 0;\\n    })\\n\\n    enterHandle.duration = 500;\\n    exitHandle.start((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.x = 0;\\n    }).finish((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) => {\\n      translateOption.x = '100%';\\n    })\\n    exitHandle.duration = 500;\\n  }\\n} 最后根据条件选择不同的动效，例如此处根据视频播放方向是否为横向，在页面跳转时使用不同的animator值。 @Component\\nexport struct CommentInput {\\n  // ...\\n  build() {\\n    Row() {\\n      // ...\\n      Image($r('app.media.icon_comments'))\\n        .width(24)\\n        .height(24)\\n        .margin({ right: 16 })\\n        .onClick(() => {\\n          if (this.isLandscape) {\\n            HMRouterMgr.push({\\n              navigationId: this.queryNavigationInfo()?.navigationId,\\n              pageUrl: 'liveComments',\\n              param: {\\n                commentRenderNode: this.commentRenderNode,\\n              },\\n              animator: myAnimator2\\n            }, {\\n              onResult: (paramInfo: PopInfo) => {\\n                this.videoWidth = '100%';\\n              }\\n            })\\n            this.videoWidth = '50%';\\n          } else {\\n            HMRouterMgr.push({\\n              navigationId: this.queryNavigationInfo()?.navigationId,\\n              pageUrl: 'liveComments',\\n              param: {\\n                commentRenderNode: this.commentRenderNode,\\n              },\\n              animator: myAnimator1\\n            }, {\\n              onResult: (paramInfo: PopInfo) => {\\n                this.videoHeight = '100%'\\n              }\\n            })\\n            this.videoHeight = '30%'\\n          }\\n        })//\\n        })// ... \\n    }\\n    // ...\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section543118711215\\\"'><a name='\\\"section543118711215\\\"'></a><a name='\\\"section543118711215\\\"'></a><h4>[h2]根据条件呈现不同转场动效</h4><p>相同的页面可能在不同情况下出现不同的转场效果，常见的有短视频播放时的评论页面弹出时的转场：</p> <ul><li>当短视频横屏播放时，评论页面由右至左弹出，视频向左缩放。</li><li>当短视频竖屏播放时，评论页面由下至上弹出，视频向上缩放。</li></ul> <p>此处以评论区组件打开的视角进行动画定义，定义竖屏播放时评论区进出场动画如下：</p>  <p>定义短视频横屏播放时评论区进出场动画如下：</p> <pre class='\\\"screen\\\"'>@HMAnimator({ animatorName: 'myAnimator2' })\\nexport class MyAnimator2 implements IHMAnimator {\\n  effect(enterHandle: HMAnimatorHandle, exitHandle: HMAnimatorHandle): void {\\n    enterHandle.start((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) =&gt; {\\n      translateOption.x = '100%';\\n      translateOption.y = 0;\\n    }).finish((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) =&gt; {\\n      translateOption.x = 0;\\n    })\\n\\n    enterHandle.duration = 500;\\n    exitHandle.start((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) =&gt; {\\n      translateOption.x = 0;\\n    }).finish((translateOption: TranslateOption, scaleOption: ScaleOption,\\n      opacityOption: OpacityOption) =&gt; {\\n      translateOption.x = '100%';\\n    })\\n    exitHandle.duration = 500;\\n  }\\n}</pre> <p>最后根据条件选择不同的动效，例如此处根据视频播放方向是否为横向，在页面跳转时使用不同的animator值。</p> <pre class='\\\"screen\\\"'>@Component\\nexport struct CommentInput {\\n  // ...\\n  build() {\\n    Row() {\\n      // ...\\n      Image($r('app.media.icon_comments'))\\n        .width(24)\\n        .height(24)\\n        .margin({ right: 16 })\\n        .onClick(() =&gt; {\\n          if (this.isLandscape) {\\n            HMRouterMgr.push({\\n              navigationId: this.queryNavigationInfo()?.navigationId,\\n              pageUrl: 'liveComments',\\n              param: {\\n                commentRenderNode: this.commentRenderNode,\\n              },\\n              animator: myAnimator2\\n            }, {\\n              onResult: (paramInfo: PopInfo) =&gt; {\\n                this.videoWidth = '100%';\\n              }\\n            })\\n            this.videoWidth = '50%';\\n          } else {\\n            HMRouterMgr.push({\\n              navigationId: this.queryNavigationInfo()?.navigationId,\\n              pageUrl: 'liveComments',\\n              param: {\\n                commentRenderNode: this.commentRenderNode,\\n              },\\n              animator: myAnimator1\\n            }, {\\n              onResult: (paramInfo: PopInfo) =&gt; {\\n                this.videoHeight = '100%'\\n              }\\n            })\\n            this.videoHeight = '30%'\\n          }\\n        })//\\n        })// ... \\n    }\\n    // ...\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 303,
        "pre": "@HMAnimator({ animatorName: 'liveInteractiveAnimator' })\\nexport class LiveInteractiveAnimator implements IHMAnimator {\\n  effect(enterHandle: HMAnimatorHandle, exitHandle: HMAnimatorHandle): void {\\n    // ...\\n  }\\n\\n  interactive(handle: HMAnimatorHandle): void {\\n    handle.actionStart((event: GestureEvent) => {\\n      if (event.offsetX > 0) {\\n        HMRouterMgr.pop()\\n      }\\n    })\\n    handle.updateProgress((event, proxy, operation, startOffset) => {\\n      if (!proxy?.updateTransition || !startOffset) {\\n        return\\n      }\\n      let offset = event.fingerList[0].localX - startOffset;\\n      if (offset < 0) {\\n        proxy?.updateTransition(0)\\n        return;\\n      }\\n      let rectWidth = event.target.area.width as number\\n      let rate = offset / rectWidth\\n      proxy?.updateTransition(rate)\\n    })\\n    handle.actionEnd((event, proxy, operation, startOffset) => {\\n      if (!startOffset) {\\n        return\\n      }\\n      let rectWidth = event.target.area.width as number\\n      let rate = (event.fingerList[0].localX - startOffset) / rectWidth\\n      if (rate > 0.4) {\\n        proxy?.finishTransition()\\n      } else {\\n        proxy?.cancelTransition?.()\\n      }\\n    })\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]交互式转场",
        "parent_text": "[h2]交互式转场当应用中有页面的进出场效果与用户手势操作同步的诉求时，即当用户手指在屏幕上移动时，页面跟随用户手势移动，可以参考以下实现，通过IHMAnimator的interactive函数控制动画播放进度，在actionStart中判断向右移动执行页面返回操作，在updateProgress更新动画进度，在actionEnd中获取到动画的最终状态，根据最终状态判断是继续执行动画与页面返回还是关闭动画取消页面返回。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section151018013496\\\"'><a name='\\\"section151018013496\\\"'></a><a name='\\\"section151018013496\\\"'></a><h4>[h2]交互式转场</h4><p>当应用中有页面的进出场效果与用户手势操作同步的诉求时，即当用户手指在屏幕上移动时，页面跟随用户手势移动，可以参考以下实现，通过IHMAnimator的interactive函数控制动画播放进度，在actionStart中判断向右移动执行页面返回操作，在updateProgress更新动画进度，在actionEnd中获取到动画的最终状态，根据最终状态判断是继续执行动画与页面返回还是关闭动画取消页面返回。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 304,
        "pre": "@Concurrent\\nasync function networkRequest(lifecycle: string): Promise<string> {\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "定义网络请求函数，可使用TaskPool在其他线程执行网络请求并返回请求结果。 ",
        "import_module": null,
        "parent": "<li>定义网络请求函数，可使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/taskpool-introduction\\\"' target='\\\"_blank\\\"'>TaskPool</a>在其他线程执行网络请求并返回请求结果。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 305,
        "pre": "@Builder\\nfunction buildComment(liveComments: LiveCommentsProduct[]) {\\n  // ...\\n}\\n\\n\\nexport class CommentNodeController extends NodeController {\\n  commentArea: BuilderNode<[LiveCommentsProduct[]]> | null = null;\\n  commentListData: LiveCommentsProduct[] = new LiveCommentsModel().getLiveCommentsList()\\n\\n  constructor() {\\n    super();\\n  }\\n\\n  makeNode(context: UIContext): FrameNode | null {\\n    if (this.commentArea == null) {\\n      this.nodeBuild(context)\\n    }\\n    return this.commentArea!.getFrameNode();\\n  }\\n\\n  nodeBuild(context: UIContext) {\\n    this.commentArea = new BuilderNode(context);\\n    if (this.commentArea !== null) {\\n      this.commentArea.build(wrapBuilder<[LiveCommentsProduct[]]>(buildComment), this.commentListData)\\n    }\\n  }\\n\\n  dispose() {\\n    if (this.commentArea !== null) {\\n      this.commentArea.dispose();\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用BuilderNode构造出评论区组件，在makeNode函数中，若评论区不存在则创建，存在便直接返回。 ",
        "import_module": null,
        "parent": "<li>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-user-defined-arktsnode-buildernode\\\"' target='\\\"_blank\\\"'>BuilderNode</a>构造出评论区组件，在makeNode函数中，若评论区不存在则创建，存在便直接返回。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 306,
        "pre": "@HMLifecycle({ lifecycleName: 'PageDurationLifecycle', global: true })\\nexport class PageDurationLifecycle implements IHMLifecycle {\\n  private time: number = 0;\\n\\n  onShown(): void {\\n    this.time = new Date().getTime();\\n  }\\n\\n  onHidden(ctx: HMLifecycleContext): void {\\n    const duration = new Date().getTime() - this.time;\\n    console.log(`Page ${ctx.navContext?.pathInfo.name} stay ${duration}`);\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]页面埋点开发",
        "parent_text": "[h2]页面埋点开发当需要统计类似于页面加载耗时等数据，或者有其他自定义打点数据需要统计时，可以使用生命周期回调，在对应的位置进行打点，以下示例为页面停留时长的数据打点统计，实现上参考以下步骤： 定义一个类PageDurationLifecycle实现IHMLifecycle接口。为该类添加@HMLifecycle注解，并配置global为true，将该生命周期配置到全局，所有页面都会执行该生命周期。在页面显示时（onShown）记录当前的时间戳，在页面隐藏时（onHidden）计算页面停留时长。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section56587381536\\\"'><a name='\\\"section56587381536\\\"'></a><a name='\\\"section56587381536\\\"'></a><h4>[h2]页面埋点开发</h4><p>当需要统计类似于页面加载耗时等数据，或者有其他自定义打点数据需要统计时，可以使用生命周期回调，在对应的位置进行打点，以下示例为页面停留时长的数据打点统计，实现上参考以下步骤：</p> <ol><li>定义一个类PageDurationLifecycle实现IHMLifecycle接口。</li><li>为该类添加@HMLifecycle注解，并配置global为true，将该生命周期配置到全局，所有页面都会执行该生命周期。</li><li>在页面显示时（onShown）记录当前的时间戳，在页面隐藏时（onHidden）计算页面停留时长。</li></ol>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hmrouter.html"
    },
    {
        "id": 307,
        "pre": "// src/main/ets/widget/pages/PlayControlCard2x4.ets\\nlet storageUpdateCall = new LocalStorage();\\n@Entry(storageUpdateCall)\\n@Component\\nstruct PlayControlCard2x4 {\\n  @LocalStorageProp('formId') formId: string = '';\\n  @LocalStorageProp('isPlay') isPlay: boolean = false;\\n  @LocalStorageProp('title') title: string = 'SongName';\\n  @LocalStorageProp('isCollected') isCollected: boolean = false;\\n  @LocalStorageProp('musicCover') musicCover: Resource = $r('app.media.ic_dream');\\n  @LocalStorageProp('singer') singer: string = 'Singer';\\n  @LocalStorageProp('songId') songId: string = '';\\n  @LocalStorageProp('isNeedRequestUpdate') @Watch('requestData') isNeedRequestUpdate: boolean = false;\\n  @LocalStorageProp('imageColor') imageColor: string = 'rgba(76, 72, 68, 1)';\\n  @LocalStorageProp('imageColorHex') imageColorHex: string = '18191d';\\n\\n  requestData() {\\n    ActionUtils.updateControlCardAction(this, this.formId);\\n  }\\n\\n  build() {\\n    RelativeContainer() {\\n      Image(this.musicCover)\\n        // ...\\n      SymbolGlyph(this.isCollected ? $r('sys.symbol.heart_fill') : $r('sys.symbol.heart'))\\n        // ...\\n      Text(this.title)\\n        // ...\\n      Text(this.singer)\\n        // ...\\n      Row() {\\n        SymbolGlyph($r('sys.symbol.backward_end_fill'))\\n          // ...\\n        SymbolGlyph(this.isPlay ? $r('sys.symbol.pause') : $r('sys.symbol.play_fill'))\\n          // ...\\n        SymbolGlyph($r('sys.symbol.forward_end_fill'))\\n          // ...\\n      }\\n      // ...\\n    }\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "开发卡片UI布局图6 音乐播控卡片效果图  分别创建2x2和2x4两个规格的动态卡片，动态卡片的创建可以参考创建一个ArkTS卡片。对于比较复杂的布局，优先考虑使用相对布局 RelativeContainer来减少性能开销。由于2x4卡片包含了2x2卡片的功能，下面将以2x4卡片为例介绍音乐播控卡片实现。 在卡片布局文件中定义卡片所需要的变量信息，使用@LocalStorageProp装饰器修饰，用于接收应用侧传递过来的数据，其中isPlay与isCollected分别表示歌曲的播放和收藏状态，根据状态的不同展示不同的图标，示例代码如下：  ",
        "import_module": null,
        "parent": "<li><strong>开发卡片UI布局</strong><div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图6 </b>音乐播控卡片效果图</span></div> <p><span><img height='\\\"151.54219500000002\\\"' originheight='\\\"262\\\"' originwidth='\\\"876\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161059.12734014754902834695418048892626:50001231000000:2800:5C78862ADD380E6FC41DE9FDE53D943FDCFAAE9AFB6C6D90AB26645EAC5A7EE7.png\\\"' title='\\\"点击放大\\\"' width='\\\"506.73\\\"'/></span></p> <p>分别创建2x2和2x4两个规格的动态卡片，动态卡片的创建可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-creation\\\"' target='\\\"_blank\\\"'>创建一个ArkTS卡片</a>。对于比较复杂的布局，优先考虑使用相对布局 <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-relative-layout\\\"' target='\\\"_blank\\\"'>RelativeContainer</a>来减少性能开销。由于2x4卡片包含了2x2卡片的功能，下面将以2x4卡片为例介绍音乐播控卡片实现。</p> <p>在卡片布局文件中定义卡片所需要的变量信息，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage#localstorageprop\\\"' target='\\\"_blank\\\"'>@LocalStorageProp</a>装饰器修饰，用于接收应用侧传递过来的数据，其中isPlay与isCollected分别表示歌曲的播放和收藏状态，根据状态的不同展示不同的图标，示例代码如下：</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-music-card.html"
    },
    {
        "id": 308,
        "pre": "// src/main/ets/entryformability/EntryFormAbility.ets\\nexport default class EntryFormAbility extends FormExtensionAbility {\\n  onAddForm(want: Want) {\\n    if (want.parameters) {\\n      let formId = want.parameters['ohos.extra.param.key.form_identity'] as string;\\n      let formName = want.parameters['ohos.extra.param.key.form_name'] as string;\\n      // ...\\n      if (formName === 'RecommendedMusic1x2' || formName === 'RecommendedMusic2x4') {\\n        // 更新歌单推荐卡片\\n        FormUtils.updateRecommendedCard(this.context, formId, IMAGE_URL1)\\n      }\\n    }\\n    return formBindingData.createFormBindingData('');\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "Row()",
        "function_name": null,
        "parent_text": "更新卡片图片歌单推荐封面图片加载的是网络图片，加载网络图片需要申请ohos.permission.INTERNET权限。在卡片预览的时候会进行下载网络图片，并更新到卡片。网络图片的下载以及如何更新到卡片，开发者可以参考：刷新本地图片和网络图片。 1.1首先在EntryFormAbility的onAddForm()方法中，调用FormUtils的updateRecommendedCard()方法更新卡片，示例代码如下。  1.2然后在updateRecommendedCard()方法中下载网络图片，并将图片添加到缓存中，接着调用updateForm()方法更新卡片。 // src/main/ets/utils/FormUtils.ets\\nclass FormUtils {\\n  // ...\\n  public async updateRecommendedCard(context: Context, formId: string, imageUrl: string) {\\n    let tempDir = context.getApplicationContext().tempDir;\\n    let fileName = 'file' + Date.now();\\n    let tmpFile = tempDir + '/' + fileName + '.jpg';\\n    let httpRequest = http.createHttp();\\n    let data = await httpRequest.request(imageUrl);\\n    let imgMap: Record<string, number> = {};\\n\\n    class FormDataClass {\\n      imgBg: string = fileName;\\n      formImages: Record<string, number> = imgMap;\\n      isLoaded: boolean = true;\\n      imageColorHex: string = '';\\n    }\\n\\n    if (data.responseCode === http.ResponseCode.OK) {\\n      let imgFile = fileIo.openSync(tmpFile, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);\\n      imgMap[fileName] = imgFile.fd;\\n      try {\\n        let imageBuffer: ArrayBuffer = data.result as ArrayBuffer;\\n        let writeLen: number = fileIo.writeSync(imgFile.fd, imageBuffer);\\n        let imageDealData = await ImageUtils.getImageDealDataByArr(imageBuffer);\\n        let formData = new FormDataClass();\\n        formData.imageColorHex = imageDealData.imageColorHex;\\n        this.updateForm(formId, formData)\\n      } catch (err) {\\n        Logger.error(TAG, `write data to file failed with error: ${JSON.stringify(err)}`);\\n      } finally {\\n        fileIo.closeSync(imgFile);\\n        httpRequest.destroy();\\n      }\\n    }\\n  }\\n  // ...\\n} 1.3最后在卡片中Image组件通过入参(memory://fileName)的方式来进行加载缓存中的图片。 // src/main/ets/widget/pages/RecommendedMusic2x4.ets\\n@Entry(storageUpdateCall2)\\n@Component\\nstruct RecommendedMusic2x4 {\\n  readonly ABILITY_NAME: string = 'EntryAbility';\\n  readonly ACTION_TYPE: string = 'router';\\n  @LocalStorageProp('imgBg') imgBg: ResourceStr = '';\\n  @LocalStorageProp('isLoaded') isLoaded: boolean = false;\\n  //...\\n  build() {\\n    FormLink({\\n      action: this.ACTION_TYPE,\\n      abilityName: this.ABILITY_NAME,\\n    }) {\\n      Row() {\\n        Image(this.isLoaded ? `memory://${this.imgBg}` : $r('app.media.ic_avatar16'))\\n          .height('100%')\\n          .borderRadius(10)\\n          .layoutWeight(1)\\n          .margin({ right: 6 })\\n        // ...\\n      }\\n      //...\\n    }\\n  }\\n}  卡片加载的图片过大可能会导致卡片白屏，建议卡片加载的图片大小不能超过2M，在加载卡片图片前需要判断下图片是否过大，如果过大可以采取压缩的方案，图片压缩可以参考FAQ：如何将PixelMap压缩到指定大小以下。  ",
        "import_module": null,
        "parent": "<li><strong>更新卡片图片</strong><p>歌单推荐封面图片加载的是网络图片，加载网络图片需要申请ohos.permission.INTERNET权限。在卡片预览的时候会进行下载网络图片，并更新到卡片。网络图片的下载以及如何更新到卡片，开发者可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-ui-widget-image-update\\\"' target='\\\"_blank\\\"'>刷新本地图片和网络图片</a>。</p> <p>1.1首先在EntryFormAbility的onAddForm()方法中，调用FormUtils的updateRecommendedCard()方法更新卡片，示例代码如下。</p>  <p>1.2然后在updateRecommendedCard()方法中下载网络图片，并将图片添加到缓存中，接着调用updateForm()方法更新卡片。</p> <pre class='\\\"screen\\\"'>// src/main/ets/utils/FormUtils.ets\\nclass FormUtils {\\n  // ...\\n  public async updateRecommendedCard(context: Context, formId: string, imageUrl: string) {\\n    let tempDir = context.getApplicationContext().tempDir;\\n    let fileName = 'file' + Date.now();\\n    let tmpFile = tempDir + '/' + fileName + '.jpg';\\n    let httpRequest = http.createHttp();\\n    let data = await httpRequest.request(imageUrl);\\n    let imgMap: Record&lt;string, number&gt; = {};\\n\\n    class FormDataClass {\\n      imgBg: string = fileName;\\n      formImages: Record&lt;string, number&gt; = imgMap;\\n      isLoaded: boolean = true;\\n      imageColorHex: string = '';\\n    }\\n\\n    if (data.responseCode === http.ResponseCode.OK) {\\n      let imgFile = fileIo.openSync(tmpFile, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);\\n      imgMap[fileName] = imgFile.fd;\\n      try {\\n        let imageBuffer: ArrayBuffer = data.result as ArrayBuffer;\\n        let writeLen: number = fileIo.writeSync(imgFile.fd, imageBuffer);\\n        let imageDealData = await ImageUtils.getImageDealDataByArr(imageBuffer);\\n        let formData = new FormDataClass();\\n        formData.imageColorHex = imageDealData.imageColorHex;\\n        this.updateForm(formId, formData)\\n      } catch (err) {\\n        Logger.error(TAG, `write data to file failed with error: ${JSON.stringify(err)}`);\\n      } finally {\\n        fileIo.closeSync(imgFile);\\n        httpRequest.destroy();\\n      }\\n    }\\n  }\\n  // ...\\n}</pre> <p>1.3最后在卡片中Image组件通过入参(memory://fileName)的方式来进行加载缓存中的图片。</p> <pre class='\\\"screen\\\"'>// src/main/ets/widget/pages/RecommendedMusic2x4.ets\\n@Entry(storageUpdateCall2)\\n@Component\\nstruct RecommendedMusic2x4 {\\n  readonly ABILITY_NAME: string = 'EntryAbility';\\n  readonly ACTION_TYPE: string = 'router';\\n  @LocalStorageProp('imgBg') imgBg: ResourceStr = '';\\n  @LocalStorageProp('isLoaded') isLoaded: boolean = false;\\n  //...\\n  build() {\\n    FormLink({\\n      action: this.ACTION_TYPE,\\n      abilityName: this.ABILITY_NAME,\\n    }) {\\n      Row() {\\n        Image(this.isLoaded ? `memory://${this.imgBg}` : $r('app.media.ic_avatar16'))\\n          .height('100%')\\n          .borderRadius(10)\\n          .layoutWeight(1)\\n          .margin({ right: 6 })\\n        // ...\\n      }\\n      //...\\n    }\\n  }\\n}</pre> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161100.34083340493827521304566965377955:50001231000000:2800:434FABA28D43FFB75886AAB042E142985E4E712D86F21CC5A48A84EA040A5055.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>卡片加载的图片过大可能会导致卡片白屏，建议卡片加载的图片大小不能超过2M，在加载卡片图片前需要判断下图片是否过大，如果过大可以采取压缩的方案，图片压缩可以参考FAQ：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs-V5/faqs-image-16-V5\\\"' target='\\\"_blank\\\"'>如何将PixelMap压缩到指定大小以下</a>。</p> </div></div> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-music-card.html"
    },
    {
        "id": 309,
        "pre": "// src/main/resources/base/profile/form_config.json\\n{\\n  \\\"forms\\\": [\\n    // ...\\n    {\\n      \\\"name\\\": \\\"LyricsCard\\\",\\n      // ...\\n      \\\"updateDuration\\\": 1,\\n      \\\"defaultDimension\\\": \\\"2*4\\\",\\n      \\\"supportDimensions\\\": [\\n        \\\"2*4\\\",\\n        \\\"4*4\\\"\\n      ]\\n    }\\n  ]\\n}",
        "type": "Reference",
        "function_call": "new CardUpdateData()",
        "function_name": null,
        "parent_text": "歌词卡片数据更新实现。本示例中歌词卡片是通过定时刷新的方式进行刷新，首先需要在卡片配置文件form_config中进行配置，设置updateEnabled参数的值为true，表示卡片支持周期性刷新（包含定时刷新和定点刷新），设置updateDuration参数的值为1，表示每隔30分钟会进行刷新卡片，参数配置如下：  接着在EntryFormAbility的onUpdateForm()回调方法中，对卡片数据进行刷新。由于onUpdateForm()方法中的参数只有formId，而本示涉及三种类型的卡片（乐播控、歌单推荐和心动歌词），因此需要依据formId查询数据库以获取卡片的具体信息。若查询到的卡片的formName为”LyricsCard”，则执行相应的数据更新操作。示例代码如下： // src/main/ets/entryformability/EntryFormAbility.ets\\nexport default class EntryFormAbility extends FormExtensionAbility {\\n  // ...\\n  onUpdateForm(formId: string) {\\n    // ...\\n    FormRdbHelper.getInstance(this.context).queryFormById(formId).then((formInfo: FormInfo) => {\\n      // update Lyrics Card\\n      if (formInfo.formName === 'LyricsCard') {\\n        FormUtils.updateLyricsCard(this.context, formInfo.formId)\\n      }\\n    })\\n  }\\n} // src/main/ets/utils/FormUtils.ets\\nclass FormUtils {\\n  // ...\\n  public async updateLyricsCard(context: Context, formId: string) {\\n    let songData = getRandomLyrics(context);\\n    let songItem: SongItem = songData.songItem as SongItem;\\n    let imageDealData = await ImageUtils.getImageDealData(context, songItem.label);\\n\\n    class CardUpdateData {\\n      lrcArray: Array<string> = songData.randomLrcStr as Array<string>;\\n      formId: string = formId;\\n      singer: string = songItem.singer;\\n      title: string = songItem.title;\\n      songId: string = songItem.id;\\n      musicCover: Resource = songItem.label;\\n      imageColor = imageDealData.imageColor;\\n    }\\n    this.updateForm(formId, new CardUpdateData());\\n  }\\n  // ...\\n} ",
        "import_module": null,
        "parent": "<li>歌词卡片数据更新实现。<p>本示例中歌词卡片是通过定时刷新的方式进行刷新，首先需要在卡片配置文件form_config中进行配置，设置updateEnabled参数的值为true，表示卡片支持周期性刷新（包含定时刷新和定点刷新），设置updateDuration参数的值为1，表示每隔30分钟会进行刷新卡片，参数配置如下：</p>  <p>接着在EntryFormAbility的onUpdateForm()回调方法中，对卡片数据进行刷新。由于onUpdateForm()方法中的参数只有formId，而本示涉及三种类型的卡片（乐播控、歌单推荐和心动歌词），因此需要依据formId查询数据库以获取卡片的具体信息。若查询到的卡片的formName为”LyricsCard”，则执行相应的数据更新操作。示例代码如下：</p> <pre class='\\\"screen\\\"'>// src/main/ets/entryformability/EntryFormAbility.ets\\nexport default class EntryFormAbility extends FormExtensionAbility {\\n  // ...\\n  onUpdateForm(formId: string) {\\n    // ...\\n    FormRdbHelper.getInstance(this.context).queryFormById(formId).then((formInfo: FormInfo) =&gt; {\\n      // update Lyrics Card\\n      if (formInfo.formName === 'LyricsCard') {\\n        FormUtils.updateLyricsCard(this.context, formInfo.formId)\\n      }\\n    })\\n  }\\n}</pre> <pre class='\\\"screen\\\"'>// src/main/ets/utils/FormUtils.ets\\nclass FormUtils {\\n  // ...\\n  public async updateLyricsCard(context: Context, formId: string) {\\n    let songData = getRandomLyrics(context);\\n    let songItem: SongItem = songData.songItem as SongItem;\\n    let imageDealData = await ImageUtils.getImageDealData(context, songItem.label);\\n\\n    class CardUpdateData {\\n      lrcArray: Array&lt;string&gt; = songData.randomLrcStr as Array&lt;string&gt;;\\n      formId: string = formId;\\n      singer: string = songItem.singer;\\n      title: string = songItem.title;\\n      songId: string = songItem.id;\\n      musicCover: Resource = songItem.label;\\n      imageColor = imageDealData.imageColor;\\n    }\\n    this.updateForm(formId, new CardUpdateData());\\n  }\\n  // ...\\n}</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-music-card.html"
    },
    {
        "id": 310,
        "pre": "let stackIndexArray = this.pageStack.getAllPathName();\\nif (stackIndexArray.length > 0 && stackIndexArray[stackIndexArray.length-1] === 'Playlists') {\\n  this.pageStack.replacePathByName('Playlists', this.playlistsTitle);\\n} else {\\n  this.pageStack.pushPathByName('Playlists', this.playlistsTitle);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]多次点击服务卡片拉起应用指定页面后，该页面在路由栈内存在多个，导致返回上一面需要多次返回操作。",
        "parent_text": "[h2]多次点击服务卡片拉起应用指定页面后，该页面在路由栈内存在多个，导致返回上一面需要多次返回操作。应用在接收到对应的router跳转事件后，处理跳转的时候需要判断跳转的页面是否已经在路由栈的栈顶，如果在的话需要替换当前的页面，如果不在的话，重新push这个页面到栈。下面以Navigation跳转路由页面为例：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section11706154125217\\\"'><a name='\\\"section11706154125217\\\"'></a><a name='\\\"section11706154125217\\\"'></a><h4>[h2]多次点击服务卡片拉起应用指定页面后，该页面在路由栈内存在多个，导致返回上一面需要多次返回操作。</h4><p>应用在接收到对应的router跳转事件后，处理跳转的时候需要判断跳转的页面是否已经在路由栈的栈顶，如果在的话需要替换当前的页面，如果不在的话，重新push这个页面到栈。下面以Navigation跳转路由页面为例：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-music-card.html"
    },
    {
        "id": 311,
        "pre": "// 1. 设备类型为phone，且支持可折叠\\nif (deviceInfo.deviceType === 'phone' && display.isFoldable()) {}\\n// 2. 判断当前折叠状态是否为展开态/折叠态/半折叠态\\nif (display.getFoldStatus() === display.FoldStatus.FOLD_STATUS_EXPANDED) {}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "折叠屏页面布局的判断条件不推荐使用以下接口，否则可能带来不同屏幕尺寸折叠屏下的布局混乱问题。  ",
        "import_module": null,
        "parent": "<div class='\\\"notebody\\\"'><p>折叠屏页面布局的判断条件不推荐使用以下接口，否则可能带来不同屏幕尺寸折叠屏下的布局混乱问题。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-foldable-guide.html"
    },
    {
        "id": 312,
        "pre": "// entry/src/main/ets/model/SampleObject.ts\\nexport type SampleInputObject = {\\n  age: number;\\n  name: string;\\n}\\n\\nexport type SampleOutputObject = {\\n  isAdult: boolean;\\n  code: number;\\n  age: number;\\n  name: string;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "作为一个简单的“排号机”(比如医院中的)，需要年龄和姓名作为输入，并额外返回标志成人与否的布尔值和所排序号。因此，构造如下两种object，分别用于输入和输出。 ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>作为一个简单的“排号机”(比如医院中的)，需要年龄和姓名作为输入，并额外返回标志成人与否的布尔值和所排序号。因此，构造如下两种object，分别用于输入和输出。 </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-complex-type-pass.html"
    },
    {
        "id": 313,
        "pre": "// entry/src/main/ets/pages/HashMapPage.ets\\nhashMap2Rec(map: HashMap<string, Object>): Record<string, Object> {\\n  let Rec: Record<string, Object> = {}\\n  map.forEach((value: Object, key: string) => {\\n    // value may also be HashMap\\n    if (value instanceof HashMap) {\\n      let vRec: Record<string, Object> = this.hashMap2Rec(value);\\n      value = vRec;\\n    }\\n    Rec[key] = value;\\n  })\\n  return Rec;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "同时，由于ArkTS中的JSON.stringify不支持直接将hashMap序列化，因此还需将hashMap先转换为Record，再序列化。方法如下： ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>同时，由于ArkTS中的JSON.stringify不支持直接将hashMap序列化，因此还需将hashMap先转换为Record，再序列化。方法如下： </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-complex-type-pass.html"
    },
    {
        "id": 314,
        "pre": "// entry/src/main/cpp/types/libentry/Index.d.ts\\nexport interface SampleClassTs2Napi {\\n  result: string;\\n\\n  add(a: number, b: number): string;\\n}",
        "type": "Reference",
        "function_call": "add(a: number, b: number)",
        "function_name": null,
        "parent_text": "在index.d.ts中声明需要传递的class。 并声明传递用函数。// entry/src/main/cpp/types/libentry/Index.d.ts\\nexport const classPassingTs2Napi: (input: SampleClassTs2Napi) => string;  ArkTS文件中也需要对此进行引用，并实现上文声明的class。// entry/src/main/ets/pages/ClassPage.ets\\nimport ParamPassing from 'libentry.so';\\nimport { OutputArea } from '../model/IOModel';\\n\\nconst HINT_STRING: string = 'Calculation completed:\\\\n';\\n\\nclass SampleClassTs2Napi implements ParamPassing.SampleClassTs2Napi {\\n  public result: string = '';\\n\\n  add(a: number, b: number) {\\n    this.result = `${a} + ${b} = ${a + b}`;\\n    return HINT_STRING;\\n  }\\n}  ",
        "import_module": null,
        "parent": "<li>在index.d.ts中声明需要传递的class。 <div class='\\\"p\\\"'>并声明传递用函数。<pre class='\\\"screen\\\"'>// entry/src/main/cpp/types/libentry/Index.d.ts\\nexport const classPassingTs2Napi: (input: SampleClassTs2Napi) =&gt; string;</pre> </div> <div class='\\\"p\\\"'>ArkTS文件中也需要对此进行引用，并实现上文声明的class。<pre class='\\\"screen\\\"'>// entry/src/main/ets/pages/ClassPage.ets\\nimport ParamPassing from 'libentry.so';\\nimport { OutputArea } from '../model/IOModel';\\n\\nconst HINT_STRING: string = 'Calculation completed:\\\\n';\\n\\nclass SampleClassTs2Napi implements ParamPassing.SampleClassTs2Napi {\\n  public result: string = '';\\n\\n  add(a: number, b: number) {\\n    this.result = `${a} + ${b} = ${a + b}`;\\n    return HINT_STRING;\\n  }\\n}</pre> </div> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-complex-type-pass.html"
    },
    {
        "id": 315,
        "pre": "// entry/src/main/cpp/types/libentry/Index.d.ts\\nexport class SampleClassNapi2Ts {\\n  private _hintStr: string;\\n\\n  constructor(hintStr: string);\\n\\n  times(a: number, b: number): string;\\n  public get hintStr();\\n  public set hintStr(value:string);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "需要在index.d.ts中声明需要传递的class。  此处需要使用get和set关键字定义访问器，不能直接引用、修改属性。  ",
        "import_module": null,
        "parent": "<li>需要在index.d.ts中声明需要传递的class。 <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161152.15145531014266358309299741758040:50001231000000:2800:F3C83154F0465C1FEB380D3B5F18BB559AF409929CA6C6ECA96631AFBD60849E.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>此处需要使用get和set关键字定义访问器，不能直接引用、修改属性。</p> </div></div> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-complex-type-pass.html"
    },
    {
        "id": 316,
        "pre": "try {\\n  let pickerProfile: cameraPicker.PickerProfile =\\n    { cameraPosition: camera.CameraPosition.CAMERA_POSITION_BACK };\\n  // 选择拉起相机动作为拍照\\n  let pickerResult: cameraPicker.PickerResult = await cameraPicker.pick(getContext(this),\\n    [cameraPicker.PickerMediaType.PHOTO], pickerProfile);\\n  // 将拍照uri返回给应用\\n  this.imageUri = pickerResult.resultUri ? pickerResult.resultUri : this.imageUri;\\n  hilog.info(0x0000, TAG, 'cameraPicker.pick succeed, uri: ' + JSON.stringify(pickerResult));\\n} catch (error) {\\n  let err = error as BusinessError;\\n  hilog.error(0x0000, TAG, `cameraPicker.pick failed, error: ${err.code}, ${err.message}`);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]拍照获取图片",
        "parent_text": "[h2]拍照获取图片除了从相册获取图片外，应用还可以通过拍照来获取图片。对于拍照这一行为，HarmonyOS上提供了系统相机和自定义相机两种选项。应用可以通过拉起系统相机拍照并获得一张照片，也可以自行实现自定义相机来拍照获取照片 实现原理 CameraPicker是系统提供的相机选择器，可以拉起系统相机为应用提供拍照或录像功能，结果以uri的形式返回给应用。系统还提供了一整套相机服务接口（包含ArkTS API和C API）给开发者用于开发适合自身需求的自定义相机功能，对自定义相机开发有诉求的开发者可以参考Camera Kit，本文不再赘述。 开发步骤 使用CameraPicker的参考代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section610819151543\\\"'><a name='\\\"section610819151543\\\"'></a><a name='\\\"section610819151543\\\"'></a><h4>[h2]拍照获取图片</h4><p>除了从相册获取图片外，应用还可以通过拍照来获取图片。对于拍照这一行为，HarmonyOS上提供了系统相机和自定义相机两种选项。应用可以通过拉起系统相机拍照并获得一张照片，也可以自行实现自定义相机来拍照获取照片</p> <p><strong>实现原理</strong></p> <p>CameraPicker是系统提供的相机选择器，可以拉起系统相机为应用提供拍照或录像功能，结果以uri的形式返回给应用。系统还提供了一整套相机服务接口（包含ArkTS API和C API）给开发者用于开发适合自身需求的自定义相机功能，对自定义相机开发有诉求的开发者可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/camera-kit\\\"' target='\\\"_blank\\\"'>Camera Kit</a>，本文不再赘述。</p> <p><strong>开发步骤</strong></p> <p>使用CameraPicker的参考代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-image_get_and_save.html"
    },
    {
        "id": 317,
        "pre": "this.imageSource = image.createImageSource(this.path);\\nthis.imageSource.getImageInfo((error: BusinessError, imageInfo: image.ImageInfo) => {\\n  if (error) {\\n    hilog.error(0x0000, TAG, `getImageInfo failed, error: ${error.code}, ${error.message}`);\\n  } else {\\n    hilog.info(0x0000, TAG, 'getImageInfo succeed, info: ' + JSON.stringify(imageInfo));\\n  }\\n});",
        "type": "Reference",
        "function_call": null,
        "function_name": "读取图片信息",
        "parent_text": "读取图片信息实现原理 HarmonyOS提供了ImageSource图片源类用于获取图片相关信息，既可以读取图片大小、像素格式等基本信息，也可以读取EXIF信息，如曝光时间、光圈值等。 开发步骤 首先基于前文获得的图片uri，创建一个ImageSource实例，然后调用相关方法即可读取图片信息。 读取基本信息：  读取EXIF信息： let key = [image.PropertyKey.IMAGE_WIDTH, image.PropertyKey.IMAGE_LENGTH, image.PropertyKey.F_NUMBER];\\nthis.imageSource.getImageProperties(key).then((data) => {\\n  hilog.info(0x0000, TAG, 'getImageProperties succeed, data: ' + JSON.stringify(data));\\n}).catch((error: BusinessError) => {\\n  hilog.error(0x0000, TAG, 'getImageProperties failed, error: ' + JSON.stringify(error));\\n}); ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section175521657142419\\\"'><a name='\\\"section175521657142419\\\"'></a><a name='\\\"section175521657142419\\\"'></a><h4>读取图片信息</h4><p><strong>实现原理</strong></p> <p>HarmonyOS提供了ImageSource图片源类用于获取图片相关信息，既可以读取图片大小、像素格式等基本信息，也可以读取EXIF信息，如曝光时间、光圈值等。</p> <p><strong>开发步骤</strong></p> <p>首先基于前文获得的图片uri，创建一个ImageSource实例，然后调用相关方法即可读取图片信息。</p> <p>读取基本信息：</p>  <p>读取EXIF信息：</p> <pre class='\\\"screen\\\"'>let key = [image.PropertyKey.IMAGE_WIDTH, image.PropertyKey.IMAGE_LENGTH, image.PropertyKey.F_NUMBER];\\nthis.imageSource.getImageProperties(key).then((data) =&gt; {\\n  hilog.info(0x0000, TAG, 'getImageProperties succeed, data: ' + JSON.stringify(data));\\n}).catch((error: BusinessError) =&gt; {\\n  hilog.error(0x0000, TAG, 'getImageProperties failed, error: ' + JSON.stringify(error));\\n});</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-image_get_and_save.html"
    },
    {
        "id": 318,
        "pre": "// ets/utils/DataConversion.ets\\n// 字符串转成字节流\\npublic static stringToUint8Array(str: string): Uint8Array {\\n  let textEncoder = util.TextEncoder.create('utf-8');\\n  return textEncoder.encodeInto(str);\\n}\\n\\n// 字节流转成可理解的字符串\\npublic static uint8ArrayToString(input: Uint8Array): string {\\n  let textDecoder = util.TextDecoder.create('utf-8');\\n  return textDecoder.decodeToString(input);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "普通编码格式的字符串与Uint8Array类型的转换建议采用UTF-8编码。UTF-8编码是一种广泛支持的字符编码，能够表示大多数语言的字符，且在不同平台间具有很好的兼容性。  ",
        "import_module": null,
        "parent": "<li>普通编码格式的字符串与Uint8Array类型的转换<p>建议采用UTF-8编码。UTF-8编码是一种广泛支持的字符编码，能够表示大多数语言的字符，且在不同平台间具有很好的兼容性。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-cross-platform-compatibility.html"
    },
    {
        "id": 319,
        "pre": "// 根据密钥参数生成SM2公钥\\npublic static async convertStrToPubKey(keyStr: string): Promise<cryptoFramework.PubKey> {\\n  const puKeyStr = keyStr.startsWith('04') ? keyStr.slice(2) : keyStr;\\n  const pkPart1 = puKeyStr.slice(0, puKeyStr.length / 2);\\n  const pkPart2 = puKeyStr.slice(puKeyStr.length / 2);\\n  // 将16进制放入对应的位置\\n  const pks: cryptoFramework.Point = {\\n    x: BigInt('0x' + pkPart1),\\n    y: BigInt('0x' + pkPart2)\\n  };\\n  // 公钥对象参数\\n  const pubKeySpec: cryptoFramework.ECCPubKeySpec = {\\n    params: cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2'),\\n    pk: pks,\\n    algName: 'SM2',\\n    specType: cryptoFramework.AsyKeySpecType.PUBLIC_KEY_SPEC\\n  };\\n  const keypairGenerator = cryptoFramework.createAsyKeyGeneratorBySpec(pubKeySpec);\\n  let pksData = keypairGenerator.generatePubKeySync();\\n  return pksData;\\n}",
        "type": "Reference",
        "function_call": "generatePriKeySync()",
        "function_name": null,
        "parent_text": "SM2密钥格式转换SM2加解密中，其他平台与HarmonyOS平台的密钥格式不符，其中HarmonyOS平台支持ASN.1序列化后的数据（公钥91字节，私钥51字节），而很多开发者使用的其他平台密钥数据是未序列化过的原始裸数据（公钥64字节，私钥32字节），不能直接使用，需要转换为ASN.1格式的数据。下面以其他平台生成的十六进制密钥为例，介绍如何转换为HarmonyOS平台可用的SM2密钥。 其他平台生成的公钥都是04开头的130位字符串，对应的格式为04+x+y，x和y的长度是一致的，私钥则是不带04的128位字符串。 将对应的16进制参数放入对应的位置，可通过密钥参数生成SM2公钥。  同理，可通过密钥参数生成SM2私钥。 // 根据密钥参数生成sm2私钥\\npublic static async convertStrToPriKey(keyStr: string): Promise<cryptoFramework.PriKey> {\\n  const sks = BigInt('0x' + keyStr);\\n  // 私钥对象参数\\n  const priKeySpec: cryptoFramework.ECCPriKeySpec = {\\n    params: cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2'),\\n    sk: sks,\\n    algName: 'SM2',\\n    specType: cryptoFramework.AsyKeySpecType.PRIVATE_KEY_SPEC\\n  };\\n  const priKeypairGenerator = cryptoFramework.createAsyKeyGeneratorBySpec(priKeySpec);\\n  let sksData = priKeypairGenerator.generatePriKeySync();\\n  return sksData;\\n} ",
        "import_module": null,
        "parent": "<li>SM2密钥格式转换<p>SM2加解密中，其他平台与HarmonyOS平台的密钥格式不符，其中HarmonyOS平台支持ASN.1序列化后的数据（公钥91字节，私钥51字节），而很多开发者使用的其他平台密钥数据是未序列化过的原始裸数据（公钥64字节，私钥32字节），不能直接使用，需要转换为ASN.1格式的数据。下面以其他平台生成的十六进制密钥为例，介绍如何转换为HarmonyOS平台可用的SM2密钥。</p> <p>其他平台生成的公钥都是04开头的130位字符串，对应的格式为04+x+y，x和y的长度是一致的，私钥则是不带04的128位字符串。</p> <p>将对应的16进制参数放入对应的位置，可通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/crypto-asym-key-generation-conversion-spec#使用密钥参数生成-3\\\"' target='\\\"_blank\\\"'>密钥参数生成</a>SM2公钥。</p>  <p>同理，可通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/crypto-asym-key-generation-conversion-spec#使用密钥参数生成-3\\\"' target='\\\"_blank\\\"'>密钥参数生成</a>SM2私钥。</p> <pre class='\\\"screen\\\"'>// 根据密钥参数生成sm2私钥\\npublic static async convertStrToPriKey(keyStr: string): Promise&lt;cryptoFramework.PriKey&gt; {\\n  const sks = BigInt('0x' + keyStr);\\n  // 私钥对象参数\\n  const priKeySpec: cryptoFramework.ECCPriKeySpec = {\\n    params: cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2'),\\n    sk: sks,\\n    algName: 'SM2',\\n    specType: cryptoFramework.AsyKeySpecType.PRIVATE_KEY_SPEC\\n  };\\n  const priKeypairGenerator = cryptoFramework.createAsyKeyGeneratorBySpec(priKeySpec);\\n  let sksData = priKeypairGenerator.generatePriKeySync();\\n  return sksData;\\n}</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-cross-platform-compatibility.html"
    },
    {
        "id": 320,
        "pre": "Slider({\\n  value: this.isSliderGesture ? this.panEndTime : this.avPlayerController.currentTime,\\n  step: 0.1,\\n  min: 0,\\n  max: this.avPlayerController.durationTime,\\n  style: this.sliderStyle\\n})\\n  // ...\\n  .trackColor($r('app.color.white_opacity_1_color')) // 滑轨背景颜色\\n  .showSteps(false) // 是否显示步长刻度\\n  .blockSize({ width: this.blockSize, height: this.blockSize }) // 滑块大小\\n  .blockColor($r('sys.color.background_primary')) // 滑块颜色\\n  .trackThickness(this.trackThicknessSize) // 滑轨粗细\\n  .trackBorderRadius(2) // 底板圆角半径\\n  .selectedBorderRadius(2) // 已滑动部分圆角半径\\n  // ...\\n  .onChange((value: number, mode: SliderChangeMode) => {\\n    this.sliderOnchange(value, mode); // 进度条变化接口\\n  })\\n\\nsliderOnchange(seconds: number, mode: SliderChangeMode) {\\n  let seekTime: number = seconds * this.avPlayerController.duration / this.avPlayerController.durationTime;\\n  this.currentStringTime = secondToTime(Math.floor(seekTime / 1000));\\n  this.avPlayerController.setCurrentStringTime(this.currentStringTime);\\n  switch (mode) {\\n    case SliderChangeMode.Begin:\\n      break;\\n    case SliderChangeMode.Click:\\n      break;\\n    case SliderChangeMode.Moving:\\n      // ...\\n      break;\\n    case SliderChangeMode.End:\\n      this.avPlayerController.seek(seekTime); // 调用AVPlayer的seek方法控制播放进度\\n      // ...\\n      break;\\n    default:\\n      break;\\n  }\\n}",
        "type": "Reference",
        "function_call": "事件中触发视频播放器AVPlayer的seek()",
        "function_name": "[h2]播放进度控制",
        "parent_text": "[h2]播放进度控制进度条控制 进度条作为视频应用的一个基础能力，可以通过点击或拖动进度条来调节视频播放进度。采用Slider组件实现进度条功能，根据Slider组件属性设置进度条样式，并在其onChange()事件中触发视频播放器AVPlayer的seek()方法，实现视频进度的控制。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section56531643135417\\\"'><a name='\\\"section56531643135417\\\"'></a><a name='\\\"section56531643135417\\\"'></a><h4>[h2]播放进度控制</h4><p><strong>进度条控制</strong></p> <p>进度条作为视频应用的一个基础能力，可以通过点击或拖动进度条来调节视频播放进度。采用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-slider\\\"' target='\\\"_blank\\\"'>Slider组件</a>实现进度条功能，根据Slider组件属性设置进度条样式，并在其onChange()事件中触发视频播放器AVPlayer的seek()方法，实现视频进度的控制。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-playback-development-practice.html"
    },
    {
        "id": 321,
        "pre": "// 根据应用自身的旋转策略选择相应的参数\\nsetMainWindowOrientation(orientation: window.Orientation, callback?: Function): void {\\n  // ...\\n  this.mainWindowClass.setPreferredOrientation(orientation).then(() => {\\n    callback?.();\\n  }).catch((err: BusinessError) => {\\n    hilog.error(0x0001, TAG, `Failed to set the ${orientation} of main window. Code:${err.code}, message:${err.message}`);\\n  });\\n}",
        "type": "Reference",
        "function_call": "通过setPreferredOrientation()",
        "function_name": null,
        "parent_text": "设置窗口旋转当进入首页视频列表时，仅支持竖屏，要切换视频播放页面为横屏时，采用window窗口能力，通过setPreferredOrientation()将窗口显示的方向修改为横屏、竖屏的状态。在使用时，根据应用自身的旋转策略选择相应的参数。窗口显示方向类型枚举可以参考：window.Orientation。  ",
        "import_module": null,
        "parent": "<li>设置窗口旋转<p>当进入首页视频列表时，仅支持竖屏，要切换视频播放页面为横屏时，采用window窗口能力，通过setPreferredOrientation()将窗口显示的方向修改为横屏、竖屏的状态。在使用时，根据应用自身的旋转策略选择相应的参数。窗口显示方向类型枚举可以参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#orientation9\\\"' target='\\\"_blank\\\"'>window.Orientation</a>。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-playback-development-practice.html"
    },
    {
        "id": 322,
        "pre": "Column() {\\n  AVVolumePanel({\\n    volumeLevel: this.volume,\\n    volumeParameter: {\\n      position: {\\n        x: 150,\\n        y: 300\\n      }\\n    }\\n  })\\n}\\n.width('50%')",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用AVVolumePanel组件设置音量面板； ",
        "import_module": null,
        "parent": "<li>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-multimedia-avvolumepanel\\\"' target='\\\"_blank\\\"'>AVVolumePanel组件</a>设置音量面板； </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-video-playback-development-practice.html"
    },
    {
        "id": 323,
        "pre": "@Concurrent\\nfunction computeTask(): string[] {\\n  let array: string[] = []\\n  // AppConstant.CITYS 为需要加载的数据\\n  for (let t of AppConstant.CITYS) {\\n    array.push(t.trim())\\n  }\\n  let collator = new Intl.Collator(\\\"zh-CN\\\", { localeMatcher: \\\"lookup\\\", usage: \\\"sort\\\" });\\n  array.sort((a, b) => collator.compare(a, b))\\n  return array;\\n}\\n\\n@Entry\\n@Component\\nstruct CityList {\\n  isAsync: boolean = (router.getParams() as Record<string, boolean>)['isAsync'];\\n  // 界面数据\\n  @State citys: string[] = []\\n  private listScroller: Scroller = new Scroller();\\n\\n  aboutToAppear() {\\n    this.computeTaskAsync(); // 调用异步运算函数\\n  }\\n\\n  // 异步线程\\n  computeTaskAsync() {\\n    let task: taskpool.Task = new taskpool.Task(computeTask);\\n    taskpool.execute(task).then((res) => {\\n      this.citys = res as string[]\\n    })\\n  }\\n\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]并发优化",
        "parent_text": "[h2]并发优化该示例是一个添加地址的功能，当点击“选择“按钮后，应用响应切换到选择城市地区的目标页。在切换过程中，要将全国城市数据加载，根据首字符排序，然后刷新到新页面列表中。 在实际场景中，开发者可能直接用同步串行的方式实现这一功能：点击按钮后，初始化页面，将数据加载到内存中，然后渲染出整个界面视图。 当目标页选择范围到”市”这一行政级别，数据量大约1000条，新页面响应速度理想，直观上没有异样； 如果功能需求调整，当目标页选择范围到”区”这一级别，数据量达到2000，页面响应速度尚可接受； 如果功能进一步调整，当目标页选择范围到”乡镇/街道”这一级别时，数据量突破4000，页面响应出现明显延迟。 因为地区数据的加载和排序，这两个过程都需要消耗一定的性能计算，在这种情况下，可以使用并发机制来优化。   代码实现 在目标页面的aboutToAppear中，使用TaskPool启动子线程加载城市数据，实现并发操作：  统计分析 使用Profiler Time工具，分别测试不同数量级别下的响应时长，得到结果如下： 表3 不同数据量的响应时长   500条数据  1000条数据  2000条数据  4000条数据    串行  49ms  94ms  296ms  780ms   并发  48ms  86ms  140ms  172ms     可以看出，在该场景下，如果数据量不大（小于1000），串行加载的用户体验也可以保持良好，但随着城市数据量的递增，当超过1000条时，响应时长增大加快，体验开始显著恶化，从手指抬起到页面转场进入列表页的第一帧画面，会明显出现视觉可见的响应迟滞。 这时采用并发异步加载的优势体现出来，在实践中，UI主线程可以第一时间拉起目标列表页面，同时触发异步加载及排序的逻辑线程，待结果返回后再刷新到列表中，提升整体的响应速度。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section878021963815\\\"'><a name='\\\"section878021963815\\\"'></a><a name='\\\"section878021963815\\\"'></a><h4>[h2]并发优化</h4><p>该示例是一个添加地址的功能，当点击“选择“按钮后，应用响应切换到选择城市地区的目标页。在切换过程中，要将全国城市数据加载，根据首字符排序，然后刷新到新页面列表中。</p> <p>在实际场景中，开发者可能直接用同步串行的方式实现这一功能：点击按钮后，初始化页面，将数据加载到内存中，然后渲染出整个界面视图。</p> <p>当目标页选择范围到”市”这一行政级别，数据量大约1000条，新页面响应速度理想，直观上没有异样；</p> <p>如果功能需求调整，当目标页选择范围到”区”这一级别，数据量达到2000，页面响应速度尚可接受；</p> <p>如果功能进一步调整，当目标页选择范围到”乡镇/街道”这一级别时，数据量突破4000，页面响应出现明显延迟。</p> <p>因为地区数据的加载和排序，这两个过程都需要消耗一定的性能计算，在这种情况下，可以使用并发机制来优化。</p> <p></p> <p></p> <p><strong>代码实现</strong></p> <p>在目标页面的aboutToAppear中，使用TaskPool启动子线程加载城市数据，实现并发操作：</p>  <p><strong>统计分析</strong></p> <p>使用Profiler Time工具，分别测试不同数量级别下的响应时长，得到结果如下：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表3 </b><strong>不同数据量的响应时长</strong></caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.4.15.2.6.1.1\\\"' valign='\\\"top\\\"' width='\\\"23.12%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.4.15.2.6.1.2\\\"' valign='\\\"top\\\"' width='\\\"18.440000000000005%\\\"'><p>500条数据</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.4.15.2.6.1.3\\\"' valign='\\\"top\\\"' width='\\\"18.6%\\\"'><p>1000条数据</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.4.15.2.6.1.4\\\"' valign='\\\"top\\\"' width='\\\"19.340000000000003%\\\"'><p>2000条数据</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.4.15.2.6.1.5\\\"' valign='\\\"top\\\"' width='\\\"20.5%\\\"'><p>4000条数据</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"23.12%\\\"'><p>串行</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.440000000000005%\\\"'><p>49ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.6%\\\"'><p>94ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.340000000000003%\\\"'><p>296ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"20.5%\\\"'><p>780ms</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"23.12%\\\"'><p>并发</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.440000000000005%\\\"'><p>48ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.6%\\\"'><p>86ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.340000000000003%\\\"'><p>140ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"20.5%\\\"'><p>172ms</p> </td> </tr> </tbody></table> </div> <p>可以看出，在该场景下，如果数据量不大（小于1000），串行加载的用户体验也可以保持良好，但随着城市数据量的递增，当超过1000条时，响应时长增大加快，体验开始显著恶化，从手指抬起到页面转场进入列表页的第一帧画面，会明显出现视觉可见的响应迟滞。</p> <p>这时采用并发异步加载的优势体现出来，在实践中，UI主线程可以第一时间拉起目标列表页面，同时触发异步加载及排序的逻辑线程，待结果返回后再刷新到列表中，提升整体的响应速度。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-latency-optimization-cases.html"
    },
    {
        "id": 324,
        "pre": "for (let i = 0; i < count; i++) {\\n  let tmp: AccountData = {\\n    id: 0,\\n    accountType: 0,\\n    typeText: '',\\n    amount: 0\\n  };\\n  tmp.id = resultSet.getDouble(resultSet.getColumnIndex('id'));\\n  tmp.accountType = resultSet.getDouble(resultSet.getColumnIndex('accountType'));\\n  tmp.typeText = resultSet.getString(resultSet.getColumnIndex('typeText'));\\n  tmp.amount = resultSet.getDouble(resultSet.getColumnIndex('amount'));\\n  result[i] = tmp;\\n  resultSet.goToNextRow();\\n}",
        "type": "Reference",
        "function_call": "goToNextRow()",
        "function_name": "[h2]减少调用数据库API次数",
        "parent_text": "[h2]减少调用数据库API次数本节示例是一个记账工具应用，其基于关系型数据库管理相关账目。 在查询用户数据时，会依次读取account表中每一行的数据，其中每一列column的值，需要借助getColumnIndex(\\\"列名\\\")得到column索引，然后再取得对应值 。 修改前代码：  从代码可知，for循环内调用getColumnIndex，总的调用次数会随着数据行数count的增大而增大。数据表结构固定的情况下，索引不会变化 ，可以将调用提前以减少总的调用次数，优化指令耗时。 修改后代码： const idIndex = resultSet.getColumnIndex(\\\"id\\\");\\nconst accountTypeIndex = resultSet.getColumnIndex(\\\"accountType\\\");\\nconst typeTextIndex = resultSet.getColumnIndex(\\\"typeText\\\");\\nconst amountIndex = resultSet.getColumnIndex(\\\"amount\\\");\\nfor (let i = 0; i < count; i++) {\\n  let tmp: AccountData = {\\n    id: 0,\\n    accountType: 0,\\n    typeText: '',\\n    amount: 0\\n  };\\n  tmp.id = resultSet.getDouble(idIndex);\\n  tmp.accountType = resultSet.getDouble(accountTypeIndex);\\n  tmp.typeText = resultSet.getString(typeTextIndex);\\n  tmp.amount = resultSet.getDouble(amountIndex);\\n  result[i] = tmp;\\n  resultSet.goToNextRow();\\n} 统计分析 使用Profiler Time工具，分别测试不同数量下的响应时长，得到结果如下： 表4 不同数据量的响应时长   50条数据  500条数据  5000条数据    修改前  72ms  97ms  157ms   修改后  72ms  92ms  110ms     由此可以看出，在数据库使用时，要关注相关API调用的潜在频率： 数据条目在初期量级不大时，API调用行对应用响应影响甚微；伴随着使用时间的增长，数据量级大到一定程度，这种潜在可能的高频调用，会直接影响程序的性能表现。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1478111913814\\\"'><a name='\\\"section1478111913814\\\"'></a><a name='\\\"section1478111913814\\\"'></a><h4>[h2]减少调用数据库API次数</h4><p>本节示例是一个记账工具应用，其基于关系型数据库管理相关账目。</p> <p>在查询用户数据时，会依次读取account表中每一行的数据，其中每一列column的值，需要借助getColumnIndex(\\\"列名\\\")得到column索引，然后再取得对应值 。</p> <p>修改前代码：</p>  <p>从代码可知，for循环内调用getColumnIndex，总的调用次数会随着数据行数count的增大而增大。数据表结构固定的情况下，索引不会变化 ，可以将调用提前以减少总的调用次数，优化指令耗时。</p> <p>修改后代码：</p> <pre class='\\\"screen\\\"'>const idIndex = resultSet.getColumnIndex(\\\"id\\\");\\nconst accountTypeIndex = resultSet.getColumnIndex(\\\"accountType\\\");\\nconst typeTextIndex = resultSet.getColumnIndex(\\\"typeText\\\");\\nconst amountIndex = resultSet.getColumnIndex(\\\"amount\\\");\\nfor (let i = 0; i &lt; count; i++) {\\n  let tmp: AccountData = {\\n    id: 0,\\n    accountType: 0,\\n    typeText: '',\\n    amount: 0\\n  };\\n  tmp.id = resultSet.getDouble(idIndex);\\n  tmp.accountType = resultSet.getDouble(accountTypeIndex);\\n  tmp.typeText = resultSet.getString(typeTextIndex);\\n  tmp.amount = resultSet.getDouble(amountIndex);\\n  result[i] = tmp;\\n  resultSet.goToNextRow();\\n}</pre> <p><strong>统计分析</strong></p> <p>使用Profiler Time工具，分别测试不同数量下的响应时长，得到结果如下：</p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表4 </b><strong>不同数据量的响应时长</strong></caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.11.2.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"28.402840284028404%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.11.2.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"22.65226522652265%\\\"'><p>50条数据</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.11.2.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"23.762376237623766%\\\"'><p>500条数据</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.11.2.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"25.182518251825186%\\\"'><p>5000条数据</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"28.402840284028404%\\\"'><p>修改前</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.65226522652265%\\\"'><p>72ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"23.762376237623766%\\\"'><p>97ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"25.182518251825186%\\\"'><p>157ms</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"28.402840284028404%\\\"'><p>修改后</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.65226522652265%\\\"'><p>72ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"23.762376237623766%\\\"'><p>92ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"25.182518251825186%\\\"'><p>110ms</p> </td> </tr> </tbody></table> </div> <p>由此可以看出，在数据库使用时，要关注相关API调用的潜在频率：</p> <p>数据条目在初期量级不大时，API调用行对应用响应影响甚微；伴随着使用时间的增长，数据量级大到一定程度，这种潜在可能的高频调用，会直接影响程序的性能表现。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-latency-optimization-cases.html"
    },
    {
        "id": 325,
        "pre": "let cameraOutput: camera.PreviewOutput;\\nlet cameraInput: camera.CameraInput;\\nlet captureSession: camera.PhotoSession;\\nlet previewOutput: camera.PhotoOutput;\\n\\n// 相机页面每次隐藏时触发一次\\nonPageHide() {\\n  this.releaseCamera();\\n}\\n\\n// 释放资源\\npublic async releaseCamera() {\\n  try {\\n    // 拍照模式会话类暂停\\n    await captureSession?.stop();\\n    // 拍照模式会话类释放\\n    await captureSession?.release();\\n    // 拍照输入对象类关闭\\n    await cameraInput?.close();\\n    // 预览输出对象类释放\\n    await previewOutput?.release();\\n    // 拍照输出对象类释放\\n    await cameraOutput?.release();\\n  } catch (e) {\\n    hilog.error(0x00, 'release input output error:', JSON.stringify(e));\\n  }\\n}",
        "type": "Reference",
        "function_call": "release()",
        "function_name": "[h2]延迟执行资源释放操作",
        "parent_text": "[h2]延迟执行资源释放操作该场景是相机正常使用后，执行释放相机资源的相关操作。通过“停止拍摄进程 > 暂停并释放相机会话 > 关闭和释放预览及拍照的输入输出对象 > 清空相机管理对象”的过程，确保应用程序在不再使用相机时能够有效管理并回收所有相机资源。但是直接调用的release方法中captureSession、cameraInput、previewOutput、cameraOutput都用了await,使相机关闭和释放顺序执行可能会导致应用程序的响应性下降，造成用户界面卡顿。 下列代码将资源释放操作放在相机页面隐藏时触发的函数：  修改后，启动setTimeout异步延迟操作，在200ms后调用release释放关闭相机。其通过“停止拍摄进程 > 并发执行：（暂停并释放相机会话 > 关闭和释放预览及拍照的输入输出对象 > 清空相机管理对象）”的过程，确保应用程序在不再使用相机时能够有效管理并回收所有相机资源。移除await关键字应用于相机资源释放操作，允许异步并发执行，显著减少了主线程阻塞，从而提升了应用性能和响应速度。 let cameraOutput: camera.PreviewOutput;\\nlet cameraInput: camera.CameraInput;\\nlet captureSession: camera.PhotoSession;\\nlet previewOutput: camera.PhotoOutput;\\n\\n// 相机页面每次隐藏时触发一次\\nonPageHide() {\\n  setTimeout(this.releaseCamera, 200);\\n}\\n\\n// 释放资源\\npublic async releaseCamera() {\\n  try {\\n    // 拍照模式会话类暂停\\n    await captureSession?.stop();\\n    // 拍照模式会话类释放\\n    await captureSession?.release();\\n    // 拍照输入对象类关闭\\n    await cameraInput?.close();\\n    // 预览输出对象类释放\\n    await previewOutput?.release();\\n    // 拍照输出对象类释放\\n    await cameraOutput?.release();\\n  } catch (e) {\\n    hilog.error(0x00, 'release input output error:', JSON.stringify(e));\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section8783201923819\\\"'><a name='\\\"section8783201923819\\\"'></a><a name='\\\"section8783201923819\\\"'></a><h4>[h2]延迟执行资源释放操作</h4><p>该场景是相机正常使用后，执行释放相机资源的相关操作。通过“停止拍摄进程 &gt; 暂停并释放相机会话 &gt; 关闭和释放预览及拍照的输入输出对象 &gt; 清空相机管理对象”的过程，确保应用程序在不再使用相机时能够有效管理并回收所有相机资源。但是直接调用的release方法中captureSession、cameraInput、previewOutput、cameraOutput都用了await,使相机关闭和释放顺序执行可能会导致应用程序的响应性下降，造成用户界面卡顿。</p> <p>下列代码将资源释放操作放在相机页面隐藏时触发的函数：</p>  <p>修改后，启动setTimeout异步延迟操作，在200ms后调用release释放关闭相机。其通过“停止拍摄进程 &gt; 并发执行：（暂停并释放相机会话 &gt; 关闭和释放预览及拍照的输入输出对象 &gt; 清空相机管理对象）”的过程，确保应用程序在不再使用相机时能够有效管理并回收所有相机资源。移除await关键字应用于相机资源释放操作，允许异步并发执行，显著减少了主线程阻塞，从而提升了应用性能和响应速度。</p> <pre class='\\\"screen\\\"'>let cameraOutput: camera.PreviewOutput;\\nlet cameraInput: camera.CameraInput;\\nlet captureSession: camera.PhotoSession;\\nlet previewOutput: camera.PhotoOutput;\\n\\n// 相机页面每次隐藏时触发一次\\nonPageHide() {\\n  setTimeout(this.releaseCamera, 200);\\n}\\n\\n// 释放资源\\npublic async releaseCamera() {\\n  try {\\n    // 拍照模式会话类暂停\\n    await captureSession?.stop();\\n    // 拍照模式会话类释放\\n    await captureSession?.release();\\n    // 拍照输入对象类关闭\\n    await cameraInput?.close();\\n    // 预览输出对象类释放\\n    await previewOutput?.release();\\n    // 拍照输出对象类释放\\n    await cameraOutput?.release();\\n  } catch (e) {\\n    hilog.error(0x00, 'release input output error:', JSON.stringify(e));\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-latency-optimization-cases.html"
    },
    {
        "id": 326,
        "pre": "import { hiTraceMeter } from '@kit.PerformanceAnalysisKit'\\n\\n@Entry\\n@Component\\nstruct PanGestureExample {\\n  @State offsetX: number = 0\\n  @State offsetY: number = 0\\n  @State positionX: number = 0\\n  @State positionY: number = 0\\n  private panOption: PanGestureOptions = new PanGestureOptions({ direction: PanDirection.Left | PanDirection.Right })\\n\\n  build() {\\n    Column() {\\n      Column() {\\n        Text('PanGesture offset:\\\\nX: ' + this.offsetX + '\\\\n' + 'Y: ' + this.offsetY)\\n      }\\n      .height(200)\\n      .width(300)\\n      .padding(20)\\n      .border({ width: 3 })\\n      .margin(50)\\n      .translate({ x: this.offsetX, y: this.offsetY, z: 0 }) // 以组件左上角为坐标原点进行移动\\n      // 左右拖动触发该手势事件\\n      .gesture(\\n        PanGesture(this.panOption)\\n          .onActionStart((event: GestureEvent) => {\\n            console.info('Pan start')\\n            hiTraceMeter.startTrace(\\\"PanGesture\\\", 1)\\n          })\\n          .onActionUpdate((event: GestureEvent) => {\\n            if (event) {\\n              this.offsetX = this.positionX + event.offsetX\\n              this.offsetY = this.positionY + event.offsetY\\n            }\\n          })\\n          .onActionEnd(() => {\\n            this.positionX = this.offsetX\\n            this.positionY = this.offsetY\\n            console.info('Pan end')\\n            hiTraceMeter.finishTrace(\\\"PanGesture\\\", 1)\\n          })\\n      )\\n\\n      Button('修改PanGesture触发条件')\\n        .onClick(() => {\\n          this.panOption.setDistance(100)\\n        })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]减小拖动识别距离",
        "parent_text": "[h2]减小拖动识别距离该场景是对一个组件添加手势事件。优化前，指定触发拖动手势事件的最小拖动距离为100vp，代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1116134115286\\\"'><a name='\\\"section1116134115286\\\"'></a><a name='\\\"section1116134115286\\\"'></a><h4>[h2]减小拖动识别距离</h4><p>该场景是对一个组件添加手势事件。优化前，指定触发拖动手势事件的最小拖动距离为100vp，代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-latency-optimization-cases.html"
    },
    {
        "id": 327,
        "pre": "// page A 转场动画设置\\npageTransition() {\\n  PageTransitionEnter({ type: RouteType.None, duration: 400 })\\n    .slide(SlideEffect.Left)\\n  PageTransitionExit({ type: RouteType.None, duration: 400 })\\n    .slide(SlideEffect.Left)\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]转场动画场景案例",
        "parent_text": "[h2]转场动画场景案例下面列举的示例通过多种不同的连贯动画，让应用使用者在操作过程中能够感受到程序的快速响应。 该示例场景：从留言箱的列表项点击后，执行响应切换进入个人页。在这一过程中，使用了三个动画组成其完整过程： 在整体界面的切换过程，使用了系统平台提供的转场动画，两个界面通过横向滑动，完成切换。在转场动画的运行中，添加了头像移动缩放等变化的共享元素动画，以此体现具体响应元素的切换过渡。在个人页列表加载前，添加了以列表轮廓为形态的骨架图闪烁动画，从而让用户感知新页面在加载运行的动态过程。 图7 场景实例图   具体实现 用router+sharedTransition+animateTo的组合实现，具体操作思路如下： 分别在两个页面中设置pageTransition转场动画参数，然后在列表页头像的点击事件中添加router跳转，实现列表页到个人页的转场动画效果。分别在两个页面的头像组件Image中添加属性sharedTransition，赋值相同的id进行唯一匹配，并添加共享元素动画的时间等相关参数，实现在转场中，头像从列表页向个人页移动的动画效果。根据个人页内容的版面样式，实现一个骨架图组件，并使用animateTo对其添加一个反复渐显渐隐的动画行为，在个人页组件onAppear时呈现出来，然后在具体内容刷新出来后隐藏该动画元素。 关键代码 转场动画设置：  列表页中共享元素动画设置： // 列表中用头像做为共享元素，指定id为sharedImage+this.itemData.id\\nImage(this.itemData.avatar)\\n  .height('40vp')\\n  .width('40vp')\\n  .borderRadius(8)\\n  .sharedTransition('sharedImage' + this.itemData.id, { duration: 500, curve: Curve.FastOutSlowIn, delay: 0 }) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section17886155414385\\\"'><a name='\\\"section17886155414385\\\"'></a><a name='\\\"section17886155414385\\\"'></a><h4>[h2]转场动画场景案例</h4><p>下面列举的示例通过多种不同的连贯动画，让应用使用者在操作过程中能够感受到程序的快速响应。</p> <p>该示例场景：从留言箱的列表项点击后，执行响应切换进入个人页。在这一过程中，使用了三个动画组成其完整过程：</p> <ul><li>在整体界面的切换过程，使用了系统平台提供的转场动画，两个界面通过横向滑动，完成切换。</li><li>在转场动画的运行中，添加了头像移动缩放等变化的共享元素动画，以此体现具体响应元素的切换过渡。</li><li>在个人页列表加载前，添加了以列表轮廓为形态的骨架图闪烁动画，从而让用户感知新页面在加载运行的动态过程。</li></ul> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图7 </b>场景实例图</span></div> <p><span><img height='\\\"416.680754\\\"' originheight='\\\"804\\\"' originwidth='\\\"385\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161217.57088015270266280420074956056398:50001231000000:2800:65C7D7976501385AA69FDB7B0EE919EC0C9FB2BCE068CD813B31725C49B652E4.png\\\"' title='\\\"点击放大\\\"' width='\\\"206.88948000000002\\\"'/></span></p> <p></p> <p><strong>具体实现</strong></p> <p>用router+sharedTransition+animateTo的组合实现，具体操作思路如下：</p> <ol><li><span>分别在两个页面中设置pageTransition转场动画参数，然后在列表页头像的点击事件中添加router跳转，实现列表页到个人页的转场动画效果。</span></li><li><span>分别在两个页面的头像组件Image中添加属性sharedTransition，赋值相同的id进行唯一匹配，并添加共享元素动画的时间等相关参数，实现在转场中，头像从列表页向个人页移动的动画效果。</span></li><li><span>根据个人页内容的版面样式，实现一个骨架图组件，并使用animateTo对其添加一个反复渐显渐隐的动画行为，在个人页组件onAppear时呈现出来，然后在具体内容刷新出来后隐藏该动画元素。</span></li></ol> <p><strong>关键代码</strong></p> <p>转场动画设置：</p>  <p>列表页中共享元素动画设置：</p> <pre class='\\\"screen\\\"'>// 列表中用头像做为共享元素，指定id为sharedImage+this.itemData.id\\nImage(this.itemData.avatar)\\n  .height('40vp')\\n  .width('40vp')\\n  .borderRadius(8)\\n  .sharedTransition('sharedImage' + this.itemData.id, { duration: 500, curve: Curve.FastOutSlowIn, delay: 0 })</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-latency-optimization-cases.html"
    },
    {
        "id": 328,
        "pre": "@Entry\\n@Component\\nstruct TabsPositiveExample {\\n  @State currentIndex: number = 0;\\n  private controller: TabsController = new TabsController();\\n  private list: string[] = ['green', 'blue', 'yellow', 'pink'];\\n\\n  @Builder\\n  customContent(color: Color) {\\n    Column()\\n      .width('100%')\\n      .height('100%')\\n      .backgroundColor(color)\\n  }\\n\\n  build() {\\n    Column() {\\n      Row({ space: 10 }) {\\n        ForEach(this.list, (item: string, index: number) => {\\n          Text(item)\\n            .textAlign(TextAlign.Center)\\n            .fontSize(16)\\n            .height(32)\\n            .layoutWeight(1)\\n            .fontColor(this.currentIndex === index ? Color.White : Color.Black)\\n            .backgroundColor(this.currentIndex === index ? Color.Blue : '#f2f2f2')\\n            .borderRadius(16)\\n            .onClick(() => {\\n              this.currentIndex = index;\\n              this.controller.changeIndex(index);\\n            })\\n        }, (item: string, index: number) => JSON.stringify(item) + index)\\n      }\\n      .margin(10)\\n\\n      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) {\\n        TabContent() {\\n          this.customContent(Color.Green)\\n        }\\n\\n        TabContent() {\\n          this.customContent(Color.Blue)\\n        }\\n\\n        TabContent() {\\n          this.customContent(Color.Yellow)\\n        }\\n\\n        TabContent() {\\n          this.customContent(Color.Pink)\\n        }\\n      }\\n      .animationDuration(100)\\n      .layoutWeight(1)\\n      .barHeight(0)\\n      .scrollable(false)\\n    }\\n    .width('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]动画时延场景案例",
        "parent_text": "[h2]动画时延场景案例页面的转场动画是提升用户体验的重要环节。然而，当动画时延耗时较长时，它会对用户的点击完成时延产生显著影响。动画的完成时间直接关系到用户何时能够开始与应用进行交互。动画时延影响点击完成时延的根因主要为动画时长设置过长。 常见的页面转场动画时长参数有： Tabs组件设置TabContent切换动画时长，即animationDauration属性。Swiper组件设置子组件切换动画时长，即duration属性。页面间转场（pageTransition）设置转场动画时长，即PageTransitionOptions对象中的duration字段。 使用Tabs组件进行页面切换时，当不设置BottomTabBarStyle时默认animationDuration属性有300ms的动画时长，当该属性值设置过长时会导致完成时延变大。接下来将该属性值分别设置为100ms与1000ms来探究animationDuration属性对完成时延的影响。 实验一：设置animationDuration为100ms   实验二：设置animationDuration为1000ms@Entry\\n@Component\\nstruct TabsNegativeExample {\\n  // ...\\n  private controller: TabsController = new TabsController();\\n\\n  // ...\\n\\n  build() {\\n    Column() {\\n      // ...\\n\\n      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) {\\n        // ...\\n\\n      }\\n      .barHeight(0)\\n      .layoutWeight(1)\\n      .animationDuration(1000)\\n      .scrollable(false)\\n    }\\n    .width('100%')\\n  }\\n}   表7 运行效果图设置animationDuration为100ms  设置animationDuration为1000ms           表8 animationDuration属性值对比animationDuration属性值  完成时延    100ms  99ms39μs   1000ms  1s7ms693μs     上述示例通过减少animationDuration属性的数值，减小了Tabs组件切换动画的完成时延。当不设置BottomTabBarStyle样式时，动画时长默认为300ms，开发者可根据实际业务场景需要适当降低该动画时长，提高应用性能。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section36181326113013\\\"'><a name='\\\"section36181326113013\\\"'></a><a name='\\\"section36181326113013\\\"'></a><h4>[h2]动画时延场景案例</h4><p>页面的转场动画是提升用户体验的重要环节。然而，当动画时延耗时较长时，它会对用户的点击完成时延产生显著影响。动画的完成时间直接关系到用户何时能够开始与应用进行交互。动画时延影响点击完成时延的根因主要为动画时长设置过长。</p> <p>常见的页面转场动画时长参数有：</p> <ol><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs\\\"' target='\\\"_blank\\\"'>Tabs</a>组件设置TabContent切换动画时长，即<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs#animationduration\\\"' target='\\\"_blank\\\"'>animationDauration</a>属性。</li><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper\\\"' target='\\\"_blank\\\"'>Swiper</a>组件设置子组件切换动画时长，即<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#duration\\\"' target='\\\"_blank\\\"'>duration</a>属性。</li><li>页面间转场（<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-page-transition-animation\\\"' target='\\\"_blank\\\"'>pageTransition</a>）设置转场动画时长，即<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-page-transition-animation#pagetransitionoptions对象说明\\\"' target='\\\"_blank\\\"'>PageTransitionOptions</a>对象中的duration字段。</li></ol> <p>使用Tabs组件进行页面切换时，当不设置BottomTabBarStyle时默认<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs#animationduration\\\"' target='\\\"_blank\\\"'>animationDuration</a>属性有300ms的动画时长，当该属性值设置过长时会导致完成时延变大。接下来将该属性值分别设置为100ms与1000ms来探究animationDuration属性对完成时延的影响。</p> <p>实验一：设置animationDuration为100ms</p>  <p><span><img height='\\\"447.9041\\\"' originheight='\\\"924\\\"' originwidth='\\\"2195\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161217.46451891364924293204651379671552:50001231000000:2800:3456E4EE1AFE2080BF481CCAC7094EB3A75463C8258D7BAF5DCD707E2D3E21EE.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></p> <div class='\\\"p\\\"'>实验二：设置animationDuration为1000ms<pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct TabsNegativeExample {\\n  // ...\\n  private controller: TabsController = new TabsController();\\n\\n  // ...\\n\\n  build() {\\n    Column() {\\n      // ...\\n\\n      Tabs({ barPosition: BarPosition.Start, controller: this.controller }) {\\n        // ...\\n\\n      }\\n      .barHeight(0)\\n      .layoutWeight(1)\\n      .animationDuration(1000)\\n      .scrollable(false)\\n    }\\n    .width('100%')\\n  }\\n}</pre> </div> <p><span><img height='\\\"448.10360000000003\\\"' originheight='\\\"924\\\"' originwidth='\\\"2194\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161217.23193518612133305029729292126056:50001231000000:2800:DE64B281D1F10E73FDE9F75AAE08D1A44D30485DC1D4AC69FD2C3AAD377BC206.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></p> <div class='\\\"tablenoborder\\\"'><table><caption><b>表7 </b>运行效果图</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.29.11.2.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>设置animationDuration为100ms</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.29.11.2.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>设置animationDuration为1000ms</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p><span><img height='\\\"538.8854100000001\\\"' originheight='\\\"1080\\\"' originwidth='\\\"523\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161217.08529653943329389424043649424626:50001231000000:2800:933D510F3269D59C789AC6FDC856A466EA370936CD23EC15798505D534A545DC.gif\\\"' title='\\\"点击放大\\\"' width='\\\"270.41134400000004\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p><span><img height='\\\"538.9971300000001\\\"' originheight='\\\"1080\\\"' originwidth='\\\"523\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161217.77595411843175432752422581973209:50001231000000:2800:C95140D48388CB1570D31391FD3BD75AE9A5876563467A4EECDBE93DCFD7A596.gif\\\"' title='\\\"点击放大\\\"' width='\\\"268.27962\\\"'/></span></p> </td> </tr> </tbody></table> </div> <div class='\\\"tablenoborder\\\"'><table><caption><b>表8 </b>animationDuration属性值对比</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.29.12.2.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>animationDuration属性值</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.29.12.2.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>完成时延</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>100ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>99ms39μs</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>1000ms</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>1s7ms693μs</p> </td> </tr> </tbody></table> </div> <p>上述示例通过减少animationDuration属性的数值，减小了Tabs组件切换动画的完成时延。当不设置BottomTabBarStyle样式时，动画时长默认为300ms，开发者可根据实际业务场景需要适当降低该动画时长，提高应用性能。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-latency-optimization-cases.html"
    },
    {
        "id": 329,
        "pre": "export class StatusCodeInterceptor implements rcp.Interceptor {\\n  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {\\n    const url = context.request.url;\\n    return next.handle(context).then((res: rcp.Response) => {\\n      if ([200, 206].includes(res.statusCode)) {\\n        return Promise.resolve(res);\\n      } else {\\n        const message = `Failed to ${url}: statusCode is ${res.statusCode}, message is ${res.toString()}`;\\n        Logger.error(message);\\n        showErrorMessage(message);\\n        return Promise.reject(new Error(message));\\n      }\\n    }).catch((err: BusinessError) => {\\n      Logger.error(`Failed to ${url}: Code is ${err.code}, message is ${err.data}`);\\n      // cancel request don't show err message prompt.\\n      if (err.code !== 1007900992) {\\n        showErrorMessage(JSON.stringify(err.data));\\n      }\\n      return Promise.reject(err);\\n    });\\n  }\\n}",
        "type": "Reference",
        "function_call": "close()",
        "function_name": "[h2]开发步骤",
        "parent_text": "[h2]开发步骤 在使用Remote Communication Kit相关能力前，需配置以下权限。详细参考申请权限步骤。 ohos.permission.INTERNET：用于应用的权限，决定是否允许应用访问互联网。ohos.permission.GET_NETWORK_INFO：用于获取设备网络信息的 API 。  为避免在每个RCP发起请求的响应中重复判断状态码和处理异常情况，可利用rcp.Interceptor提供的拦截器对响应进行统一处理。对于非200、206状态码的响应， 使其返回失败的promise，并对请求失败情况进行统一的弹窗提示。具体的拦截逻辑可根据业务需求灵活设置。  在rcp.sessionConfiguration中配置请求的基地址baseAddress、相关拦截器interceptors、超时时间timeout和添加进度监听回调方法的对象httpEventsHandler。 function genSessionConfig(httpEventsHandler?: rcp.HttpEventsHandler) {\\n  const config: rcp.SessionConfiguration = {\\n    baseAddress: BASE_URL,\\n    interceptors: [new StatusCodeInterceptor()],\\n    requestConfiguration: {\\n      tracing: { httpEventsHandler },\\n      transfer: {\\n        timeout: {\\n          connectMs: 1000 * 60 * 20,\\n          transferMs: 1000 * 60 * 20\\n        }\\n      }\\n    }\\n  };\\n  return config;\\n} 下载步骤使用rcp.createSession()方法创建http会话，使用Session.downloadToFile()方法下载到沙箱路径，注意下载完成后使用Session.close()方法关闭会话，释放相关资源。export function download(fileName: string, httpEventsHandler: rcp.HttpEventsHandler) {\\n  const destPath = getSandboxPath(fileName);\\n  const rcpSession = rcp.createSession(genSessionConfig(httpEventsHandler));\\n  const downloadTo: rcp.DownloadToFile = {\\n    kind: 'file',\\n    file: destPath\\n  };\\n  return rcpSession.downloadToFile(`/${fileName}`, downloadTo)\\n    .then(() => destPath)\\n    .finally(() => {\\n      rcpSession.close();\\n    });\\n} 通过phAccessHelper.showAssetsCreationDialog()方法获取相册路径，并将下载到沙箱路径的文件拷贝到相册路径中。export async function saveImageToAlbum(sandboxPath: string) {\\n  const phAccessHelper = photoAccessHelper.getPhotoAccessHelper(getContext());\\n  const fileNameExtension = sandboxPath.split('.').pop() || 'png';\\n  const photoCreationConfig: photoAccessHelper.PhotoCreationConfig = {\\n    fileNameExtension,\\n    photoType: getPhotoType(fileNameExtension),\\n  };\\n  const uri: string = fileUri.getUriFromPath(sandboxPath);\\n  const desFileUris: string[] = await phAccessHelper.showAssetsCreationDialog([uri], [photoCreationConfig]);\\n  const filePath = desFileUris[0];\\n  if (!filePath) throw new Error('photo assets permission denied');\\n  copyFileSync(sandboxPath, filePath);\\n  return filePath;\\n}  上传步骤PhotoPicker.select()方法拉起相册模块，选择相册文件后在该方法回调函数中将相册文件拷贝到沙箱路径。export async function selectImagesFromAlbum(maxNumber: number = 1): Promise<string[]> {\\n  const photoPicker = new photoAccessHelper.PhotoViewPicker();\\n  const photoSelectOptions: photoAccessHelper.PhotoSelectOptions = {\\n    MIMEType: photoAccessHelper.PhotoViewMIMETypes.IMAGE_VIDEO_TYPE,\\n    maxSelectNumber: maxNumber\\n  };\\n  return photoPicker.select(photoSelectOptions).then((photoSelectResult: photoAccessHelper.PhotoSelectResult) => {\\n    const filePaths = photoSelectResult.photoUris;\\n    return filePaths.map(filePath => {\\n      const imageName = filePath.split('/').pop() || '';\\n      const sandboxPath = getSandboxPath(imageName);\\n      copyFileSync(filePath, sandboxPath);\\n      return sandboxPath;\\n    });\\n  });\\n} 使用rcp.createSession()方法创建http会话，使用rcp.MultipartForm类型构造请求体，使用Session.post()方法发起上传文件请求。export function upload(srcPath: string, httpEventsHandler: rcp.HttpEventsHandler) {\\n  const session = rcp.createSession(genSessionConfig(httpEventsHandler));\\n  const formData = new rcp.MultipartForm({\\n    file: {\\n      contentOrPath: srcPath\\n    }\\n  });\\n  return session.post('/', formData).finally(() => {\\n    session.close();\\n  });\\n}   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section932925421117\\\"'><a name='\\\"section932925421117\\\"'></a><a name='\\\"section932925421117\\\"'></a><h4>[h2]开发步骤</h4><div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161449.08116301466120962591140005172950:50001231000000:2800:247F3198777644DD6D65765729032C211508AD62012E274F1ED4577EA9BBE626.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>在使用Remote Communication Kit相关能力前，需配置以下权限。详细参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/remote-communication-preparations#section178884218124\\\"' target='\\\"_blank\\\"'>申请权限步骤</a>。</p> <ul><li>ohos.permission.INTERNET：用于应用的权限，决定是否允许应用访问互联网。</li><li>ohos.permission.GET_NETWORK_INFO：用于获取设备网络信息的 API 。</li></ul> </div></div> <p>为避免在每个RCP发起请求的响应中重复判断状态码和处理异常情况，可利用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section1385412349596\\\"' target='\\\"_blank\\\"'>rcp.Interceptor</a>提供的拦截器对响应进行统一处理。对于非200、206状态码的响应， 使其返回失败的promise，并对请求失败情况进行统一的弹窗提示。具体的拦截逻辑可根据业务需求灵活设置。</p>  <p>在<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section18613443123412\\\"' target='\\\"_blank\\\"'>rcp.sessionConfiguration</a>中配置请求的基地址baseAddress、相关拦截器interceptors、超时时间timeout和添加进度监听回调方法的对象httpEventsHandler。</p> <pre class='\\\"screen\\\"'>function genSessionConfig(httpEventsHandler?: rcp.HttpEventsHandler) {\\n  const config: rcp.SessionConfiguration = {\\n    baseAddress: BASE_URL,\\n    interceptors: [new StatusCodeInterceptor()],\\n    requestConfiguration: {\\n      tracing: { httpEventsHandler },\\n      transfer: {\\n        timeout: {\\n          connectMs: 1000 * 60 * 20,\\n          transferMs: 1000 * 60 * 20\\n        }\\n      }\\n    }\\n  };\\n  return config;\\n}</pre> <ul><li>下载步骤<ol><li>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section163819131811\\\"' target='\\\"_blank\\\"'>rcp.createSession()</a>方法创建http会话，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section16508121443318\\\"' target='\\\"_blank\\\"'>Session.downloadToFile()</a>方法下载到沙箱路径，注意下载完成后使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section1044116613331\\\"' target='\\\"_blank\\\"'>Session.close()</a>方法关闭会话，释放相关资源。<pre class='\\\"screen\\\"'>export function download(fileName: string, httpEventsHandler: rcp.HttpEventsHandler) {\\n  const destPath = getSandboxPath(fileName);\\n  const rcpSession = rcp.createSession(genSessionConfig(httpEventsHandler));\\n  const downloadTo: rcp.DownloadToFile = {\\n    kind: 'file',\\n    file: destPath\\n  };\\n  return rcpSession.downloadToFile(`/${fileName}`, downloadTo)\\n    .then(() =&gt; destPath)\\n    .finally(() =&gt; {\\n      rcpSession.close();\\n    });\\n}</pre> </li><li>通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-photoaccesshelper#showassetscreationdialog12\\\"' target='\\\"_blank\\\"'>phAccessHelper.showAssetsCreationDialog()</a>方法获取相册路径，并将下载到沙箱路径的文件拷贝到相册路径中。<pre class='\\\"screen\\\"'>export async function saveImageToAlbum(sandboxPath: string) {\\n  const phAccessHelper = photoAccessHelper.getPhotoAccessHelper(getContext());\\n  const fileNameExtension = sandboxPath.split('.').pop() || 'png';\\n  const photoCreationConfig: photoAccessHelper.PhotoCreationConfig = {\\n    fileNameExtension,\\n    photoType: getPhotoType(fileNameExtension),\\n  };\\n  const uri: string = fileUri.getUriFromPath(sandboxPath);\\n  const desFileUris: string[] = await phAccessHelper.showAssetsCreationDialog([uri], [photoCreationConfig]);\\n  const filePath = desFileUris[0];\\n  if (!filePath) throw new Error('photo assets permission denied');\\n  copyFileSync(sandboxPath, filePath);\\n  return filePath;\\n}</pre> </li></ol> </li><li>上传步骤<ol><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-photoaccesshelper#select\\\"' target='\\\"_blank\\\"'>PhotoPicker.select()</a>方法拉起相册模块，选择相册文件后在该方法回调函数中将相册文件拷贝到沙箱路径。<pre class='\\\"screen\\\"'>export async function selectImagesFromAlbum(maxNumber: number = 1): Promise&lt;string[]&gt; {\\n  const photoPicker = new photoAccessHelper.PhotoViewPicker();\\n  const photoSelectOptions: photoAccessHelper.PhotoSelectOptions = {\\n    MIMEType: photoAccessHelper.PhotoViewMIMETypes.IMAGE_VIDEO_TYPE,\\n    maxSelectNumber: maxNumber\\n  };\\n  return photoPicker.select(photoSelectOptions).then((photoSelectResult: photoAccessHelper.PhotoSelectResult) =&gt; {\\n    const filePaths = photoSelectResult.photoUris;\\n    return filePaths.map(filePath =&gt; {\\n      const imageName = filePath.split('/').pop() || '';\\n      const sandboxPath = getSandboxPath(imageName);\\n      copyFileSync(filePath, sandboxPath);\\n      return sandboxPath;\\n    });\\n  });\\n}</pre> </li><li>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section163819131811\\\"' target='\\\"_blank\\\"'>rcp.createSession()</a>方法创建http会话，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section1420174317517\\\"' target='\\\"_blank\\\"'>rcp.MultipartForm</a>类型构造请求体，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section12392443193017\\\"' target='\\\"_blank\\\"'>Session.post()</a>方法发起上传文件请求。<pre class='\\\"screen\\\"'>export function upload(srcPath: string, httpEventsHandler: rcp.HttpEventsHandler) {\\n  const session = rcp.createSession(genSessionConfig(httpEventsHandler));\\n  const formData = new rcp.MultipartForm({\\n    file: {\\n      contentOrPath: srcPath\\n    }\\n  });\\n  return session.post('/', formData).finally(() =&gt; {\\n    session.close();\\n  });\\n}</pre> </li></ol> </li></ul> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-file-transfer.html"
    },
    {
        "id": 330,
        "pre": "export function getFileSize(fileName: string): Promise<number> {\\n  const session = rcp.createSession(genSessionConfig());\\n  return session.head(`/${fileName}`).then(res => {\\n    const contentLength = res.headers['content-length'];\\n    return contentLength ? Number(contentLength): 0;\\n  }).finally(() => {\\n    session.close();\\n  });\\n}",
        "type": "Reference",
        "function_call": "head()",
        "function_name": null,
        "parent_text": "使用Session.head()方法发送head请求，通过响应头中的content-length属性获取文件大小。 ",
        "import_module": null,
        "parent": "<li>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/remote-communication-rcp#section102891334203115\\\"' target='\\\"_blank\\\"'>Session.head()</a>方法发送head请求，通过响应头中的content-length属性获取文件大小。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-file-transfer.html"
    },
    {
        "id": 331,
        "pre": "async startBackgroundTask(task: () => Promise<void>) {\\n  try {\\n    const wantAgentObj = await wantAgent.getWantAgent(this.getWantAgentInfo());\\n    await backgroundTaskManager.startBackgroundRunning(\\n      getContext(this),\\n      backgroundTaskManager.BackgroundMode.DATA_TRANSFER,\\n      wantAgentObj\\n    );\\n    task().finally(() => {\\n      backgroundTaskManager.stopBackgroundRunning(getContext(this));\\n    });\\n  } catch (err) {\\n    Logger.error('Failed to start background task', JSON.stringify(err));\\n    showErrorMessage('A background task is running');\\n  }\\n}",
        "type": "Reference",
        "function_call": "stopBackgroundRunning()",
        "function_name": null,
        "parent_text": "使用backgroundTaskManager.startBackgroundRunning()方法申请后台长时任务。申请长时任务成功后执行上传下载任务task()，在请求完成后使用backgroundTaskManager.stopBackgroundRunning()方法关闭长时任务。 ",
        "import_module": null,
        "parent": "<li>使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-resourceschedule-backgroundtaskmanager#backgroundtaskmanagerstartbackgroundrunning-1\\\"' target='\\\"_blank\\\"'>backgroundTaskManager.startBackgroundRunning()</a>方法申请后台长时任务。申请长时任务成功后执行上传下载任务task()，在请求完成后使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-resourceschedule-backgroundtaskmanager#backgroundtaskmanagerstopbackgroundrunning-1\\\"' target='\\\"_blank\\\"'>backgroundTaskManager.stopBackgroundRunning()</a>方法关闭长时任务。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-rcp-file-transfer.html"
    },
    {
        "id": 332,
        "pre": "import { taskpool } from '@kit.ArkTS';\\n\\n@Concurrent\\nasync function foo(a: number, b: number) {\\n  return a + b;\\n}\\n\\ntaskpool.execute(foo, 1, 2).then((ret: Object) => { // 结果处理\\n  console.log('Return:' + ret);\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "案例参考 ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 333,
        "pre": "import { taskpool } from '@kit.ArkTS';\\n\\n@Concurrent\\nfunction additionDelay(delay: number): void {\\n  let start: number = new Date().getTime();\\n  while (new Date().getTime() - start < delay) {\\n    continue;\\n  }\\n}\\n\\n@Concurrent\\nfunction waitForRunner(resString: string): string {\\n  return resString;\\n}\\n\\nasync function seqRunner() {\\n  let result: string = \\\"\\\";\\n  let task1: taskpool.Task = new taskpool.Task(additionDelay, 300);\\n  let task2: taskpool.Task = new taskpool.Task(additionDelay, 200);\\n  let task3: taskpool.Task = new taskpool.Task(additionDelay, 100);\\n  let task4: taskpool.Task = new taskpool.Task(waitForRunner, 50);\\n\\n  let runner: taskpool.SequenceRunner = new taskpool.SequenceRunner();\\n  runner.execute(task1).then(() => {\\n    result += 'a';\\n  });\\n  runner.execute(task2).then(() => {\\n    result += 'b';\\n  });\\n  runner.execute(task3).then(() => {\\n    result += 'c';\\n  });\\n  await runner.execute(task4);\\n  console.info(\\\"seqrunner: result is \\\" + result);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "案例参考 ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 334,
        "pre": "import { taskpool } from '@kit.ArkTS';\\n\\n@Concurrent\\nfunction updateSAB(args: Uint32Array) {\\n  if (args[0] == 0) {\\n    args[0] = 100;\\n    return 100;\\n  } else if (args[0] == 100) {\\n    args[0] = 200;\\n    return 200;\\n  } else if (args[0] == 200) {\\n    args[0] = 300;\\n    return 300;\\n  }\\n  return 0;\\n}\\n\\nlet sab = new SharedArrayBuffer(20);\\nlet typedArray = new Uint32Array(sab);\\nlet task1 = new taskpool.Task(updateSAB, typedArray);\\nlet task2 = new taskpool.Task(updateSAB, typedArray);\\nlet task3 = new taskpool.Task(updateSAB, typedArray);\\ntask1.addDependency(task2);\\ntask2.addDependency(task3);\\ntaskpool.execute(task1).then((res: object) => {\\n  console.info(\\\"taskpool:: execute task1 res: \\\" + res);\\n})\\ntaskpool.execute(task2).then((res: object) => {\\n  console.info(\\\"taskpool:: execute task2 res: \\\" + res);\\n})\\ntaskpool.execute(task3).then((res: object) => {\\n  console.info(\\\"taskpool:: execute task3 res: \\\" + res);\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "案例参考 ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 335,
        "pre": "import { taskpool } from '@kit.ArkTS';\\n\\n// 定义异步任务\\n@Concurrent\\nfunction imageProcessing(arrayBuffer: ArrayBuffer): ArrayBuffer {\\n  // 此处添加业务逻辑，输入为ArrayBuffer，输出为存储了解析结果的ArrayBuffer\\n  let message: ArrayBuffer = arrayBuffer;\\n  return message;\\n}\\n\\nlet taskGroup: taskpool.TaskGroup = new taskpool.TaskGroup();\\nlet TASK_POOL_CAPACITY: number = 10;\\n\\nfunction histogramStatistic(pixelBuffer: ArrayBuffer): void {\\n  // 往任务组中添加任务\\n  let byteLengthOfTask: number = pixelBuffer.byteLength;\\n  for (let i = 0; i < TASK_POOL_CAPACITY; i++) {\\n    let dataSlice: Object = (i === TASK_POOL_CAPACITY - 1) ? pixelBuffer.slice(i * byteLengthOfTask) : pixelBuffer.slice(i * byteLengthOfTask, (i + 1) * byteLengthOfTask);\\n    let task: taskpool.Task = new taskpool.Task(imageProcessing, dataSlice);\\n    taskGroup.addTask(task);\\n  }\\n  taskpool.execute(taskGroup, taskpool.Priority.HIGH).then((res: Object[]): void | Promise<void> => {\\n    // 结果数据处理\\n  }).catch((error: Error) => {\\n    console.error(`taskpool excute error: ${error}`);\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "案例参考 ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 336,
        "pre": "import { taskpool } from '@kit.ArkTS';\\n\\nfunction exec(bufferArray: ArrayBuffer): void {\\n  let task = execColorInfo(bufferArray);\\n  taskpool.execute(execColorInfo, taskpool.Priority.HIGH);\\n}\\n\\n@Concurrent\\nasync function execColorInfo(bufferArray: ArrayBuffer): Promise<ArrayBuffer> {\\n  if (!bufferArray) {\\n    return new ArrayBuffer(0);\\n  }\\n  const newBufferArr = bufferArray;\\n  let colorInfo = new Uint8Array(newBufferArr);\\n  let PIXEL_STEP = 2;\\n  for (let i = 0; i < colorInfo?.length; i += PIXEL_STEP) {\\n    // 数据处理\\n  }\\n  return newBufferArr;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "案例参考 ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 337,
        "pre": "import { taskpool } from '@kit.ArkTS';\\n\\n@Concurrent\\nfunction concurrentTask(num: number): number {\\n  console.log('这里添加需延时执行的任务');\\n  return num;\\n}\\n\\n// 创建任务\\nlet task: taskpool.Task = new taskpool.Task(concurrentTask, 100);\\n// 延时执行task\\ntaskpool.executeDelayed(3000, task, taskpool.Priority.HIGH).then((value: Object) => {\\n  // 处理延时任务返回的结果\\n  console.log(\\\"taskpool result: \\\" + value);\\n});",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "案例参考 ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 338,
        "pre": "// napi_init.cpp\\nstruct CallbackData {\\n    napi_env env;\\n    uv_thread_t threadId;\\n    napi_async_work asyncWork = nullptr;\\n    napi_threadsafe_function tsfn = nullptr;\\n    int32_t data = -1;\\n};\\n\\nstatic void CallJs(napi_env env, napi_value jsCb, void* context, void* data)\\n{\\n    CallbackData* callbackData = reinterpret_cast<CallbackData*>(data);\\n    napi_value global;\\n    assert(napi_get_global(env, &global) == napi_ok);\\n    napi_value number;\\n    assert(napi_create_int32(env, callbackData->data, &number) == napi_ok);\\n    assert(napi_call_function(env, global, jsCb, 1, &number, nullptr) == napi_ok);\\n}\\nstatic void NativeThread(void* data)\\n{\\n    CallbackData* callbackData = reinterpret_cast<CallbackData*>(data);\\n    /* 跨线程调用*/\\n    {\\n        assert(napi_acquire_threadsafe_function(callbackData->tsfn) == napi_ok);\\n\\n        callbackData->data = 123456;\\n        napi_status status = napi_call_threadsafe_function(callbackData->tsfn,\\n            callbackData, napi_tsfn_blocking);\\n        assert(status == napi_ok);\\n    }\\n}\\nstatic void ThreadFinished(napi_env env, void* data, [[maybe_unused]] void* context)\\n{\\n    CallbackData* callbackData = reinterpret_cast<CallbackData*>(data);\\n\\n    assert(uv_thread_join(&(callbackData->threadId)) == 0);\\n    assert(napi_release_threadsafe_function(callbackData->tsfn,\\n                                            napi_tsfn_release) == napi_ok);;\\n    callbackData->asyncWork = nullptr;\\n    callbackData->tsfn = nullptr;\\n    delete callbackData;\\n}\\nstatic napi_value NativeCall(napi_env env, napi_callback_info info)\\n{\\n    napi_value resourceName = nullptr;\\n    CallbackData* callbackData = new CallbackData;\\n    callbackData->env = env;\\n\\n    napi_value jsCb = nullptr;\\n    size_t argc = 1;\\n\\n    assert(napi_get_cb_info(env, info, &argc, &jsCb, nullptr, nullptr) == napi_ok);\\n    assert(argc == 1);\\n  \\n    assert(napi_create_string_utf8(env, \\\"Call thread-safe function from c++ thread\\\",\\n                                   NAPI_AUTO_LENGTH,\\n                                   &resourceName) == napi_ok);\\n    napi_status status;\\n    status = napi_create_threadsafe_function(env,\\n                                         jsCb,\\n                                         nullptr,\\n                                         resourceName,\\n                                         0,\\n                                         1,\\n                                         callbackData,\\n                                         ThreadFinished,\\n                                         callbackData,\\n                                         CallJs,\\n                                         &(callbackData->tsfn));\\n    assert(status == napi_ok);\\n\\n    assert(uv_thread_create(&(callbackData->threadId), NativeThread, callbackData) == 0);\\n    return nullptr;\\n}\\n\\n// Index.ets\\nButton('click me')\\n  .onClick(() => {\\n    nativeModule.nativeCall((a: number) => {\\n      console.log('Received data from thread-function: %{public}d', a);\\n    })\\n  })",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "案例参考 ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 339,
        "pre": "// napi_init.cpp\\nclass Singleton {\\npublic:\\n    static Singleton &GetInstance() {\\n        static Singleton instance;\\n        return instance;\\n    }\\n    static napi_value GetAddress(napi_env env, napi_callback_info info) {\\n        uint64_t addressVal = reinterpret_cast<uint64_t>(&GetInstance());\\n        napi_value napiAddress = nullptr;\\n        napi_create_bigint_uint64(env, addressVal, &napiAddress);\\n        return napiAddress;\\n    }\\n    static napi_value GetSetSize(napi_env env, napi_callback_info info) {\\n        std::lock_guard<std::mutex> lock(Singleton::GetInstance().numberSetMutex_);\\n        uint32_t setSize = Singleton::GetInstance().numberSet_.size();\\n        napi_value napiSize = nullptr;\\n        napi_create_uint32(env, setSize, &napiSize);\\n        return napiSize;\\n    }\\n    static napi_value Store(napi_env env, napi_callback_info info) {\\n        size_t argc = 1;\\n        napi_value args[1] = {nullptr};\\n        napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\\n        if (argc != 1) {\\n            napi_throw_error(env, \\\"ERROR: \\\", \\\"store args number must be one\\\");\\n            return nullptr;\\n        }\\n        napi_valuetype type = napi_undefined;\\n        napi_typeof(env, args[0], &type);\\n        if (type != napi_number) {\\n            napi_throw_error(env, \\\"ERROR: \\\", \\\"store args is not number\\\");\\n            return nullptr;\\n        }\\n        std::lock_guard<std::mutex> lock(Singleton::GetInstance().numberSetMutex_);\\n        uint32_t value = 0;\\n        napi_get_value_uint32(env, args[0], &value);\\n        Singleton::GetInstance().numberSet_.insert(value);\\n        return nullptr;\\n    }\\nprivate:\\n    Singleton() {}                                    // 私有构造函数，防止外部实例化对象\\n    Singleton(const Singleton &) = delete;            // 禁止拷贝构造函数\\n    Singleton &operator=(const Singleton &) = delete; // 禁止赋值运算符\\n\\npublic:\\n    std::unordered_set<uint32_t> numberSet_{};\\n    std::mutex numberSetMutex_{};\\n};\\n\\n// Index.ets\\nimport singleton from 'libentry.so';\\nimport { taskpool } from '@kit.ArkTS';\\n\\n@Concurrent\\nfunction getAddress() {\\n  let address = singleton.getAddress();\\n  console.info(\\\"taskpool:: address is \\\" + address);\\n}\\n\\n@Concurrent\\nfunction store(a: number, b: number, c: number) {\\n  let size = singleton.getSetSize();\\n  console.info(\\\"set size is \\\" + size + \\\" before store\\\");\\n  singleton.store(a);\\n  singleton.store(b);\\n  singleton.store(c);\\n  size = singleton.getSetSize();\\n  console.info(\\\"set size is \\\" + size + \\\" after store\\\");\\n}\\n\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    Row() {\\n      Column() {\\n        Button(\\\"TestSingleton\\\").onClick(() => {\\n          let address = singleton.getAddress();\\n          console.info(\\\"host thread address is \\\" + address);\\n          let task1 = new taskpool.Task(getAddress);\\n          taskpool.execute(task1);\\n          let task2 = new taskpool.Task(store, 1, 2, 3);\\n          taskpool.execute(task2);\\n          let task3 = new taskpool.Task(store, 4, 5, 6);\\n          taskpool.execute(task3);\\n        })\\n      }\\n      .width('100%')\\n    }\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "案例参考 ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 340,
        "pre": "// xxx.ets\\nimport { worker } from '@kit.ArkTS';\\nimport { freezeObj } from './freezeObj';\\n\\n@Sendable\\nexport class GlobalConfig {\\n  // 一些配置属性与方法\\n  init() {\\n    // 初始化相关逻辑\\n    freezeObj(this) // 初始化完成后冻结当前对象\\n  }\\n}\\n\\nlet globalConfig = new GlobalConfig();\\nglobalConfig.init();\\nconst workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ets`', { name: 'Worker1' });\\nworkerInstance.postMessage(globalConfig);",
        "type": "Reference",
        "function_call": "function freezeObj(obj: any)",
        "function_name": null,
        "parent_text": "案例参考以全局环境变量共享为例：  // worker文件路径为：entry/ets/workers/Worker.ets\\n// Worker.ets\\nimport { MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';\\nimport { GlobalConfig } from '../pages/InterthreadCommunication4';\\n\\nconst workerPort: ThreadWorkerGlobalScope = worker.workerPort;\\nworkerPort.onmessage = (e: MessageEvents) => {\\n  let globalConfig: GlobalConfig = e.data;\\n  // 使用globalConfig对象\\n} // freezeObj.ts\\nexport function freezeObj(obj: any) {\\n  Object.freeze(obj);\\n} ",
        "import_module": null,
        "parent": "<li><strong>案例参考</strong><p>以全局环境变量共享为例：</p>  <pre class='\\\"screen\\\"'>// worker文件路径为：entry/ets/workers/Worker.ets\\n// Worker.ets\\nimport { MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';\\nimport { GlobalConfig } from '../pages/InterthreadCommunication4';\\n\\nconst workerPort: ThreadWorkerGlobalScope = worker.workerPort;\\nworkerPort.onmessage = (e: MessageEvents) =&gt; {\\n  let globalConfig: GlobalConfig = e.data;\\n  // 使用globalConfig对象\\n}</pre> <pre class='\\\"screen\\\"'>// freezeObj.ts\\nexport function freezeObj(obj: any) {\\n  Object.freeze(obj);\\n}</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-concurrency-design.html"
    },
    {
        "id": 341,
        "pre": "import { router } from '@kit.ArkUI';\\n\\nimport { common } from '@kit.AbilityKit';\\nimport { LearningResource, ActionButtonView, CommonConstants, ArticleCardButtonView } from '@ohos/common';\\n// 引入power模块\\nimport { power } from '@kit.BasicServicesKit';\\n\\n@Component\\nexport struct ArticleCardView {\\n  @Prop isLiked: boolean = false;\\n  @Prop isCollected: boolean = false;\\n  @ObjectLink articleItem: LearningResource;\\n  onCollected?: () => void;\\n  onLiked?: () => void;\\n\\n  build() {\\n    Row({ space: CommonConstants.SPACE_16 }) {\\n      Column() {\\n        // ...\\n        Row() {\\n          ActionButtonView({\\n            imgResource: $r('app.media.ic_eye_open'),\\n            count: this.articleItem.viewsCount,\\n            textWidth: $r('app.float.view_count_icon_width')\\n          })\\n          // 使用getPowerMode获取当前系统的电源模式，并判断当前是否为省电模式\\n          if (power.getPowerMode() == power.DevicePowerMode.MODE_POWER_SAVE) {\\n            ActionButtonView({\\n              imgResource: this.isLiked ? $r('app.media.btn_good_on') : $r('app.media.btn_good_normal'),\\n              count: this.articleItem.likesCount,\\n              textWidth: $r('app.float.like_icon_width')\\n            })\\n              .onClick(() => {\\n                this.onLiked?.();\\n              })\\n            // ...\\n          } else {\\n            ArticleCardButtonView({\\n              clickAnimationPath: 'common/lottie/liked_lottie.json',\\n              cancelAnimationPath: 'common/lottie/cancel_liked_lottie.json',\\n              isClicked: this.isLiked,\\n              count: this.articleItem.likesCount,\\n              articleId: this.articleItem.id,\\n              textWidth: $r('app.float.like_icon_width'),\\n              type: 'like',\\n              onClicked: this.onLiked,\\n              normalImage: $r('app.media.btn_like_normal'),\\n              onImage: $r('app.media.btn_like_on')\\n            })\\n            // ...\\n          }\\n        }\\n        .width(CommonConstants.FULL_PERCENT)\\n        .justifyContent(FlexAlign.SpaceBetween)\\n      }\\n      .layoutWeight(1)\\n      .height(CommonConstants.FULL_PERCENT)\\n      .justifyContent(FlexAlign.SpaceAround)\\n    }\\n   }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]场景案例",
        "parent_text": "[h2]场景案例当设备电量较低时，系统可以切换至省电模式，以减少设备的能耗并延长电池的使用时间。通过与系统省电模式的配合，应用程序可以更加智能地调整自身的功耗策略，以适应设备电量较低的情况，从而延长设备的续航时间，提供更加稳定和持久的使用体验。 一般而言，获取当前设备的电源模式可以通过以下步骤实现： 引入系统电源管理模块power，该模块主要提供重启、关机、查询屏幕状态等接口；调用power的getPowerMode方法来获取当前设备的电源模式。 在省电模式下，获取当前系统的电源模式的代码如下所示：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1377219341465\\\"'><a name='\\\"section1377219341465\\\"'></a><a name='\\\"section1377219341465\\\"'></a><h4>[h2]场景案例</h4><p>当设备电量较低时，系统可以切换至省电模式，以减少设备的能耗并延长电池的使用时间。通过与系统省电模式的配合，应用程序可以更加智能地调整自身的功耗策略，以适应设备电量较低的情况，从而延长设备的续航时间，提供更加稳定和持久的使用体验。</p> <p>一般而言，获取当前设备的电源模式可以通过以下步骤实现：</p> <ol><li><span>引入系统电源管理模块power，该模块主要提供重启、关机、查询屏幕状态等接口；</span></li><li><span>调用power的getPowerMode方法来获取当前设备的电源模式。</span></li></ol> <p>在省电模式下，获取当前系统的电源模式的代码如下所示：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-low-power-design-in-dark-mode.html"
    },
    {
        "id": 342,
        "pre": "int Global = 12;\\n\\nvoid Set1() {\\n    *(char *)&Global = 4;\\n}\\n\\nvoid Set2() {\\n    Global=43;\\n}\\n\\nvoid *Thread1(void *x){\\n    Set1();\\n    return x;\\n}\\n\\nstatic napi_value Add(napi_env env, napi_callback_info info){\\n    ...\\n    pthread_t t;\\n    pthread_create(&t, NULL, Thread1, NULL);\\n    Set2();\\n    pthread_join(t, NULL);\\n    ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]Data race",
        "parent_text": "[h2]Data race背景 多个线程在没有正确加锁的情况下，同时访问同一块数据，并且至少有一个线程是写操作，对数据的读取和修改产生了竞争，从而导致各种不可预计的问题 错误代码实例  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section4408522155118\\\"'><a name='\\\"section4408522155118\\\"'></a><a name='\\\"section4408522155118\\\"'></a><h4>[h2]Data race</h4><p><strong>背景</strong></p> <p>多个线程在没有正确加锁的情况下，同时访问同一块数据，并且至少有一个线程是写操作，对数据的读取和修改产生了竞争，从而导致各种不可预计的问题</p> <p><strong>错误代码实例</strong></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-stability-tsan-detection.html"
    },
    {
        "id": 343,
        "pre": "private permissions: Array<Permissions> = [\\n  'ohos.permission.CAMERA',\\n  'ohos.permission.MICROPHONE',\\n  'ohos.permission.MEDIA_LOCATION',\\n  'ohos.permission.READ_IMAGEVIDEO',\\n  'ohos.permission.WRITE_IMAGEVIDEO',\\n];\\n\\nabilityAccessCtrl.createAtManager().requestPermissionsFromUser(getContext(this), this.permissions).then(() => {\\n  this.surfaceId = this.mXComponentController.getXComponentSurfaceId();\\n  this.initCamera();\\n  this.getThumbnail();\\n})",
        "type": "Reference",
        "function_call": "nbuild()",
        "function_name": "[h2]关键代码",
        "parent_text": "[h2]关键代码申请对应权限。  相机设置Moving Photo属性。 setEnableLivePhoto(isMovingPhoto: boolean) {\\n  if (this.photoOutput?.isMovingPhotoSupported()) {\\n    this.photoOutput?.enableMovingPhoto(isMovingPhoto);\\n  }\\n} 获取媒体库中最新图片地址与缩略图。async getThumbnail(): Promise<void> {\\n  let photoAsset: photoAccessHelper.PhotoAsset =\\n    AppStorage.get(CommonConstants.KEY_PHOTO_ASSET) as photoAccessHelper.PhotoAsset;\\n  if (photoAsset === undefined) {\\n    return;\\n  }\\n  this.currentImg = await photoAsset.getThumbnail();\\n}  引入Moving Photo相关库。 import { MovingPhotoView, MovingPhotoViewController, MovingPhotoViewAttribute } from '@ohos.multimedia.movingphotoview'; 通过拍摄后获取的photoAccessHelper.PhotoAsset请求Moving Photo。 @StorageLink(CommonConstants.KEY_MOVING_DATA) src: photoAccessHelper.MovingPhoto | undefined = undefined;\\n@State isMuted: boolean = false;\\n\\nasync aboutToAppear(): Promise<void> {\\n  // ...\\n  this.requestMovingPhoto();\\n}\\n\\nprivate requestMovingPhoto() {\\n  let photoAsset: photoAccessHelper.PhotoAsset =\\n    AppStorage.get(CommonConstants.KEY_PHOTO_ASSET) as photoAccessHelper.PhotoAsset;\\n  if (photoAsset === undefined) {\\n    return;\\n  }\\n  let requestOptions: photoAccessHelper.RequestOptions = {\\n    deliveryMode: photoAccessHelper.DeliveryMode.FAST_MODE,\\n  }\\n  photoAccessHelper.MediaAssetManager.requestMovingPhoto(context, photoAsset, requestOptions,\\n    new MediaDataHandlerMovingPhoto());\\n}\\n\\nclass MediaDataHandlerMovingPhoto implements photoAccessHelper.MediaAssetDataHandler<photoAccessHelper.MovingPhoto> {\\n  async onDataPrepared(movingPhoto: photoAccessHelper.MovingPhoto): Promise<void> {\\n    AppStorage.setOrCreate(CommonConstants.KEY_MOVING_DATA, movingPhoto);\\n  }\\n} 添加Moving Photo展示图。 private controller: MovingPhotoViewController = new MovingPhotoViewController();\\n\\nbuild() {\\n  Flex({\\n    direction: new BreakpointType(\\n      {\\n        sm: FlexDirection.Column,\\n        md: FlexDirection.Column,\\n        lg: FlexDirection.Row,\\n      }\\n    ).getValue(this.currentBreakpoint),\\n    wrap: FlexWrap.NoWrap,\\n    justifyContent: FlexAlign.Start,\\n    alignItems: ItemAlign.Start,\\n    alignContent: FlexAlign.Start\\n  }) {\\n    // ...\\n    MovingPhotoView({\\n      movingPhoto: this.src,\\n      controller: this.controller\\n    })\\n    // ...\\n  }\\n  .backgroundColor(Color.Black)\\n  .width($r('app.string.full_screen'))\\n  .height($r('app.string.full_screen'))\\n}  本章节只介绍主干流程的关键代码，要实现自定义相机实际上还有很多配置，可详细关注封装模块CameraService文件，Moving Photo的使用可查看相关Api使用：动图照片。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1833663316397\\\"'><a name='\\\"section1833663316397\\\"'></a><a name='\\\"section1833663316397\\\"'></a><h4>[h2]关键代码</h4><p>申请对应权限。</p>  <p>相机设置Moving Photo属性。</p> <pre class='\\\"screen\\\"'>setEnableLivePhoto(isMovingPhoto: boolean) {\\n  if (this.photoOutput?.isMovingPhotoSupported()) {\\n    this.photoOutput?.enableMovingPhoto(isMovingPhoto);\\n  }\\n}</pre> <div class='\\\"p\\\"'>获取媒体库中最新图片地址与缩略图。<pre class='\\\"screen\\\"'>async getThumbnail(): Promise&lt;void&gt; {\\n  let photoAsset: photoAccessHelper.PhotoAsset =\\n    AppStorage.get(CommonConstants.KEY_PHOTO_ASSET) as photoAccessHelper.PhotoAsset;\\n  if (photoAsset === undefined) {\\n    return;\\n  }\\n  this.currentImg = await photoAsset.getThumbnail();\\n}</pre> </div> <p>引入Moving Photo相关库。</p> <pre class='\\\"screen\\\"'>import { MovingPhotoView, MovingPhotoViewController, MovingPhotoViewAttribute } from '@ohos.multimedia.movingphotoview';</pre> <p>通过拍摄后获取的photoAccessHelper.PhotoAsset请求Moving Photo。</p> <pre class='\\\"screen\\\"'>@StorageLink(CommonConstants.KEY_MOVING_DATA) src: photoAccessHelper.MovingPhoto | undefined = undefined;\\n@State isMuted: boolean = false;\\n\\nasync aboutToAppear(): Promise&lt;void&gt; {\\n  // ...\\n  this.requestMovingPhoto();\\n}\\n\\nprivate requestMovingPhoto() {\\n  let photoAsset: photoAccessHelper.PhotoAsset =\\n    AppStorage.get(CommonConstants.KEY_PHOTO_ASSET) as photoAccessHelper.PhotoAsset;\\n  if (photoAsset === undefined) {\\n    return;\\n  }\\n  let requestOptions: photoAccessHelper.RequestOptions = {\\n    deliveryMode: photoAccessHelper.DeliveryMode.FAST_MODE,\\n  }\\n  photoAccessHelper.MediaAssetManager.requestMovingPhoto(context, photoAsset, requestOptions,\\n    new MediaDataHandlerMovingPhoto());\\n}\\n\\nclass MediaDataHandlerMovingPhoto implements photoAccessHelper.MediaAssetDataHandler&lt;photoAccessHelper.MovingPhoto&gt; {\\n  async onDataPrepared(movingPhoto: photoAccessHelper.MovingPhoto): Promise&lt;void&gt; {\\n    AppStorage.setOrCreate(CommonConstants.KEY_MOVING_DATA, movingPhoto);\\n  }\\n}</pre> <p>添加Moving Photo展示图。</p> <pre class='\\\"screen\\\"'>private controller: MovingPhotoViewController = new MovingPhotoViewController();\\n\\nbuild() {\\n  Flex({\\n    direction: new BreakpointType(\\n      {\\n        sm: FlexDirection.Column,\\n        md: FlexDirection.Column,\\n        lg: FlexDirection.Row,\\n      }\\n    ).getValue(this.currentBreakpoint),\\n    wrap: FlexWrap.NoWrap,\\n    justifyContent: FlexAlign.Start,\\n    alignItems: ItemAlign.Start,\\n    alignContent: FlexAlign.Start\\n  }) {\\n    // ...\\n    MovingPhotoView({\\n      movingPhoto: this.src,\\n      controller: this.controller\\n    })\\n    // ...\\n  }\\n  .backgroundColor(Color.Black)\\n  .width($r('app.string.full_screen'))\\n  .height($r('app.string.full_screen'))\\n}</pre> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161418.20818365213783268235636741629634:50001231000000:2800:23E7ACCD87099EFAAE184A955C53AEE86AEA920EC76A08119387DE2A22A22F68.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>本章节只介绍主干流程的关键代码，要实现自定义相机实际上还有很多配置，可详细关注封装模块CameraService文件，Moving Photo的使用可查看相关Api使用：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ohos-multimedia-movingphotoview\\\"' target='\\\"_blank\\\"'>动图照片</a>。</p> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-content-creation.html"
    },
    {
        "id": 344,
        "pre": "import {\\n  CollaborationServiceFilter,\\n  CollaborationServiceStateDialog,\\n  createCollaborationServiceMenuItems\\n} from '@kit.ServiceCollaborationKit';\\n\\n@Builder\\nCollaborationMenu() {\\n  Menu() {\\n    createCollaborationServiceMenuItems([CollaborationServiceFilter.ALL]);\\n  }\\n}",
        "type": "Reference",
        "function_call": "async (uri: string)",
        "function_name": "[h2]关键代码",
        "parent_text": "[h2]关键代码跨端拍照与跨端相册访问： 借助createCollaborationCameraMenuItems定义设备列表选择器，该组件需要在Menu组件内调用。用于显示组网内具有对应相机能力的设备列表。  使用CollaborationCameraStateDialog弹窗组件，用于提示对端相机拍摄状态。 该组件可在build()函数内直接调用，开发者需要实现其中的onState方法，当拍摄完成之后，将通过onState方法回传返回内容。 onstate方法有的回调函数有两个参数，分别是stateCode业务完成状态和buffer成功返回的数据。 @Builder\\nsetCollaborationDialog() {\\n  CollaborationServiceStateDialog({\\n    onState: (stateCode: number, bufferType: string, buffer: ArrayBuffer): void => this.doInsertPicture(stateCode,\\n      bufferType, buffer)\\n  });\\n}\\n\\ndoInsertPicture(stateCode: number, bufferType: string, buffer: ArrayBuffer): void {\\n  if (stateCode !== 0) {\\n    Logger.error(this.tag, `doInsertPicture stateCode: ${stateCode}}`);\\n    return;\\n  }\\n  Logger.info(this.tag, `doInsertPicture bufferType: ${bufferType}}`);\\n  if (bufferType === CommonConstants.BUFFER_TYPE) {\\n    if (this.photoUriArr.length === CommonConstants.LIMIT_PICKER_NUM) {\\n      promptAction.showToast({\\n        message: $r('app.string.toast_picker_limit'),\\n        duration: DataUtils.fromResToNumber($r('app.float.show_DELAY_TIME')),\\n      });\\n      return;\\n    }\\n    FileUtils.saveFile(getContext(this), buffer).then(async (uri: string) => {\\n      let pixelMap = await FileUtils.createPixelMapFromUri(uri);\\n      if (pixelMap === undefined) {\\n        return;\\n      }\\n      this.selectedData.unshiftData(pixelMap);\\n      FileUtils.copyToDistributedDir(getContext(this), uri);\\n      FileUtils.unshiftFiles(uri);\\n      this.photoUriArr.unshift(uri);\\n    });\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section28901469125\\\"'><a name='\\\"section28901469125\\\"'></a><a name='\\\"section28901469125\\\"'></a><h4>[h2]关键代码</h4><p>跨端拍照与跨端相册访问：</p> <p>借助createCollaborationCameraMenuItems定义设备列表选择器，该组件需要在Menu组件内调用。用于显示组网内具有对应相机能力的设备列表。</p>  <p>使用CollaborationCameraStateDialog弹窗组件，用于提示对端相机拍摄状态。</p> <p>该组件可在build()函数内直接调用，开发者需要实现其中的onState方法，当拍摄完成之后，将通过onState方法回传返回内容。</p> <p>onstate方法有的回调函数有两个参数，分别是stateCode业务完成状态和buffer成功返回的数据。</p> <pre class='\\\"screen\\\"'>@Builder\\nsetCollaborationDialog() {\\n  CollaborationServiceStateDialog({\\n    onState: (stateCode: number, bufferType: string, buffer: ArrayBuffer): void =&gt; this.doInsertPicture(stateCode,\\n      bufferType, buffer)\\n  });\\n}\\n\\ndoInsertPicture(stateCode: number, bufferType: string, buffer: ArrayBuffer): void {\\n  if (stateCode !== 0) {\\n    Logger.error(this.tag, `doInsertPicture stateCode: ${stateCode}}`);\\n    return;\\n  }\\n  Logger.info(this.tag, `doInsertPicture bufferType: ${bufferType}}`);\\n  if (bufferType === CommonConstants.BUFFER_TYPE) {\\n    if (this.photoUriArr.length === CommonConstants.LIMIT_PICKER_NUM) {\\n      promptAction.showToast({\\n        message: $r('app.string.toast_picker_limit'),\\n        duration: DataUtils.fromResToNumber($r('app.float.show_DELAY_TIME')),\\n      });\\n      return;\\n    }\\n    FileUtils.saveFile(getContext(this), buffer).then(async (uri: string) =&gt; {\\n      let pixelMap = await FileUtils.createPixelMapFromUri(uri);\\n      if (pixelMap === undefined) {\\n        return;\\n      }\\n      this.selectedData.unshiftData(pixelMap);\\n      FileUtils.copyToDistributedDir(getContext(this), uri);\\n      FileUtils.unshiftFiles(uri);\\n      this.photoUriArr.unshift(uri);\\n    });\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-content-creation.html"
    },
    {
        "id": 345,
        "pre": "\\\"requestPermissions\\\": [\\n  {\\n    \\\"name\\\": \\\"ohos.permission.DISTRIBUTED_DATASYNC\\\",\\n    \\\"reason\\\": \\\"$string:distributed_desc\\\",\\n    \\\"usedScene\\\": {\\n      \\\"abilities\\\": [\\n        \\\"EntryAbility\\\"\\n      ],\\n      \\\"when\\\": \\\"always\\\"\\n    }\\n  }\\n  // ...\\n]",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]关键点说明",
        "parent_text": "[h2]关键点说明接续的使用条件 （1）两端设备登录同一华为账号； （2）两端设备打开Wi-Fi和蓝牙开关，连接相同局域网，可提升数据传输的速度； （3）应用接续只能在同应用（UIAbility）之间触发，双端设备都需要有该应用； （4）在onContinue回调中使用wantParam传输的数据需要控制在100KB以下，大需数据的情况，要使用分布式数据对象或分布式文件系统。例如图片文件。 申请权限，需要在module.json5里的module对象的requestPermissions如下申请：  打开应用接续开关，在module.json5文件里的module对象的abilities字段内设置\\\"continuable\\\"的值为true。\\\"abilities\\\": [\\n  {\\n    // ...\\n    \\\"continuable\\\": true,\\n    // ...\\n  }\\n]  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section17420124841615\\\"'><a name='\\\"section17420124841615\\\"'></a><a name='\\\"section17420124841615\\\"'></a><h4>[h2]关键点说明</h4><p>接续的使用条件</p> <p>（1）两端设备登录同一华为账号；</p> <p>（2）两端设备打开Wi-Fi和蓝牙开关，连接相同局域网，可提升数据传输的速度；</p> <p>（3）应用接续只能在同应用（UIAbility）之间触发，双端设备都需要有该应用；</p> <p>（4）在onContinue回调中使用wantParam传输的数据需要控制在100KB以下，大需数据的情况，要使用分布式数据对象或分布式文件系统。例如图片文件。</p> <p>申请权限，需要在module.json5里的module对象的requestPermissions如下申请：</p>  <div class='\\\"p\\\"'>打开应用接续开关，在module.json5文件里的module对象的abilities字段内设置\\\"continuable\\\"的值为true。<pre class='\\\"screen\\\"'>\\\"abilities\\\": [\\n  {\\n    // ...\\n    \\\"continuable\\\": true,\\n    // ...\\n  }\\n]</pre> </div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-content-creation.html"
    },
    {
        "id": 346,
        "pre": "onContinue(wantParam: Record<string, Object | undefined>): AbilityConstant.OnContinueResult {\\n  wantParam[CommonConstants.KEY_TITLE] = AppStorage.get(CommonConstants.KEY_TITLE);\\n  wantParam[CommonConstants.KEY_DESCRIPTION] = AppStorage.get(CommonConstants.KEY_DESCRIPTION);\\n  // ...\\n  wantParam[CommonConstants.KEY_PICTURE_PATHS] = nameArr.join(this.splitSymbol);\\n  return AbilityConstant.OnContinueResult.AGREE;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "迁移端实现onContinue接口 ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>迁移端实现onContinue接口 </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-content-creation.html"
    },
    {
        "id": 347,
        "pre": "// src/main/ets/pages/LazyForeachSwiper.ets\\n@Reusable\\n@Component\\nstruct QuestionSwiperItem {\\n  @State itemData: Question | null = null;\\n\\n  aboutToReuse(params: Record<string, Object>): void {\\n    this.itemData = params.itemData as Question;\\n  }\\n\\n  build() {\\n    Column() {\\n      Text(this.itemData?.title)\\n        // ...\\n      Image(this.itemData?.image)\\n        // ...\\n\\n      Column({ space: 16 }) { // Question answers\\n        // ...\\n      }\\n      .width('100%')\\n      .alignItems(HorizontalAlign.Start)\\n    }\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]场景案例",
        "parent_text": "[h2]场景案例为了体现Swiper使用ForEach与LazyForEach加载的性能差距，本地模拟答题场景进行测试分析。 Swiper子组件核心代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section233416451545\\\"'><a name='\\\"section233416451545\\\"'></a><a name='\\\"section233416451545\\\"'></a><h4>[h2]场景案例</h4><p><span rgb(36,41,46);\\\"=\"\" style='\\\"color:'>为了体现Swiper使用ForEach与LazyForEach加载的性能差距</span><span rgb(36,41,46);\\\"=\"\" style='\\\"color:'>，本地模拟答题场景进行测试分析</span>。</p> <p>Swiper子组件核心代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-swiper_high_performance_development_guide.html"
    },
    {
        "id": 348,
        "pre": "@Component\\nstruct SwiperItem {\\n  private data: number[] = [];\\n  private myIndex: number = 0;\\n  // 构造数据\\n  private imgURL: string[] = Constant.imgURL;\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i < 50; i++) {\\n      this.data.push(i);\\n    }\\n  }\\n\\n  build() {\\n    Column() {\\n      List({ space: 20 }) {\\n        ForEach(this.data, (index: number) => {\\n          ListItem() {\\n            Image(this.imgURL[this.myIndex * 50 + index])\\n              .objectFit(ImageFit.Contain)\\n              .width(\\\"100%\\\")\\n              .height(\\\"100%\\\")\\n          }\\n          .aspectRatio(1)\\n          .border({ width: 2, color: Color.Green })\\n        }, (index: number) => index.toString());\\n      }\\n      // ...\\n    }\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "toString()",
        "function_name": "[h2]场景案例",
        "parent_text": "[h2]场景案例案例模拟Swiper的子组件包含大量图像资源，采用下列前置条件： Swiper的子组件为带有50个ListItem的List组件；每个ListItem加载网络图片；Swiper组件共有20个List子组件；一屏显示一个Swiper子组件。 Swiper子组件核心代码如下  Swiper主页面核心代码如下 private dataSrc: NumberDataSource = new NumberDataSource();\\n\\naboutToAppear(): void {\\n  for (let i = 0; i < 20; i++) {\\n    this.dataSrc.addData(i, i);\\n  }\\n}\\n\\nbuild() {\\n  Column({ space: 5 }) {\\n    Swiper() {\\n      LazyForEach(this.dataSrc, (item: number, index: number) => {\\n        SwiperItem({\\n          myIndex: index\\n        });\\n      }, (item: number) => item.toString());\\n    }\\n    .cachedCount(1)\\n    .autoPlay(true)\\n    .interval(1000)\\n    .duration(100)\\n    // ...\\n  }.width('100%')\\n  .margin({ top: 5 })\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section16450155101716\\\"'><a name='\\\"section16450155101716\\\"'></a><a name='\\\"section16450155101716\\\"'></a><h4>[h2]场景案例</h4><p>案例模拟Swiper的子组件包含大量图像资源，采用下列前置条件：</p> <ul><li>Swiper的子组件为带有50个ListItem的List组件；</li><li>每个ListItem加载网络图片；</li><li><span rgb(73,73,73);\\\"=\"\" style='\\\"color:'>Swiper组件共有20个List子组件；</span></li><li><span rgb(73,73,73);\\\"=\"\" style='\\\"color:'>一屏显示一个Swiper子组件。</span></li></ul> <p>Swiper子组件核心代码如下</p>  <p>Swiper主页面核心代码如下</p> <pre class='\\\"screen\\\"'>private dataSrc: NumberDataSource = new NumberDataSource();\\n\\naboutToAppear(): void {\\n  for (let i = 0; i &lt; 20; i++) {\\n    this.dataSrc.addData(i, i);\\n  }\\n}\\n\\nbuild() {\\n  Column({ space: 5 }) {\\n    Swiper() {\\n      LazyForEach(this.dataSrc, (item: number, index: number) =&gt; {\\n        SwiperItem({\\n          myIndex: index\\n        });\\n      }, (item: number) =&gt; item.toString());\\n    }\\n    .cachedCount(1)\\n    .autoPlay(true)\\n    .interval(1000)\\n    .duration(100)\\n    // ...\\n  }.width('100%')\\n  .margin({ top: 5 })\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-swiper_high_performance_development_guide.html"
    },
    {
        "id": 349,
        "pre": "@Reusable\\n@Component\\nstruct PreloadSwiperItem {\\n  // ...\\n  aboutToAppear(): void {\\n    hiTraceMeter.startTrace('preloadData', 1);\\n    // ...\\n    if (!this.swiperData.pixelMap) {\\n      ImageUtils.getPixelMap(IMAGE_URL, (pixelMap: PixelMap) => {\\n        this.swiperData.pixelMap = pixelMap;\\n      });\\n    }\\n    // ...\\n  }\\n\\n  onDidBuild(): void {\\n    hiTraceMeter.finishTrace('preloadData', 1);\\n  }\\n\\n  build() {\\n    Grid() {\\n      LazyForEach(this.gridDataSource, (item: string) => {\\n        GridItem() {\\n          ImageItem({ item: item, swiperData: this.swiperData })\\n        }\\n      }, (item: string): string => item.toString())\\n    }\\n    .columnsTemplate('1fr 1fr 1fr 1fr')\\n    // ...\\n  }\\n}",
        "type": "Reference",
        "function_call": "toString()",
        "function_name": "[h2]场景案例",
        "parent_text": "[h2]场景案例Swiper子组件：在子组件首次构建(生命周期执行到aboutToAppear)时，先判断Swiper数据中图片资源是否已经存在，若不存则先下载图片资源，再构建节点。   打点事件说明，当SwiperItem发生预加载时，会先进入自定义组件生命周期回调aboutToAppear，在aboutToAppear回调中使用startTrace开启打点跟踪，随后会进入build渲染组件，build函数执行完成后进入onDidBuild回调，在该回调中使用finishTrace停止打点追踪。分别使用“noPreLoadData”，“preLoadData”标签统计两种场景下的SwiperItem预加载耗时，关于本例中使用性能打点的介绍，请参考性能打点。  Swiper主页面 不提前加载数据@Entry\\n@Component\\nstruct NoPreLoadData {\\n  private dataSrc: PixelMapDataSource = new PixelMapDataSource();\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i < 20; i++) {\\n      this.dataSrc.addData(i, []);\\n    }\\n  }\\n\\n  build() {\\n    Column({ space: 5 }) {\\n      Swiper() {\\n        LazyForEach(this.dataSrc, (item: PixelMap[], index: number) => {\\n          SwiperItem({\\n            myIndex: index,\\n            dataSource: this.dataSrc\\n          });\\n        }, (item: number, index: number) => index.toString());\\n      }\\n      // ...\\n    }\\n    .width('100%')\\n    .margin({ top: 5 })\\n  }\\n}  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section105391550185214\\\"'><a name='\\\"section105391550185214\\\"'></a><a name='\\\"section105391550185214\\\"'></a><h4>[h2]场景案例</h4><p>Swiper子组件：在子组件首次构建(生命周期执行到<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoappear\\\"' target='\\\"_blank\\\"'>aboutToAppear</a>)时，先判断Swiper数据中图片资源是否已经存在，若不存则先下载图片资源，再构建节点。</p>  <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161215.41684854768989800332258827101152:50001231000000:2800:174FD7C653037F89FBA2BDD497CF744638F439EC369D10C3EAB899D5B550F622.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>打点事件说明，当SwiperItem发生预加载时，会先进入<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-page-custom-components-lifecycle\\\"' target='\\\"_blank\\\"'>自定义组件生命周期</a>回调aboutToAppear，在aboutToAppear回调中使用startTrace开启打点跟踪，随后会进入build渲染组件，build函数执行完成后进入onDidBuild回调，在该回调中使用finishTrace停止打点追踪。分别使用“noPreLoadData”，“preLoadData”标签统计两种场景下的SwiperItem预加载耗时，关于本例中使用性能打点的介绍，请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hitracemeter\\\"' target='\\\"_blank\\\"'>性能打点</a>。</p> </div></div> <p>Swiper主页面</p> <ul><li>不提前加载数据<pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct NoPreLoadData {\\n  private dataSrc: PixelMapDataSource = new PixelMapDataSource();\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i &lt; 20; i++) {\\n      this.dataSrc.addData(i, []);\\n    }\\n  }\\n\\n  build() {\\n    Column({ space: 5 }) {\\n      Swiper() {\\n        LazyForEach(this.dataSrc, (item: PixelMap[], index: number) =&gt; {\\n          SwiperItem({\\n            myIndex: index,\\n            dataSource: this.dataSrc\\n          });\\n        }, (item: number, index: number) =&gt; index.toString());\\n      }\\n      // ...\\n    }\\n    .width('100%')\\n    .margin({ top: 5 })\\n  }\\n}</pre> </li></ul> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-swiper_high_performance_development_guide.html"
    },
    {
        "id": 350,
        "pre": "await DownloadManager.getInstance().init(getContext() as common.UIAbilityContext);\\nlet downloadConfig: DownloadConfig = {\\n  url: this.url, // 远端文件url地址\\n  fileName: this.fileName, // 本地文件名\\n  concurrency: this.concurrency, // 启用的线程数，concurrency为1~8的正整数\\n  // ...\\n};\\n// 根据配置创建下载任务，downloadListener为可选的下载过程回调\\nthis.downloadInstance = DownloadManager.getInstance().createDownloadTask(downloadConfig, downloadListener);\\n// ...\\nawait this.downloadInstance?.start(); // 启用多线程下载",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "开发者开启多线程下载，并指定使用的线程数。 ",
        "import_module": null,
        "parent": "<li>开发者开启多线程下载，并指定使用的线程数。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-file-transmission-based-on-sfft.html"
    },
    {
        "id": 351,
        "pre": "await UploadManager.getInstance().init(getContext() as common.UIAbilityContext);\\nlet uploadConfig: UploadConfig = {\\n  url: this.isChunk ? CONSTANTS_CONFIG.urls.chunkUploadUrl : CONSTANTS_CONFIG.urls.ordinaryUploadUrl, // 上传请求url\\n  filePath: this.filePath, // 本地文件地址\\n  isChunk: this.isChunk, // 是否启用分片上传，isChunk为true时启用，启用分片上传后将支持断点续传\\n  chunkSize: 1024 * 1024 * 10, // 分片大小指定为10MB，当isChunk为true时生效\\n  // ...\\n};\\n// 根据配置创建上传任务，uploadListener为可选的上传过程回调\\nthis.uploadInstance = UploadManager.getInstance().createUploadTask(uploadConfig, uploadListener);\\n// ...\\nawait this.uploadInstance?.start(); // 启用分片上传",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "开发者主动启用分片上传，并设置了分片大小。 ",
        "import_module": null,
        "parent": "<li>开发者主动启用分片上传，并设置了分片大小。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-file-transmission-based-on-sfft.html"
    },
    {
        "id": 352,
        "pre": "await DownloadManager.getInstance().init(getContext() as common.UIAbilityContext);\\nlet downloadConfig: DownloadConfig = {\\n  url: this.url, // 远端文件url地址\\n  fileName: this.fileName, // 本地文件名\\n  concurrency: this.concurrency, // 启用的线程数，concurrency为1~8的正整数\\n  isBreakpointResume: this.isResumable, // 是否启用断点续下，isBreakpointResume为true时启用\\n  // ...\\n};\\n// 根据配置创建下载任务，downloadListener为可选的下载过程回调\\nthis.downloadInstance = DownloadManager.getInstance().createDownloadTask(downloadConfig, downloadListener);\\n// ...\\nawait this.downloadInstance?.start(); // 启用多线程下载\\n// ...\\nawait this.downloadInstance?.pause(); // 手动暂停下载或其他原因使下载暂停\\n// ...\\nawait this.downloadInstance?.resume(); // 断点续下",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "断点续下。 ",
        "import_module": null,
        "parent": "<li>断点续下。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-file-transmission-based-on-sfft.html"
    },
    {
        "id": 353,
        "pre": "let downloadConfig: DownloadConfig = {\\n  url: this.url, // 远端文件url地址\\n  fileName: this.fileName, // 本地文件名\\n  concurrency: this.concurrency, // 启用的线程数，concurrency为1~8的正整数\\n  isBreakpointResume: this.isResumable, // 是否启用断点续下，isBreakpointResume为true时启用\\n  maxRetries: 3, // 重试次数为3次\\n  retryInterval: 2000, // 重试间隔为2000ms\\n  // ...\\n};\\n// 根据配置创建下载任务，downloadListener为可选的下载过程回调\\nthis.downloadInstance = DownloadManager.getInstance().createDownloadTask(downloadConfig, downloadListener);",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "以文件下载为例，下面的代码使用了自动重连特性。在下载失败时，将自动尝试进行3次重连，重连间隔为2000毫秒。 ",
        "import_module": null,
        "parent": "<li>以文件下载为例，下面的代码使用了自动重连特性。在下载失败时，将自动尝试进行3次重连，重连间隔为2000毫秒。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-file-transmission-based-on-sfft.html"
    },
    {
        "id": 354,
        "pre": "onImageArrival(receiver: image.ImageReceiver): void {\\n  receiver.on('imageArrival', () => {\\n    receiver.readNextImage((err: BusinessError, nextImage: image.Image) => {\\n      if (err || nextImage === undefined) {\\n        Logger.error(TAG, `requestPermissionsFromUser call Failed! error: ${err.code}`);\\n        return;\\n      }\\n      if (nextImage) {\\n        nextImage.getComponent(image.ComponentType.JPEG, async (_err, component: image.Component) => {\\n          let width = 1080; // width为应用创建预览流分辨率对应的宽\\n          let height = 1080; // height为应用创建预览流分辨率对应的高\\n          // component.byteBuffer为相机返回的预览流数据，其中包含了stride对齐数据\\n          let pixelMap = await image.createPixelMap(component.byteBuffer, {\\n            size: {\\n              height: height,\\n              width: width\\n            },\\n            // 反例：width没有处理stride值，创建PixelMap解析buffer时直接按照宽去读取每行数据，可能使用了无效像素数据，导致预览流花屏。\\n            srcPixelFormat: image.PixelMapFormat.NV21\\n          })\\n          AppStorage.setOrCreate('stridePixel', pixelMap); // 将创建出的PixelMap存储到全局变量stridePixel中并传给Image组件送显。\\n          nextImage.release();\\n        })\\n      }\\n    });\\n  })\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "应用通过image.ImageReceiver注册imageArrival图像回调方法，获取每帧图像数据实例image.Image，应用通过定义一个width为1080*height为1080分辨率的预览流直接创建pixelMap，此时获取到的stride的值为1088，解析buffer时若直接按照宽去读取每行数据（使用了无效像素数据）并存储到全局变量stridePixel中，传给Image送显，会导致预览流花屏。 ",
        "import_module": null,
        "parent": "<li>应用通过image.ImageReceiver注册imageArrival图像回调方法，获取每帧图像数据实例image.Image，应用通过定义一个width为1080*height为1080分辨率的预览流直接创建pixelMap，此时获取到的stride的值为1088，解析buffer时若直接按照宽去读取每行数据（使用了无效像素数据）并存储到全局变量stridePixel中，传给Image送显，会导致预览流花屏。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-deal-stride-solution.html"
    },
    {
        "id": 355,
        "pre": "import { runningLock } from '@kit.BasicServicesKit';\\n\\n//退到后台主动释放锁\\nrunningLock.createRunningLock('running_lock_test', runningLock.RunningLockType.BACKGROUND)\\n  .then((lock: runningLock.RunningLock) => {\\n    lock.unlock();\\n    console.info('create running lock and unlock success');\\n  })\\n  .catch((err: Error) => {\\n    console.error('create running lock failed, err: ' + err);\\n  });",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]应用直接持锁",
        "parent_text": "[h2]应用直接持锁 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section161618519147\\\"'><a name='\\\"section161618519147\\\"'></a><a name='\\\"section161618519147\\\"'></a><h4>[h2]应用直接持锁</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-system-use.html"
    },
    {
        "id": 356,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { audio } from '@kit.AudioKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n\\n  onForeground(): void {\\n    //申请系统需要的资源，或者重新申请在onBackground()中释放的资源\\n    audio.createAudioRenderer(audioRendererOptions, ((err: BusinessError) => {});\\n  }\\n\\n  onBackground(): void {\\n    //释放UI不可见时释放资源\\n    audioRenderer.stop((err: BusinessError) => {});\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]系统帮助应用持锁",
        "parent_text": "[h2]系统帮助应用持锁使用音频资源时，系统会帮助应用持锁，如果不释放音频资源，会导致系统持锁不释放，因此应用在后台要主动释放音频资源。 可参考合理使用音频资源。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section05147472145\\\"'><a name='\\\"section05147472145\\\"'></a><a name='\\\"section05147472145\\\"'></a><h4>[h2]系统帮助应用持锁</h4><p>使用音频资源时，系统会帮助应用持锁，如果不释放音频资源，会导致系统持锁不释放，因此应用在后台要主动释放音频资源。</p> <p>可参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-reasonable-audio-use\\\"' target='\\\"_blank\\\"'>合理使用音频资源</a>。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-system-use.html"
    },
    {
        "id": 357,
        "pre": "// 常量声明\\nconst animationDuration: number = 500; // move动画时长\\nconst opacityChangeValue: number = 0.1; // opacity每次变化的值\\nconst opacityChangeRange: number = 1; // opacity变化的范围\\nconst translateYChangeValue: number = 180; // translateY每次变化的值\\nconst translateYChangeRange: number = 250; // translateY变化的范围\\nconst scaleXChangeValue: number = 0.6; // scaleX每次变化的值\\nconst scaleXChangeRange: number = 0.8; // scaleX每次变化的值\\n\\n// 样式属性类\\nclass UIStyle {\\n  public translateX: number = 0;\\n  public translateY: number = 0;\\n  public scaleX: number = 0.3;\\n  public scaleY: number = 0.3;\\n}\\n\\n@Component\\nstruct ComponentA {\\n  @Link uiStyle: UIStyle; // uiStyle的属性被多个组件使用\\n\\n  build() {\\n    Column() {\\n      // 使用状态变量的组件\\n      SpecialImage({ specialImageUiStyle: this.uiStyle })\\n      Stack() {\\n        Column() {\\n          Image($r('app.media.app_icon'))\\n            .height(78)\\n            .width(78)\\n            .scale({\\n              x: this.uiStyle.scaleX,\\n              y: this.uiStyle.scaleY\\n            })\\n        }\\n\\n        Stack() {\\n          Text('Hello World')\\n        }\\n      }\\n      .translate({\\n        x: this.uiStyle.translateX,\\n        y: this.uiStyle.translateY\\n      })\\n\\n      // 通过按钮点击回调修改状态变量的值，引起相应的组件刷新\\n      Column() {\\n        Button('Move')\\n          .onClick(() => {\\n            animateTo({ duration: animationDuration }, () => {\\n              this.uiStyle.translateY = (this.uiStyle.translateY + translateYChangeValue) % translateYChangeRange;\\n            })\\n          })\\n        Button('Scale')\\n          .onClick(() => {\\n            this.uiStyle.scaleX = (this.uiStyle.scaleX + scaleXChangeValue) % scaleXChangeRange;\\n          })\\n      }\\n    }\\n  }\\n}\\n\\n@Component\\nstruct SpecialImage {\\n  @Link specialImageUiStyle: UIStyle;\\n  private opacityNum: number = 0.5; // 默认透明度\\n\\n  private isRenderSpecialImage(): number {\\n    // Image每次渲染时透明度增加0.1, 在0-1之间循环\\n    this.opacityNum = (this.opacityNum + opacityChangeValue) % opacityChangeRange;\\n    return this.opacityNum;\\n  }\\n\\n  build() {\\n    Column() {\\n      Image($r('app.media.app_icon'))\\n        .size({ width: 200, height: 200 })\\n        .scale({\\n          x: this.specialImageUiStyle.scaleX,\\n          y: this.specialImageUiStyle.scaleY\\n        })\\n        .opacity(this.isRenderSpecialImage())\\n      Text(\\\"SpecialImage\\\")\\n    }\\n  }\\n}\\n\\n@Entry\\n@Component\\nstruct DFXStateBeforeOptimization {\\n  @State uiStyle: UIStyle = new UIStyle();\\n\\n  build() {\\n    Column() {\\n      ComponentA({\\n        uiStyle: this.uiStyle\\n      })\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "示例代码",
        "parent_text": "示例代码在以下代码中，创建了自定义组件ComponentA、SpecialImage，每个组件都拥有一些状态变量和UI组件。组件ComponentA中存在Move和Scale两个按钮，在按钮的点击回调中改变状态变量的值刷新相应的组件。  运行上述示例并分别点击按钮，可以看到点击Move按钮和Scale按钮时组件SpecialImage都出现了刷新，运行效果图如下。 图1 修改代码前点击Scale按钮和Move按钮时运行动图   点击Move按钮的时候SpecialImage组件却发生了旋转动画，这就造成了冗余刷新。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section84244372244\\\"'><a name='\\\"section84244372244\\\"'></a><a name='\\\"section84244372244\\\"'></a><h4>示例代码</h4><p>在以下代码中，创建了自定义组件ComponentA、SpecialImage，每个组件都拥有一些状态变量和UI组件。组件ComponentA中存在Move和Scale两个按钮，在按钮的点击回调中改变状态变量的值刷新相应的组件。</p>  <p>运行上述示例并分别点击按钮，可以看到点击Move按钮和Scale按钮时组件SpecialImage都出现了刷新，运行效果图如下。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图1 </b>修改代码前点击Scale按钮和Move按钮时运行动图</span><p><span><img height='\\\"535.356255\\\"' originheight='\\\"1080\\\"' originwidth='\\\"523\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161118.85116260729057436816923472885307:50001231000000:2800:CEE03846EB8698E29937D2D5C9DB6D2B993007A57D47B780EE796C361AE854A8.gif\\\"' title='\\\"点击放大\\\"' width='\\\"267.33000000000004\\\"'/></span></p> <p></p> </div> <p>点击Move按钮的时候SpecialImage组件却发生了旋转动画，这就造成了冗余刷新。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-redundancy-refresh-guide.html"
    },
    {
        "id": 358,
        "pre": "this.specifiedLocationDialog = this.specifiedLocationDialog ?? DialogHub.getCustomDialog()\\n  .setOperableContent(wrapBuilder(SnackbarBuilder), (action: DialogAction) => {\\n    let param = new SnackbarParams(() => {\\n      action.dismiss()\\n    }, this.pageInfos)\\n    return param\\n  })\\n  // ...\\n  .setConfig({\\n    dialogBehavior: { isModal: false, passThroughGesture: true },\\n    dialogPosition: {\\n      alignment: DialogAlignment.Bottom,\\n      offset: { dx: 0, dy: $r('app.float.specified_location_offset') }\\n    }\\n  })\\n  .build();\\nthis.specifiedLocationDialog.show();",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]指定位置弹窗的非模态弹窗",
        "parent_text": "[h2]指定位置弹窗的非模态弹窗在屏幕底部弹出SnakeBar，该弹窗可以响应用户点击跳转页面或者关闭弹窗。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section105701523142918\\\"'><a name='\\\"section105701523142918\\\"'></a><a name='\\\"section105701523142918\\\"'></a><h4>[h2]指定位置弹窗的非模态弹窗</h4><p>在屏幕底部弹出SnakeBar，该弹窗可以响应用户点击跳转页面或者关闭弹窗。</p>  <p><span><img height='\\\"467.75275400000004\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161142.12207397622775336585956548440733:50001231000000:2800:297BFF19906C9A44C7BCE987CB4883A62BE115A58FEB2F69FBE5F07AB1B1EF0C.png\\\"' title='\\\"点击放大\\\"' width='\\\"236.71579400000002\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 359,
        "pre": "this.intervalsDisappearsDialog = this.intervalsDisappearsDialog ?? DialogHub.getCustomDialog()\\n  .setContent(wrapBuilder(TimeToastBuilder), params)\\n  .setStyle({\\n    radius: $r('app.float.popup_disappears_intervals_radius'),\\n    shadow: CommonConstant.CUSTOM_SAMPLE_STYLE_SHADOW\\n  })\\n  .setAnimation({ dialogAnimation: AnimationType.UP_DOWN })\\n  .setConfig({\\n    dialogBehavior: { isModal: false, passThroughGesture: true },\\n    dialogPosition: {\\n      alignment: DialogAlignment.Top,\\n      offset: { dy: $r('app.float.popup_disappears_intervals_offset'), dx: 0 }\\n    }\\n  })\\n  .build();\\n\\nthis.intervalsDisappearsDialog.show();\\n\\nintervalID = setInterval(() => {\\n  time -= 1;\\n  params.content = time + CommonConstant.TIMED_CLOSED;\\n  this.intervalsDisappearsDialog?.updateContent(params)\\n  if (time <= 0 && intervalID) {\\n    this.intervalsDisappearsDialog?.dismiss();\\n    clearInterval(intervalID);\\n  }\\n}, CommonConstant.DURATION_1000);",
        "type": "Reference",
        "function_call": "通过dialog实例的updateContent()",
        "function_name": "[h2]会定时消失且带弹出动效的弹窗",
        "parent_text": "[h2]会定时消失且带弹出动效的弹窗实现一个定时弹窗，6s自动关闭。 通过setAnimation()设置弹窗弹出动效。通过dialog实例的updateContent()，定时动态刷新弹窗内容。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section182672073918\\\"'><a name='\\\"section182672073918\\\"'></a><a name='\\\"section182672073918\\\"'></a><h4>[h2]会定时消失且带弹出动效的弹窗</h4><p>实现一个定时弹窗，6s自动关闭。</p> <ul><li>通过setAnimation()设置弹窗弹出动效。</li><li>通过dialog实例的updateContent()，定时动态刷新弹窗内容。</li></ul>  <p><span><img height='\\\"480.520754\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161142.95292366363850315394578333270332:50001231000000:2800:8C99E228D4066152F00D15F4594BF7478332949CECC0DACCF383FDB1F3F8449D.png\\\"' title='\\\"点击放大\\\"' width='\\\"247.40287600000002\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 360,
        "pre": "this.avoidKeyboardDialog = this.avoidKeyboardDialog ?? DialogHub.getCustomDialog()\\n  .setContent(wrapBuilder(InputBuilder), param)\\n  // ...\\n  .setConfig({\\n    dialogBehavior: {\\n      isModal: false,\\n      passThroughGesture: true,\\n      requestFocusWhenShow: true,\\n      keyboardAvoidMode: CustomKeyboardAvoidMode.CONTENT_AVOID\\n    },\\n    dialogPosition: { alignment: DialogAlignment.Bottom }\\n  })\\n  .build();\\nthis.avoidKeyboardDialog.show();",
        "type": "Reference",
        "function_call": "通过setConfig()",
        "function_name": "[h2]会避让键盘的弹窗",
        "parent_text": "[h2]会避让键盘的弹窗通过setConfig()的keyboardAvoidMode可以配置避让模式，CustomKeyboardAvoidMode.CONTENT_AVOID为弹窗内容避让。 requestFocusWhenShow配置为true，弹窗显示时，弹窗自动获焦。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section395448164119\\\"'><a name='\\\"section395448164119\\\"'></a><a name='\\\"section395448164119\\\"'></a><h4>[h2]会避让键盘的弹窗</h4><p>通过setConfig()的keyboardAvoidMode可以配置避让模式，CustomKeyboardAvoidMode.CONTENT_AVOID为弹窗内容避让。</p> <p>requestFocusWhenShow配置为true，弹窗显示时，弹窗自动获焦。</p>  <p><span><img height='\\\"476.929754\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161142.40786659116715767632717230831228:50001231000000:2800:CAB6B475F422D95CDE8F5C0FF5998D3720ABBB0A4A5C21E813D6224B5682B4CC.png\\\"' title='\\\"点击放大\\\"' width='\\\"236.57109\\\"'/></span><span><img height='\\\"475.932254\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161142.94478247794802762822905031200688:50001231000000:2800:E2ADCBA00B3FAF27C87B74E4D13B68C7C095F76561F15954AE6293F39594F07B.png\\\"' title='\\\"点击放大\\\"' width='\\\"240.16209000000003\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 361,
        "pre": "DialogHub.getPopup()\\n  // ...\\n  .setComponentTargetId('PopupDialog1')\\n  .setStyle({\\n    radius: $r('app.float.image_popup_builder_borderRadius'),\\n    backgroundColor: Color.White,\\n    shadow: {\\n      radius: $r('app.float.image_popup_shadow_radius'),\\n      color: $r('app.color.image_popup_shadow_color')\\n    },\\n  })\\n  .setConfig({\\n    dialogPosition: {\\n      preferPlacement: Placement.Bottom\\n    }\\n  })\\n  .build()\\n  .show();",
        "type": "Reference",
        "function_call": "setConfig()",
        "function_name": "[h2]指向选定组件的带箭头弹窗",
        "parent_text": "[h2]指向选定组件的带箭头弹窗通过getPopup()构造Popup弹窗实例，setStyle()中enableArrow、arrowOffset、arrowWidth、arrowHeight可配置箭头属性； setConfig()中preferPlacement可配置箭头偏向。  绑定组件需要调用setComponentTargetId(targetCompId)，targetCompId组件id标识确保唯一，否则会报错且弹窗位置异常。     ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section102481945135720\\\"'><a name='\\\"section102481945135720\\\"'></a><a name='\\\"section102481945135720\\\"'></a><h4>[h2]指向选定组件的带箭头弹窗</h4><p>通过getPopup()构造Popup弹窗实例，setStyle()中enableArrow、arrowOffset、arrowWidth、arrowHeight可配置箭头属性；</p> <p>setConfig()中preferPlacement可配置箭头偏向。</p> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161143.06959171552562031685133796992499:50001231000000:2800:7CA03BC7AFC7B1799E8C50F666752C11926D5A6DED890568041A4D78A6D2E16C.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p><span rgb(0,32,96);\\\"=\"\" style='\\\"color:'>绑定组件需要调用setComponentTargetId(targetCompId</span><span rgb(0,32,96);\\\"=\"\" style='\\\"color:'>)</span>，targetCompId组件id标识确保唯一，否则会报错且弹窗位置异常。</p> </div></div>  <p></p> <p><span><img height='\\\"469.74775400000004\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161143.15050912554094943660180467547930:50001231000000:2800:E9AC74800EE771C0B48F054D409455BE6FBF4E3E8E6E8A44089004E9AF2ABD20.png\\\"' title='\\\"点击放大\\\"' width='\\\"229.80405000000002\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 362,
        "pre": "this.maskCloseDialog = this.maskCloseDialog ?? DialogHub.getCustomDialog()\\n  // ...\\n  .setConfig({ dialogBehavior: { isModal: true, autoDismiss: true, passThroughGesture: false } })\\n  .build();\\nthis.maskCloseDialog.show();",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]点击蒙层自动关闭的弹窗",
        "parent_text": "[h2]点击蒙层自动关闭的弹窗弹出此类型弹窗需要打开isModel蒙层开关，并将autoDismiss设置为true   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section3273176135820\\\"'><a name='\\\"section3273176135820\\\"'></a><a name='\\\"section3273176135820\\\"'></a><h4>[h2]点击蒙层自动关闭的弹窗</h4><p>弹出此类型弹窗需要打开isModel蒙层开关，并将autoDismiss设置为true</p>  <p><span><img height='\\\"480.121621\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161143.87712251394699822256256548172255:50001231000000:2800:C3EB126B4F843E8BF3699A50AE04CED9B33FD7C2C5A7D4EF14C608D4C6216687.png\\\"' title='\\\"点击放大\\\"' width='\\\"246.97395100000003\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 363,
        "pre": "this.activelyCloseDialog = this.activelyCloseDialog ?? DialogHub.getCustomDialog()\\n  .setOperableContent(wrapBuilder(ActiveCloseBuilder), (action: DialogAction) => {\\n    let param =\\n      new ActiveCloseParams(CommonConstant.LOGOUT, CommonConstant.LOGOUT_TIPS,\\n        CommonConstant.CANCEL, CommonConstant.OUT, () => {\\n          action.dismiss()\\n        }, () => {\\n          this.activelyCloseDialog?.dismiss()\\n        })\\n    return param\\n  })\\n  .setConfig({ dialogBehavior: { isModal: true, autoDismiss: false, passThroughGesture: false } })\\n  .setStyle({\\n    radius: $r('app.float.active_close_builder_borderRadius'),\\n    backgroundColor: Color.White,\\n  })\\n  .build();\\nthis.activelyCloseDialog.show();",
        "type": "Reference",
        "function_call": "调用setOperableContent()",
        "function_name": "[h2]可主动关闭的弹窗",
        "parent_text": "[h2]可主动关闭的弹窗能够通过点击弹窗按钮关闭弹窗，设置弹窗Content时，调用setOperableContent()，并将DialogHub的Dismiss事件作为参数传递给Builder。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1422171715581\\\"'><a name='\\\"section1422171715581\\\"'></a><a name='\\\"section1422171715581\\\"'></a><h4>[h2]可主动关闭的弹窗</h4><p>能够通过点击弹窗按钮关闭弹窗，设置弹窗Content时，调用setOperableContent()，并将DialogHub的Dismiss事件作为参数传递给Builder。</p>  <p><span><img height='\\\"475.73275400000006\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161143.84357688548384912433862712820938:50001231000000:2800:058D7471E615375E37B2C77EDA31AECDE375826F5915D61F098BB38F853D0E15.png\\\"' title='\\\"点击放大\\\"' width='\\\"237.72021\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 364,
        "pre": "this.adjustSheetDialog = DialogHub.getSheet()\\n  .setContent(wrapBuilder(SheetBuilder), sheetParams)\\n  .setStyle({ detents: [CommonConstant.SHEET_MIDDLE, CommonConstant.SHEET_LARGE] })\\n  .setConfig({ enableOutsideInteractive: false, scrollSizeMode: ScrollSizeMode.CONTINUOUS })\\n  .setComponentTargetId(CommonConstant.ADJUST_SHEET_DIALOG_ID)\\n  .build();",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "获取DialogHub的Sheet类型弹窗实例 ",
        "import_module": null,
        "parent": "<li>获取DialogHub的Sheet类型弹窗实例 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 365,
        "pre": "this.sensorDialog?.addLifeCycleListener({\\n  onWillShow: () => {\\n    this.isSensorDialogShow = true\\n    return true;\\n  },\\n  onWillDismiss: (reason: DialogDismissReason) => {\\n    this.isSensorDialogShow = false\\n    return true;\\n  }\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "对弹窗实例增加生命周期，拦截弹窗的展示与销毁。 ",
        "import_module": null,
        "parent": "<li>对弹窗实例增加生命周期，拦截弹窗的展示与销毁。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 366,
        "pre": "this.returnDataDialog = DialogHub.getCustomDialog()\\n  .setOperableContent(wrapBuilder(InputCallbackBuilder), (action: DialogAction) => {\\n    let parms = new InputCallbackParams(CommonConstant.UPDATE_TAG, () => {\\n      action.dismiss()\\n    }, (value) => {\\n      this.tagName = value\\n    })\\n    return parms\\n  })\\n  .setStyle({\\n    radius: $r('app.float.InputCallbackBuilderBorderRadius')\\n  })\\n  .setConfig({ dialogBehavior: { isModal: true, autoDismiss: false } })\\n  .build();\\nthis.returnDataDialog.show();",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]需要向页面返回数据的弹窗",
        "parent_text": "[h2]需要向页面返回数据的弹窗给Builder参数传递修改页面数据的回调函数，在Builder里面进行调用。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1013112118319\\\"'><a name='\\\"section1013112118319\\\"'></a><a name='\\\"section1013112118319\\\"'></a><h4>[h2]需要向页面返回数据的弹窗</h4><p>给Builder参数传递修改页面数据的回调函数，在Builder里面进行调用。</p>  <p><span><img height='\\\"472.34019\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161143.28520304188547347315027444340391:50001231000000:2800:11D9C5DE8BDB7295A7623835359DFD3B50F074F93D1F1238CB835BDD9C303493.png\\\"' title='\\\"点击放大\\\"' width='\\\"233.58962900000003\\\"'/></span><span><img height='\\\"471.543254\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161144.42125629719798064186756383259188:50001231000000:2800:6C4F5B07B9288F6777B7601E08C93F71C4063340B2678C8DC6051C7246D76492.png\\\"' title='\\\"点击放大\\\"' width='\\\"235.52571\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 367,
        "pre": "let params = new ProgressParams(CommonConstant.ProgressName, CommonConstant.ProgressNameStart,\\n  CommonConstant.ProgressNameTotal)\\n\\nthis.updateByParentDialog = DialogHub.getCustomDialog()\\n  .setContent(wrapBuilder(ProgressBuilder), params)\\n  .setStyle({ radius: $r('app.float.ProgressBuilderProgressBorderRadius') })\\n  .setConfig({ dialogBehavior: { isModal: true, autoDismiss: false } })\\n  .build();\\nthis.updateByParentDialog.show();\\n\\nthis.intervalID = setInterval(() => {\\n  params.value += 1\\n  if (params.value >= CommonConstant.ProgressNameTotal && this.intervalID >= 0) {\\n    this.updateByParentDialog?.dismiss();\\n    clearInterval(this.intervalID);\\n  }\\n  this.updateByParentDialog?.updateContent(params);\\n}, CommonConstant.Interval_20);",
        "type": "Reference",
        "function_call": "再调用updateContent()",
        "function_name": "[h2]父页面刷新正在展示的弹窗内容",
        "parent_text": "[h2]父页面刷新正在展示的弹窗内容修改Builder参数内容，再调用updateContent()进行修改。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1813121114315\\\"'><a name='\\\"section1813121114315\\\"'></a><a name='\\\"section1813121114315\\\"'></a><h4>[h2]父页面刷新正在展示的弹窗内容</h4><p>修改Builder参数内容，再调用updateContent()进行修改。</p>  <p><span><img height='\\\"462.76419\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161144.33104872575017235262941454922050:50001231000000:2800:8F110A4317C3EF3F213CBBF22AD3DAA391078128D5557EF84B50BC9004BACF78.png\\\"' title='\\\"点击放大\\\"' width='\\\"228.913349\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 368,
        "pre": "DialogHub.addEventListener({\\n  OnCurentPageDialogNumberChange: (newNum: number, oldNum: number) => {\\n    this.dialogNum = newNum;\\n  }\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]页面需要感知当前页面是否存在弹窗",
        "parent_text": "[h2]页面需要感知当前页面是否存在弹窗DialogHub注册页面弹窗数监听，当前页面弹窗数量发生变化会触发。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section198508281251\\\"'><a name='\\\"section198508281251\\\"'></a><a name='\\\"section198508281251\\\"'></a><h4>[h2]页面需要感知当前页面是否存在弹窗</h4><p>DialogHub注册页面弹窗数监听，当前页面弹窗数量发生变化会触发。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 369,
        "pre": "let parms = new SkipParams(() => {\\n  this.skipDialog?.dismiss()\\n}, 1, this.pageInfos);\\nthis.skipDialog?.updateContent(parms);\\nthis.skipDialog?.updateConfig({\\n  dialogPosition: { offset: { dx: 0, dy: 0 } }\\n});\\nthis.skipDialog?.show();",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]存在跳转链接的弹窗",
        "parent_text": "[h2]存在跳转链接的弹窗点击弹窗上特定内容，跳转到其他页面。 router：在弹窗Builder里通过router模板跳转。 Navigation：将pageInfos传入弹窗Builder，然后在弹窗里进行push页面。   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section19131181110319\\\"'><a name='\\\"section19131181110319\\\"'></a><a name='\\\"section19131181110319\\\"'></a><h4>[h2]存在跳转链接的弹窗</h4><p>点击弹窗上特定内容，跳转到其他页面。</p> <p>router：在弹窗Builder里通过router模板跳转。</p> <p>Navigation：将pageInfos传入弹窗Builder，然后在弹窗里进行push页面。</p>  <p><span><img height='\\\"469.548254\\\"' originheight='\\\"1026\\\"' originwidth='\\\"496\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161144.25327891496167349768658527324290:50001231000000:2800:4E6D30D9BCBD0A3C967B838A24F16ED6FB01AB6E61B756E9DF88EDCC2343985E.png\\\"' title='\\\"点击放大\\\"' width='\\\"229.83996000000002\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 370,
        "pre": "let parms = new SkipParams(() => {\\n  this.skipDialog?.dismiss()\\n}, 1, this.pageInfos);\\nthis.skipDialog?.updateContent(parms);\\nthis.skipDialog?.updateConfig({\\n  dialogPosition: { offset: CommonConstant.LEFT_DIALOG_OFFSET }\\n});\\nthis.skipDialog?.show();",
        "type": "Reference",
        "function_call": "show()",
        "function_name": "[h2]折叠屏展开态不同位置的弹窗",
        "parent_text": "[h2]折叠屏展开态不同位置的弹窗弹窗默认在屏幕中间；通过设置弹窗偏移量可以在不同位置进行弹窗。 弹窗在左半屏：   弹窗在右半屏： let parms = new SkipParams(() => {\\n  this.skipDialog?.dismiss()\\n}, 1, this.pageInfos);\\nthis.skipDialog?.updateContent(parms);\\nthis.skipDialog?.updateConfig({\\n  dialogPosition: { offset: CommonConstant.RIGHT_DIALOG_OFFSET }\\n});\\nthis.skipDialog?.show();  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1131811733\\\"'><a name='\\\"section1131811733\\\"'></a><a name='\\\"section1131811733\\\"'></a><h4>[h2]折叠屏展开态不同位置的弹窗</h4><p>弹窗默认在屏幕中间；通过设置弹窗偏移量可以在不同位置进行弹窗。</p> <p>弹窗在左半屏：</p>  <p><span><img height='\\\"634.135754\\\"' originheight='\\\"1102\\\"' originwidth='\\\"988\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161144.27317972046388946441565398107200:50001231000000:2800:3AB0EB3B8CC07DA1C50F97682FB33750C18F71C644E6FBB83B2176EC6151921F.png\\\"' title='\\\"点击放大\\\"' width='\\\"570.9579610000001\\\"'/></span></p> <p>弹窗在右半屏：</p> <pre class='\\\"screen\\\"'>let parms = new SkipParams(() =&gt; {\\n  this.skipDialog?.dismiss()\\n}, 1, this.pageInfos);\\nthis.skipDialog?.updateContent(parms);\\nthis.skipDialog?.updateConfig({\\n  dialogPosition: { offset: CommonConstant.RIGHT_DIALOG_OFFSET }\\n});\\nthis.skipDialog?.show();</pre> <p><span><img height='\\\"635.73069\\\"' originheight='\\\"1102\\\"' originwidth='\\\"988\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161144.09013274982080916959878344090245:50001231000000:2800:A2D8522FDFB851D1ED5EFB7854E9C0642226D8808C87F33717BBB1294841235B.png\\\"' title='\\\"点击放大\\\"' width='\\\"571.556594\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 371,
        "pre": "if (this.dialogA?.getStatus() != DialogStatus.SHOW) {\\n  this.dialogB?.show();\\n}",
        "type": "Reference",
        "function_call": "可以通过弹窗A对象的getStatus()",
        "function_name": null,
        "parent_text": "弹窗A弹出时抑制弹窗B的弹出可以通过弹窗A对象的getStatus()方法获取弹窗A的状态，以判断是否允许弹窗B弹出。  ",
        "import_module": null,
        "parent": "<li><strong>弹窗A弹出时抑制弹窗B的弹出</strong><p>可以通过弹窗A对象的getStatus()方法获取弹窗A的状态，以判断是否允许弹窗B弹出。</p>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-hadss_dialoghub.html"
    },
    {
        "id": 372,
        "pre": "#include \\\"napi/native_api.h\\\"\\n#include \\\"uv.h\\\"\\n#define LOG_DOMAIN 0X0202\\n#define LOG_TAG \\\"MyTag\\\"\\n#include <hilog/log.h>\\n#include <thread>\\n#include <sys/eventfd.h>\\n#include <unistd.h>\\nuv_loop_t *loop;\\nnapi_value jsCb;\\nint fd = -1;\\n\\nstatic napi_value Add(napi_env env, napi_callback_info info)\\n{\\n    napi_value work_name;\\n    napi_async_work work;\\n    napi_create_string_utf8(env, \\\"ohos\\\", NAPI_AUTO_LENGTH, &work_name);\\n    /* 第四个参数是异步线程的work任务，第五个参数为主线程的回调 */\\n    napi_create_async_work(env, nullptr, work_name, [](napi_env env, void* data){\\n        OH_LOG_INFO(LOG_APP, \\\"ohos in execute\\\");\\n    }, [](napi_env env, napi_status status, void *data){\\n        /* 不关心具体实现 */\\n        OH_LOG_INFO(LOG_APP, \\\"ohos in complete\\\");\\n        napi_delete_async_work(env, (napi_async_work)data);\\n    }, nullptr, &work);\\n    /* 通过napi_queue_async_work触发异步任务执行 */\\n    napi_queue_async_work(env, work);\\n    return 0;\\n}\\n\\nEXTERN_C_START\\nstatic napi_value Init(napi_env env, napi_value exports){\\n    napi_property_descriptor desc[] = {{\\\"add\\\", nullptr, Add, nullptr, nullptr, nullptr, napi_default, nullptr}};\\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\\n    return exports;\\n}\\nEXTERN_C_END\\n\\nstatic napi_module demoModule = {\\n    .nm_version = 1,\\n    .nm_flags = 0,\\n    .nm_filename = nullptr,\\n    .nm_register_func = Init,\\n    .nm_modname = \\\"entry\\\",\\n    .nm_priv = ((void *)0),\\n    .reserved = {0},\\n};\\n\\nextern \\\"C\\\" __attribute__((constructor)) void RegisterEntryModule(void){\\n    napi_module_register(&demoModule);\\n}",
        "type": "Reference",
        "function_call": "so(ArkNativeReference::FinalizeCallback()",
        "function_name": "方舟运行时API",
        "parent_text": "方舟运行时API1、【use after free】napi_async_work使用不规范 【问题描述】 napi_async_work使用不规范，对相关接口理解不深导致的UAF问题，涉及接口主要包括napi_create_async_work、napi_queue_async_work\\\\napi_queue_async_work_with_qos、napi_delete_async_work 【使用错误影响】 crash在系统栈，问题溯源困难。 【使用建议】 将napi_delete_async_work的工作放在napi_create_async_work中的第五个参数中的回调函数里面做。可以保证在异步任务执行期间上层开发者的内存问题不会报在系统栈导致问题无法定位。 【典型案例】 打开某应用闪退  此栈多为native开发者使用napi_async_work变量，对其生命周期管理不当导致UAF问题，难点在于都是系统栈无法追踪到具体调用方。但是该问题是必现的，因此用memtracker压测出崩溃栈如下  根据上面崩溃栈，发现是liblargelanguagemodel.z.so申请和释放的内存，看一下他们的代码  开发者使用了智能指针管理AsyncWorkData这块内存，在将任务插入到异步任务队列后就reset走到了析构函数里调用napi_delete_async_work。导致异步任务整个流程还没走完，内存就被释放，产生了UAF问题  将napi_delete_async_work的工作放在napi_create_async_work中的第五个参数中的回调函数里面做。可以保证在异步任务执行期间上层开发者的内存问题不会报在系统栈导致问题无法定位。  2、【double free】开发者手动释放ArrayBuffer内存导致double free 【问题描述】 开发者通过napi_get_arraybuffer_info接口获取ArrayBuffer的data指针，然后直接手动free这个内存导致应用崩溃，ArrayBuffer的内存由虚拟机GC统一管理，禁止开发者手动释放。 napi_create_arraybuffer/napi_create_sendable_arraybuffer/napi_get_arraybuffer_info/napi_create_buffer/napi_get_buffer_info/napi_get_typedarray_info/napi_get_dataview_info等接口同理 【使用错误影响】 应用闪退 【使用建议】 禁止开发者手动释放ArrayBuffer内存 【文档链接】 防止重复释放获取的buffer 【典型案例】 某应用安装起来后，搁置一段时间，会被强制杀死进程退出，崩溃栈如下：  【案例分析】 安装MemTracker地址越界检测工具后，发现问题发生的根因是开发者自己释放了通过虚拟机创建的ArrayBuffer的内存，然后虚拟机GC后再次去释放导致的double free。对于ArrayBuffer内存，无需开发者手动释放，而是统一交给虚拟机来管理，如果开发者尝试手动去释放这块内存，则可能导致double free问题。  【最佳实践】 不允许开发者主动释放虚拟机所管理的arraybuffer指针。  3、【memory leak】开发者使用uv_queue_work方法将任务抛到js线程上面执行的时候，对js线程的回调方法未加handle scope 【问题描述】 开发者使用uv_queue_work方法将任务抛到js线程上面执行的时候，在js回调里面创建了js对象，但是未使用api_handle_scope来管理回调方法创建的napi_value的生命周期，导致内存泄漏。 【使用错误影响】 内存泄漏 【使用建议】 当使用uv_queue_work方法将任务抛到js线程上面执行的时候，对js线程的回调方法，一般情况下需要加上napi_handle_scope来管理回调方法创建的napi_value的生命周期。 【文档链接】 异步任务 【最佳实践】 void callbackTest(CallbackContext* context)\\n{\\n    uv_loop_s* loop = nullptr;\\n    napi_get_uv_event_loop(context->env, &loop);\\n\\n    uv_work_t* work = new uv_work_t;\\n    context->retData = 1;\\n    work->data = (void*)context;\\n\\n    uv_queue_work(\\n        loop, work, [](uv_work_t* work) {},\\n        // using callback function back to JS thread\\n        [](uv_work_t* work, int status) {\\n            CallbackContext* context = (CallbackContext*)work->data;\\n            napi_handle_scope scope = nullptr;\\n            napi_open_handle_scope(context->env, &scope); // open handle scope，在这个下面创建的js对象的生命周期归这个scope管理\\n            if (scope == nullptr) {\\n                return;\\n            }\\n            napi_value callback = nullptr;\\n            napi_get_reference_value(context->env, context->callbackRef, &callback);\\n            napi_value retArg;\\n            napi_create_int32(context->env, context->retData, &retArg);\\n            napi_value ret;\\n            napi_call_function(context->env, nullptr, callback, 1, &retArg, &ret);\\n            napi_delete_reference(context->env, context->callbackRef);\\n            napi_close_handle_scope(context->env, scope); // close handle scope，如果该scope下面的对象没被其他对象引用，则GC后会释放\\n            if (work != nullptr) {\\n                delete work;\\n            }\\n            delete context;\\n        }\\n    );\\n}  4、【multi-thread】开发者使用napi接口时，跨线程使用napi_env或napi_value引发多线程安全问题 【问题描述】 绝大多数的napi接口，在调用时，存在线程安全的要求，即： 1. napi接口只能在js线程上使用。 2. 使用napi接口的线程，需要与napi_env所对应的js线程保持一致。 3. 使用napi接口的线程，需要与创建资源类型（napi_value/napi_ref等）的js线程保持一致。 若开发者有以下任一一种使用方式，则存在多线程安全问题： 1. 开发者在非js线程使用napi接口。 2. 开发者在js线程使用napi接口，但不在napi_env所对应的js线程上。 3. 开发者使用napi接口，但不在napi_value/napi_ref所创建的js线程上。 注意到以上指的是“绝大多数napi接口”，有部分napi接口是例外，并无以上约束。涉及接口有： 1. napi_call_threadsafe_function/napi_call_threadsafe_function_with_priority/napi_acquire_threadsafe_function/napi_release_threadsafe_function/napi_get_threadsafe_function_context/napi_ref_threadsafe_function/napi_unref_threadsafe_function -- napi的线程安全函数 2. napi_get_uv_event_loop -- 获取env上的loop，不涉及上述限制 3. napi_get_node_version 【使用错误影响】 应用闪退 【使用建议】 请遵循上述线程安全的要求，并且在开发过程中，打开多线程检测开关，可第一现场拦截多线程安全问题。 hdc shell param set persist.ark.properties 0x107c\\nhdc shell reboot 【典型案例】 struct AddonData {\\n    napi_async_work asyncWork = nullptr;\\n};\\nstatic void AddExecuteCB(napi_env env, void *data) {\\n    napi_value ret = nullptr;\\n    napi_create_object(env, &ret); // 在非js线程使用napi_create_object接口，存在多线程安全问题\\n}\\nstatic void AddCallbackCompleteCB(napi_env env, napi_status status, void *data) {\\n\\n}\\n\\nstatic napi_value Test(napi_env env, napi_callback_info info) {\\n    struct AddonData *addonData = (struct AddonData *)malloc(sizeof(struct AddonData));\\n    if (addonData == nullptr) {\\n        return nullptr;\\n    }\\n    napi_value resourceName = nullptr;\\n    napi_create_string_utf8(env, \\\"AsyncWorkTest\\\", NAPI_AUTO_LENGTH, &resourceName);\\n    napi_create_async_work(env, nullptr, resourceName, AddExecuteCB, AddCallbackCompleteCB,\\n                                          (void *)addonData, &addonData->asyncWork);\\n    napi_queue_async_work(env, addonData->asyncWork);\\n\\n    return nullptr;\\n} 【最佳实践】 打开多线程检测开关后，即可拦截到第一现场。 可通过命令，整机打开多线程检测开关。 hdc shell param set persist.ark.properties 0x107c\\nhdc shell reboot 也可直接在ide中勾选多线程检测选项。  5、【multi-thread】跨线程使用napi_add_env_cleanup_hook导致多线程安全问题 【问题描述】 同理接口有napi_remove_env_cleanup_hook。此系列接口并非线程安全，只允许在napi_env所对应的js线程上使用，多线程使用会存在多线程安全问题导致崩溃。 【使用错误影响】 应用闪退 【使用建议】 只允许在napi_env所对应的js线程调用napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook，禁止跨线程调用。 【典型案例】 Reason:Signal:SIGSEGV(SEGV_MAPERR)@0x006b6b5b440fd5c8 \\nLastFatalMessage:LabelServiceStub construct\\nFault thread info:\\nTid:9138, Name:OS_IPC_13_9138\\n#00 pc 0000000000069ff0 /system/lib64/platformsdk/libace_napi.z.so(std::__h::__hash_table<NativeEngine*, std::__h::hash<NativeEngine*>, std::__h::equal_to<NativeEngine*>, std::__h::allocator<NativeEngine*>>::remove(std::__h::__hash_const_iterator<std::__h::__hash_node<NativeEngine*, void*>*>)+112)(1529322f26fe2bfe6fc21fa2caae6e4d)\\n#01 pc 000000000006a938 /system/lib64/platformsdk/libace_napi.z.so(1529322f26fe2bfe6fc21fa2caae6e4d)\\n#02 pc 0000000000068170 /system/lib64/platformsdk/libace_napi.z.so(NativeEngine::RemoveCleanupHook(void (*)(void*), void*)+416)(1529322f26fe2bfe6fc21fa2caae6e4d)\\n#03 pc 000000000006cbbc /system/lib64/platformsdk/libace_napi.z.so(napi_remove_env_cleanup_hook+76)(1529322f26fe2bfe6fc21fa2caae6e4d)\\n#04 pc 000000000004460c /system/lib64/platformsdk/libipc_napi.z.so(OHOS::NAPIRemoteObject::OnJsRemoteRequest(OHOS::CallbackParam*)+796)(f9231ae5cbe6abf63dff4fda9df5a97b)\\n#05 pc 00000000000441a8 /system/lib64/platformsdk/libipc_napi.z.so(OHOS::NAPIRemoteObject::OnRemoteRequest(unsigned int, OHOS::MessageParcel&, OHOS::MessageParcel&, OHOS::MessageOption&)+544)(f9231ae5cbe6abf63dff4fda9df5a97b)\\n#06 pc 00000000000443e8 /system/lib64/chipset-pub-sdk/libipc_single.z.so(OHOS::IPCObjectStub::SendRequestInner(unsigned int, OHOS::MessageParcel&, OHOS::MessageParcel&, OHOS::MessageOption&)+152)(762ec7ac78c9865d1985559fef9f42ac)\\n#07 pc 000000000005f508 /system/lib64/chipset-pub-sdk/libipc_single.z.so(OHOS::BinderInvoker::GeneralServiceSendRequest(binder_transaction_data const&, OHOS::MessageParcel&, OHOS::MessageParcel&, OHOS::MessageOption&)+408)(762ec7ac78c9865d1985559fef9f42ac)\\n#08 pc 000000000005f66c /system/lib64/chipset-pub-sdk/libipc_single.z.so(OHOS::BinderInvoker::TargetStubSendRequest(binder_transaction_data const&, OHOS::MessageParcel&, OHOS::MessageParcel&, OHOS::MessageOption&, unsigned int&)+148)(762ec7ac78c9865d1985559fef9f42ac)\\n#09 pc 000000000005f92c /system/lib64/chipset-pub-sdk/libipc_single.z.so(OHOS::BinderInvoker::Transaction(binder_transaction_data_secctx&)+644)(762ec7ac78c9865d1985559fef9f42ac) 【最佳实践】 开发者可在开发过程中打开多线程安全检测开关，若存在napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook的multi-thread问题，在hilog中会打印出第一现场的调用栈。  6、开发者使用napi_add_env_cleanup_hook时，键值重复导致注册失败 【问题描述】 同理接口有napi_remove_env_cleanup_hook。开发者使用napi_add_env_cleanup_hook向env上注册回调时，该接口第三个入参args是作为map的key值，当开发者重复注册同一个args的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能/崩溃问题。 【使用错误影响】 功能问题/应用闪退。 【使用建议】 避免对同一个args值注册不同的回调，需要在一次回调内把所需动作都做完。 【典型案例】 使用env作为参数调用AddCleanHook注册有可能会失败。如果失败了,就调不到回调去清理map里的reference,这个env的指针后面可能会复用,就导致拿到了一个已经被释放的napi_ref。 修改方案：使用唯一的key  【最佳实践】 打开多线程检测开关后，hilog中将打印出注册失败的backtrace  7、【use after free】合理运用napi_handle_scope，避免超napi_value生命周期导致崩溃 【问题描述】 napi_value受scope管控，出scope后napi_value将失效，出scope后再使用napi_value会产生未定义行为。 【使用错误影响】 应用闪退/应用行为异常 【使用建议】 可选方案（任选其一）： 1. 使用napi_escapable_handle_scope，将napi_value逃逸出当前scope，交由上层scope管理 2. 使用napi_ref创建强应用，主动管理js对象生命周期，但注意需要开发者主动调用napi_delete_reference以释放强引用。 【典型案例】 案例一：napi_value超开发者自己声明的scope范围 static napi_value Test2(napi_env env, napi_callback_info info) {\\n    napi_handle_scope scope = nullptr;\\n    napi_value value1 = nullptr;\\n    napi_value value2 = nullptr;\\n    napi_value value3 = nullptr;\\n    napi_open_handle_scope(env, &scope);\\n    napi_create_object(env, &value1);\\n    napi_close_handle_scope(env, scope);\\n    napi_create_string_utf8(env, \\\"const char *str\\\", NAPI_AUTO_LENGTH, &value2);\\n    napi_create_string_utf8(env, \\\"const char *str\\\", NAPI_AUTO_LENGTH, &value3);\\n    napi_valuetype type = napi_null;\\n    napi_typeof(env, value1, &type);\\n    OH_LOG_INFO(LOG_APP, \\\"xxx, %{public}d\\\", type);\\n\\n    return value1;\\n}  创建时是个obj，但是出scope后再使用，变成了string，行为异常。 案例二：napi_value超napi框架的scope范围 testNapi.test3(2, 3);\\ntestNapi.test4().length; napi_value objvalues = nullptr;\\nstatic napi_value Test3(napi_env env, napi_callback_info info) {\\n    napi_create_object(env, &objvalues);\\n    return nullptr;\\n}\\n\\nstatic napi_value Test4(napi_env env, napi_callback_info info) { return objvalues; }  原因分析： 跨napi的native_value未使用napi_ref保存，出napi调用框架的scope后，native_value失效。 注：NAPI框架的scope即napi_handle_scope，napi开发者可以通过napi_handle_scope来管理napi_value的生命周期。框架层的scope嵌入在js call native的端到端流程中，即：进入开发者自己写的native方法前open scope，native方法结束后close scope。 【最佳实践】 1. 针对案例1，使用napi_escapable_handle_scope，并在close之前提前escape。 static napi_value Test2(napi_env env, napi_callback_info info) {\\n    napi_escapable_handle_scope scope = nullptr;\\n    napi_value value1 = nullptr;\\n    napi_value value2 = nullptr;\\n    napi_value value3 = nullptr;\\n    napi_value value4 = nullptr;\\n\\n    napi_open_escapable_handle_scope(env, &scope);\\n    napi_create_object(env, &value1);\\n    napi_escape_handle(env, scope, value1, &value4);\\n    napi_close_escapable_handle_scope(env, scope);\\n    napi_create_string_utf8(env, \\\"const char *str\\\", NAPI_AUTO_LENGTH, &value2);\\n    napi_create_string_utf8(env, \\\"const char *str\\\", NAPI_AUTO_LENGTH, &value3);\\n    napi_valuetype type = napi_null;\\n    napi_typeof(env, value4, &type);\\n    OH_LOG_INFO(LOG_APP, \\\"xxx, %{public}d\\\", type);\\n\\n    return value1;\\n} 以上代码，结果符合预期  2. 针对案例2，使用napi_ref保存强引用。 napi_ref g_ref = nullptr;\\nstatic napi_value Test3(napi_env env, napi_callback_info info) {\\n    napi_value value;\\n    napi_create_object(env, &value);\\n    napi_create_reference(env, value, 1, &g_ref);\\n    return nullptr;\\n}\\n\\nstatic napi_value Test4(napi_env env, napi_callback_info info) {\\n    napi_value result;\\n    napi_get_reference_value(env, g_ref, &result);\\n    napi_delete_reference(env, g_ref);\\n    return result;\\n}  8、【use after free】开发者保存env指针，env释放后开发者继续使用，产生UAF导致崩溃 【问题描述】 开发者提前保存napi_env指针，当js线程退出后，napi_env所指向的地址被释放，但开发者并未感知，后续再使用旧的napi_env调用napi接口时，发生崩溃。 【使用错误影响】 应用闪退 【使用建议】 减少“保存env指针”这种行为，直接使用napi框架层透传下来的env更为安全。若一定要保存env指针，可利用napi_add_env_cleanup_hook接口注册回调，在回调中感知env的退出。 【典型案例】 Timestamp:2023-07-21 22:42:43.036\\nPid:3952\\nUid:20010086\\nReason:Signal:SIGSEGV(SEGV_MAPERR)@0x0000000000000028 \\nTid:3997, Name:PaEngineRunner1\\n#00 pc 0000000000022794 /system/lib64/platformsdk/libace_napi.z.so(NativeEngineInterface::ClearLastError()+0)(7c5267e605f12e7abb774fca82e34826)\\n#01 pc 000000000001c150 /system/lib64/platformsdk/libace_napi.z.so(napi_delete_reference+44)(7c5267e605f12e7abb774fca82e34826)\\n#02 pc 000000000002cf74 /system/lib64/chipset-pub-sdk/libipc_napi.z.so(OHOS::NAPIRemoteObject::~NAPIRemoteObject()+100)(e5ef129057d21508b210b1ea767c123e)\\n#03 pc 000000000002d0e0 /system/lib64/chipset-pub-sdk/libipc_napi.z.so(virtual thunk to OHOS::NAPIRemoteObject::~NAPIRemoteObject()+36)(e5ef129057d21508b210b1ea767c123e)\\n#04 pc 00000000000208b8 /system/lib64/chipset-pub-sdk/libutils.z.so(OHOS::RefBase::DecStrongRef(void const*)+184)(764d94f3f9f77923ad3529406319770b)\\n#05 pc 000000000003123c /system/lib64/chipset-pub-sdk/libipc_napi.z.so(OHOS::NAPIRemoteObjectHolder::~NAPIRemoteObjectHolder()+92)(e5ef129057d21508b210b1ea767c123e)\\n#06 pc 00000000000312b4 /system/lib64/chipset-pub-sdk/libipc_napi.z.so(OHOS::NAPIRemoteObjectHolder::~NAPIRemoteObjectHolder()+16)(e5ef129057d21508b210b1ea767c123e)\\n#07 pc 0000000000026b24 /system/lib64/libace_napi_ark.z.so(ArkNativeReference::FinalizeCallback()+36)(6b56b7e2cdfb750cbb348dbc6b3f65cd) 根据日志打印env地址定位，发现是env被释放后仍然被使用  9、【use after free】开发者使用napi_get_reference_value时，napi_ref已被释放，导致UAF问题 【问题描述】 开发者使用napi_get_reference_value时，napi_ref已被释放，导致UAF问题 【使用错误影响】 应用闪退 【使用建议】 若创建的napi_ref为强应用，则开发者需要主动管理napi_ref的生命周期，避免在napi_delete_reference之后还在使用的情况 【典型案例】 napi_ref被释放后使用  10、【buffer overflow】napi_get_value_string_utf8时，buffer长度不足导致越界问题 【问题描述】 同理接口有napi_get_cb_info/napi_get_string_value_xxx，此类接口有个共同特点：需要开发者传入buffer与对应的buffer长度。若开发者传入的buffer size超过实际的buffer size时，就会发生越界问题。 【使用错误影响】 应用闪退 【使用建议】 1. 开发者需保证buffer容量充足，不会越界 2. 对于napi_get_value_string_xxx系列接口，buffer长度可传入NAPI_AUTO_LENGTH，接口内部会自动计算buffer长度。 【典型案例】 argc长度超过argv实际长度，导致越界 static napi_value Test5(napi_env env, napi_callback_info info) {\\n    size_t argc; // 未初始化，argc可能是个随机的、很大的值\\n    napi_value argv[3] = {nullptr};\\n    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);\\n    return argv[0];\\n}  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1219614634615\\\"'><a name='\\\"section1219614634615\\\"'></a><a name='\\\"section1219614634615\\\"'></a><h4>方舟运行时API</h4><p>1、【use after free】napi_async_work使用不规范</p> <p><strong>【问题描述】</strong></p> <p>napi_async_work使用不规范，对相关接口理解不深导致的UAF问题，涉及接口主要包括napi_create_async_work、napi_queue_async_work\\\\napi_queue_async_work_with_qos、napi_delete_async_work</p> <p><strong>【使用错误影响】</strong></p> <p>crash在系统栈，问题溯源困难。</p> <p><strong>【使用建议】</strong></p> <p>将napi_delete_async_work的工作放在napi_create_async_work中的第五个参数中的回调函数里面做。可以保证在异步任务执行期间上层开发者的内存问题不会报在系统栈导致问题无法定位。</p> <p><strong>【典型案例】</strong></p> <p>打开某应用闪退</p> <p><span><img originheight='\\\"252\\\"' originwidth='\\\"1028\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161253.39719625175627901221437071399999:50001231000000:2800:19693278E2455FC12EA9F45017381B43C4092520B8327A6C5A67B0D75DD6F090.png\\\"'/></span></p> <p>此栈多为native开发者使用napi_async_work变量，对其生命周期管理不当导致UAF问题，难点在于都是系统栈无法追踪到具体调用方。但是该问题是必现的，因此用memtracker压测出崩溃栈如下</p> <p><span><img height='\\\"266.534926\\\"' originheight='\\\"393\\\"' originwidth='\\\"1868\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161253.69719523880907457012599345171050:50001231000000:2800:03F79B40A7F2C0FFD9D4E0EF631DD99ACF2065E9209C7AA6FDEB8A918BB212FB.png\\\"' title='\\\"点击放大\\\"' width='\\\"1266.88485\\\"'/></span></p> <p>根据上面崩溃栈，发现是liblargelanguagemodel.z.so申请和释放的内存，看一下他们的代码</p> <p><span><img height='\\\"616.657426\\\"' originheight='\\\"746\\\"' originwidth='\\\"1858\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161253.31470939920087068276356374319996:50001231000000:2800:CFEC0C5FBC01D3DC226E223EE256932783BFA3CF512052297DC8D883882402AC.png\\\"' title='\\\"点击放大\\\"' width='\\\"1535.8607250000002\\\"'/></span></p> <p>开发者使用了智能指针管理AsyncWorkData这块内存，在将任务插入到异步任务队列后就reset走到了析构函数里调用napi_delete_async_work。导致异步任务整个流程还没走完，内存就被释放，产生了UAF问题</p>  <p>将napi_delete_async_work的工作放在napi_create_async_work中的第五个参数中的回调函数里面做。可以保证在异步任务执行期间上层开发者的内存问题不会报在系统栈导致问题无法定位。</p> <p></p> <p>2、【double free】开发者手动释放ArrayBuffer内存导致double free</p> <p><strong>【问题描述】</strong></p> <p>开发者通过napi_get_arraybuffer_info接口获取ArrayBuffer的data指针，然后直接手动free这个内存导致应用崩溃，ArrayBuffer的内存由虚拟机GC统一管理，禁止开发者手动释放。</p> <p>napi_create_arraybuffer/napi_create_sendable_arraybuffer/napi_get_arraybuffer_info/napi_create_buffer/napi_get_buffer_info/napi_get_typedarray_info/napi_get_dataview_info等接口同理</p> <p><strong>【使用错误影响】</strong></p> <p>应用闪退</p> <p><strong>【使用建议】</strong></p> <p>禁止开发者手动释放ArrayBuffer内存</p> <p><strong>【文档链接】</strong></p> <p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-guidelines#防止重复释放获取的buffer\\\"' target='\\\"_blank\\\"'>防止重复释放获取的buffer</a></p> <p><strong>【典型案例】</strong></p> <p>某应用安装起来后，搁置一段时间，会被强制杀死进程退出，崩溃栈如下：</p> <p><span><img height='\\\"355.312426\\\"' originheight='\\\"480\\\"' originwidth='\\\"1844\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161253.91560335713358027319460107427601:50001231000000:2800:11EC1DB96E61C8AB161D951D31C45ED9F955525A0B976A30F87E3CDCB4DD8DE8.png\\\"' title='\\\"点击放大\\\"' width='\\\"1364.988975\\\"'/></span></p> <p>【案例分析】</p> <p>安装MemTracker地址越界检测工具后，发现问题发生的根因是开发者自己释放了通过虚拟机创建的ArrayBuffer的内存，然后虚拟机GC后再次去释放导致的double free。对于ArrayBuffer内存，无需开发者手动释放，而是统一交给虚拟机来管理，如果开发者尝试手动去释放这块内存，则可能导致double free问题。</p> <p><span><img originheight='\\\"331\\\"' originwidth='\\\"1597\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161253.26011642092194121924542133203322:50001231000000:2800:257FD6C546629FAB245A5272C5ECE71A8A912CC8886AB1D126855C89A2969349.png\\\"'/></span></p> <p><strong>【最佳实践】</strong></p> <p>不允许开发者主动释放虚拟机所管理的arraybuffer指针。</p> <p></p> <p>3、【memory leak】开发者使用uv_queue_work方法将任务抛到js线程上面执行的时候，对js线程的回调方法未加handle scope</p> <p><strong>【问题描述】</strong></p> <p>开发者使用uv_queue_work方法将任务抛到js线程上面执行的时候，在js回调里面创建了js对象，但是未使用api_handle_scope来管理回调方法创建的napi_value的生命周期，导致内存泄漏。</p> <p><strong>【使用错误影响】</strong></p> <p>内存泄漏</p> <p><strong>【使用建议】</strong></p> <p>当使用uv_queue_work方法将任务抛到js线程上面执行的时候，对js线程的回调方法，一般情况下需要加上napi_handle_scope来管理回调方法创建的napi_value的生命周期。</p> <p><strong>【文档链接】</strong></p> <p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-guidelines#异步任务\\\"' target='\\\"_blank\\\"'>异步任务</a></p> <p><strong>【最佳实践】</strong></p> <pre class='\\\"screen\\\"'>void callbackTest(CallbackContext* context)\\n{\\n    uv_loop_s* loop = nullptr;\\n    napi_get_uv_event_loop(context-&gt;env, &amp;loop);\\n\\n    uv_work_t* work = new uv_work_t;\\n    context-&gt;retData = 1;\\n    work-&gt;data = (void*)context;\\n\\n    uv_queue_work(\\n        loop, work, [](uv_work_t* work) {},\\n        // using callback function back to JS thread\\n        [](uv_work_t* work, int status) {\\n            CallbackContext* context = (CallbackContext*)work-&gt;data;\\n            napi_handle_scope scope = nullptr;\\n            napi_open_handle_scope(context-&gt;env, &amp;scope); // open handle scope，在这个下面创建的js对象的生命周期归这个scope管理\\n            if (scope == nullptr) {\\n                return;\\n            }\\n            napi_value callback = nullptr;\\n            napi_get_reference_value(context-&gt;env, context-&gt;callbackRef, &amp;callback);\\n            napi_value retArg;\\n            napi_create_int32(context-&gt;env, context-&gt;retData, &amp;retArg);\\n            napi_value ret;\\n            napi_call_function(context-&gt;env, nullptr, callback, 1, &amp;retArg, &amp;ret);\\n            napi_delete_reference(context-&gt;env, context-&gt;callbackRef);\\n            napi_close_handle_scope(context-&gt;env, scope); // close handle scope，如果该scope下面的对象没被其他对象引用，则GC后会释放\\n            if (work != nullptr) {\\n                delete work;\\n            }\\n            delete context;\\n        }\\n    );\\n}</pre> <p></p> <p>4、【multi-thread】开发者使用napi接口时，跨线程使用napi_env或napi_value引发多线程安全问题</p> <p><strong>【问题描述】</strong></p> <p>绝大多数的napi接口，在调用时，存在线程安全的要求，即：</p> <p>1. napi接口只能在js线程上使用。</p> <p>2. 使用napi接口的线程，需要与napi_env所对应的js线程保持一致。</p> <p>3. 使用napi接口的线程，需要与创建资源类型（napi_value/napi_ref等）的js线程保持一致。</p> <p>若开发者有以下任一一种使用方式，则存在多线程安全问题：</p> <p>1. 开发者在非js线程使用napi接口。</p> <p>2. 开发者在js线程使用napi接口，但不在napi_env所对应的js线程上。</p> <p>3. 开发者使用napi接口，但不在napi_value/napi_ref所创建的js线程上。</p> <p>注意到以上指的是“绝大多数napi接口”，有部分napi接口是例外，并无以上约束。涉及接口有：</p> <p>1. napi_call_threadsafe_function/napi_call_threadsafe_function_with_priority/napi_acquire_threadsafe_function/napi_release_threadsafe_function/napi_get_threadsafe_function_context/napi_ref_threadsafe_function/napi_unref_threadsafe_function -- napi的线程安全函数</p> <p>2. napi_get_uv_event_loop -- 获取env上的loop，不涉及上述限制</p> <p>3. napi_get_node_version</p> <p><strong>【使用错误影响】</strong></p> <p>应用闪退</p> <p><strong>【使用建议】</strong></p> <p>请遵循上述线程安全的要求，并且在开发过程中，打开多线程检测开关，可第一现场拦截多线程安全问题。</p> <pre class='\\\"screen\\\"'>hdc shell param set persist.ark.properties 0x107c\\nhdc shell reboot</pre> <p><strong>【典型案例】</strong></p> <pre class='\\\"screen\\\"'>struct AddonData {\\n    napi_async_work asyncWork = nullptr;\\n};\\nstatic void AddExecuteCB(napi_env env, void *data) {\\n    napi_value ret = nullptr;\\n    napi_create_object(env, &amp;ret); // 在非js线程使用napi_create_object接口，存在多线程安全问题\\n}\\nstatic void AddCallbackCompleteCB(napi_env env, napi_status status, void *data) {\\n\\n}\\n\\nstatic napi_value Test(napi_env env, napi_callback_info info) {\\n    struct AddonData *addonData = (struct AddonData *)malloc(sizeof(struct AddonData));\\n    if (addonData == nullptr) {\\n        return nullptr;\\n    }\\n    napi_value resourceName = nullptr;\\n    napi_create_string_utf8(env, \\\"AsyncWorkTest\\\", NAPI_AUTO_LENGTH, &amp;resourceName);\\n    napi_create_async_work(env, nullptr, resourceName, AddExecuteCB, AddCallbackCompleteCB,\\n                                          (void *)addonData, &amp;addonData-&gt;asyncWork);\\n    napi_queue_async_work(env, addonData-&gt;asyncWork);\\n\\n    return nullptr;\\n}</pre> <p><strong>【最佳实践】</strong></p> <p>打开多线程检测开关后，即可拦截到第一现场。</p> <p>可通过命令，整机打开多线程检测开关。</p> <pre class='\\\"screen\\\"'>hdc shell param set persist.ark.properties 0x107c\\nhdc shell reboot</pre> <p>也可直接在ide中勾选多线程检测选项。</p> <p><span><img height='\\\"738.352426\\\"' originheight='\\\"877\\\"' originwidth='\\\"1881\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161253.23688510524284152503693476308677:50001231000000:2800:B83679C95AC95DD821B0EB5A06D35864FBA5D6A4487BE4D715B7C8D223D03C64.png\\\"' title='\\\"点击放大\\\"' width='\\\"1583.631\\\"'/></span></p> <p>5、【multi-thread】跨线程使用napi_add_env_cleanup_hook导致多线程安全问题</p> <p><strong>【问题描述】</strong></p> <p>同理接口有napi_remove_env_cleanup_hook。此系列接口并非线程安全，只允许在napi_env所对应的js线程上使用，多线程使用会存在多线程安全问题导致崩溃。</p> <p><strong>【使用错误影响】</strong></p> <p>应用闪退</p> <p><strong>【使用建议】</strong></p> <p>只允许在napi_env所对应的js线程调用napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook，禁止跨线程调用。</p> <p><strong>【典型案例】</strong></p> <pre class='\\\"screen\\\"'>Reason:Signal:SIGSEGV(SEGV_MAPERR)@0x006b6b5b440fd5c8 \\nLastFatalMessage:LabelServiceStub construct\\nFault thread info:\\nTid:9138, Name:OS_IPC_13_9138\\n#00 pc 0000000000069ff0 /system/lib64/platformsdk/libace_napi.z.so(std::__h::__hash_table&lt;NativeEngine*, std::__h::hash&lt;NativeEngine*&gt;, std::__h::equal_to&lt;NativeEngine*&gt;, std::__h::allocator&lt;NativeEngine*&gt;&gt;::remove(std::__h::__hash_const_iterator&lt;std::__h::__hash_node&lt;NativeEngine*, void*&gt;*&gt;)+112)(1529322f26fe2bfe6fc21fa2caae6e4d)\\n#01 pc 000000000006a938 /system/lib64/platformsdk/libace_napi.z.so(1529322f26fe2bfe6fc21fa2caae6e4d)\\n#02 pc 0000000000068170 /system/lib64/platformsdk/libace_napi.z.so(NativeEngine::RemoveCleanupHook(void (*)(void*), void*)+416)(1529322f26fe2bfe6fc21fa2caae6e4d)\\n#03 pc 000000000006cbbc /system/lib64/platformsdk/libace_napi.z.so(napi_remove_env_cleanup_hook+76)(1529322f26fe2bfe6fc21fa2caae6e4d)\\n#04 pc 000000000004460c /system/lib64/platformsdk/libipc_napi.z.so(OHOS::NAPIRemoteObject::OnJsRemoteRequest(OHOS::CallbackParam*)+796)(f9231ae5cbe6abf63dff4fda9df5a97b)\\n#05 pc 00000000000441a8 /system/lib64/platformsdk/libipc_napi.z.so(OHOS::NAPIRemoteObject::OnRemoteRequest(unsigned int, OHOS::MessageParcel&amp;, OHOS::MessageParcel&amp;, OHOS::MessageOption&amp;)+544)(f9231ae5cbe6abf63dff4fda9df5a97b)\\n#06 pc 00000000000443e8 /system/lib64/chipset-pub-sdk/libipc_single.z.so(OHOS::IPCObjectStub::SendRequestInner(unsigned int, OHOS::MessageParcel&amp;, OHOS::MessageParcel&amp;, OHOS::MessageOption&amp;)+152)(762ec7ac78c9865d1985559fef9f42ac)\\n#07 pc 000000000005f508 /system/lib64/chipset-pub-sdk/libipc_single.z.so(OHOS::BinderInvoker::GeneralServiceSendRequest(binder_transaction_data const&amp;, OHOS::MessageParcel&amp;, OHOS::MessageParcel&amp;, OHOS::MessageOption&amp;)+408)(762ec7ac78c9865d1985559fef9f42ac)\\n#08 pc 000000000005f66c /system/lib64/chipset-pub-sdk/libipc_single.z.so(OHOS::BinderInvoker::TargetStubSendRequest(binder_transaction_data const&amp;, OHOS::MessageParcel&amp;, OHOS::MessageParcel&amp;, OHOS::MessageOption&amp;, unsigned int&amp;)+148)(762ec7ac78c9865d1985559fef9f42ac)\\n#09 pc 000000000005f92c /system/lib64/chipset-pub-sdk/libipc_single.z.so(OHOS::BinderInvoker::Transaction(binder_transaction_data_secctx&amp;)+644)(762ec7ac78c9865d1985559fef9f42ac)</pre> <p><strong>【最佳实践】</strong></p> <p>开发者可在开发过程中打开多线程安全检测开关，若存在napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook的multi-thread问题，在hilog中会打印出第一现场的调用栈。</p> <p><span><img height='\\\"389.476801\\\"' originheight='\\\"572\\\"' originwidth='\\\"2492\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161253.58738078177659675933634132147634:50001231000000:2800:B390F58170263766EBCC69BBAD5A6C344A3768FFE4A9929E9E0F682BAC08D7F8.png\\\"' title='\\\"点击放大\\\"' width='\\\"1696.857225\\\"'/></span></p> <p>6、开发者使用napi_add_env_cleanup_hook时，键值重复导致注册失败</p> <p><strong>【问题描述】</strong></p> <p>同理接口有napi_remove_env_cleanup_hook。开发者使用napi_add_env_cleanup_hook向env上注册回调时，该接口第三个入参args是作为map的key值，当开发者重复注册同一个args的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能/崩溃问题。</p> <p><strong>【使用错误影响】</strong></p> <p>功能问题/应用闪退。</p> <p><strong>【使用建议】</strong></p> <p>避免对同一个args值注册不同的回调，需要在一次回调内把所需动作都做完。</p> <p><strong>【典型案例】</strong></p> <p>使用env作为参数调用AddCleanHook注册有可能会失败。如果失败了,就调不到回调去清理map里的reference,这个env的指针后面可能会复用,就导致拿到了一个已经被释放的napi_ref。</p> <p>修改方案：使用唯一的key</p> <p><span><img height='\\\"184.740059\\\"' originheight='\\\"289\\\"' originwidth='\\\"1883\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161253.92704113588818639291051689810113:50001231000000:2800:A2355ADDC9AB1E14859CF1C4248388D569D256D5364D82090C6142DA656D2C19.png\\\"' title='\\\"点击放大\\\"' width='\\\"1203.68325\\\"'/></span></p> <p><strong>【最佳实践】</strong></p> <p>打开多线程检测开关后，hilog中将打印出注册失败的backtrace</p> <p><span><img originheight='\\\"295\\\"' originwidth='\\\"1609\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161254.40939334120846910436690057358609:50001231000000:2800:FC913D9C74E3F6B29FB4F6AACDB9F0E25D2F6910F168444C95ACB370B54A96D6.png\\\"'/></span></p> <p>7、【use after free】合理运用napi_handle_scope，避免超napi_value生命周期导致崩溃</p> <p><strong>【问题描述】</strong></p> <p>napi_value受scope管控，出scope后napi_value将失效，出scope后再使用napi_value会产生未定义行为。</p> <p><strong>【使用错误影响】</strong></p> <p>应用闪退/应用行为异常</p> <p><strong>【使用建议】</strong></p> <p>可选方案（任选其一）：</p> <p>1. 使用napi_escapable_handle_scope，将napi_value逃逸出当前scope，交由上层scope管理</p> <p>2. 使用napi_ref创建强应用，主动管理js对象生命周期，但注意需要开发者主动调用napi_delete_reference以释放强引用。</p> <p><strong>【典型案例】</strong></p> <p><strong>案例一</strong>：napi_value超开发者自己声明的scope范围</p> <pre class='\\\"screen\\\"'>static napi_value Test2(napi_env env, napi_callback_info info) {\\n    napi_handle_scope scope = nullptr;\\n    napi_value value1 = nullptr;\\n    napi_value value2 = nullptr;\\n    napi_value value3 = nullptr;\\n    napi_open_handle_scope(env, &amp;scope);\\n    napi_create_object(env, &amp;value1);\\n    napi_close_handle_scope(env, scope);\\n    napi_create_string_utf8(env, \\\"const char *str\\\", NAPI_AUTO_LENGTH, &amp;value2);\\n    napi_create_string_utf8(env, \\\"const char *str\\\", NAPI_AUTO_LENGTH, &amp;value3);\\n    napi_valuetype type = napi_null;\\n    napi_typeof(env, value1, &amp;type);\\n    OH_LOG_INFO(LOG_APP, \\\"xxx, %{public}d\\\", type);\\n\\n    return value1;\\n}</pre> <p><span><img originheight='\\\"72\\\"' originwidth='\\\"715\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161254.84036293460173789376863827081355:50001231000000:2800:5F4C745221AE5245AA5980789AB6342E39A60E24C1353B7836F37DF855CB96F3.png\\\"'/></span></p> <p>创建时是个obj，但是出scope后再使用，变成了string，行为异常。</p> <p><strong>案例二</strong>：napi_value超napi框架的scope范围</p> <pre class='\\\"screen\\\"'>testNapi.test3(2, 3);\\ntestNapi.test4().length;</pre> <pre class='\\\"screen\\\"'>napi_value objvalues = nullptr;\\nstatic napi_value Test3(napi_env env, napi_callback_info info) {\\n    napi_create_object(env, &amp;objvalues);\\n    return nullptr;\\n}\\n\\nstatic napi_value Test4(napi_env env, napi_callback_info info) { return objvalues; }</pre> <p><span><img originheight='\\\"436\\\"' originwidth='\\\"775\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161254.44546879429683831575309099687744:50001231000000:2800:AE0010972248BC62E1013DFBF6579ADD08C52C5FB73056100B9D06078A063510.png\\\"'/></span></p> <p><strong>原因分析：</strong></p> <p>跨napi的native_value未使用napi_ref保存，出napi调用框架的scope后，native_value失效。</p> <p>注：NAPI框架的scope即napi_handle_scope，napi开发者可以通过napi_handle_scope来管理napi_value的生命周期。框架层的scope嵌入在js call native的端到端流程中，即：进入开发者自己写的native方法前open scope，native方法结束后close scope。</p> <p><strong>【最佳实践】</strong></p> <p>1. 针对案例1，使用napi_escapable_handle_scope，并在close之前提前escape。</p> <pre class='\\\"screen\\\"'>static napi_value Test2(napi_env env, napi_callback_info info) {\\n    napi_escapable_handle_scope scope = nullptr;\\n    napi_value value1 = nullptr;\\n    napi_value value2 = nullptr;\\n    napi_value value3 = nullptr;\\n    napi_value value4 = nullptr;\\n\\n    napi_open_escapable_handle_scope(env, &amp;scope);\\n    napi_create_object(env, &amp;value1);\\n    napi_escape_handle(env, scope, value1, &amp;value4);\\n    napi_close_escapable_handle_scope(env, scope);\\n    napi_create_string_utf8(env, \\\"const char *str\\\", NAPI_AUTO_LENGTH, &amp;value2);\\n    napi_create_string_utf8(env, \\\"const char *str\\\", NAPI_AUTO_LENGTH, &amp;value3);\\n    napi_valuetype type = napi_null;\\n    napi_typeof(env, value4, &amp;type);\\n    OH_LOG_INFO(LOG_APP, \\\"xxx, %{public}d\\\", type);\\n\\n    return value1;\\n}</pre> <p>以上代码，结果符合预期</p> <p><span><img originheight='\\\"56\\\"' originwidth='\\\"527\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161254.04520957844436610045404321782019:50001231000000:2800:61B9F1CE4E4B9D29F395AF6755E99626B440A3BEBB1FD3FC9E73125792AE16EF.png\\\"'/></span></p> <p>2. 针对案例2，使用napi_ref保存强引用。</p> <pre class='\\\"screen\\\"'>napi_ref g_ref = nullptr;\\nstatic napi_value Test3(napi_env env, napi_callback_info info) {\\n    napi_value value;\\n    napi_create_object(env, &amp;value);\\n    napi_create_reference(env, value, 1, &amp;g_ref);\\n    return nullptr;\\n}\\n\\nstatic napi_value Test4(napi_env env, napi_callback_info info) {\\n    napi_value result;\\n    napi_get_reference_value(env, g_ref, &amp;result);\\n    napi_delete_reference(env, g_ref);\\n    return result;\\n}</pre> <p></p> <p>8、【use after free】开发者保存env指针，env释放后开发者继续使用，产生UAF导致崩溃</p> <p><strong>【问题描述】</strong></p> <p>开发者提前保存napi_env指针，当js线程退出后，napi_env所指向的地址被释放，但开发者并未感知，后续再使用旧的napi_env调用napi接口时，发生崩溃。</p> <p><strong>【使用错误影响】</strong></p> <p>应用闪退</p> <p><strong>【使用建议】</strong></p> <ul><li>减少“保存env指针”这种行为，直接使用napi框架层透传下来的env更为安全。</li><li>若一定要保存env指针，可利用napi_add_env_cleanup_hook接口注册回调，在回调中感知env的退出。</li></ul> <p><strong>【典型案例】</strong></p> <pre class='\\\"screen\\\"'>Timestamp:2023-07-21 22:42:43.036\\nPid:3952\\nUid:20010086\\nReason:Signal:SIGSEGV(SEGV_MAPERR)@0x0000000000000028 \\nTid:3997, Name:PaEngineRunner1\\n#00 pc 0000000000022794 /system/lib64/platformsdk/libace_napi.z.so(NativeEngineInterface::ClearLastError()+0)(7c5267e605f12e7abb774fca82e34826)\\n#01 pc 000000000001c150 /system/lib64/platformsdk/libace_napi.z.so(napi_delete_reference+44)(7c5267e605f12e7abb774fca82e34826)\\n#02 pc 000000000002cf74 /system/lib64/chipset-pub-sdk/libipc_napi.z.so(OHOS::NAPIRemoteObject::~NAPIRemoteObject()+100)(e5ef129057d21508b210b1ea767c123e)\\n#03 pc 000000000002d0e0 /system/lib64/chipset-pub-sdk/libipc_napi.z.so(virtual thunk to OHOS::NAPIRemoteObject::~NAPIRemoteObject()+36)(e5ef129057d21508b210b1ea767c123e)\\n#04 pc 00000000000208b8 /system/lib64/chipset-pub-sdk/libutils.z.so(OHOS::RefBase::DecStrongRef(void const*)+184)(764d94f3f9f77923ad3529406319770b)\\n#05 pc 000000000003123c /system/lib64/chipset-pub-sdk/libipc_napi.z.so(OHOS::NAPIRemoteObjectHolder::~NAPIRemoteObjectHolder()+92)(e5ef129057d21508b210b1ea767c123e)\\n#06 pc 00000000000312b4 /system/lib64/chipset-pub-sdk/libipc_napi.z.so(OHOS::NAPIRemoteObjectHolder::~NAPIRemoteObjectHolder()+16)(e5ef129057d21508b210b1ea767c123e)\\n#07 pc 0000000000026b24 /system/lib64/libace_napi_ark.z.so(ArkNativeReference::FinalizeCallback()+36)(6b56b7e2cdfb750cbb348dbc6b3f65cd)</pre> <p>根据日志打印env地址定位，发现是env被释放后仍然被使用</p> <p><span><img originheight='\\\"303\\\"' originwidth='\\\"1622\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161254.80951667975546319143509204345457:50001231000000:2800:DB6003C05A22E236247D32CA2363898556C0CAB551D5BCE5DBC3554EB12E6F12.png\\\"'/></span></p> <p>9、【use after free】开发者使用napi_get_reference_value时，napi_ref已被释放，导致UAF问题</p> <p><strong>【问题描述】</strong></p> <p>开发者使用napi_get_reference_value时，napi_ref已被释放，导致UAF问题</p> <p><strong>【使用错误影响】</strong></p> <p>应用闪退</p> <p><strong>【使用建议】</strong></p> <p>若创建的napi_ref为强应用，则开发者需要主动管理napi_ref的生命周期，避免在napi_delete_reference之后还在使用的情况</p> <p><strong>【典型案例】</strong></p> <p>napi_ref被释放后使用</p> <p><span><img height='\\\"268.529926\\\"' originheight='\\\"407\\\"' originwidth='\\\"1851\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161254.36554615924735013036218303481960:50001231000000:2800:BE44F878F39A594E12C7B071EADB55B672CF142DC6F429C5F38855AD54B28B78.png\\\"' title='\\\"点击放大\\\"' width='\\\"1221.249225\\\"'/></span></p> <p>10、【buffer overflow】napi_get_value_string_utf8时，buffer长度不足导致越界问题</p> <p><strong>【问题描述】</strong></p> <p>同理接口有napi_get_cb_info/napi_get_string_value_xxx，此类接口有个共同特点：需要开发者传入buffer与对应的buffer长度。若开发者传入的buffer size超过实际的buffer size时，就会发生越界问题。</p> <p><strong>【使用错误影响】</strong></p> <p>应用闪退</p> <p><strong>【使用建议】</strong></p> <p>1. 开发者需保证buffer容量充足，不会越界</p> <p>2. 对于napi_get_value_string_xxx系列接口，buffer长度可传入NAPI_AUTO_LENGTH，接口内部会自动计算buffer长度。</p> <p><strong>【典型案例】</strong></p> <p>argc长度超过argv实际长度，导致越界</p> <pre class='\\\"screen\\\"'>static napi_value Test5(napi_env env, napi_callback_info info) {\\n    size_t argc; // 未初始化，argc可能是个随机的、很大的值\\n    napi_value argv[3] = {nullptr};\\n    napi_get_cb_info(env, info, &amp;argc, argv, nullptr, nullptr);\\n    return argv[0];\\n}</pre> <p><span><img originheight='\\\"232\\\"' originwidth='\\\"1638\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161254.60593744616589402426526590897075:50001231000000:2800:1442368A4B44ADB057D785DFD61074DA47FC00BC469363A649D877429532673F.png\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-stability-coding-standard-api.html"
    },
    {
        "id": 373,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { geoLocationManager } from '@kit.LocationKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onForeground(): void {\\n    //在前台时按业务所需创建定位请求\\n    let requestInfo: geoLocationManager.LocationRequest = {\\n      'priority': geoLocationManager.LocationRequestPriority.ACCURACY,\\n      'timeInterval': 0,\\n      'distanceInterval': 0,\\n      'maxAccuracy': 0\\n    };\\n    let locationChange = (location: geoLocationManager.Location): void => {\\n      console.log('locationChanger:data:' + JSON.stringify(location));\\n    };\\n    //监听位置的变化\\n    geoLocationManager.on('locationChange', requestInfo, locationChange);\\n  }\\n\\n  onBackground(): void {\\n    //退后台取消监听\\n    geoLocationManager.off('locationChange', locationChange);\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "示例",
        "parent_text": "示例 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1465011149533\\\"'><a name='\\\"section1465011149533\\\"'></a><a name='\\\"section1465011149533\\\"'></a><h4>示例</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-gps-use.html"
    },
    {
        "id": 374,
        "pre": "// Sample3.ets\\n@Concurrent\\nfunction wrongConcurrentFunc() {\\n  let promise = Promise.resolve();\\n  promise.then(() => {\\n    taskpool.Task.sendData();\\n  })\\n}",
        "type": "Reference",
        "function_call": "并使用terminateTask()",
        "function_name": "[h2]使用emitter和LongTask()的组合实现回调场景的通信诉求，避免在回调函数中使用SendData()",
        "parent_text": "[h2]使用emitter和LongTask()的组合实现回调场景的通信诉求，避免在回调函数中使用SendData()场景描述 TaskPool提供了支持TaskPool子线程和宿主线程通信的接口SendData()。作为TaskPool提供的接口，SendData()能够安全的将子线程的数据传输到宿主线程。 然而SendData()接口依赖于Task，生命周期同Task一致。考虑到微任务和异步事件的特性，回调函数可能在TaskPool任务结果返回后才会被处理。此时Task可能已经被销毁，如果再去调用依赖Task的接口SendData()是不合理和不安全的。TaskPool在这种情况下会抛出异常，如果这种异常是在任务返回后调用抛出的，还将会遗留在线程中不被处理，因此需避免在回调函数中使用SendData()。 如果有需要，推荐使用emitter，emitter能够方便地实现宿主线程和子线程之间的双向通信。另外emitter的on接口具有监听性质，在没有取消注册的情况下，能在任意时间被触发，因此需要在LongTask()中注册。  反例  // Sample3.ets\\nlet task: taskpool.Task = new taskpool.Task(wrongConcurrentFunc);\\ntask.onReceiveData(() => {\\n  hilog.info(0xFF00, 'sampleTag', \\\"onReceiveData has been called\\\");\\n})\\ntaskpool.execute(task); 在上述反例中，使用了异步接口，并在then中使用了SendData()。从执行流来看，wrongConcurrentFunc()会先调用Promise.resolve()生成并返回一个promise。此时，并没有其他可执行逻辑，因此会直接返回，即出了wrongConcurrentFunc()的作用域。之后在执行微任务队列时，then中的回调逻辑会被执行，且不在wrongConcurrentFunc()的作用域中执行，因此会抛出异常：SendData is not called in the concurrent function。 正例 // Sample3.ets\\n@Concurrent\\nfunction correctConcurrentFunc() {\\n  let promise = Promise.resolve();\\n  promise.then(() => {\\n    emitter.emit(\\\"1\\\", {data: {name: \\\"anonymous\\\"}});\\n  })\\n} // Sample3.ets\\nlet task: taskpool.LongTask = new taskpool.LongTask(correctConcurrentFunc);\\nemitter.on(\\\"1\\\", (data: emitter.EventData) => {\\n  hilog.info(0xff00, 'sampleTag', \\\"name is : \\\" + data.data?.name);\\n  emitter.off(\\\"1\\\")\\n  taskpool.terminateTask(task)\\n})\\ntaskpool.execute(task); 正例中仍使用了Promise then的用法，区别于反例，在then的逻辑里使用了emitter来代替SendData()接口。同时将correctConcurrentFunc()这个任务声明为LongTask()，并使用terminateTask()手动管理生命周期，在实现功能的同时也能够保证程序的正确性。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section71021154125417\\\"'><a name='\\\"section71021154125417\\\"'></a><a name='\\\"section71021154125417\\\"'></a><h4>[h2]使用emitter和LongTask()的组合实现回调场景的通信诉求，避免在回调函数中使用SendData()</h4><p><strong>场景描述</strong></p> <p>TaskPool提供了支持TaskPool子线程和宿主线程通信的接口<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#senddata11\\\"' target='\\\"_blank\\\"'>SendData()</a>。作为TaskPool提供的接口，<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#senddata11\\\"' target='\\\"_blank\\\"'>SendData()</a>能够安全的将子线程的数据传输到宿主线程。</p> <p>然而<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#senddata11\\\"' target='\\\"_blank\\\"'>SendData()</a>接口依赖于Task，生命周期同Task一致。考虑到微任务和异步事件的特性，回调函数可能在TaskPool任务结果返回后才会被处理。此时Task可能已经被销毁，如果再去调用依赖Task的接口<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#senddata11\\\"' target='\\\"_blank\\\"'>SendData()</a>是不合理和不安全的。TaskPool在这种情况下会抛出异常，如果这种异常是在任务返回后调用抛出的，还将会遗留在线程中不被处理，因此需避免在回调函数中使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#senddata11\\\"' target='\\\"_blank\\\"'>SendData()</a>。</p> <p>如果有需要，推荐使用emitter，emitter能够方便地实现宿主线程和子线程之间的双向通信。另外emitter的on接口具有监听性质，在没有取消注册的情况下，能在任意时间被触发，因此需要在LongTask()中注册。</p> <p><span><img height='\\\"384.454455\\\"' originheight='\\\"473\\\"' originwidth='\\\"1048\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161105.32480207932615916981108100750296:50001231000000:2800:AAA541063ACACC4FC3BE020BE12B249688E4B34C29DF592014CCC98CDB213EBA.png\\\"' title='\\\"点击放大\\\"' width='\\\"851.865\\\"'/></span></p> <p><strong>反例</strong></p>  <pre class='\\\"screen\\\"'>// Sample3.ets\\nlet task: taskpool.Task = new taskpool.Task(wrongConcurrentFunc);\\ntask.onReceiveData(() =&gt; {\\n  hilog.info(0xFF00, 'sampleTag', \\\"onReceiveData has been called\\\");\\n})\\ntaskpool.execute(task);</pre> <p>在上述反例中，使用了异步接口，并在then中使用了SendData()。从执行流来看，wrongConcurrentFunc()会先调用Promise.resolve()生成并返回一个promise。此时，并没有其他可执行逻辑，因此会直接返回，即出了wrongConcurrentFunc()的作用域。之后在执行微任务队列时，then中的回调逻辑会被执行，且不在wrongConcurrentFunc()的作用域中执行，因此会抛出异常：SendData is not called in the concurrent function。</p> <p><strong>正例</strong></p> <pre class='\\\"screen\\\"'>// Sample3.ets\\n@Concurrent\\nfunction correctConcurrentFunc() {\\n  let promise = Promise.resolve();\\n  promise.then(() =&gt; {\\n    emitter.emit(\\\"1\\\", {data: {name: \\\"anonymous\\\"}});\\n  })\\n}</pre> <pre class='\\\"screen\\\"'>// Sample3.ets\\nlet task: taskpool.LongTask = new taskpool.LongTask(correctConcurrentFunc);\\nemitter.on(\\\"1\\\", (data: emitter.EventData) =&gt; {\\n  hilog.info(0xff00, 'sampleTag', \\\"name is : \\\" + data.data?.name);\\n  emitter.off(\\\"1\\\")\\n  taskpool.terminateTask(task)\\n})\\ntaskpool.execute(task);</pre> <p>正例中仍使用了Promise then的用法，区别于反例，在then的逻辑里使用了emitter来代替SendData()接口。同时将correctConcurrentFunc()这个任务声明为LongTask()，并使用terminateTask()手动管理生命周期，在实现功能的同时也能够保证程序的正确性。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-taskpool_usage_specifications_and_faqs.html"
    },
    {
        "id": 375,
        "pre": "// Sample4.ets\\n@Concurrent\\nfunction correctConcurrentFunc() {\\n  let count: number = 0;\\n  let id = setInterval(() => {\\n    count++;\\n    if (count == 10) {\\n      hilog.info(0xFF00, 'sampleTag', \\\"the value has reached the threshold\\\");\\n      clearInterval(id);\\n    }\\n  }, 1000);\\n}",
        "type": "Reference",
        "function_call": "nfunction correctConcurrentFunc2()",
        "function_name": "[h2]正确处理业务逻辑异常情况，避免Task损耗",
        "parent_text": "[h2]正确处理业务逻辑异常情况，避免Task损耗场景描述 在TaskPool并发场景下，调用接口需要保证匹配，例如open()接口和close()接口要对应，使用了setInterval()后也需要调用clearInterval()。如果接口不匹配，在退出阶段可能会有些句柄未正常关闭，这将会导致线程不能被释放。当线程较多时，这种情况对常驻内存会有较大影响。 推荐使用try...catch...来处理业务逻辑可能出现的异常。例如当taskpool.execute()传入的参数可能发生异常时，使用外层try...catch...及时捕获，当子线程中的task可能出现异常时，则可以使用.catch进行捕获。 例1  // Sample4.ets\\nlet task: taskpool.Task = new taskpool.Task(correctConcurrentFunc);\\ntaskpool.execute(task); 在子线程使用定时器setInterval()模拟了一个定时任务，当定时条件满足条件后，主动使用clearInterval()将定时器取消，能够保证线程在空闲时能被正常释放。 例2 // Sample4.ets\\n@Observed\\nclass Foo {\\n  id: number = 0;\\n  name: string = \\\"foo\\\"\\n}\\n\\n@Concurrent\\nfunction correctConcurrentFunc1(foo: Foo) {\\n  console.info(\\\"the id is: \\\" + foo.id);\\n} // Sample4.ets\\ntry {\\n  let foo = new Foo();\\n  taskpool.execute(correctConcurrentFunc1, foo);\\n} catch (e) {\\n  let error: ErrorEvent = e;\\n  hilog.error(0xFF00, 'sampleTag', \\\"error info: \\\" + error.message);\\n} 在创建并执行Task时，模拟误传入标注了@Observed的class Foo，构建序列化错误场景。通常对于taskpool抛出的异常，会使用.catch的形式来捕获。但对于taskpool.execute()的序列化逻辑，此时Promise还未被创建，所以也无法被.catch捕获，因此此处使用外层的try...catch...来捕获异常 例3 // Sample4.ets\\n@Concurrent\\nfunction correctConcurrentFunc2() {\\n  let error: Error = new Error(\\\"TaskPoolThread error\\\");\\n  throw error;\\n} // Sample4.ets\\ntaskpool.execute(correctConcurrentFunc2).catch((error: BusinessError) => {\\n  hilog.error(0xFF00, 'sampleTag', \\\"error info: \\\" + error.message);\\n}) 例3中对于子线程抛出的异常，使用了.catch的方式，异常能被正确捕获，打印也符合预期。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section769720122012\\\"'><a name='\\\"section769720122012\\\"'></a><a name='\\\"section769720122012\\\"'></a><h4>[h2]正确处理业务逻辑异常情况，避免Task损耗</h4><p><strong>场景描述</strong></p> <p>在TaskPool并发场景下，调用接口需要保证匹配，例如open()接口和close()接口要对应，使用了setInterval()后也需要调用clearInterval()。如果接口不匹配，在退出阶段可能会有些句柄未正常关闭，这将会导致线程不能被释放。当线程较多时，这种情况对常驻内存会有较大影响。</p> <p>推荐使用try...catch...来处理业务逻辑可能出现的异常。例如当taskpool.execute()传入的参数可能发生异常时，使用外层try...catch...及时捕获，当子线程中的task可能出现异常时，则可以使用.catch进行捕获。</p> <p><strong>例1</strong></p>  <pre class='\\\"screen\\\"'>// Sample4.ets\\nlet task: taskpool.Task = new taskpool.Task(correctConcurrentFunc);\\ntaskpool.execute(task);</pre> <p>在子线程使用定时器setInterval()模拟了一个定时任务，当定时条件满足条件后，主动使用clearInterval()将定时器取消，能够保证线程在空闲时能被正常释放。</p> <p><strong>例2</strong></p> <pre class='\\\"screen\\\"'>// Sample4.ets\\n@Observed\\nclass Foo {\\n  id: number = 0;\\n  name: string = \\\"foo\\\"\\n}\\n\\n@Concurrent\\nfunction correctConcurrentFunc1(foo: Foo) {\\n  console.info(\\\"the id is: \\\" + foo.id);\\n}</pre> <pre class='\\\"screen\\\"'>// Sample4.ets\\ntry {\\n  let foo = new Foo();\\n  taskpool.execute(correctConcurrentFunc1, foo);\\n} catch (e) {\\n  let error: ErrorEvent = e;\\n  hilog.error(0xFF00, 'sampleTag', \\\"error info: \\\" + error.message);\\n}</pre> <p>在创建并执行Task时，模拟误传入标注了@Observed的class Foo，构建序列化错误场景。通常对于taskpool抛出的异常，会使用.catch的形式来捕获。但对于taskpool.execute()的序列化逻辑，此时Promise还未被创建，所以也无法被.catch捕获，因此此处使用外层的try...catch...来捕获异常</p> <p><strong>例3</strong></p> <pre class='\\\"screen\\\"'>// Sample4.ets\\n@Concurrent\\nfunction correctConcurrentFunc2() {\\n  let error: Error = new Error(\\\"TaskPoolThread error\\\");\\n  throw error;\\n}</pre> <pre class='\\\"screen\\\"'>// Sample4.ets\\ntaskpool.execute(correctConcurrentFunc2).catch((error: BusinessError) =&gt; {\\n  hilog.error(0xFF00, 'sampleTag', \\\"error info: \\\" + error.message);\\n})</pre> <p>例3中对于子线程抛出的异常，使用了.catch的方式，异常能被正确捕获，打印也符合预期。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-taskpool_usage_specifications_and_faqs.html"
    },
    {
        "id": 376,
        "pre": "import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';\\n\\n// 冗余操作反例\\n@Entry\\n@Component\\nstruct RedundantOperation {\\n  private arr: number[] = [];\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i < 500; i++) {\\n      this.arr[i] = i;\\n    }\\n  }\\n\\n  build() {\\n    Scroll() {\\n      List() {\\n        ForEach(this.arr, (item: number) => {\\n          ListItem() {\\n            Text('TextItem' + item)\\n          }\\n          .onAreaChange((oldValue, newValue) => {\\n            // 无任何业务操作\\n          })\\n          .width('100%')\\n          .height(100)\\n        }, (item: number) => item.toString())\\n      }\\n      .divider({ strokeWidth: 3, color: Color.Gray })\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .onWillScroll(() => {\\n      hiTraceMeter.startTrace('ScrollSlide', 1001);\\n\\n      console.debug('Debug', ('内容：' + '日志'));\\n      // 业务逻辑\\n      // ...\\n\\n      hiTraceMeter.finishTrace('ScrollSlide', 1001);\\n    })\\n  }\\n}",
        "type": "Reference",
        "function_call": "toString()",
        "function_name": "常见冗余操作",
        "parent_text": "常见冗余操作在软件开发中，冗余操作指的是那些不必要、重复执行且对程序功能无实质性贡献的操作。这些操作不仅会浪费计算资源，还可能降低程序的运行效率，特别是在高频调用的场景下，其负面影响更为显著。下面列举一些release版本中常见的冗余操作： debug日志打印Trace打点冗余空回调 【反例】：release版本中冗余日志打印，Trace打点，以及无业务代码的空回调  【正例】：release版本中删除冗余的debug日志，Trace打点以及无业务代码的空回调 // 冗余操作正例\\n@Entry\\n@Component\\n struct NoRedundantOperation {\\n  private arr: number[] = [];\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i < 500; i++) {\\n      this.arr[i] =i;\\n    }\\n  }\\n\\n  build() {\\n    Scroll() {\\n      List() {\\n        ForEach(this.arr, (item: number) => {\\n          ListItem() {\\n            Text('TextItem' + item)\\n          }\\n          .width('100%')\\n          .height(100)\\n        }, (item: number) => item.toString())\\n      }\\n      .divider({ strokeWidth: 3, color: Color.Gray })\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .onWillScroll(() => {\\n      // 业务逻辑\\n      // ...\\n    })\\n  }\\n} 图1 反例标签\\\"H:ScrollSlide\\\"Trace图 通过上图可知，在3.5s的滑动过程中，总计触发了424次日志打印以及Trace追踪，打印一次日志的平均耗时为84μs，由此可以计算出冗余的debug日志浪费了35.616ms。release版本建议删除无效日志的打印。 对于回调函数体内不包含任何业务逻辑代码的冗余回调而言，即使开发者在回调函数内部未进行任何实质性的操作，只要注册了回调接口，如onAreaChange，系统底层仍会耗费资源去监测对应事件的发生，例如计算组件的位置或大小变化，并将这些数据传递给ArkTS侧。即使这些数据最终在ArkTS层没有被有效利用，底层的计算和通信开销已然存在。所以，为了避免不必要的资源消耗，提升应用性能，应当仔细审查并移除这类无实际用途的回调函数注册。开发过程中，除了需要避免冗余操作，还需要注意避免在高频回调场景执行耗时操作，接下来介绍一下高频回调场景以及需要避免的耗时操作。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1193294163616\\\"'><a name='\\\"section1193294163616\\\"'></a><a name='\\\"section1193294163616\\\"'></a><h4>常见冗余操作</h4><p>在软件开发中，冗余操作指的是那些不必要、重复执行且对程序功能无实质性贡献的操作。这些操作不仅会浪费计算资源，还可能降低程序的运行效率，特别是在高频调用的场景下，其负面影响更为显著。下面列举一些release版本中常见的冗余操作：</p> <ul><li>debug日志打印</li><li>Trace打点</li><li>冗余空回调</li></ul> <p>【反例】：release版本中冗余日志打印，Trace打点，以及无业务代码的空回调</p>  <p>【正例】：release版本中删除冗余的debug日志，Trace打点以及无业务代码的空回调</p> <pre class='\\\"screen\\\"'>// 冗余操作正例\\n@Entry\\n@Component\\n struct NoRedundantOperation {\\n  private arr: number[] = [];\\n\\n  aboutToAppear(): void {\\n    for (let i = 0; i &lt; 500; i++) {\\n      this.arr[i] =i;\\n    }\\n  }\\n\\n  build() {\\n    Scroll() {\\n      List() {\\n        ForEach(this.arr, (item: number) =&gt; {\\n          ListItem() {\\n            Text('TextItem' + item)\\n          }\\n          .width('100%')\\n          .height(100)\\n        }, (item: number) =&gt; item.toString())\\n      }\\n      .divider({ strokeWidth: 3, color: Color.Gray })\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .onWillScroll(() =&gt; {\\n      // 业务逻辑\\n      // ...\\n    })\\n  }\\n}</pre> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图1 </b>反例标签\\\"H:ScrollSlide\\\"Trace图</span><br/><span><img height='\\\"218.8781\\\"' originheight='\\\"287\\\"' originwidth='\\\"1388\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161114.10834865754779247619951689465043:50001231000000:2800:597AD46022AA4A0D7967162D7777970FF5A66648C0711B5E8BD6DA86140C175C.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></div> <p>通过上图可知，在3.5s的滑动过程中，总计触发了424次日志打印以及Trace追踪，打印一次日志的平均耗时为84μs，由此可以计算出冗余的debug日志浪费了35.616ms。release版本建议删除无效日志的打印。</p> <p>对于回调函数体内不包含任何业务逻辑代码的冗余回调而言，即使开发者在回调函数内部未进行任何实质性的操作，只要注册了回调接口，如onAreaChange，系统底层仍会耗费资源去监测对应事件的发生，例如计算组件的位置或大小变化，并将这些数据传递给ArkTS侧。即使这些数据最终在ArkTS层没有被有效利用，底层的计算和通信开销已然存在。所以，为了避免不必要的资源消耗，提升应用性能，应当仔细审查并移除这类无实际用途的回调函数注册。开发过程中，除了需要避免冗余操作，还需要注意避免在高频回调场景执行耗时操作，接下来介绍一下高频回调场景以及需要避免的耗时操作。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-time-optimization-of-the-main-thread.html"
    },
    {
        "id": 377,
        "pre": "// onWillScroll高频回调场景反例\\n@Entry\\n@Component\\nstruct NegativeOfOnScroll {\\n  private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n\\n  count(): number {\\n    let temp: number = 0;\\n    for (let i = 0; i < 1000000; i++) {\\n      temp += 1;\\n    }\\n    return temp;\\n  }\\n\\n  build() {\\n    Scroll() {\\n      List() {\\n        ForEach(this.arr, (item: number) => {\\n          ListItem() {\\n            Text('TextItem' + item)\\n          }\\n          .width('100%')\\n          .height(100)\\n        }, (item: number) => item.toString())\\n      }\\n      .divider({ strokeWidth: 3, color: Color.Gray })\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .onWillScroll(() => {\\n      hiTraceMeter.startTrace('ScrollSlide', 1001);\\n      console.log('Scroll', 'TextItem');\\n      // 耗时操作\\n      this.count();\\n      // 业务逻辑\\n      // ...\\n      hiTraceMeter.finishTrace('ScrollSlide', 1001);\\n    })\\n  }\\n}",
        "type": "Reference",
        "function_call": "toString()",
        "function_name": "[h2]高频事件回调",
        "parent_text": "[h2]高频事件回调例如，触摸事件、拖拽事件、移动事件、组件区域变化事件、滑动事件等系统事件在应用程序运行过程中会被频繁触发，如果在这些回调接口中执行耗时操作，将导致引用出现卡顿丢帧的问题。下方是基于Scroll组件滑动时会高频调用onWillScroll的场景，分析性能差异。 场景案例 【案例一】在onWillScroll回调中执行耗时操作  【案例二】onWillScroll回调中不执行耗时操作 // onWillScroll高频回调场景正例\\n@Entry\\n@Component\\nstruct PositiveOfOnScroll {\\n  private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n\\n  build() {\\n    Scroll() {\\n      List() {\\n        ForEach(this.arr, (item: number) => {\\n          ListItem() {\\n            Text('TextItem' + item)\\n          }\\n          .width('100%')\\n          .height(100)\\n        }, (item: number) => item.toString())\\n      }\\n      .divider({ strokeWidth: 3, color: Color.Gray })\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .onWillScroll(() => {\\n      hiTraceMeter.startTrace('ScrollSlide', 1001);\\n      console.log('Scroll', 'TextItem');\\n      // 业务逻辑\\n      // ...\\n      hiTraceMeter.finishTrace('ScrollSlide', 1001);\\n    })\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section204221336134312\\\"'><a name='\\\"section204221336134312\\\"'></a><a name='\\\"section204221336134312\\\"'></a><h4>[h2]高频事件回调</h4><p>例如，触摸事件、拖拽事件、移动事件、组件区域变化事件、滑动事件等系统事件在应用程序运行过程中会被频繁触发，如果在这些回调接口中执行耗时操作，将导致引用出现卡顿丢帧的问题。下方是基于Scroll组件滑动时会高频调用onWillScroll的场景，分析性能差异。</p> <p><strong>场景案例</strong></p> <p>【案例一】在onWillScroll回调中执行耗时操作</p>  <p>【案例二】onWillScroll回调中不执行耗时操作</p> <pre class='\\\"screen\\\"'>// onWillScroll高频回调场景正例\\n@Entry\\n@Component\\nstruct PositiveOfOnScroll {\\n  private arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n\\n  build() {\\n    Scroll() {\\n      List() {\\n        ForEach(this.arr, (item: number) =&gt; {\\n          ListItem() {\\n            Text('TextItem' + item)\\n          }\\n          .width('100%')\\n          .height(100)\\n        }, (item: number) =&gt; item.toString())\\n      }\\n      .divider({ strokeWidth: 3, color: Color.Gray })\\n    }\\n    .width('100%')\\n    .height('100%')\\n    .onWillScroll(() =&gt; {\\n      hiTraceMeter.startTrace('ScrollSlide', 1001);\\n      console.log('Scroll', 'TextItem');\\n      // 业务逻辑\\n      // ...\\n      hiTraceMeter.finishTrace('ScrollSlide', 1001);\\n    })\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-time-optimization-of-the-main-thread.html"
    },
    {
        "id": 378,
        "pre": "// ...\\n// 这里用循环函数模拟耗时操作\\ncount(): number {\\n  let temp: number = 0;\\n  for (let index = 0; index < 1000000; index++) {\\n    temp += 1;\\n  }\\n  return temp;\\n}\\n\\naboutToReuse(params: Record<string, number>) {\\n  hiTraceMeter.startTrace('ReuseOfGrid', 1001);\\n  this.item = params.item;\\n  // 模拟耗时操作\\n  this.count();\\n  hiTraceMeter.finishTrace('ReuseOfGrid', 1001);\\n}\\n\\n// ...",
        "type": "Reference",
        "function_call": "naboutToReuse(params: Record&lt;string, number&gt;)",
        "function_name": "[h2]组件复用回调",
        "parent_text": "[h2]组件复用回调在滑动场景中，使用组件复用通常需要用生命周期回调aboutToReuse去更新组件的状态变量。在滑动时，aboutToReuse会被频繁调用。如果在aboutToReuse中进行了耗时操作，将导致应用出现卡顿丢帧的问题。下面的案例将基于Grid懒加载组件复用场景进行分析。 场景案例 【反例】：在aboutToReuse中进行耗时操作  【正例】：在aboutToReuse中不进行耗时操作 // ...\\naboutToReuse(params: Record<string, number>) {\\n  hiTraceMeter.startTrace('ReuseOfGrid', 1001);\\n  this.item = params.item;\\n  hiTraceMeter.finishTrace('ReuseOfGrid', 1001);\\n}\\n\\n// ... 结果对比 图7 反例滑动时单个aboutToReuse耗时 图8 正例滑动时单个aboutToReuse耗时 如图7所示，从反例Trace中“H:ReuseOfGrid”标签可以看出，单个aboutToReuse执行耗时20ms。而从图8正例Trace中“H:ReuseOfGrid”标签看，单个aboutToReuse执行耗时仅56μs。带有耗时操作的单个aboutToReuse执行耗时远超期望时间8.3ms，在Grid滑动高频调用aboutToReuse的场景中，将会导致应用连续丢帧卡顿，性能大幅下降。因此，组件复用时应避免在aboutToReuse中执行耗时操作。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section20815336174316\\\"'><a name='\\\"section20815336174316\\\"'></a><a name='\\\"section20815336174316\\\"'></a><h4>[h2]组件复用回调</h4><p>在滑动场景中，使用组件复用通常需要用生命周期回调aboutToReuse去更新组件的状态变量。在滑动时，aboutToReuse会被频繁调用。如果在aboutToReuse中进行了耗时操作，将导致应用出现卡顿丢帧的问题。下面的案例将基于Grid懒加载组件复用场景进行分析。</p> <p><strong>场景案例</strong></p> <p>【反例】：在aboutToReuse中进行耗时操作</p>  <p>【正例】：在aboutToReuse中不进行耗时操作</p> <pre class='\\\"screen\\\"'>// ...\\naboutToReuse(params: Record&lt;string, number&gt;) {\\n  hiTraceMeter.startTrace('ReuseOfGrid', 1001);\\n  this.item = params.item;\\n  hiTraceMeter.finishTrace('ReuseOfGrid', 1001);\\n}\\n\\n// ...</pre> <p><strong>结果对比</strong></p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图7 </b>反例滑动时单个aboutToReuse耗时</span><br/><span><img height='\\\"245.2254\\\"' originheight='\\\"351\\\"' originwidth='\\\"1511\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161115.34483680197955615207318883203542:50001231000000:2800:E5CC7696B39105BDD12EAD7CE44313A2A46486B356F992B21A13613A8D60A729.png\\\"' title='\\\"点击放大\\\"' width='\\\"1064\\\"'/></span></div> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图8 </b>正例滑动时单个aboutToReuse耗时</span><br/><span><img height='\\\"284.05209\\\"' originheight='\\\"378\\\"' originwidth='\\\"1411\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161115.75058515327125186021632895962487:50001231000000:2800:BFA46193D4821213E5A7064C80F7245FAB73FB42333A486F53B7E67D64BAA221.png\\\"' title='\\\"点击放大\\\"' width='\\\"1060.3425\\\"'/></span></div> <p>如图7所示，从反例Trace中“H:ReuseOfGrid”标签可以看出，单个aboutToReuse执行耗时20ms。而从图8正例Trace中“H:ReuseOfGrid”标签看，单个aboutToReuse执行耗时仅56μs。带有耗时操作的单个aboutToReuse执行耗时远超期望时间8.3ms，在Grid滑动高频调用aboutToReuse的场景中，将会导致应用连续丢帧卡顿，性能大幅下降。因此，组件复用时应避免在aboutToReuse中执行耗时操作。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-time-optimization-of-the-main-thread.html"
    },
    {
        "id": 379,
        "pre": "@Entry\\n@Component\\nstruct MyComponent {\\n  // 切换自定义组件标志位\\n  @State flag: boolean = false;\\n\\n  build() {\\n    Column({ space: 10 }) {\\n      Button('switch custom component')\\n        .onClick(() => {\\n          // 点击按钮切换自定义组件\\n          this.flag = !this.flag;\\n        })\\n      // 使用条件渲染，通过点击按钮来模拟频繁创建和销毁组件的场景\\n      if (this.flag) {\\n        // 自定义组件A\\n        CustomComponentA()\\n      } else {\\n        // 自定义组件B\\n        CustomComponentB()\\n      }\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}\\n\\n@Component\\nstruct CustomComponentA {\\n  aboutToAppear() {\\n    let temp = 0;\\n    for (let i = 0; i < 1000000; i++) {\\n      temp += 1;\\n    }\\n    console.log('CustomComponentA aboutToAppear');\\n  }\\n\\n  aboutToDisappear() {\\n    let temp = 0;\\n    for (let i = 0; i < 1000000; i++) {\\n      temp += 1;\\n    }\\n    console.log('CustomComponentA aboutToDisappear');\\n  }\\n\\n  build() {\\n    Column()\\n    .backgroundColor(Color.Blue)\\n    .width(200)\\n    .height(200)\\n  }\\n}\\n\\n@Component\\nstruct CustomComponentB {\\n  aboutToAppear() {\\n    let temp = 0;\\n    for (let i = 0; i < 1000000; i++) {\\n      temp += 1;\\n    }\\n    console.log('CustomComponentB aboutToAppear');\\n  }\\n\\n  aboutToDisappear() {\\n    let temp = 0;\\n    for (let i = 0; i < 1000000; i++) {\\n      temp += 1;\\n    }\\n    console.log('CustomComponentB aboutToDisappear');\\n  }\\n\\n  build() {\\n    Column()\\n    .backgroundColor(Color.Red)\\n    .width(200)\\n    .height(200)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]组件生命周期回调",
        "parent_text": "[h2]组件生命周期回调在需要频繁创建和销毁组件的场景中，将会频繁调用组件生命周期回调aboutToAppear，aboutToDisappear。下面是一个使用条件渲染，通过点击按钮切换自定义组件A和B来模拟频繁创建和销毁组件的场景示例。 在自定义组件A，B的生命周期回调函数aboutToAppear和aboutToDisappear中加入耗时操作。  因为示例中使用了条件渲染，每次销毁前一个自定义组件都会调用一次aboutToDisappear函数，然后创建新的自定义组件时，又会调用一次aboutToAppear，所以调用较为频繁。因此，在频繁创建和销毁组件的场景中，应尽量避免在aboutToAppear，aboutToDisappear中执行耗时操作。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section418843713435\\\"'><a name='\\\"section418843713435\\\"'></a><a name='\\\"section418843713435\\\"'></a><h4>[h2]组件生命周期回调</h4><p>在需要频繁创建和销毁组件的场景中，将会频繁调用组件生命周期回调aboutToAppear，aboutToDisappear。下面是一个使用条件渲染，通过点击按钮切换自定义组件A和B来模拟频繁创建和销毁组件的场景示例。</p> <p>在自定义组件A，B的生命周期回调函数aboutToAppear和aboutToDisappear中加入耗时操作。</p>  <p>因为示例中使用了条件渲染，每次销毁前一个自定义组件都会调用一次aboutToDisappear函数，然后创建新的自定义组件时，又会调用一次aboutToAppear，所以调用较为频繁。因此，在频繁创建和销毁组件的场景中，应尽量避免在aboutToAppear，aboutToDisappear中执行耗时操作。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-time-optimization-of-the-main-thread.html"
    },
    {
        "id": 380,
        "pre": "@Entry\\n@Component\\nexport struct NegativeOfProperty {\\n  // Row宽度\\n  @State rowWidth: number = 100;\\n\\n  getHeight(): number {\\n    let height: number = 0;\\n    // 这里用循环函数模拟耗时操作\\n    for (let index = 0; index < 1000000; index++) {\\n      height += 0.0001;\\n    }\\n    return height;\\n  }\\n\\n  build() {\\n    Column({ space: 10 }) {\\n      Button('change row width')\\n        .onClick(() => {\\n          this.rowWidth = this.rowWidth + 20;\\n          if (this.rowWidth > 200) {\\n            this.rowWidth = 100;\\n          }\\n        })\\n      Row()\\n        .width(this.rowWidth)\\n        .height(this.getHeight())\\n        .backgroundColor(Color.Blue)\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "Row()",
        "function_name": "[h2]组件属性",
        "parent_text": "[h2]组件属性组件单一属性刷新时，组件的其他属性也会同时进行刷新。在需要频繁刷新组件属性的场景中，如果组件中其他不需要刷新的属性使用了耗时的函数作为入参。那么在刷新组件某个属性时，组件中那些实际上不需要去刷新的属性将会去调用耗时函数，导致不必要的性能损耗，同时也会引起应用卡顿丢帧的问题。 下面是一个点击按钮改变Row组件宽度的示例 【反例】：Row组件的高度以耗时函数作为入参  【正例】：使用任务池taskpool处理耗时操作后返回结果给Row的高度rowHeight import { taskpool } from '@kit.ArkTS'; // 任务池\\n\\n@Concurrent\\nfunction getHeight(): number {\\n  let height: number = 0;\\n  // 这里用循环函数模拟耗时操作\\n  for (let index = 0; index < 1000000; index++) {\\n    height += 0.0001;\\n  }\\n  console.log('Scenario 4 call getHeight');\\n  return height;\\n}\\n\\n// 执行getHeight()\\ntaskpool.execute(getHeight).then((value: Object) => {\\n  AppStorage.setOrCreate('height', value);\\n});\\n\\n@Entry\\n@Component\\nstruct PositiveOfProperty {\\n  // Row宽度\\n  @State rowWidth: number = 100;\\n  // Row高度\\n  @StorageLink('height') rowHeight: number = 0;\\n  // 点击按钮改变Row宽度的次数\\n  private count: number = 0;\\n\\n  build() {\\n    Column({ space: 10 }) {\\n      Button('change row width')\\n        .onClick(() => {\\n          this.rowWidth = this.rowWidth + 20;\\n          this.count++;\\n          console.log('Scenario 4 change row width count:' + this.count);\\n          if (this.rowWidth > 200) {\\n            this.rowWidth = 100;\\n          }\\n        })\\n      Row()\\n        .width(this.rowWidth)\\n        .height(this.rowHeight)\\n        .backgroundColor(Color.Blue)\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section166841738154316\\\"'><a name='\\\"section166841738154316\\\"'></a><a name='\\\"section166841738154316\\\"'></a><h4>[h2]组件属性</h4><p>组件单一属性刷新时，组件的其他属性也会同时进行刷新。在需要频繁刷新组件属性的场景中，如果组件中其他不需要刷新的属性使用了耗时的函数作为入参。那么在刷新组件某个属性时，组件中那些实际上不需要去刷新的属性将会去调用耗时函数，导致不必要的性能损耗，同时也会引起应用卡顿丢帧的问题。</p> <p>下面是一个点击按钮改变Row组件宽度的示例</p> <p>【反例】：Row组件的高度以耗时函数作为入参</p>  <p>【正例】：使用任务池taskpool处理耗时操作后返回结果给Row的高度rowHeight</p> <pre class='\\\"screen\\\"'>import { taskpool } from '@kit.ArkTS'; // 任务池\\n\\n@Concurrent\\nfunction getHeight(): number {\\n  let height: number = 0;\\n  // 这里用循环函数模拟耗时操作\\n  for (let index = 0; index &lt; 1000000; index++) {\\n    height += 0.0001;\\n  }\\n  console.log('Scenario 4 call getHeight');\\n  return height;\\n}\\n\\n// 执行getHeight()\\ntaskpool.execute(getHeight).then((value: Object) =&gt; {\\n  AppStorage.setOrCreate('height', value);\\n});\\n\\n@Entry\\n@Component\\nstruct PositiveOfProperty {\\n  // Row宽度\\n  @State rowWidth: number = 100;\\n  // Row高度\\n  @StorageLink('height') rowHeight: number = 0;\\n  // 点击按钮改变Row宽度的次数\\n  private count: number = 0;\\n\\n  build() {\\n    Column({ space: 10 }) {\\n      Button('change row width')\\n        .onClick(() =&gt; {\\n          this.rowWidth = this.rowWidth + 20;\\n          this.count++;\\n          console.log('Scenario 4 change row width count:' + this.count);\\n          if (this.rowWidth &gt; 200) {\\n            this.rowWidth = 100;\\n          }\\n        })\\n      Row()\\n        .width(this.rowWidth)\\n        .height(this.rowHeight)\\n        .backgroundColor(Color.Blue)\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-time-optimization-of-the-main-thread.html"
    },
    {
        "id": 381,
        "pre": "import { hiTraceMeter } from '@kit.PerformanceAnalysisKit';\\n\\n@Entry\\n@Component\\nstruct GetStrOfResource {\\n  @State message: string = 'getStringSync';\\n\\n  aboutToAppear(): void {\\n    hiTraceMeter.startTrace('getStringSync', 1);\\n    // getStringSync接口的入参直接使用资源，未使用资源ID\\n    getContext().resourceManager.getStringSync($r('app.string.test'));\\n    hiTraceMeter.finishTrace('getStringSync', 1);\\n  }\\n\\n  build() {\\n    RelativeContainer() {\\n      Text(this.message)\\n        .fontSize(50)\\n        .fontWeight(FontWeight.Bold)\\n    }\\n    .height('100%')\\n    .width('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "通过resource对象获取 ",
        "import_module": null,
        "parent": "<li>通过resource对象获取 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-time-optimization-of-the-main-thread.html"
    },
    {
        "id": 382,
        "pre": "build() {\\n  Column({ space: 2 }) {\\n    WaterFlow() {\\n      LazyForEach(this.dataSource, (item: number) => {\\n        FlowItem() {\\n          // ...\\n        }\\n        .onAppear(() => {\\n          // 即将触底时提前增加数据\\n          if (item + 20 === this.dataSource.totalCount()) {\\n            //  模拟网络获取数据引起的耗时，\\n            this.mockRequestData().then((data: Item[]) => {\\n              for (let i = 0; i < data.length; i++) {\\n                this.dataSource.addLastItem();\\n              }\\n            })\\n          }\\n        })\\n        // ...\\n      }, (item: string) => item)\\n    }\\n    // ...\\n  }\\n}\\n\\nasync mockRequestData(): Promise<Item[]> {\\n  let res: ResponseData = new ResponseData();\\n  // data.json是存在本地的json数据，大小大约20M,模拟从网络端获取数据\\n  await getContext().resourceManager.getRawFileContent('data.json').then((data: Uint8Array) => {\\n    // 解析json\\n    let str = buffer.from(data).toString();\\n    res = JSON.parse(str);\\n  })\\n  return dataToItem(res.data);\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]使用多线程能力",
        "parent_text": "[h2]使用多线程能力在主线程面临耗时操作时，采用多线程能力是一种高效的优化手段。通过将耗时任务分配给后台线程并行执行，主线程可以继续处理其他任务，保持应用的流畅性和响应性。这种方式能够充分利用多核处理器的计算能力，提高程序的执行效率，减少用户等待时间，从而提升整体的用户体验。 场景案例 列表无限滑动的场景，在即将触底的时候需要进行数据请求，如果在主线程中直接处理请求数据，可能会导致滑动动画被中断。如果回调函数处理的耗时较长，会直接阻塞主线程，卡顿就会非常明显。使用异步执行的方式进行异步调用，回调函数的执行还是会在主线程，一样会阻塞UI绘制和渲染。 以瀑布流使用案例为基础进行代码改造,得到如下代码,瀑布流在即将触底时调用异步函数mockRequestData获取新数据，并将新数据写入数据源。异步函数mockRequestData用于模拟耗时的网络请求，从rawfile目录下读取数据，将数据处理后返回。  export class Item {\\n  url: string = '';\\n  id: number = 0;\\n  name: string = '';\\n\\n  // ...\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section32971936174416\\\"'><a name='\\\"section32971936174416\\\"'></a><a name='\\\"section32971936174416\\\"'></a><h4>[h2]使用多线程能力</h4><p>在主线程面临耗时操作时，采用多线程能力是一种高效的优化手段。通过将耗时任务分配给后台线程并行执行，主线程可以继续处理其他任务，保持应用的流畅性和响应性。这种方式能够充分利用多核处理器的计算能力，提高程序的执行效率，减少用户等待时间，从而提升整体的用户体验。</p> <p><strong>场景案例</strong></p> <p>列表无限滑动的场景，在即将触底的时候需要进行数据请求，如果在主线程中直接处理请求数据，可能会导致滑动动画被中断。如果回调函数处理的耗时较长，会直接阻塞主线程，卡顿就会非常明显。使用异步执行的方式进行异步调用，回调函数的执行还是会在主线程，一样会阻塞UI绘制和渲染。</p> <p>以<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow#示例1使用基本瀑布流\\\"' target='\\\"_blank\\\"'>瀑布流使用案例</a>为基础进行代码改造,得到如下代码,瀑布流在即将触底时调用异步函数mockRequestData获取新数据，并将新数据写入数据源。异步函数mockRequestData用于模拟耗时的网络请求，从rawfile目录下读取数据，将数据处理后返回。</p>  <pre class='\\\"screen\\\"'>export class Item {\\n  url: string = '';\\n  id: number = 0;\\n  name: string = '';\\n\\n  // ...\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-time-optimization-of-the-main-thread.html"
    },
    {
        "id": 383,
        "pre": "export class Item {\\n  url: string = '';\\n  id: number = 0;\\n  name: string = '';\\n\\n  // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]@Sendable装饰器",
        "parent_text": "[h2]@Sendable装饰器@Sendable装饰器可以实现数据在多线程间的传递行为是引用传递，使用方式如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section7359185917239\\\"'><a name='\\\"section7359185917239\\\"'></a><a name='\\\"section7359185917239\\\"'></a><h4>[h2]@Sendable装饰器</h4><p>@Sendable装饰器可以实现数据在多线程间的传递行为是引用传递，使用方式如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-time-optimization-of-the-main-thread.html"
    },
    {
        "id": 384,
        "pre": "// 在类方法执行前插桩 \\nstatic addBefore(targetClass, methodName, isStatic, before): void {\\n  let target =  isStatic ? targetClass : targetClass.prototype;\\n  let origin = target[methodName];\\n  // 定义新函数，里面先执行before，再执行老方法\\n  let newFunc = function (...args) {\\n    before(this, ...args);\\n    return origin.bind(this)(...args);\\n  }\\n  // 将方法替换成新函数\\n  target[methodName] = newFunc;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]接口原理的伪代码示意",
        "parent_text": "[h2]接口原理的伪代码示意addBefore: 类方法前插桩  addAfter: 类方法后插桩 // 在类方法执行后插桩\\nstatic addAfter(targetClass, methodName, isStatic, after) : void {\\n  let target =  isStatic ? targetClass : targetClass.prototype;\\n  let origin = target[methodName];\\n  // 定义新函数，里面先执行老方法，再执行after\\n  let newFunc = function (...args) {\\n    let ret = origin.bind(this)(...args);\\n    return after(this, ret, ...args);\\n  }\\n  // 将方法替换成新函数\\n  target[methodName] = newFunc;\\n} replace: 替换类方法 static replace(targetClass, methodName, isStatic, instead) : void {\\n  let target =  isStatic ? targetClass : targetClass.prototype;\\n  // 定义新函数，里面只执行instead\\n  let newFunc = function (...args) {\\n    return instead(this, ...args);\\n  }\\n  // 将方法替换成新函数\\n  target[methodName] = newFunc;\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section5291113010525\\\"'><a name='\\\"section5291113010525\\\"'></a><a name='\\\"section5291113010525\\\"'></a><h4>[h2]接口原理的伪代码示意</h4><p><strong>addBefore: 类方法前插桩</strong></p>  <p><strong>addAfter: 类方法后插桩</strong></p> <pre class='\\\"screen\\\"'>// 在类方法执行后插桩\\nstatic addAfter(targetClass, methodName, isStatic, after) : void {\\n  let target =  isStatic ? targetClass : targetClass.prototype;\\n  let origin = target[methodName];\\n  // 定义新函数，里面先执行老方法，再执行after\\n  let newFunc = function (...args) {\\n    let ret = origin.bind(this)(...args);\\n    return after(this, ret, ...args);\\n  }\\n  // 将方法替换成新函数\\n  target[methodName] = newFunc;\\n}</pre> <p><strong>replace: 替换类方法</strong></p> <pre class='\\\"screen\\\"'>static replace(targetClass, methodName, isStatic, instead) : void {\\n  let target =  isStatic ? targetClass : targetClass.prototype;\\n  // 定义新函数，里面只执行instead\\n  let newFunc = function (...args) {\\n    return instead(this, ...args);\\n  }\\n  // 将方法替换成新函数\\n  target[methodName] = newFunc;\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 385,
        "pre": "// baseAbility.ts\\nexport class A {\\n  getElementByIndex<T>(arr: Array<T>, idx: number): T {\\n    return arr[idx];\\n  }\\n}",
        "type": "Reference",
        "function_call": "new A()",
        "function_name": "[h2]代码实现",
        "parent_text": "[h2]代码实现在class A中，封装其基础能力，此处为获取数组指定下标的元素，具体代码实现如下：  在主界面中集成基础能力，并校验参数类型、判断下标是否越界，具体代码实现如下： // index.ets\\nimport {A} from './baseAbility';\\nimport {util} from '@kit.ArkTS';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\nutil.Aspect.addBefore(A, 'getElementByIndex', false,\\n  // 参数校验\\n  (instance: A, arr: Object, idx: number) => {\\n    if (!(arr instanceof Array)) {\\n       throw Error('arg arr is expected to be an array');\\n    }\\n    if (!(Number.isInteger(idx) && idx >= 0)) {\\n      throw Error('arg idx is expected to be a non-negative integer');\\n    }\\n    if (idx >= arr.length) {\\n      throw Error('arg idx is expected to be smaller than arr.length');\\n    }\\n  });\\n// 原方法执行\\nlet buffer : Array<number> = [1,2,3,5];\\nlet that = new A();\\nthat.getElementByIndex(buffer,-1);\\nthat.getElementByIndex(buffer,5);\\nthat.getElementByIndex(123 as Object as Array<number> ,5) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section124421652144912\\\"'><a name='\\\"section124421652144912\\\"'></a><a name='\\\"section124421652144912\\\"'></a><h4>[h2]代码实现</h4><p>在class A中，封装其基础能力，此处为获取数组指定下标的元素，具体代码实现如下：</p>  <p>在主界面中集成基础能力，并校验参数类型、判断下标是否越界，具体代码实现如下：</p> <pre class='\\\"screen\\\"'>// index.ets\\nimport {A} from './baseAbility';\\nimport {util} from '@kit.ArkTS';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\nutil.Aspect.addBefore(A, 'getElementByIndex', false,\\n  // 参数校验\\n  (instance: A, arr: Object, idx: number) =&gt; {\\n    if (!(arr instanceof Array)) {\\n       throw Error('arg arr is expected to be an array');\\n    }\\n    if (!(Number.isInteger(idx) &amp;&amp; idx &gt;= 0)) {\\n      throw Error('arg idx is expected to be a non-negative integer');\\n    }\\n    if (idx &gt;= arr.length) {\\n      throw Error('arg idx is expected to be smaller than arr.length');\\n    }\\n  });\\n// 原方法执行\\nlet buffer : Array&lt;number&gt; = [1,2,3,5];\\nlet that = new A();\\nthat.getElementByIndex(buffer,-1);\\nthat.getElementByIndex(buffer,5);\\nthat.getElementByIndex(123 as Object as Array&lt;number&gt; ,5)</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 386,
        "pre": "// somePackage.ets\\nexport class Test {\\n  foo(){}\\n}\\n\\n// index.ets\\nimport {Test} from './somePackage';\\nimport {util} from '@kit.ArkTS';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\nutil.TextDecoder.toString();\\n// 调用次数自增\\nlet countFoo = 0;\\nutil.Aspect.addBefore(Test, 'foo', false, () => {\\n  countFoo++;\\n});\\n// 调用并打印日志\\nnew Test().foo();\\nconsole.log('countFoo = ', countFoo);\\n// [LOG]: \\\"countFoo = \\\", 1\\nlet a = new Test();\\na.foo()\\nconsole.log('countFoo = ', countFoo);\\n// [LOG]: \\\"countFoo = \\\", 2\\nfunction bar(a: Test) {\\n  a.foo();\\n  console.log('countFoo = ', countFoo);\\n  new Test().foo();\\n  console.log('countFoo = ', countFoo);\\n}\\nbar(a);\\n// [LOG]: \\\"countFoo = \\\", 3\\n// [LOG]: \\\"countFoo = \\\", 4\\nconsole.log('countFoo = ', countFoo);\\n// [LOG]: \\\"countFoo = \\\", 4",
        "type": "Reference",
        "function_call": "test()",
        "function_name": "[h2]代码实现",
        "parent_text": "[h2]代码实现统计执行次数，具体代码实现如下：  统计执行时间，具体代码实现如下： // somePackage.ets\\nexport class Test {\\n  doSomething() { // 实例方法\\n    // ...\\n  }\\n  static test() { // 静态方法\\n    // ...\\n  }\\n}\\n\\n// index.ets\\nimport {Test} from './somePackage'\\nimport {util} from '@kit.ArkTS';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\n// 插入执行前后打印时间, 将插入动作封装成一个接口\\nfunction addTimePrinter(targetClass: Object, methodName: string, isStatic: boolean) {\\n  let t1 = 0;\\n  let t2 = 0;\\n  util.Aspect.addBefore(targetClass, methodName, isStatic, () => {\\n    t1 = new Date().getTime();\\n  });\\n  util.Aspect.addAfter(targetClass, methodName, isStatic, () => {\\n    t2 = new Date().getTime();\\n    console.log(\\\"t2---t1 = \\\" + (t2 - t1).toString());\\n  });\\n}\\n// 给Test的doSomething实例方法添加打印执行时间的逻辑\\naddTimePrinter(Test, 'doSomething', false);\\nnew Test().doSomething()\\n// 给Test的test静态方法添加打印执行时间的逻辑\\naddTimePrinter(Test, 'test', true);\\nTest.test()  不推荐用该方式来统计在多个线程执行的函数，否则可能造成方法次数变量或者执行时间变量的写冲突。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section9492163084816\\\"'><a name='\\\"section9492163084816\\\"'></a><a name='\\\"section9492163084816\\\"'></a><h4>[h2]代码实现</h4><p>统计执行次数，具体代码实现如下：</p>  <p>统计执行时间，具体代码实现如下：</p> <pre class='\\\"screen\\\"'>// somePackage.ets\\nexport class Test {\\n  doSomething() { // 实例方法\\n    // ...\\n  }\\n  static test() { // 静态方法\\n    // ...\\n  }\\n}\\n\\n// index.ets\\nimport {Test} from './somePackage'\\nimport {util} from '@kit.ArkTS';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\n// 插入执行前后打印时间, 将插入动作封装成一个接口\\nfunction addTimePrinter(targetClass: Object, methodName: string, isStatic: boolean) {\\n  let t1 = 0;\\n  let t2 = 0;\\n  util.Aspect.addBefore(targetClass, methodName, isStatic, () =&gt; {\\n    t1 = new Date().getTime();\\n  });\\n  util.Aspect.addAfter(targetClass, methodName, isStatic, () =&gt; {\\n    t2 = new Date().getTime();\\n    console.log(\\\"t2---t1 = \\\" + (t2 - t1).toString());\\n  });\\n}\\n// 给Test的doSomething实例方法添加打印执行时间的逻辑\\naddTimePrinter(Test, 'doSomething', false);\\nnew Test().doSomething()\\n// 给Test的test静态方法添加打印执行时间的逻辑\\naddTimePrinter(Test, 'test', true);\\nTest.test()</pre> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161053.41633607433661782444945000445606:50001231000000:2800:DFF73FF7E3CD713BE15C3E13F1B76FB0DD347A5456DAEF0F096A27E7C8E8DFF2.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>不推荐用该方式来统计在多个线程执行的函数，否则可能造成方法次数变量或者执行时间变量的写冲突。</p> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 387,
        "pre": "// someThirdParty.ets\\nexport class WebHandler {\\n  getWebAddrHttps(): string {\\n    let ret = 'http';\\n    // ...\\n    return ret;\\n  }\\n}\\n\\n// index.ets\\nimport {WebHandler} from './someThirdParty';\\nimport {util} from '@kit.ArkTS';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\nutil.Aspect.addAfter(WebHandler, 'getWebAddrHttps', false, (instance: WebHandler, ret: string) => {\\n  if (!ret.startsWith('https')) {\\n    throw Error('Handler\\\\'s method \\\\'getWebAddrHttps\\\\': return value does not start with \\\\'https\\\\'');\\n  }\\n  // 校验没问题，记得将原方法返回值返回\\n  return ret;\\n});\\nnew WebHandler().getWebAddrHttps();",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]代码实现",
        "parent_text": "[h2]代码实现对三方库方法返回的网址进行校验，校验不通过的抛出异常，具体实现代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1984193711583\\\"'><a name='\\\"section1984193711583\\\"'></a><a name='\\\"section1984193711583\\\"'></a><h4>[h2]代码实现</h4><p>对三方库方法返回的网址进行校验，校验不通过的抛出异常，具体实现代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 388,
        "pre": "// somePackage.ets\\nexport class Person {\\n  name: string;\\n  age: number;\\n  constructor(n: string, a: number) {\\n    this.name = n;\\n    this.age = a;\\n  }\\n  getInfo(): string {\\n    return 'name: ' + this.name + ', ' + 'age: ' + this.age.toString();\\n  }\\n}\\n\\n// index.ets\\nimport {Person} from './somePackage';\\nimport {util} from '@kit.ArkTS';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\n// 校验name成员和age成员\\nutil.Aspect.addBefore(Person, 'getInfo', false, (instance: Person) => {\\n  if (instance.name.length == 0) {\\n    throw Error('empty name');\\n  }\\n  if (instance.age < 0) {\\n    throw Error('invalid age');\\n  }\\n});\\nnew Person('c', -1).getInfo();",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]代码实现",
        "parent_text": "[h2]代码实现在getInfo方法中校验Person类的name和age属性是否正常，具体实现代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section142542422019\\\"'><a name='\\\"section142542422019\\\"'></a><a name='\\\"section142542422019\\\"'></a><h4>[h2]代码实现</h4><p>在getInfo方法中校验Person类的name和age属性是否正常，具体实现代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 389,
        "pre": "// somePackage\\nexport class Test {\\n  foo(arg: string) {\\n    console.log(arg);\\n  }\\n}\\n\\n// index.ets\\nimport {Test} from './somePackage';\\nimport {util} from '@kit.ArkTS';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\nnew Test().foo('123');\\n// [LOG]: \\\"123\\\"\\n// 替换原方法\\nutil.Aspect.replace(Test, 'foo', false, (instance: Test, arg: string) => {\\n  console.log(arg + ' __replaced implementation');\\n});\\nnew Test().foo('123');\\n// [LOG]: \\\"123 __replaced implementation\\\"",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]代码实现",
        "parent_text": "[h2]代码实现修改Test类的foo方法中的打印日志，具体实现代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section121021481222\\\"'><a name='\\\"section121021481222\\\"'></a><a name='\\\"section121021481222\\\"'></a><h4>[h2]代码实现</h4><p>修改Test类的foo方法中的打印日志，具体实现代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 390,
        "pre": "// base.ets\\nexport class Base {\\n  foo() {\\n    console.log('hello');\\n  }\\n}\\n\\n // child1\\nimport {Base} from './base';\\nexport class Child1 extends Base {}\\n\\n// child2\\nimport {Base} from './base';\\nexport class Child2 extends Base {}\\n\\n// index.ets\\nimport {util} from '@kit.ArkTS';\\nimport {Child1} from './child1';\\nimport {Child2} from './child2';\\nimport {Base} from './base';\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\n// 修改Child1的foo的实现\\nutil.Aspect.replace(Child1, 'foo', false, () => {\\n  console.log('changed Child1 foo');\\n});\\nnew Base().foo();\\n// [LOG]: \\\"hello\\\"\\nnew Child1().foo();\\n// [LOG]: \\\"changed Child1 foo\\\"\\nnew Child2().foo();\\n// [LOG]: \\\"hello\\\"",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]案例一：替换子类一方法实现",
        "parent_text": "[h2]案例一：替换子类一方法实现Base有两个子类Child1和Child2，两个子类都继承了foo方法。需要修改Child1的foo的实现，但不影响Base和Child2的foo方法。具体实现代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section684214016314\\\"'><a name='\\\"section684214016314\\\"'></a><a name='\\\"section684214016314\\\"'></a><h4>[h2]案例一：替换子类一方法实现</h4><p>Base有两个子类Child1和Child2，两个子类都继承了foo方法。需要修改Child1的foo的实现，但不影响Base和Child2的foo方法。具体实现代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 391,
        "pre": "// base.ets\\nimport {geoLocationManager} from \\\"@kit.LocationKit\\\";\\nexport class Base {\\n  getCurrentLocation() {\\n    return geoLocationManager.getCurrentLocation();\\n  }\\n}\\n\\n// child.ets\\nimport {Base} from \\\"./base\\\";\\nexport class Child extends Base {\\n  // 继承父类的getCurrentLocation方法\\n}\\n\\n// index.ets\\nimport {Child} from './child';\\nimport {util} from '@kit.ArkTS';\\nimport {geoLocationManager} from \\\"@kit.LocationKit\\\";\\n@Entry\\n@Component\\nstruct Index {\\n  build() {\\n    // UI代码\\n    …\\n  }\\n}\\nlet cached_location: Object | undefined;\\nlet time: number | undefined;\\nutil.Aspect.replace(Child, 'getCurrentLocation', false, () => {\\n  let newTime = new Date().getTime();\\n  // 一分钟最多调用一次实时位置\\n  if (!cached_location || !time || newTime - time > 60000) {\\n    time = newTime;\\n    cached_location = geoLocationManager.getCurrentLocation();\\n  }\\n  // 返回缓存的位置信息\\n  return cached_location;\\n});\\nnew Child().getCurrentLocation()",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]案例二：获取实时位置信息",
        "parent_text": "[h2]案例二：获取实时位置信息原Child继承Base的获取实时位置方法，但测试发现Child的getCurrentLocation方法在实际场景调用非常频繁，需要控制调用频率，采取的措施是想修改Child的getCurrentLocation方法的实现，通过将位置信息缓存起来，下次调用的时候如果距离上次调用时间少于一分钟，则直接返回缓存的位置；否则才允许调用位置接口。具体实现代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section665210312461\\\"'><a name='\\\"section665210312461\\\"'></a><a name='\\\"section665210312461\\\"'></a><h4>[h2]案例二：获取实时位置信息</h4><p>原Child继承Base的获取实时位置方法，但测试发现Child的getCurrentLocation方法在实际场景调用非常频繁，需要控制调用频率，采取的措施是想修改Child的getCurrentLocation方法的实现，通过将位置信息缓存起来，下次调用的时候如果距离上次调用时间少于一分钟，则直接返回缓存的位置；否则才允许调用位置接口。具体实现代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 392,
        "pre": "// EntryAbility.ets\\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\nimport { util } from '@kit.ArkTS';\\n// 获取目标包名\\nexport default class EntryAbility extends UIAbility {\\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\\n    hilog.info(0x0000, 'testTag', '%{public}s', ' onCreate');\\n    util.Aspect.addBefore(this.context.constructor, 'startAbility', false,\\n      (instance: Object, wantParam: Want) => {\\n        console.info('UIAbilityContext startAbility: want.bundleName is ' + wantParam.bundleName);\\n      });\\n    this.context.startAbility(want, () => {})\\n  }\\n  // 其他相关配置\\n  …\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]代码实现",
        "parent_text": "[h2]代码实现通过类实例的constructor属性获取类对象，具体实现代码如下：  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section677815194915\\\"'><a name='\\\"section677815194915\\\"'></a><a name='\\\"section677815194915\\\"'></a><h4>[h2]代码实现</h4><p>通过类实例的constructor属性获取类对象，具体实现代码如下：</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 393,
        "pre": "class Test {\\n  foo() {}\\n}\\nutil.Aspect.addBefore(Test, 'foo', false, (instance: Test) => {\\n  instance.foo();\\n});\\n// 无限递归\\nnew Test().foo();",
        "type": "Reference",
        "function_call": "则可以直接调用原方法originalFoo()",
        "function_name": null,
        "parent_text": "接口的第四个参数是回调函数，回调函数中第一个参数是执行方法调用的this对象。如果通过这个调用原方法，并且没有退出机制，容易造成无限递归调用。如果需要调用原方法，需要在接口调用前将原方法存储起来。不推荐的用法参考如下示例。 如果确实有需要调用原方法的场景，实现方法参考如下示例。 class Test {\\n  foo() {}\\n}\\n// 将原方法实现先保存起来\\nlet originalFoo = new Test().foo;\\nutil.Aspect.addBefore(Test, 'foo', false, (instance: Test) => {\\n  // 如果原方法没有使用this，则可以直接调用原方法originalFoo();\\n  // 如果原方法中使用了this，应该使用bind绑定instance，但是会有编译warningoriginalFoo.bind(instance);\\n}); ",
        "import_module": null,
        "parent": "<li>接口的第四个参数是回调函数，回调函数中第一个参数是执行方法调用的this对象。如果通过这个调用原方法，并且没有退出机制，容易造成无限递归调用。如果需要调用原方法，需要在接口调用前将原方法存储起来。不推荐的用法参考如下示例。 <p>如果确实有需要调用原方法的场景，实现方法参考如下示例。</p> <pre class='\\\"screen\\\"'>class Test {\\n  foo() {}\\n}\\n// 将原方法实现先保存起来\\nlet originalFoo = new Test().foo;\\nutil.Aspect.addBefore(Test, 'foo', false, (instance: Test) =&gt; {\\n  // 如果原方法没有使用this，则可以直接调用原方法originalFoo();\\n  // 如果原方法中使用了this，应该使用bind绑定instance，但是会有编译warningoriginalFoo.bind(instance);\\n});</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-application-aspect-programming-design.html"
    },
    {
        "id": 394,
        "pre": "import { BuilderNode, FrameNode, NodeController, NodeRenderType } from '@kit.ArkUI';\\nimport { webview } from '@kit.ArkWeb';\\nimport { PRODUCT_DATA } from '../viewmodel/GoodsViewModel';\\nimport { ProductDataModel } from '../model/GoodsModel';\\n\\nconst MARGIN_VERTICAL: number = 8;\\nconst FONT_WEIGHT: number = 500;\\nconst PLACEHOLDER: ResourceStr = $r('app.string.embed_search');\\n\\ndeclare class Params {\\n  width: number;\\n  height: number;\\n}\\n\\ndeclare class NodeControllerParams {\\n  surfaceId: string;\\n  type: string;\\n  renderType: NodeRenderType;\\n  embedId: string;\\n  width: number;\\n  height: number;\\n}\\n\\nclass SearchNodeController extends NodeController {\\n  private rootNode: BuilderNode<[Params]> | undefined | null = null;\\n  private embedId: string = '';\\n  private surfaceId: string = '';\\n  private renderType: NodeRenderType = NodeRenderType.RENDER_TYPE_DISPLAY;\\n  private componentWidth: number = 0;\\n  private componentHeight: number = 0;\\n  private componentType: string = '';\\n\\n  setRenderOption(params: NodeControllerParams): void {\\n    this.surfaceId = params.surfaceId;\\n    this.renderType = params.renderType;\\n    this.embedId = params.embedId;\\n    this.componentWidth = params.width;\\n    this.componentHeight = params.height;\\n    this.componentType = params.type;\\n  }\\n\\n  makeNode(uiContext: UIContext): FrameNode | null {\\n    this.rootNode = new BuilderNode(uiContext, { surfaceId: this.surfaceId, type: this.renderType });\\n    if (this.componentType === 'native/component') {\\n      this.rootNode.build(wrapBuilder(searchBuilder), { width: this.componentWidth, height: this.componentHeight });\\n    }\\n    return this.rootNode.getFrameNode();\\n  }\\n\\n  setBuilderNode(rootNode: BuilderNode<Params[]> | null): void {\\n    this.rootNode = rootNode;\\n  }\\n\\n  getBuilderNode(): BuilderNode<[Params]> | undefined | null {\\n    return this.rootNode;\\n  }\\n\\n  updateNode(arg: Object): void {\\n    this.rootNode?.update(arg);\\n  }\\n\\n  getEmbedId(): string {\\n    return this.embedId;\\n  }\\n\\n  postEvent(event: TouchEvent | undefined): boolean {\\n    return this.rootNode?.postTouchEvent(event) as boolean;\\n  }\\n}\\n\\n@Component\\nstruct SearchComponent {\\n  @Prop params: Params;\\n  controller: SearchController = new SearchController();\\n\\n  build() {\\n    Column({ space: MARGIN_VERTICAL }) {\\n      Text($r(\\\"app.string.embed_mall\\\"))\\n        .fontSize($r('app.string.ohos_id_text_size_body4'))\\n        .fontWeight(FONT_WEIGHT)\\n        .fontFamily('HarmonyHeiTi-Medium')\\n      Row() {\\n        Search({ placeholder: PLACEHOLDER, controller: this.controller })\\n          .backgroundColor(Color.White)\\n      }\\n      .width($r(\\\"app.string.embed_full_percent\\\"))\\n      .margin($r(\\\"app.integer.embed_row_margin\\\"))\\n\\n      Grid() {\\n        ForEach(PRODUCT_DATA, (item: ProductDataModel, index: number) => {\\n          GridItem() {\\n            Column({ space: MARGIN_VERTICAL }) {\\n              Image(item.uri).width($r(\\\"app.integer.embed_image_size\\\"))\\n              Row({ space: MARGIN_VERTICAL }) {\\n                Text(item.title)\\n                  .fontSize($r('app.string.ohos_id_text_size_body1'))\\n                  .width(100)\\n                  .maxLines(1)\\n                  .textOverflow({ overflow: TextOverflow.Ellipsis })\\n                Text(item.price)\\n                  .fontSize($r('app.string.ohos_id_text_size_body1'))\\n                  .width(50)\\n                  .maxLines(1)\\n              }\\n            }\\n            .backgroundColor($r('app.color.ohos_id_color_background'))\\n            .alignItems(HorizontalAlign.Center)\\n            .justifyContent(FlexAlign.Center)\\n            .width($r(\\\"app.string.embed_full_percent\\\"))\\n            .height($r(\\\"app.string.embed_full_percent\\\"))\\n            .borderRadius($r('app.string.ohos_id_corner_radius_default_m'))\\n          }\\n        }, (item: ProductDataModel, index: number) => index.toString())\\n      }\\n      .columnsTemplate('1fr 1fr')\\n      .rowsTemplate('1fr 1fr 1fr')\\n      .rowsGap($r('app.string.ohos_id_elements_margin_vertical_m'))\\n      .columnsGap($r('app.string.ohos_id_elements_margin_vertical_m'))\\n      .width($r(\\\"app.string.embed_full_percent\\\"))\\n      .height($r(\\\"app.string.embed_sixty_percent\\\"))\\n      .backgroundColor($r('app.color.ohos_id_color_sub_background'))\\n    }\\n    .padding($r('app.string.ohos_id_card_margin_start'))\\n    .width(this.params.width)\\n    .height(this.params.height)\\n  }\\n}\\n\\n@Builder\\nfunction searchBuilder(params: Params) {\\n  SearchComponent({ params: params })\\n    .backgroundColor($r('app.color.ohos_id_color_sub_background'))\\n}\\n\\n@Entry\\n@Component\\nstruct Index {\\n  browserTabController: WebviewController = new webview.WebviewController();\\n  @State componentIdArr: Array<string> = [];\\n  private nodeControllerMap: Map<string, SearchNodeController> = new Map();\\n\\n  build() {\\n    Stack() {\\n      ForEach(this.componentIdArr, (componentId: string) => {\\n        NodeContainer(this.nodeControllerMap.get(componentId));\\n      }, (embedId: string) => embedId)\\n      Web({ src: $rawfile('embed_view.html'), controller: this.browserTabController })\\n        .backgroundColor($r('app.color.ohos_id_color_sub_background'))\\n        .zoomAccess(false)\\n        .enableNativeEmbedMode(true)\\n        .onNativeEmbedLifecycleChange((embed) => {\\n          const componentId = embed.info?.id?.toString() as string\\n          if (embed.status === NativeEmbedStatus.CREATE) {\\n            let nodeController = new SearchNodeController();\\n            nodeController.setRenderOption({\\n              surfaceId: embed.surfaceId as string,\\n              type: embed.info?.type as string,\\n              renderType: NodeRenderType.RENDER_TYPE_TEXTURE,\\n              embedId: embed.embedId as string,\\n              width: px2vp(embed.info?.width),\\n              height: px2vp(embed.info?.height)\\n            });\\n            nodeController.rebuild();\\n            this.nodeControllerMap.set(componentId, nodeController);\\n            this.componentIdArr.push(componentId);\\n          } else if (embed.status === NativeEmbedStatus.UPDATE) {\\n            let nodeController = this.nodeControllerMap.get(componentId);\\n            nodeController?.updateNode({\\n              text: 'update',\\n              width: px2vp(embed.info?.width),\\n              height: px2vp(embed.info?.height)\\n            } as ESObject);\\n            nodeController?.rebuild();\\n          } else {\\n            let nodeController = this.nodeControllerMap.get(componentId);\\n            nodeController?.setBuilderNode(null);\\n            nodeController?.rebuild();\\n          }\\n        })\\n        .onNativeEmbedGestureEvent((touch) => {\\n          this.componentIdArr.forEach((componentId: string) => {\\n            let nodeController = this.nodeControllerMap.get(componentId);\\n            if (nodeController?.getEmbedId() === touch.embedId) {\\n              nodeController?.postEvent(touch.touchEvent);\\n            }\\n          })\\n        })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]使用同层渲染",
        "parent_text": "[h2]使用同层渲染同层渲染简单来说就是，底层使用空白的H5页面，用Embed标签进行占位，ArkTS使用NodeContainer来占位，最后将Web侧的surfaceId和原生组件绑定，渲染在NodeContainer上。这里给出一些大致步骤： 用Stack组件层叠NodeContainer和Web组件，并开启enableNativeEmbedMode模式。因为要使用NodeContainer，所以封装一个继承自NodeController的类SearchNodeController。使用Web组件加载nativeembed_view.html文件，Web组件解析到Embed标签后，通过onNativeEmbedLifecycleChange接口上报Embed标签创建消息通知到应用侧。在步骤3的回调内，根据embed.status，将配置传入searchNodeController后，执行rebuild方法重新触发其makeNode方法。makeNode方法触发后，NodeContainer组件获取到BuilderNode对象，页面出现原生组件。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1025022152117\\\"'><a name='\\\"section1025022152117\\\"'></a><a name='\\\"section1025022152117\\\"'></a><h4>[h2]使用同层渲染</h4><p>同层渲染简单来说就是，底层使用空白的H5页面，用Embed标签进行占位，ArkTS使用NodeContainer来占位，最后将Web侧的surfaceId和原生组件绑定，渲染在NodeContainer上。这里给出一些大致步骤：</p> <ol><li>用Stack组件层叠NodeContainer和Web组件，并开启enableNativeEmbedMode模式。</li><li>因为要使用NodeContainer，所以封装一个继承自NodeController的类SearchNodeController。</li><li>使用Web组件加载nativeembed_view.html文件，Web组件解析到Embed标签后，通过onNativeEmbedLifecycleChange接口上报Embed标签创建消息通知到应用侧。</li><li>在步骤3的回调内，根据embed.status，将配置传入searchNodeController后，执行rebuild方法重新触发其makeNode方法。</li><li>makeNode方法触发后，NodeContainer组件获取到BuilderNode对象，页面出现原生组件。</li></ol>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-render-web-using-same-layer-render.html"
    },
    {
        "id": 395,
        "pre": "{\\n  \\\"src\\\": [\\n    \\\"pages/Index\\\",\\n    \\\"pages/GoHouse\\\",\\n    \\\"pages/GoCompany\\\"\\n  ]\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "创建页面并配置页面的路由信息。首先需要创建对应的快捷方式页面，且页面组件需要用@Entry装饰。然后在resources/base/profile下的main_pages.json文件中添加对应快捷方式页面的路由信息。 ",
        "import_module": null,
        "parent": "<li>创建页面并配置页面的路由信息。首先需要创建对应的快捷方式页面，且页面组件需要用@Entry装饰。然后在resources/base/profile下的main_pages.json文件中添加对应快捷方式页面的路由信息。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-desktop-shortcuts.html"
    },
    {
        "id": 396,
        "pre": "import { common } from '@kit.AbilityKit';\\nimport { fileIo } from '@kit.CoreFileKit'\\nimport { zlib } from '@kit.BasicServicesKit';",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "导入相关模块： ",
        "import_module": null,
        "parent": "<li>导入相关模块： </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-file-upload-and-download-performance.html"
    },
    {
        "id": 397,
        "pre": "import { common } from '@kit.AbilityKit';\\nimport { request } from '@kit.BasicServicesKit';",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "导入相关模块： ",
        "import_module": null,
        "parent": "<li>导入相关模块： </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-file-upload-and-download-performance.html"
    },
    {
        "id": 398,
        "pre": "let config: request.agent.Config = {\\n  action: request.agent.Action.DOWNLOAD, // 配置任务选项，这里配置为下载任务\\n  url: downloadUrl, // 配置下载任务url\\n  overwrite: true, // 下载过程中路径已存在时的解决方案选择。true表示覆盖已存在的文件\\n  method: 'GET', // HTTP标准方法。下载时，使用GET或POST。\\n  saveas: './', // 这里'./'表示下载至应用当前缓存路径下。\\n  mode: request.agent.Mode.BACKGROUND, // 任务模式设置后台任务。\\n  gauge: true // 后台任务的过程进度通知策略，仅应用于后台任务。true表示发出每个进度已完成或失败的通知。\\n};",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "配置下载参数。一个下载任务需要对应配置一套下载参数request.agent.Config。本例中使用downloadConfig方法简单配置了下载文件的url，实际业务中按需调整配置。 ",
        "import_module": null,
        "parent": "<li>配置下载参数。一个下载任务需要对应配置一套下载参数request.agent.Config。本例中使用downloadConfig方法简单配置了下载文件的url，实际业务中按需调整配置。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-file-upload-and-download-performance.html"
    },
    {
        "id": 399,
        "pre": "import { BusinessError } from '@kit.BasicServicesKit';\\nimport { ComponentContent, promptAction } from '@kit.ArkUI';\\nimport { UIContext } from '@ohos.arkui.UIContext';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\n\\nexport class PromptActionClass {\\n  static ctx: UIContext;\\n  static contentNode: ComponentContent<Object>;\\n  static options: promptAction.BaseDialogOptions;\\n\\n  static setContext(context: UIContext) {\\n    PromptActionClass.ctx = context;\\n  }\\n\\n  static setContentNode(node: ComponentContent<Object>) {\\n    PromptActionClass.contentNode = node;\\n  }\\n\\n  static setOptions(options: promptAction.BaseDialogOptions) {\\n    PromptActionClass.options = options;\\n  }\\n\\n  static openDialog() {\\n    if (PromptActionClass.contentNode !== null) {\\n      PromptActionClass.ctx.getPromptAction()\\n        .openCustomDialog(PromptActionClass.contentNode, PromptActionClass.options)\\n        .then(() => {\\n          hilog.info(0x0000, 'testTag', 'OpenCustomDialog complete.');\\n        })\\n        .catch((error: BusinessError) => {\\n          let message = (error as BusinessError).message;\\n          let code = (error as BusinessError).code;\\n          hilog.error(0x0000, 'testTag', `OpenCustomDialog args error code is ${code}, message is ${message}`);\\n        })\\n    }\\n  }\\n\\n  static closeDialog() {\\n    if (PromptActionClass.contentNode !== null) {\\n      PromptActionClass.ctx.getPromptAction()\\n        .closeCustomDialog(PromptActionClass.contentNode)\\n        .then(() => {\\n          hilog.info(0x0000, 'testTag', 'CloseCustomDialog complete.');\\n        })\\n        .catch((error: BusinessError) => {\\n          let message = (error as BusinessError).message;\\n          let code = (error as BusinessError).code;\\n          hilog.error(0x0000, 'testTag', `CloseCustomDialog args error code is ${code}, message is ${message}`);\\n        })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "关闭方法closeDialog()",
        "function_name": null,
        "parent_text": "封装自定义弹窗类PromptActionClass，自定义弹窗的打开方法openDialog()、关闭方法closeDialog()。 ",
        "import_module": null,
        "parent": "<li>封装自定义弹窗类PromptActionClass，自定义弹窗的打开方法openDialog()、关闭方法closeDialog()。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custome-dialog-development-practice.html"
    },
    {
        "id": 400,
        "pre": "import { PromptAction } from '@kit.ArkUI';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\n\\n@Component\\nexport struct InterceptReturn01 {\\n  private context: UIContext = this.getUIContext();\\n  private promptAction: PromptAction = this.getUIContext().getPromptAction();\\n  private customDialogComponentId: number = 0;\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  @Builder\\n  customDialogComponent() {\\n    Column() {\\n      Row() {\\n        Text('Title')\\n          .fontSize(20)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n      .width('100%')\\n      .height(56)\\n      .justifyContent(FlexAlign.Center)\\n\\n      Text('This is a dialog content.')\\n        .fontSize(14)\\n\\n      Button('CONFIRM')\\n        .fontSize(16)\\n        .fontColor('#0A59F7')\\n        .backgroundColor(Color.White)\\n        .onClick(() => {\\n          this.context.getPromptAction().closeCustomDialog(this.customDialogComponentId);\\n        })\\n        .width('100%')\\n        .margin({\\n          top: 8,\\n          bottom: 16\\n        })\\n    }\\n    .padding({\\n      left: 24,\\n      right: 24\\n    })\\n    .justifyContent(FlexAlign.Center)\\n    .alignItems(HorizontalAlign.Center)\\n    .backgroundColor(Color.White)\\n    .borderRadius(32)\\n    .margin({\\n      left: 16,\\n      right: 16\\n    })\\n  }\\n\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Row() {\\n          Button('OPEN')\\n            .fontSize(16)\\n            .width('100%')\\n            .borderRadius(20)\\n            .margin({ bottom: 16 })\\n            .backgroundColor('#0A59F7')\\n            .onClick(() => {\\n              this.promptAction.openCustomDialog({\\n                builder: () => {\\n                  this.customDialogComponent()\\n                },\\n                alignment: DialogAlignment.Center,\\n                maskColor: 'rgba(0, 0, 0, 0.2)',\\n                onWillDismiss: (dismissDialogAction: DismissDialogAction) => {\\n                  hilog.info(0xFF00, 'testTag', JSON.stringify(dismissDialogAction.reason));\\n                }\\n              }).then((dialogId: number) => {\\n                this.customDialogComponentId = dialogId\\n              })\\n            })\\n        }\\n        .width('100%')\\n        .alignItems(VerticalAlign.Center)\\n      }\\n      .width('100%')\\n      .height('100%')\\n      .padding({\\n        left: 16,\\n        right: 16\\n      })\\n      .justifyContent(FlexAlign.End)\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "pop()",
        "function_name": "[h2]拦截物理返回按钮、手势滑动关闭弹窗",
        "parent_text": "[h2]拦截物理返回按钮、手势滑动关闭弹窗用户只能通过按钮关闭弹窗，不允许使用物理返回按钮、手势滑动关闭弹窗。 典型场景 密码输入框，输入密码之前不允许关闭弹窗展示隐私协议弹窗时，用户必须点击同意才能继续使用应用 实现思路 方式一 基于UIContext.getPromptAction弹窗，使用弹窗的选项对象中的onWillDismiss交互式关闭回调函数，支持物理拦截返回。当用户执行点击遮障层关闭、左滑/右滑、三键back、键盘ESC关闭交互操作时，如果注册该回调函数，则不会立刻关闭弹窗。在回调函数中可以通过DismissReason得到关闭弹窗的操作类型，从而根据原因选择是否能关闭弹窗。 示例代码   效果演示   方式二 可以基于Navigation自定义弹窗实现，使用NavDestination的回调函数onBackPressed，当与Navigation绑定的页面栈中存在内容时，此回调生效。当点击物理返回按钮或使用手势滑动时，触发该回调。返回值为true时，表示重写返回键逻辑，即可实现拦截。 示例代码 @Component\\nexport struct InterceptReturn02 {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Row() {\\n          Button('OPEN')\\n            .fontSize(16)\\n            .width('100%')\\n            .borderRadius(20)\\n            .margin({ bottom: 16 })\\n            .backgroundColor('#0A59F7')\\n            .onClick(() => {\\n              this.pageStack.pushPathByName('DialogPage1', '');\\n            })\\n        }\\n        .width('100%')\\n        .alignItems(VerticalAlign.Center)\\n      }\\n      .width('100%')\\n      .height('100%')\\n      .padding({\\n        left: 16,\\n        right: 16\\n      })\\n      .justifyContent(FlexAlign.End)\\n    }\\n  }\\n}\\n\\n@Component\\nexport struct DialogPage1 {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  build() {\\n    NavDestination() {\\n      Stack({ alignContent: Alignment.Center }) {\\n        Column() {\\n          Row() {\\n            Text('Title')\\n              .fontSize(20)\\n              .fontWeight(FontWeight.Bold)\\n          }\\n          .width('100%')\\n          .height(56)\\n          .justifyContent(FlexAlign.Center)\\n\\n          Text('This is a dialog content.')\\n            .fontSize(14)\\n\\n          Button('CONFIRM')\\n            .fontSize(16)\\n            .fontColor('#0A59F7')\\n            .backgroundColor(Color.White)\\n            .onClick(() => {\\n              this.pageStack.pop();\\n            })\\n            .width('100%')\\n            .margin({\\n              top: 8,\\n              bottom: 16\\n            })\\n        }\\n        .padding({\\n          left: 24,\\n          right: 24\\n        })\\n        .justifyContent(FlexAlign.Center)\\n        .alignItems(HorizontalAlign.Center)\\n        .backgroundColor(Color.White)\\n        .borderRadius(32)\\n        .margin({\\n          left: 16,\\n          right: 16\\n        })\\n      }\\n      .height('100%')\\n      .width('100%')\\n    }\\n    .backgroundColor('rgba(0, 0, 0, 0.2)')\\n    .hideTitleBar(true)\\n    .mode(NavDestinationMode.DIALOG)\\n    .onBackPressed((): boolean => {\\n      return true;\\n    })\\n    .borderColor(Color.White)\\n  }\\n}  效果演示   ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section111721345172917\\\"'><a name='\\\"section111721345172917\\\"'></a><a name='\\\"section111721345172917\\\"'></a><h4>[h2]拦截物理返回按钮、手势滑动关闭弹窗</h4><p>用户只能通过按钮关闭弹窗，不允许使用物理返回按钮、手势滑动关闭弹窗。</p> <p><strong>典型场景</strong></p> <ul><li>密码输入框，输入密码之前不允许关闭弹窗</li><li>展示隐私协议弹窗时，用户必须点击同意才能继续使用应用</li></ul> <p><strong>实现思路</strong></p> <p>方式一 基于UIContext.getPromptAction弹窗，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11\\\"' target='\\\"_blank\\\"'>弹窗的选项</a>对象中的onWillDismiss交互式关闭回调函数，支持物理拦截返回。当用户执行点击遮障层关闭、左滑/右滑、三键back、键盘ESC关闭交互操作时，如果注册该回调函数，则不会立刻关闭弹窗。在回调函数中可以通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#dismissreason12枚举说明\\\"' target='\\\"_blank\\\"'>DismissReason</a>得到关闭弹窗的操作类型，从而根据原因选择是否能关闭弹窗。</p> <p><strong>示例代码</strong></p>  <p></p> <p><strong>效果演示</strong></p> <p></p> <p><span><img height='\\\"545.5261\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161122.58109345032997414555372339294434:50001231000000:2800:0F73725F691FBB21DB57E5731D9BB87D45F634F1A898E155903DCF1AE9514F07.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> <p>方式二 可以基于Navigation自定义弹窗实现，使用NavDestination的回调函数<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination#onbackpressed10\\\"' target='\\\"_blank\\\"'>onBackPressed</a>，当与Navigation绑定的页面栈中存在内容时，此回调生效。当点击物理返回按钮或使用手势滑动时，触发该回调。返回值为true时，表示重写返回键逻辑，即可实现拦截。</p> <p><strong>示例代码</strong></p> <pre class='\\\"screen\\\"'>@Component\\nexport struct InterceptReturn02 {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Row() {\\n          Button('OPEN')\\n            .fontSize(16)\\n            .width('100%')\\n            .borderRadius(20)\\n            .margin({ bottom: 16 })\\n            .backgroundColor('#0A59F7')\\n            .onClick(() =&gt; {\\n              this.pageStack.pushPathByName('DialogPage1', '');\\n            })\\n        }\\n        .width('100%')\\n        .alignItems(VerticalAlign.Center)\\n      }\\n      .width('100%')\\n      .height('100%')\\n      .padding({\\n        left: 16,\\n        right: 16\\n      })\\n      .justifyContent(FlexAlign.End)\\n    }\\n  }\\n}\\n\\n@Component\\nexport struct DialogPage1 {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  build() {\\n    NavDestination() {\\n      Stack({ alignContent: Alignment.Center }) {\\n        Column() {\\n          Row() {\\n            Text('Title')\\n              .fontSize(20)\\n              .fontWeight(FontWeight.Bold)\\n          }\\n          .width('100%')\\n          .height(56)\\n          .justifyContent(FlexAlign.Center)\\n\\n          Text('This is a dialog content.')\\n            .fontSize(14)\\n\\n          Button('CONFIRM')\\n            .fontSize(16)\\n            .fontColor('#0A59F7')\\n            .backgroundColor(Color.White)\\n            .onClick(() =&gt; {\\n              this.pageStack.pop();\\n            })\\n            .width('100%')\\n            .margin({\\n              top: 8,\\n              bottom: 16\\n            })\\n        }\\n        .padding({\\n          left: 24,\\n          right: 24\\n        })\\n        .justifyContent(FlexAlign.Center)\\n        .alignItems(HorizontalAlign.Center)\\n        .backgroundColor(Color.White)\\n        .borderRadius(32)\\n        .margin({\\n          left: 16,\\n          right: 16\\n        })\\n      }\\n      .height('100%')\\n      .width('100%')\\n    }\\n    .backgroundColor('rgba(0, 0, 0, 0.2)')\\n    .hideTitleBar(true)\\n    .mode(NavDestinationMode.DIALOG)\\n    .onBackPressed((): boolean =&gt; {\\n      return true;\\n    })\\n    .borderColor(Color.White)\\n  }\\n}</pre> <p></p> <p><strong>效果演示</strong></p> <p></p> <p><span><img height='\\\"545.5261\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161122.25119091089155766731316543363569:50001231000000:2800:6759015695471D6D67FC90CE49F11E55F3C34356A99A1D7F639BB9AD3F9AA2BC.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custome-dialog-development-practice.html"
    },
    {
        "id": 401,
        "pre": "@Component\\nexport struct CustomDialogNotDisappear {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Row() {\\n          Button('OPEN')\\n            .fontSize(16)\\n            .width('100%')\\n            .borderRadius(20)\\n            .margin({ bottom: 16 })\\n            .backgroundColor('#0A59F7')\\n            .onClick(() => {\\n              this.pageStack.pushPathByName('DialogPage', '');\\n            })\\n        }\\n        .width('100%')\\n        .alignItems(VerticalAlign.Center)\\n      }\\n      .width('100%')\\n      .height('100%')\\n      .padding({\\n        left: 16,\\n        right: 16\\n      })\\n      .justifyContent(FlexAlign.End)\\n    }\\n  }\\n}\\n\\n@Component\\nexport struct DialogPage {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  build() {\\n    NavDestination() {\\n      Stack({ alignContent: Alignment.Center }) {\\n        Column() {\\n          Row() {\\n            Text('Title')\\n              .fontSize(20)\\n              .fontWeight(FontWeight.Bold)\\n          }\\n          .width('100%')\\n          .height(56)\\n          .justifyContent(FlexAlign.Center)\\n\\n          Text('This is a dialog content.')\\n            .fontSize(14)\\n\\n          Button('CONFIRM')\\n            .fontSize(16)\\n            .fontColor('#0A59F7')\\n            .backgroundColor(Color.White)\\n            .onClick(() => {\\n              this.pageStack.pushPathByName('PageOne', 'PageOne Param');\\n            })\\n            .width('100%')\\n            .margin({\\n              top: 8,\\n              bottom: 16\\n            })\\n        }\\n        .padding({\\n          left: 24,\\n          right: 24\\n        })\\n        .justifyContent(FlexAlign.Center)\\n        .alignItems(HorizontalAlign.Center)\\n        .backgroundColor(Color.White)\\n        .borderRadius(32)\\n        .margin({\\n          left: 16,\\n          right: 16\\n        })\\n      }\\n      .height('100%')\\n      .width('100%')\\n    }\\n    .backgroundColor('rgba(0,0,0,0.2)')\\n    .hideTitleBar(true)\\n    .mode(NavDestinationMode.DIALOG)\\n  }\\n}\\n\\n@Component\\nexport struct PageOne {\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  build() {\\n    NavDestination() {\\n      Stack({ alignContent: Alignment.Center }) {\\n        Column() {\\n          Row() {\\n            Image($r('app.media.Back'))\\n              .width(40)\\n              .height(40)\\n              .margin({ right: 8 })\\n              .onClick(() => {\\n                this.pageStack.pop();\\n              })\\n\\n            Text('Back')\\n              .fontSize(20)\\n              .fontWeight(FontWeight.Bold)\\n          }\\n          .width('100%')\\n          .height(56)\\n          .justifyContent(FlexAlign.Start)\\n        }\\n        .backgroundColor('#F1F3F5')\\n        .padding({\\n          left: 16,\\n          right: 16\\n        })\\n        .height('100%')\\n        .width('100%')\\n      }\\n      .height('100%')\\n      .width('100%')\\n    }\\n    .backgroundColor('#F1F3F5')\\n    .hideTitleBar(true)\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]切换页面弹窗不消失",
        "parent_text": "[h2]切换页面弹窗不消失点击弹窗中的按钮或链接打开新页面，返回后自定义弹窗还在原页面上展示。 典型场景 用户首次进入应用需要进行权限配置，弹出弹窗后，点击跳转到隐私详情页面，返回后弹窗还在显示。 实现思路 NavDestinationMode.DIALOG弹窗存在于路由栈中，可以实现切换页面弹窗不消失。 示例代码   效果演示    ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section690764913302\\\"'><a name='\\\"section690764913302\\\"'></a><a name='\\\"section690764913302\\\"'></a><h4>[h2]切换页面弹窗不消失</h4><p>点击弹窗中的按钮或链接打开新页面，返回后自定义弹窗还在原页面上展示。</p> <p><strong>典型场景</strong></p> <p>用户首次进入应用需要进行权限配置，弹出弹窗后，点击跳转到隐私详情页面，返回后弹窗还在显示。</p> <p><strong>实现思路</strong></p> <p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation#页面显示类型\\\"' target='\\\"_blank\\\"'>NavDestinationMode.DIALOG弹窗</a>存在于路由栈中，可以实现切换页面弹窗不消失。</p> <p><strong>示例代码</strong></p>  <p></p> <p><strong>效果演示</strong></p> <p></p> <p></p> <p><span><img height='\\\"545.5261\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161122.64347929810628613141070634759586:50001231000000:2800:90B9A5963BBF55AA36BE679F438F4757194845CA07216A0A2F9FA74710AA7CCE.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custome-dialog-development-practice.html"
    },
    {
        "id": 402,
        "pre": "import { PromptAction } from '@kit.ArkUI';\\n\\n@Component\\nexport struct CustomDialogDisplayAndExitAnimations {\\n  private promptAction: PromptAction = this.getUIContext().getPromptAction();\\n  private customDialogComponentId: number = 0;\\n  @Consume('NavPathStack') pageStack: NavPathStack;\\n\\n  @Builder\\n  customDialogComponent() {\\n    Column() {\\n      Row() {\\n        Text('Title')\\n          .fontSize(20)\\n          .fontWeight(FontWeight.Bold)\\n      }\\n      .width('100%')\\n      .height(56)\\n      .justifyContent(FlexAlign.Center)\\n\\n      Text('This is a custom dialog box with different entrance and exit animations.')\\n        .fontSize(14)\\n        .width('100%')\\n\\n      Button('CONFIRM')\\n        .fontSize(16)\\n        .fontColor('#0A59F7')\\n        .backgroundColor(Color.White)\\n        .onClick(() => {\\n          this.promptAction.closeCustomDialog(this.customDialogComponentId);\\n        })\\n        .width('100%')\\n        .margin({\\n          top: 8,\\n          bottom: 16\\n        })\\n    }\\n    .padding({\\n      left: 24,\\n      right: 24\\n    })\\n    .width('100%')\\n    .justifyContent(FlexAlign.Center)\\n    .alignItems(HorizontalAlign.Center)\\n    .backgroundColor(Color.White)\\n    .borderRadius(32)\\n  }\\n\\n  build() {\\n    NavDestination() {\\n      Column() {\\n        Row() {\\n          Button('OPEN')\\n            .fontSize(16)\\n            .width('100%')\\n            .borderRadius(20)\\n            .margin({ bottom: 16 })\\n            .backgroundColor('#0A59F7')\\n            .onClick(() => {\\n              this.promptAction.openCustomDialog({\\n                builder: () => {\\n                  this.customDialogComponent();\\n                },\\n                alignment: DialogAlignment.Center,\\n                maskColor: 'rgba(0, 0, 0, 0.2)',\\n                // Set two animations, corresponding to the pop-up window display and hidden animation respectively.\\n                transition: TransitionEffect.asymmetric(\\n                  TransitionEffect.OPACITY\\n                    .animation({ duration: 1000 })\\n                  ,\\n                  TransitionEffect.OPACITY\\n                    .animation({ delay: 500, duration: 1000 })\\n                )\\n              }).then((dialogId: number) => {\\n                this.customDialogComponentId = dialogId;\\n              })\\n            })\\n        }\\n        .width('100%')\\n        .alignItems(VerticalAlign.Center)\\n      }\\n      .width('100%')\\n      .height('100%')\\n      .padding({\\n        left: 16,\\n        right: 16\\n      })\\n      .justifyContent(FlexAlign.End)\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]自定义弹窗显示和退出动画",
        "parent_text": "[h2]自定义弹窗显示和退出动画典型场景 在应用开发中，系统弹窗的显示和退出动画往往不满足需求，若要实现自定义弹窗出入动画，可以使用以下方式，例如：1）渐隐渐显的方式弹出，2）从左往右弹出，从右往左收回，3）从下往上的抽屉式弹出、关闭时从上往下收回。我们以渐隐渐显的方式为例，来介绍自定义弹窗的显示和退出动画。 实现思路 可以基于UIContext.getPromptAction弹窗实现，通过CustomDialogOptions自定义弹窗的内容，BaseDialogOptions弹窗选项transition参数可以设置弹窗显示和退出的过渡效果。 示例代码   效果演示    ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section621242223120\\\"'><a name='\\\"section621242223120\\\"'></a><a name='\\\"section621242223120\\\"'></a><h4>[h2]自定义弹窗显示和退出动画</h4><p><strong>典型场景</strong></p> <p>在应用开发中，系统弹窗的显示和退出动画往往不满足需求，若要实现自定义弹窗出入动画，可以使用以下方式，例如：1）渐隐渐显的方式弹出，2）从左往右弹出，从右往左收回，3）从下往上的抽屉式弹出、关闭时从上往下收回。我们以渐隐渐显的方式为例，来介绍自定义弹窗的显示和退出动画。</p> <p><strong>实现思路</strong></p> <p>可以基于<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#promptactionopencustomdialog11\\\"' target='\\\"_blank\\\"'>UIContext.getPromptAction</a>弹窗实现，通过CustomDialogOptions自定义弹窗的内容，<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-promptaction#basedialogoptions11\\\"' target='\\\"_blank\\\"'>BaseDialogOptions</a>弹窗选项transition参数可以设置弹窗显示和退出的过渡效果。</p> <p><strong>示例代码</strong></p>  <p></p> <p><strong>效果演示</strong></p> <p></p> <p></p> <p><span><img height='\\\"545.5261\\\"' originheight='\\\"720\\\"' originwidth='\\\"348\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161122.28984157870091324427392588758095:50001231000000:2800:5E213A297B9D84A2D77FDF914E520A3844B2D57B6327A6441CB96424C738EA3E.gif\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-custome-dialog-development-practice.html"
    },
    {
        "id": 403,
        "pre": "export default class EntryAbility extends UIAbility {\\n  private uiContext?: UIContext;\\n  private onWindowSizeChange: (windowSize: window.Size) => void = (windowSize: window.Size) => {\\n    let widthBp: WidthBreakpoint = this.uiContext!.getWindowWidthBreakpoint();\\n    AppStorage.setOrCreate('currentWidthBreakpoint', widthBp);\\n    let heightBp: HeightBreakpoint = this.uiContext!.getWindowHeightBreakpoint();\\n    AppStorage.setOrCreate('currentHeightBreakpoint', heightBp);\\n  };\\n  // ...\\n  onWindowStageCreate(windowStage: window.WindowStage): void {\\n    // Main window is created, set main page for this ability\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');\\n\\n    windowStage.loadContent('pages/Index', (err) => {\\n      if (err.code) {\\n        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\\n        return;\\n      }\\n      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');\\n      // The system interface depends on UIContext and needs to be invoked after the page is loaded. It needs to be written in the loadContent callback function.\\n      windowStage.getMainWindow().then((data: window.Window) => {\\n        this.uiContext = data.getUIContext();\\n        let widthBp: WidthBreakpoint = this.uiContext.getWindowWidthBreakpoint();\\n        let heightBp: HeightBreakpoint = this.uiContext.getWindowHeightBreakpoint();\\n        AppStorage.setOrCreate('currentWidthBreakpoint', widthBp);\\n        AppStorage.setOrCreate('currentHeightBreakpoint', heightBp);\\n        data.on('windowSizeChange', this.onWindowSizeChange);\\n      }).catch((err: BusinessError) => {\\n        console.error(`Failed to obtain the main window. Cause code: ${err.code}, message: ${err.message}`);\\n      });\\n    });\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "loadContent()",
        "function_name": null,
        "parent_text": "系统在UIContext中提供系统接口getWindowWidthBreakpoint()和getWindowHeightBreakpoint()，开发者需要在windowStage.loadContent()页面加载后直接获取横向和纵向断点值。 ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>系统在UIContext中提供<span>系统</span>接口<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V13/js-apis-arkui-uicontext-V13#getwindowwidthbreakpoint13\\\"' target='\\\"_blank\\\"'>getWindowWidthBreakpoint()</a>和<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V13/js-apis-arkui-uicontext-V13#getwindowheightbreakpoint13\\\"' target='\\\"_blank\\\"'>getWindowHeightBreakpoint()</a>，开发者需要在windowStage.loadContent()页面加载后直接获取横向和纵向断点值。 </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-device-bp-practice.html"
    },
    {
        "id": 404,
        "pre": "export class BreakpointType<T> {\\n  sm: T;\\n  md: T;\\n  lg: T;\\n\\n  constructor(sm: T, md: T, lg: T) {\\n    this.sm = sm;\\n    this.md = md;\\n    this.lg = lg;\\n  }\\n\\n  getValue(currentWidthBreakpoint: string): T {\\n    if (currentWidthBreakpoint === 'sm') {\\n      return this.sm;\\n    }\\n    if (currentWidthBreakpoint === 'md') {\\n      return this.md;\\n    }\\n    if (currentWidthBreakpoint === 'lg') {\\n      return this.lg;\\n    }\\n    return this.sm;\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]技术要点",
        "parent_text": "[h2]技术要点实际一多应用开发，可能不会涉及到全部的横向断点，开发者可根据应用的实际需求灵活选用并整理工具类，为响应式布局的属性赋值。例如：应用仅需适配手机、大折叠屏（X系列）和平板设备，可以设计为工具类BreakpointType覆盖三个横向断点下的成员变量。使用工具类实现具体的响应式布局。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1818018451507\\\"'><a name='\\\"section1818018451507\\\"'></a><a name='\\\"section1818018451507\\\"'></a><h4>[h2]技术要点</h4><p>实际一多应用开发，可能不会涉及到全部的横向断点，开发者可根据应用的实际需求灵活选用并整理工具类，为响应式布局的属性赋值。例如：应用仅需适配手机、大折叠屏（X系列）和平板设备，可以设计为工具类BreakpointType覆盖三个横向断点下的成员变量。使用工具类实现具体的响应式布局。</p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-device-bp-practice.html"
    },
    {
        "id": 405,
        "pre": "// Movable layout.\\nGridRow({\\n  columns: { sm: 4, md: 12, lg: 12 },\\n  gutter: 12,\\n  breakpoints: { value: ['320vp', '600vp', '840vp'], reference: BreakpointsReference.WindowSize },\\n  direction: GridRowDirection.Row\\n}) {\\n  GridCol({\\n    span: { sm: 4, md: 7, lg: 7 }\\n  }) {\\n    this.topTabBar()\\n  }\\n  .height(56)\\n\\n  GridCol({\\n    span: { sm: 4, md: 5, lg: 5 }\\n  }) {\\n    this.topSearch()\\n  }\\n  .height(56)\\n}\\n.width('100%')",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]挪移布局",
        "parent_text": "[h2]挪移布局挪移布局作为典型的响应式布局，能够调整组件的位置与展示方式，在上下布局与左右布局之间切换，通常应用于首页的顶部页签与搜索框。 实现原理 不同横向断点下，顶部页签和搜索框占用不同栅格列数，使用栅格布局实现在sm横向断点下分两行显示，在md和lg横向断点下单行显示。根据设计将栅格在sm、md和lg的横向断点上分别划分为4列、12列、12列。示意图如下： 示意图  sm  md  lg    效果图         栅格布局图          ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section15284115345619\\\"'><a name='\\\"section15284115345619\\\"'></a><a name='\\\"section15284115345619\\\"'></a><h4>[h2]挪移布局</h4><p>挪移布局作为典型的响应式布局，能够调整组件的位置与展示方式，在上下布局与左右布局之间切换，通常应用于首页的顶部页签与搜索框。</p> <p><strong>实现原理</strong></p> <p>不同横向断点下，顶部页签和搜索框占用不同栅格列数，使用栅格布局实现在sm横向断点下分两行显示，在md和lg横向断点下单行显示。根据设计将栅格在sm、md和lg的横向断点上分别划分为4列、12列、12列。示意图如下：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.11.5.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"6.809319068093191%\\\"'><p>示意图</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.11.5.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"17.16828317168283%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.11.5.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"29.85701429857014%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.11.5.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"46.16538346165384%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.809319068093191%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"17.16828317168283%\\\"'><p><span><img height='\\\"90.82570000000001\\\"' originheight='\\\"224\\\"' originwidth='\\\"656\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161300.49686034119642193225770148844801:50001231000000:2800:F410B765759ADC08A929CD9CB4BDAA72EFAE4518F0522AEC4424BB9E8A3699BE.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"29.85701429857014%\\\"'><p><span><img height='\\\"39.607400000000005\\\"' originheight='\\\"112\\\"' originwidth='\\\"1354\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161300.91651875467963629049808042445146:50001231000000:2800:6CF622C548C649D388F9FF0142D3D674CB4E71DBF388BBF3A56567C66CE87288.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"46.16538346165384%\\\"'><p><span><img height='\\\"37.745400000000004\\\"' originheight='\\\"112\\\"' originwidth='\\\"2368\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161301.80521629118095295477993618207989:50001231000000:2800:75281D66EA3ACF7741241C88C8E6936624AB0C8C083B4DBB2410C343FF267965.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>栅格布局图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p><span><img height='\\\"98.6727\\\"' originheight='\\\"217\\\"' originwidth='\\\"585\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161301.63292084613939901809792962331421:50001231000000:2800:B4137BE7BE579C89C3AF1A6ED520988F351ED595AAA41A4FC27705A4E9DE8345.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' colspan='\\\"2\\\"' valign='\\\"top\\\"'><p><span><img height='\\\"66.0079\\\"' originheight='\\\"145\\\"' originwidth='\\\"1753\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161301.35206362634330793410176342887289:50001231000000:2800:EAF68F88B779054C84F220B35FD4A3A9C011976F3947EDAB85C860E0FF74F06C.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-device-bp-practice.html"
    },
    {
        "id": 406,
        "pre": "// Carousel layout.\\nSwiper() {\\n  // ...\\n}\\n.displayCount(new BreakpointType(1, 2, 3).getValue(this.currentWidthBreakpoint))\\n.nextMargin(new BreakpointType(0, 16, 32).getValue(this.currentWidthBreakpoint))\\n.prevMargin(new BreakpointType(0, 16, 32).getValue(this.currentWidthBreakpoint))\\n.indicator(this.currentWidthBreakpoint === 'sm' ? Indicator.dot()\\n  .itemWidth(6)\\n  .itemHeight(6)\\n  .selectedItemWidth(12)\\n  .selectedItemHeight(6)\\n  .color('#4DFFFFFF')\\n  .bottom(6)\\n  .selectedColor(Color.White) : false\\n)\\n.padding({\\n  left: this.currentWidthBreakpoint === 'sm' ? 12 : 0,\\n  right: this.currentWidthBreakpoint === 'sm' ? 12 : 0\\n})",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "Swiper组件首页展示Banner图的Swiper组件，又称运营横幅或轮播布局。在不同横向断点下，展示不同数量的图片。 sm  md  lg    显示导航点指示器，展示1张Banner图  隐藏导航点指示器，展示2张Banner图，后边距16vp  隐藏导航点指示器，展示3张Banner图，后边距32vp            通过BreakpointType工具类为Swiper组件的displayCount、indicator和nextMargin属性赋值，实现目标效果。  ",
        "import_module": null,
        "parent": "<li><span><strong>Swiper组件</strong></span><p></p><p>首页展示Banner图的Swiper组件，又称运营横幅或轮播布局。在不同横向断点下，展示不同数量的图片。</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.5.1.2.2.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"17%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.5.1.2.2.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"31%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.12.5.1.2.2.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"52%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"17%\\\"'><p>显示导航点指示器，展示1张Banner图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"31%\\\"'><p>隐藏导航点指示器，展示2张Banner图，后边距16vp</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"52%\\\"'><p>隐藏导航点指示器，展示3张Banner图，后边距32vp</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"17%\\\"'><p><span><img height='\\\"129.20950000000002\\\"' originheight='\\\"256\\\"' originwidth='\\\"527\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161301.15988414619526327455005978530148:50001231000000:2800:E20AA8912EFB974F9D456C216508642A00E9F6C3E91BCD7B6D807EFA10F35160.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"31%\\\"'><p><span><img height='\\\"121.41570000000002\\\"' originheight='\\\"177\\\"' originwidth='\\\"698\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161301.90448853216690406338983912143147:50001231000000:2800:FDF686F5A093D11C34A801A21C9D508B323814452B6C04778D3F6C471B43781D.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"52%\\\"'><p><span><img height='\\\"136.5777\\\"' originheight='\\\"197\\\"' originwidth='\\\"1151\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161301.44091772061642760003455458366500:50001231000000:2800:278DF06575E4473457F183F4155403C1DCC7F6C8D2B9C3054F9E16E69CE7153C.png\\\"' title='\\\"点击放大\\\"' width='\\\"798\\\"'/></span></p> </td> </tr> </tbody></table> </div> <p>通过BreakpointType工具类为Swiper组件的displayCount、indicator和nextMargin属性赋值，实现目标效果。</p>  <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-device-bp-practice.html"
    },
    {
        "id": 407,
        "pre": "// Judgment of the horizontal window. (The actual application may need to be combined with other conditions, for example, determine the horizontal breakpoint)\\nif (this.currentHeightBreakpoint === 'sm' && this.currentWidthBreakpoint === 'md') {\\n  // Horizontal window page layout.\\n}\\n// Judgment of the square window. (The actual use may need to be combined with other conditions, such as determining horizontal breakpoints)\\nif (this.currentHeightBreakpoint === 'md' && this.currentWidthBreakpoint === 'sm') {\\n  // Square-like window page layout.\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]技术要点",
        "parent_text": "[h2]技术要点系统推荐按照以下方式判断横向窗口或类方型窗口，并展示特殊的页面布局。 窗口类型  横向窗口  类方型窗口    效果图       判断条件  纵向断点为sm 或 窗口高宽比小于0.8  纵向断点为md 或 窗口高宽比在[0.8, 1.2)之间      ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section297101311810\\\"'><a name='\\\"section297101311810\\\"'></a><a name='\\\"section297101311810\\\"'></a><h4>[h2]技术要点</h4><p>系统推荐按照以下方式判断横向窗口或类方型窗口，并展示特殊的页面布局。</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.3.1.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>窗口类型</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.3.1.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"46.239999999999995%\\\"'><p>横向窗口</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.3.1.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"46.239999999999995%\\\"'><p>类方型窗口</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"46.239999999999995%\\\"'><p><span><img height='\\\"225.8606\\\"' originheight='\\\"1093\\\"' originwidth='\\\"2317\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161301.21727261252377044120919455674927:50001231000000:2800:095D02AFDD360524D0375B14C2573AC8D249FEAFD8F9A521DBCE5ED0E21D4A0B.png\\\"' title='\\\"点击放大\\\"' width='\\\"478.8\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"46.239999999999995%\\\"'><p><span><img height='\\\"563.8801000000001\\\"' originheight='\\\"2317\\\"' originwidth='\\\"1093\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161301.43364984778122784047370398216195:50001231000000:2800:DC3A4C4961C02DAF85C5C333A884503AB7DB8A578C1143141DCB7AFCBCE8EF9E.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.5200000000000005%\\\"'><p>判断条件</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"46.239999999999995%\\\"'><p>纵向断点为sm 或 窗口高宽比小于0.8</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"46.239999999999995%\\\"'><p>纵向断点为md 或 窗口高宽比在[0.8, 1.2)之间</p> </td> </tr> </tbody></table> </div>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-device-bp-practice.html"
    },
    {
        "id": 408,
        "pre": "let currentHeightBreakpoint: string | undefined = AppStorage.get('currentHeightBreakpoint');\\nif (currentHeightBreakpoint === 'md') {\\n  this.mainWindowClass?.setPreferredOrientation(window.Orientation.AUTO_ROTATION_RESTRICTED);\\n}",
        "type": "Reference",
        "function_call": "setPreferredOrientation()",
        "function_name": null,
        "parent_text": "判断纵向断点为md时，通过window.setPreferredOrientation()设置窗口支持旋转。 ",
        "import_module": null,
        "parent": "<li>判断纵向断点为md时，通过<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-window#getpreferredorientation12\\\"' target='\\\"_blank\\\"'>window.setPreferredOrientation()</a>设置窗口支持旋转。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-device-bp-practice.html"
    },
    {
        "id": 409,
        "pre": "export default class EntryAbility extends UIAbility {\\n  private windowObj?: window.Window;\\n  private windowUtil?: WindowUtil = WindowUtil.getInstance();\\n  private onWindowSizeChange: (windowSize: window.Size) => void = (windowSize: window.Size) => {\\n    this.windowUtil!.updateHeightBp();\\n    this.windowUtil!.updateWidthBp();\\n    AppStorage.setOrCreate('windowWidth', windowSize.width);\\n  };\\n  // ...\\n  onWindowStageCreate(windowStage: window.WindowStage) {\\n    // Main window is created, set main page for this ability\\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');\\n\\n    this.windowUtil!.setWindowStage(windowStage);\\n    windowStage.getMainWindow().then((data: window.Window) => {\\n      this.windowObj = data;\\n      this.windowUtil!.updateWidthBp();\\n      this.windowUtil!.updateHeightBp();\\n      // ...\\n      this.windowObj.on('windowSizeChange', this.onWindowSizeChange);\\n    });\\n    // ...\\n  }\\n  // ...\\n}",
        "type": "Reference",
        "function_call": "和updateHeightBp()",
        "function_name": null,
        "parent_text": "在EntryAbility的onWindowStageCreate()生命周期中增加对宽度和“高宽比”的监听。在获取到主窗口后调用updateWidthBp()和updateHeightBp()方法初始设置一次横纵断点，之后在窗口大小变化时设置窗口尺寸变化的监听window.on('windowSizeChange')，当windowSize改变的时候就会触发。 ",
        "import_module": null,
        "parent": "<li>在EntryAbility的onWindowStageCreate()生命周期中增加对宽度和“高宽比”的监听。在获取到主窗口后调用updateWidthBp()和updateHeightBp()方法初始设置一次横纵断点，之后在窗口大小变化时设置窗口尺寸变化的监听window.on('windowSizeChange')，当windowSize改变的时候就会触发。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-multi-device-bp-practice.html"
    },
    {
        "id": 410,
        "pre": "// commons/base/src/main/ets/utils/BreakpointType.ets\\nexport class BreakpointType<T> {\\n  sm: T;\\n  md: T;\\n  lg: T;\\n\\n  constructor(sm: T, md: T, lg: T) {\\n    this.sm = sm;\\n    this.md = md;\\n    this.lg = lg;\\n  }\\n\\n  getValue(currentWidthBreakpoint: string): T {\\n    if (currentWidthBreakpoint === BreakpointConstants.BREAKPOINT_MD) {\\n      return this.md;\\n    }\\n    if (currentWidthBreakpoint === BreakpointConstants.BREAKPOINT_LG) {\\n      return this.lg;\\n    } else {\\n      return this.sm;\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]资源使用",
        "parent_text": "[h2]资源使用本节以长视频应用为例，根据实际的资源使用情况，给出“一多”应用开发中推荐的资源使用方式。 在长视频应用中，多端页面显示的效果不同，使用的资源值随断点变化，推荐使用媒体查询获取资源值。借助媒体查询中监听断点的功能做简单的封装，创建BreakpointType类，通过getValue方法获取对应的资源值。在使用时，创建不同的资源文件传入BreakpointType代表sm、md和lg断点下的资源值，实现应用窗口大小变化时的不同效果。  // features/home/src/main/ets/view/DailyVideo.ets\\nImage($r('app.media.daily_small_video'))\\n  .height(new BreakpointType($r('app.float.small_daily_image_height_sm'),\\n    $r('app.float.small_daily_image_height_md'), $r('app.float.small_daily_image_height_lg'))\\n    .getValue(this.currentWidthBreakpoint))\\n  .width(new BreakpointType($r('app.float.small_daily_image_width_sm'),\\n    $r('app.float.small_daily_image_width_md'), $r('app.float.small_daily_image_width_lg'))\\n    .getValue(this.currentWidthBreakpoint))\\n  .borderRadius($r('app.float.daily_small_img_radius')) ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section208330326545\\\"'><a name='\\\"section208330326545\\\"'></a><a name='\\\"zh-cn_topic_0000001744653537_section208330326545\\\"'></a><h4>[h2]资源使用</h4><p>本节以长视频应用为例，根据实际的资源使用情况，给出“一多”应用开发中推荐的资源使用方式。</p> <p>在长视频应用中，多端页面显示的效果不同，使用的资源值随断点变化，推荐使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/responsive-layout#媒体查询\\\"' target='\\\"_blank\\\"'>媒体查询</a>获取资源值。借助媒体查询中监听断点的功能做简单的封装，创建BreakpointType类，通过getValue方法获取对应的资源值。在使用时，创建不同的资源文件传入BreakpointType代表sm、md和lg断点下的资源值，实现应用窗口大小变化时的不同效果。</p>  <pre class='\\\"screen\\\"'>// features/home/src/main/ets/view/DailyVideo.ets\\nImage($r('app.media.daily_small_video'))\\n  .height(new BreakpointType($r('app.float.small_daily_image_height_sm'),\\n    $r('app.float.small_daily_image_height_md'), $r('app.float.small_daily_image_height_lg'))\\n    .getValue(this.currentWidthBreakpoint))\\n  .width(new BreakpointType($r('app.float.small_daily_image_width_sm'),\\n    $r('app.float.small_daily_image_width_md'), $r('app.float.small_daily_image_width_lg'))\\n    .getValue(this.currentWidthBreakpoint))\\n  .borderRadius($r('app.float.daily_small_img_radius'))</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-video-app.html"
    },
    {
        "id": 411,
        "pre": "let request: geoLocationManager.SingleLocationRequest = {\\n  locatingPriority: geoLocationManager.LocatingPriority.PRIORITY_LOCATING_SPEED,\\n  locatingTimeoutMs: 10000\\n};",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "实例化位置信息请求对象，确认当前定位策略。以实例化SingleLocationRequest对象为例，将其定位方式优先级设置为快速获取位置优先，定位超时时间设置为10秒，具体代码如下： ",
        "import_module": null,
        "parent": "<li>实例化位置信息请求对象，确认当前定位策略。以实例化SingleLocationRequest对象为例，将其定位方式优先级设置为快速获取位置优先，定位超时时间设置为10秒，具体代码如下： </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-location-service.html"
    },
    {
        "id": 412,
        "pre": "let request: geoLocationManager.ContinuousLocationRequest = {\\n  locationScenario: geoLocationManager.UserActivityScenario.NAVIGATION,\\n  interval: 1\\n};",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "实例化位置信息请求对象，确认持续定位策略。以实例化ContinuousLocationRequest为例，将定位场景类型设置为导航场景，位置信息上报时间间隔设置为1秒，具体代码如下： ",
        "import_module": null,
        "parent": "<li>实例化位置信息请求对象，确认持续定位策略。以实例化ContinuousLocationRequest为例，将定位场景类型设置为导航场景，位置信息上报时间间隔设置为1秒，具体代码如下： </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-location-service.html"
    },
    {
        "id": 413,
        "pre": "{\\n  \\\"name\\\": \\\"ohos.permission.KEEP_BACKGROUND_RUNNING\\\",\\n  \\\"reason\\\": \\\"$string:running_background\\\",\\n  \\\"usedScene\\\": {\\n    \\\"abilities\\\": [\\n      \\\"EntryAbility\\\"\\n    ],\\n    \\\"when\\\": \\\"always\\\"\\n  }\\n},",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在模块的module.json5文件中，申请长时任务权限，并将长时任务模式设置为定位导航类型。申请长时任务权限  设置长时任务模式为定位导航类型 \\\"abilities\\\": [\\n  {\\n    // ...\\n    \\\"backgroundModes\\\": [\\\"location\\\"],\\n    // ...\\n  }\\n], ",
        "import_module": null,
        "parent": "<li>在模块的module.json5文件中，申请长时任务权限，并将长时任务模式设置为定位导航类型。<p>申请长时任务权限</p>  <p>设置长时任务模式为定位导航类型</p> <pre class='\\\"screen\\\"'>\\\"abilities\\\": [\\n  {\\n    // ...\\n    \\\"backgroundModes\\\": [\\\"location\\\"],\\n    // ...\\n  }\\n],</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-location-service.html"
    },
    {
        "id": 414,
        "pre": "import { connection } from '@kit.NetworkKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';",
        "type": "Import",
        "function_call": null,
        "function_name": null,
        "parent_text": "导入模块。 ",
        "import_module": "import { connection } from '@kit.NetworkKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';",
        "parent": "<li><span>导入模块。</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-management.html"
    },
    {
        "id": 415,
        "pre": "import { radio } from '@kit.TelephonyKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';",
        "type": "Import",
        "function_call": null,
        "function_name": null,
        "parent_text": "导入模块。 ",
        "import_module": "import { radio } from '@kit.TelephonyKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';",
        "parent": "<li><span>导入模块。</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-management.html"
    },
    {
        "id": 416,
        "pre": "networkListen() {\\n  this.netCon = connection.createNetConnection();\\n  this.netCon.register((error: BusinessError) => {\\n    if (error) {\\n      console.log('networkListen fail' + JSON.stringify(error))\\n      return;\\n    }\\n  });\\n\\n  this.netCon.on('netAvailable', (data: connection.NetHandle) => {\\n    console.info(\\\"Succeeded to get netAvailable: \\\" + JSON.stringify(data));\\n    if (connection.hasDefaultNetSync()) {\\n      if (this.networkPause) {\\n        this.controller?.start();\\n        this.networkPause = false;\\n      }\\n    }\\n  });\\n\\n  // 订阅网络丢失事件\\n  this.netCon.on('netLost', (data: connection.NetHandle) => {\\n    if (connection.getAllNetsSync().length == 0) {\\n      this.controller?.pause();\\n      this.networkPause = true;\\n    }\\n    console.info(\\\"Succeeded to get netLost: \\\" + JSON.stringify(data));\\n  });\\n\\n  this.netCon.on('netCapabilitiesChange', (data: connection.NetCapabilityInfo) => {\\n    console.info(\\\"Succeeded to get netCapabilitiesChange: \\\" + JSON.stringify(data));\\n  });\\n\\n  this.netCon.on('netUnavailable', () => {\\n    console.info(\\\"Succeeded to get unavailable net event\\\");\\n  });\\n}",
        "type": "Reference",
        "function_call": "let recvWifiConnectionChangeFunc = (result: number)",
        "function_name": "[h2]监听网络可用与丢失",
        "parent_text": "[h2]监听网络可用与丢失在日常使用网络中，当使用WiFi或者蜂窝时，如果信号良好，且手机、电脑、平板等可以顺利连接到网络，并进行在线视频播放、浏览网页、下载文件等操作，这些就是网络可用的典型场景。 而设备故障、信号干扰、网络拥堵、网络服务提供商的服务器故障、维护或升级都可能会导致网络丢失。为了提升用户上网体验，就需要对网络是否可用、网络是否丢失等进行监听，然后做出相应的处理。 网络连接管理中提供了对网络状态监听的方法，开发时定义了相关的监听方法后，在不同场景下会触发不同的事件，如： on('netAvailable')：订阅网络可用事件，当网络可用时触发该事件。on('netBlockStatusChange')：订阅网络阻塞状态事件，当网络阻塞时，如网络性能下降、数据传输出现延迟等情况时，会触发该事件。on('netCapabilitiesChange')：订阅网络能力变化事件，当网络能力变化时，如网络从无网络到有网络、从4G切换到5G时，会触发该事件。on('netConnectionPropertiesChange')：订阅网络连接信息变化事件，当网络连接信息变化时，如从无网络到有网络、从WiFi切换到蜂窝时，会触发该事件。on('netLost')：订阅网络丢失事件，当网络严重中断或正常断开时触发该事件。on('netUnavailable')：订阅网络不可用事件，当网络不可用时触发该事件。 网络丢失和网络不可用并非是一个概念，网络丢失和网络不可用的区别如下： 网络丢失是指网络严重中断或正常断开事件，当断开WiFi时，是属于正常断开网络连接，会触发netLost事件。网络不可用是指网络不可用事件，当连接的网络不能使用时，会触发netUnavailable事件。  在播放视频时，可能会遇到无网络的情况，此时需要监听网络是否可用或者丢失，来实现对视频无网络时暂停、有网络时自动播放的能力，提升用户播放视频时的体验。通过注册监听网络相关变化，注册监听步骤如下： 进行“获取当前网络连接类型”中的步骤1。调用connection.createNetConnection()方法，创建一个网络连接对象。订阅指定网络状态变化的通知register()，只有先通过register接口注册了订阅事件，其他事件被触发时才能接收到对应的通知。订阅网络可用事件 on('netAvailable')。订阅网络丢失事件 on('netLost')。订阅网络不可用事件 on('netUnavailable')。退出页面或应用时取消订阅指定网络状态变化的通知unregister()。 核心代码  aboutToDisappear(): void {\\n  this.netCon?.unregister((error: BusinessError) => {\\n    console.log(JSON.stringify(error));\\n  });\\n}  connection.createNetConnection()方法中有两个可选传入参，netSpecifier和timeout。其中netSpecifier指定关注的网络的各项特征；timeout是超时时间(单位是毫秒)；netSpecifier是timeout的必要条件，两者都没有则表示关注默认网络。  播放视频可使用Video组件实现，如果开发者想自定义视频播放，请参考视频播放。 @Component\\nexport struct VideoPlayer{\\n  private controller:VideoController | undefined;\\n  @State videoSrc: string= 'https://www.example.com/example.mp4' // 使用时请替换为实际视频加载网址\\n  build(){\\n    Column() {\\n      Video({\\n        src: this.videoSrc,\\n        controller: this.controller\\n      })\\n    }\\n  }\\n} 当网络不可用时，调用暂停方法，暂停视频播放。 this.controller?.pause(); 有网络后，调用播放方法，开始视频播放。 this.controller?.start(); 上述过程中可能会涉及到WiFi切换，当需要判断WiFi是否切换，需要监听WLAN状态改变事件和WLAN连接状态改变事件，步骤如下： 进行“获取当前网络连接类型”中的步骤1和“查询WLAN是否已使能”中的步骤1。调用connection.createNetConnection()方法，创建一个网络连接对象，并指定关注WiFi网络的各项特征。注册WLAN状态改变事件on('wifiStateChange')。注册WLAN连接状态改变事件on('wifiConnectionChange')。 核心代码 wifiChangeListen() {\\n  this.netCon = connection.createNetConnection({\\n    netCapabilities: {\\n      bearerTypes: [connection.NetBearType.BEARER_WIFI]\\n    }\\n  });\\n  // 先使用register接口注册订阅事件\\n  this.netCon.register((error: BusinessError) => {\\n    console.log(JSON.stringify(error));\\n  });\\n\\n  // 订阅网络可用事件。调用register后，才能接收到此事件通知\\n  this.netCon.on('netAvailable', (data: connection.NetHandle) => {\\n    console.info(\\\"WifiChangeListen-- Succeeded to get data: \\\" + JSON.stringify(data));\\n  });\\n\\n  // 订阅网络丢失事件。调用register后，才能接收到此事件通知\\n  this.netCon.on('netLost', (data: connection.NetHandle) => {\\n    console.info(\\\"WifiChangeListen-- Succeeded to get data: \\\" + JSON.stringify(data));\\n  });\\n\\n  let recvPowerNotifyFunc = (result: number) => {\\n    console.info(\\\"WifiChangeListen-- Receive power state change event: \\\" + result);\\n  }\\n  let recvWifiConnectionChangeFunc = (result: number) => {\\n    console.info(\\\"WifiChangeListen-- Receive wifi connection change event: \\\" + result);\\n  }\\n\\n  // 注册事件\\n  wifiManager.on(\\\"wifiStateChange\\\", recvPowerNotifyFunc);\\n  wifiManager.on(\\\"wifiConnectionChange\\\", recvWifiConnectionChangeFunc);\\n} 其中状态改变事件的枚举： 枚举值  说明    0  未激活。   1  已激活。   2  激活中。   3  去激活中。     连接状态改变事件的枚举： 枚举值  说明    0  已断开。   1  已连接。      设备从无网络到有网络会触发netAvailable事件、netCapabilitiesChange事件和netConnectionPropertiesChange事件； 设备从有网络到无网络状态会触发netLost事件； 设备从WiFi切换到蜂窝会先触发netLost事件（WiFi丢失），之后触发 netAvailable事件（蜂窝可用）。  ",
        "import_module": "import { radio } from '@kit.TelephonyKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';",
        "parent": "<div class='\\\"section\\\"' id='\\\"section18536043291\\\"'><a name='\\\"section18536043291\\\"'></a><a name='\\\"section18536043291\\\"'></a><h4>[h2]监听网络可用与丢失</h4><p>在日常使用网络中，当使用WiFi或者蜂窝时，如果信号良好，且手机、电脑、平板等可以顺利连接到网络，并进行在线视频播放、浏览网页、下载文件等操作，这些就是网络可用的典型场景。</p> <p>而设备故障、信号干扰、网络拥堵、网络服务提供商的服务器故障、维护或升级都可能会导致网络丢失。为了提升用户上网体验，就需要对网络是否可用、网络是否丢失等进行监听，然后做出相应的处理。</p> <p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection\\\"' target='\\\"_blank\\\"'>网络连接管理</a>中提供了对网络状态监听的方法，开发时定义了相关的监听方法后，在不同场景下会触发不同的事件，如：</p> <ul><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetavailable\\\"' target='\\\"_blank\\\"'>on('netAvailable')</a>：订阅网络可用事件，当网络可用时触发该事件。</li><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetblockstatuschange\\\"' target='\\\"_blank\\\"'>on('netBlockStatusChange')</a>：订阅网络阻塞状态事件，当网络阻塞时，如网络性能下降、数据传输出现延迟等情况时，会触发该事件。</li><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetcapabilitieschange\\\"' target='\\\"_blank\\\"'>on('netCapabilitiesChange')</a>：订阅网络能力变化事件，当网络能力变化时，如网络从无网络到有网络、从4G切换到5G时，会触发该事件。</li><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetconnectionpropertieschange\\\"' target='\\\"_blank\\\"'>on('netConnectionPropertiesChange')</a>：订阅网络连接信息变化事件，当网络连接信息变化时，如从无网络到有网络、从WiFi切换到蜂窝时，会触发该事件。</li><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetlost\\\"' target='\\\"_blank\\\"'>on('netLost')</a>：订阅网络丢失事件，当网络严重中断或正常断开时触发该事件。</li><li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetunavailable\\\"' target='\\\"_blank\\\"'>on('netUnavailable')</a>：订阅网络不可用事件，当网络不可用时触发该事件。</li></ul> <p>网络丢失和网络不可用并非是一个概念，网络丢失和网络不可用的区别如下：</p> <ul><li>网络丢失是指网络严重中断或正常断开事件，当断开WiFi时，是属于正常断开网络连接，会触发<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetlost\\\"' target='\\\"_blank\\\"'>netLost</a>事件。</li><li>网络不可用是指网络不可用事件，当连接的网络不能使用时，会触发<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetunavailable\\\"' target='\\\"_blank\\\"'>netUnavailable</a>事件。</li></ul> <p></p> <p>在播放视频时，可能会遇到无网络的情况，此时需要监听网络是否可用或者丢失，来实现对视频无网络时暂停、有网络时自动播放的能力，提升用户播放视频时的体验。通过注册监听网络相关变化，注册监听步骤如下：</p> <ol><li><span>进行“获取当前网络连接类型”中的步骤1。</span></li><li><span>调用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#connectioncreatenetconnection\\\"' target='\\\"_blank\\\"'>connection.createNetConnection()</a>方法，创建一个网络连接对象。</span></li><li><span>订阅指定网络状态变化的通知<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#register\\\"' target='\\\"_blank\\\"'>register()</a>，只有先通过register接口注册了订阅事件，其他事件被触发时才能接收到对应的通知。</span></li><li><span>订阅网络可用事件 <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetavailable\\\"' target='\\\"_blank\\\"'>on('netAvailable')</a>。</span></li><li><span>订阅网络丢失事件 <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetlost\\\"' target='\\\"_blank\\\"'>on('netLost')</a>。</span></li><li><span>订阅网络不可用事件 <a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetunavailable\\\"' target='\\\"_blank\\\"'>on('netUnavailable')</a>。</span></li><li><span>退出页面或应用时取消订阅指定网络状态变化的通知<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#unregister\\\"' target='\\\"_blank\\\"'>unregister()</a>。</span></li></ol> <p><strong>核心代码</strong></p>  <pre class='\\\"screen\\\"'>aboutToDisappear(): void {\\n  this.netCon?.unregister((error: BusinessError) =&gt; {\\n    console.log(JSON.stringify(error));\\n  });\\n}</pre> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161448.02596559248235553364462546595007:50001231000000:2800:041EAD6C10A2D23899632A851ACD4791BA81213A707D4D9515BCA04D5E3A6958.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>connection.createNetConnection()方法中有两个可选传入参，netSpecifier和timeout。其中<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#netspecifier\\\"' target='\\\"_blank\\\"'>netSpecifier</a>指定关注的网络的各项特征；timeout是超时时间(单位是毫秒)；netSpecifier是timeout的必要条件，两者都没有则表示关注默认网络。</p> </div></div> <p>播放视频可使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-common-components-video-player\\\"' target='\\\"_blank\\\"'>Video</a>组件实现，如果开发者想自定义视频播放，请参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-playback\\\"' target='\\\"_blank\\\"'>视频播放</a>。</p> <pre class='\\\"screen\\\"'>@Component\\nexport struct VideoPlayer{\\n  private controller:VideoController | undefined;\\n  @State videoSrc: string= 'https://www.example.com/example.mp4' // 使用时请替换为实际视频加载网址\\n  build(){\\n    Column() {\\n      Video({\\n        src: this.videoSrc,\\n        controller: this.controller\\n      })\\n    }\\n  }\\n}</pre> <p>当网络不可用时，调用暂停方法，暂停视频播放。</p> <pre class='\\\"screen\\\"'>this.controller?.pause();</pre> <p>有网络后，调用播放方法，开始视频播放。</p> <pre class='\\\"screen\\\"'>this.controller?.start();</pre> <p>上述过程中可能会涉及到WiFi切换，当需要判断WiFi是否切换，需要监听WLAN状态改变事件和WLAN连接状态改变事件，步骤如下：</p> <ol><li><span>进行“获取当前网络连接类型”中的步骤1和“查询WLAN是否已使能”中的步骤1。</span></li><li><span>调用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#connectioncreatenetconnection\\\"' target='\\\"_blank\\\"'>connection.createNetConnection()</a>方法，创建一个网络连接对象，并指定关注WiFi网络的各项特征。</span></li><li><span>注册WLAN状态改变事件<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-wifimanager#wifimanageronwifistatechange9\\\"' target='\\\"_blank\\\"'>on('wifiStateChange')</a>。</span></li><li><span>注册WLAN连接状态改变事件<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-wifimanager#wifimanageronwificonnectionchange9\\\"' target='\\\"_blank\\\"'>on('wifiConnectionChange')</a>。</span></li></ol> <p><strong>核心代码</strong></p> <pre class='\\\"screen\\\"'>wifiChangeListen() {\\n  this.netCon = connection.createNetConnection({\\n    netCapabilities: {\\n      bearerTypes: [connection.NetBearType.BEARER_WIFI]\\n    }\\n  });\\n  // 先使用register接口注册订阅事件\\n  this.netCon.register((error: BusinessError) =&gt; {\\n    console.log(JSON.stringify(error));\\n  });\\n\\n  // 订阅网络可用事件。调用register后，才能接收到此事件通知\\n  this.netCon.on('netAvailable', (data: connection.NetHandle) =&gt; {\\n    console.info(\\\"WifiChangeListen-- Succeeded to get data: \\\" + JSON.stringify(data));\\n  });\\n\\n  // 订阅网络丢失事件。调用register后，才能接收到此事件通知\\n  this.netCon.on('netLost', (data: connection.NetHandle) =&gt; {\\n    console.info(\\\"WifiChangeListen-- Succeeded to get data: \\\" + JSON.stringify(data));\\n  });\\n\\n  let recvPowerNotifyFunc = (result: number) =&gt; {\\n    console.info(\\\"WifiChangeListen-- Receive power state change event: \\\" + result);\\n  }\\n  let recvWifiConnectionChangeFunc = (result: number) =&gt; {\\n    console.info(\\\"WifiChangeListen-- Receive wifi connection change event: \\\" + result);\\n  }\\n\\n  // 注册事件\\n  wifiManager.on(\\\"wifiStateChange\\\", recvPowerNotifyFunc);\\n  wifiManager.on(\\\"wifiConnectionChange\\\", recvWifiConnectionChangeFunc);\\n}</pre> <p>其中状态改变事件的枚举：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.38.26.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>枚举值</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.38.26.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>说明</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>0</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>未激活。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>1</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>已激活。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>2</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>激活中。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>3</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>去激活中。</p> </td> </tr> </tbody></table> </div> <p>连接状态改变事件的枚举：</p> <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.38.28.1.3.1.1\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>枚举值</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.38.28.1.3.1.2\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>说明</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>0</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>已断开。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>1</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"50%\\\"'><p>已连接。</p> </td> </tr> </tbody></table> </div> <div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161448.69138538944023122636525469320866:50001231000000:2800:A96F3A76A800C57AFBE7BEC44F6704C2D934325C68F8C00E5B71793F29CC77D3.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>设备从无网络到有网络会触发netAvailable事件、netCapabilitiesChange事件和<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-net-connection#onnetconnectionpropertieschange\\\"' target='\\\"_blank\\\"'>netConnectionPropertiesChange</a>事件；</p> <p>设备从有网络到无网络状态会触发netLost事件；</p> <p>设备从WiFi切换到蜂窝会先触发netLost事件（WiFi丢失），之后触发 netAvailable事件（蜂窝可用）。</p> </div></div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-management.html"
    },
    {
        "id": 417,
        "pre": "import { BusinessError } from '@kit.BasicServicesKit';\\nimport { netQuality } from '@kit.NetworkBoostKit';",
        "type": "Import",
        "function_call": null,
        "function_name": null,
        "parent_text": "导入模块。 ",
        "import_module": "import { BusinessError } from '@kit.BasicServicesKit';\\nimport { netQuality } from '@kit.NetworkBoostKit';",
        "parent": "<li><span>导入模块。</span><p></p> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-network-management.html"
    },
    {
        "id": 418,
        "pre": "import { fileIo as fs } from '@kit.CoreFileKit';\\n\\nlet context = getContext(this);\\n\\nasync function read() {\\n  const bufferSize: number = await audioRenderer.getBufferSize();\\n  let path = context.filesDir; //文件所在路径\\n\\n  const filePath = path + '/voice_call_data.wav'; //禁止该文件为无声播放的文件\\n  let file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_ONLY); //打开文件\\n  let buf = new ArrayBuffer(bufferSize);\\n  let readsize: number = await fs.read(file.fd, buf); //读取文件内容\\n  let writeSize: number = await audioRenderer.write(buf); //播放文件内容\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "示例",
        "parent_text": "示例 有关AudioRenderer开发相关接口的使用，详情可以参考使用AudioRenderer开发音频播放功能。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1064810451181\\\"'><a name='\\\"section1064810451181\\\"'></a><a name='\\\"section1064810451181\\\"'></a><h4>示例</h4> <p>有关AudioRenderer开发相关接口的使用，详情可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/using-audiorenderer-for-playback\\\"' target='\\\"_blank\\\"'>使用AudioRenderer开发音频播放功能</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-audio-playback-use.html"
    },
    {
        "id": 419,
        "pre": "  Row() {\\n    ... // 10、100、500、1000层Row容器嵌套\\n    Row() {\\n      Text('Inner Text')\\n    } \\n    ... \\n  }",
        "type": "Reference",
        "function_call": "Image()",
        "function_name": "精简节点数",
        "parent_text": "  精简节点数 布局阶段是采用递归遍历所有节点的方式进行组件位置和大小的计算， 如果嵌套层级过深，将带来了更多的中间节点，在布局测算阶段下，额外的节点数将导致更多的计算过程，造成性能劣化。我们通过模拟了10、100、500、1000层Row嵌套的情况下，通过Profiler工具抓取Launch数据查看对应的首帧绘制，以及页面Measure/Layout时间进行对比。  然后进一步对比了在平铺的情况下，Row内组件个数在10、100、500、1000的条件下，使用Profiler工具抓取Launch的数据情况，得到如下结果如表1所示。  Row() {\\n    Row() {} \\n    ... // 10、100、500、1000层Row容器并排\\n    Text('Inner Text')\\n  }    表1 嵌套与平铺下的布局时间对比    对比指标 10 100 500 1000     嵌套/层 首帧绘制 3.2ms 5.8ms 17.3ms 32ms   Measure 1.88ms 2.89ms 5.93ms 10.46ms   Layout 0.38ms 1.12ms 5.26ms 10.88ms    平铺 /个 首帧绘制 3.6ms 4.5ms 14ms 24.3ms   Measure 2.15ms 2.31ms 5.61ms 9.26ms   Layout 0.39ms 1.38ms 4.74ms 9.92ms        以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。    根据以上数据对比发现，组件平铺和嵌套在相同组件个数的情况下，其性能差异不大，并且整体上趋势保持一致，随着组件数量增加呈现线性增长的劣化，由此可以得到结论，真正影响布局性能的因素是参与布局的节点数量。所以在进行布局时，应该尽量减少整体的节点数，来减少布局的性能劣化。 针对减少总节点，主要有两个方向：  移除冗余的节点。 使用扁平化布局减少节点数。  移除冗余节点 对于常出现冗余的情况，例如可能会在Row容器包含一个同样也是Row容器的子级。这种嵌套实际是多余的，并且会给布局层次结构造成不必要的开销。 Row() {\\n  Row(){\\n    Image()\\n    Text()\\n  }\\n  Image()\\n} 由于其中Row容器父子布局方向相同，所以可以去掉Image和Text外层的Row来减少层级，如果视图更加复杂，布局在渲染时，会产生没有必要的计算。 Row() {\\n  Image()\\n  Text()\\n  Image()\\n} 尽管在这里只是多了一层，但是实际开发中的布局往往非常复杂，冗余带来的开销可能非常影响布局性能，尤其是在列表中动态创建组件时，带来的性能影响是显著的。 使用扁平化布局减少节点数 在某些情况下，开发者所实现的布局在嵌套层级上是没有冗余的，但是嵌套层级仍然较深，可能无法通过调整现有的布局方案，使其不包含多余的布局，唯一的解决方案可能是，通过切换到完全不同的布局类型来实现层次结构的扁平化。 例如图1中元素结构示意图，传统使用线性布局的情况下，总共存在4层嵌套、共15个节点，并且其中并没有冗余的嵌套节点。而扁平化布局是一种让页面结构变浅变宽的方式，通过一些高级组件如RelativeContainer、Grid等容器，可以让元素在平面上展开。这种布局方式能够有效减少由于使用线性布局带来的嵌套深度，将其用于描述布局的容器节点进行优化，达到精简节点数的目的。图一中将线性布局改成相对布局的情况下，嵌套2层、总共10个节点，相比之下前后少了5个节点。  图1 扁平化布局示意图  这种方式对于布局的影响主要体现在：  页面创建时，扁平化减少了中间的嵌套层级，使总的组件节点的数量越少，在进行布局时所需要进行的计算相对越少。 页面更新时，当要更新的结构是嵌套子树的结构，其树内包含过多节点时，整体更新会导致更新的节点数过多，造成布局性能劣化。  所以当页面不存在冗余节点时，可以考虑是否能够通过替换为更高级的布局使得页面扁平化，来达到减少节点数的目的。主要方式可以参考：  RelativeContainer 通过相对布局实现扁平化。 绝对定位 通过锚点定位实现扁平化。 Grid 通过二维布局实现扁平化。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section9293918175210\\\"'> <a name='\\\"section9293918175210\\\"'></a><a name='\\\"section9293918175210\\\"'></a> <h4>精简节点数</h4> <p>布局阶段是采用递归遍历所有节点的方式进行组件位置和大小的计算， 如果嵌套层级过深，将带来了更多的中间节点，在布局测算阶段下，额外的节点数将导致更多的计算过程，造成性能劣化。我们通过模拟了10、100、500、1000层Row嵌套的情况下，通过Profiler工具抓取Launch数据查看对应的首帧绘制，以及页面Measure/Layout时间进行对比。</p>  <p>然后进一步对比了在平铺的情况下，Row内组件个数在10、100、500、1000的条件下，使用Profiler工具抓取Launch的数据情况，得到如下结果如表1所示。</p> <pre class='\\\"screen\\\"'> Row() {\\n    Row() {} \\n    ... // 10、100、500、1000层Row容器并排\\n    Text('Inner Text')\\n  }</pre> <div class='\\\"tablenoborder\\\"'> <table> <caption> <b>表1 </b><strong>嵌套与平铺下的布局时间对比</strong> </caption> <thead> <tr> <th align='\\\"center\\\"' class='\\\"cellrowborder\\\"' colspan='\\\"2\\\"' id='\\\"mcps1.3.15.6.2.7.1.1\\\"' valign='\\\"top\\\"'><p>对比指标</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.6.2.7.1.2\\\"' valign='\\\"top\\\"'><p>10</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.6.2.7.1.3\\\"' valign='\\\"top\\\"'><p>100</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.6.2.7.1.4\\\"' valign='\\\"top\\\"'><p>500</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.15.6.2.7.1.5\\\"' valign='\\\"top\\\"'><p>1000</p></th> </tr> </thead> <tbody><tr> <td align='\\\"center\\\"' class='\\\"cellrowborder\\\"' rowspan='\\\"3\\\"' valign='\\\"top\\\"' width='\\\"9.028194361127776%\\\"'><p></p> <p>嵌套/层</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"16.98660267946411%\\\"'><p>首帧绘制</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.49630073985203%\\\"'><p>3.2ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.49630073985203%\\\"'><p>5.8ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.49630073985203%\\\"'><p>17.3ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.49630073985203%\\\"'><p>32ms</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>Measure</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>1.88ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>2.89ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>5.93ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>10.46ms</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>Layout</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>0.38ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>1.12ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>5.26ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>10.88ms</p></td> </tr> <tr> <td align='\\\"center\\\"' class='\\\"cellrowborder\\\"' rowspan='\\\"3\\\"' valign='\\\"top\\\"' width='\\\"9.028194361127776%\\\"'><p></p> <p>平铺 /个</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"16.98660267946411%\\\"'><p>首帧绘制</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.49630073985203%\\\"'><p>3.6ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.49630073985203%\\\"'><p>4.5ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.49630073985203%\\\"'><p>14ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.49630073985203%\\\"'><p>24.3ms</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>Measure</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>2.15ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>2.31ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>5.61ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>9.26ms</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>Layout</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>0.39ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>1.38ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>4.74ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"'><p>9.92ms</p></td> </tr> </tbody></table> </div> <div class='\\\"note\\\"'> <img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161106.64384041796982195729293627185268:50001231000000:2800:60FC1F0EF2689A1C2DCD072E7A791AEDDCC29B41D6C0E21FF2855E1018697BD2.png\\\"'/><span class='\\\"notetitle\\\"'> </span> <div class='\\\"notebody\\\"'> <p>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</p> </div> </div> <p><span><img height='\\\"239.63833600000004\\\"' originheight='\\\"444\\\"' originwidth='\\\"2251\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161106.49499392740896106836323540691033:50001231000000:2800:CF9FBE1D0C6AFC26560CAD98F261653B16B17BC36D5EB869A0E6992418019A5E.png\\\"' title='\\\"点击放大\\\"' width='\\\"1214.9550000000002\\\"'/></span></p> <p>根据以上数据对比发现，组件平铺和嵌套在相同组件个数的情况下，其性能差异不大，并且整体上趋势保持一致，随着组件数量增加呈现线性增长的劣化，由此可以得到结论，真正影响布局性能的因素是参与布局的节点数量。所以在进行布局时，应该尽量减少整体的节点数，来减少布局的性能劣化。</p> <p>针对减少总节点，主要有两个方向：</p> <ul> <li>移除冗余的节点。</li> <li>使用扁平化布局减少节点数。</li> </ul> <p><strong>移除冗余节点</strong></p> <p>对于常出现冗余的情况，例如可能会在Row容器包含一个同样也是Row容器的子级。这种嵌套实际是多余的，并且会给布局层次结构造成不必要的开销。</p> <pre class='\\\"screen\\\"'>Row() {\\n  Row(){\\n    Image()\\n    Text()\\n  }\\n  Image()\\n}</pre> <p>由于其中Row容器父子布局方向相同，所以可以去掉Image和Text外层的Row来减少层级，如果视图更加复杂，布局在渲染时，会产生没有必要的计算。</p> <pre class='\\\"screen\\\"'>Row() {\\n  Image()\\n  Text()\\n  Image()\\n}</pre> <p>尽管在这里只是多了一层，但是实际开发中的布局往往非常复杂，冗余带来的开销可能非常影响布局性能，尤其是在列表中动态创建组件时，带来的性能影响是显著的。</p> <p><strong>使用扁平化布局减少节点数</strong></p> <p>在某些情况下，开发者所实现的布局在嵌套层级上是没有冗余的，但是嵌套层级仍然较深，可能无法通过调整现有的布局方案，使其不包含多余的布局，唯一的解决方案可能是，通过切换到完全不同的布局类型来实现层次结构的扁平化。</p> <p>例如图1中元素结构示意图，传统使用线性布局的情况下，总共存在4层嵌套、共15个节点，并且其中并没有冗余的嵌套节点。而扁平化布局是一种让页面结构变浅变宽的方式，通过一些高级组件如RelativeContainer、Grid等容器，可以让元素在平面上展开。这种布局方式能够有效减少由于使用线性布局带来的嵌套深度，将其用于描述布局的容器节点进行优化，达到精简节点数的目的。图一中将线性布局改成相对布局的情况下，嵌套2层、总共10个节点，相比之下前后少了5个节点。</p> <div class='\\\"fignone\\\"'> <span class='\\\"figcap\\\"'><b>图1 </b>扁平化布局示意图</span><br/><span><img height='\\\"145.4355\\\"' originheight='\\\"400\\\"' originwidth='\\\"2000\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161106.49005155225595193717916189030761:50001231000000:2800:FEE1AB2A4714A91631528509F9986E131D73BB0F8FE3CCA62FA769517E594E16.png\\\"' title='\\\"点击放大\\\"' width='\\\"727.1775\\\"'/></span> </div> <p>这种方式对于布局的影响主要体现在：</p> <ol> <li>页面创建时，扁平化减少了中间的嵌套层级，使总的组件节点的数量越少，在进行布局时所需要进行的计算相对越少。</li> <li>页面更新时，当要更新的结构是嵌套子树的结构，其树内包含过多节点时，整体更新会导致更新的节点数过多，造成布局性能劣化。</li> </ol> <p>所以当页面不存在冗余节点时，可以考虑是否能够通过替换为更高级的布局使得页面扁平化，来达到减少节点数的目的。主要方式可以参考：</p> <ul> <li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-relative-layout\\\"' target='\\\"_blank\\\"'>RelativeContainer</a> 通过相对布局实现扁平化。</li> <li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-location#position\\\"' target='\\\"_blank\\\"'>绝对定位</a> 通过锚点定位实现扁平化。</li> <li><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-grid\\\"' target='\\\"_blank\\\"'>Grid</a> 通过二维布局实现扁平化。</li> </ul> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-improve-layout-performance.html"
    },
    {
        "id": 420,
        "pre": "Column() {\\n  Button(\\\"修改宽度\\\").onClick(() => {\\n    this.testWidth = '90%'\\n  }).height('20%')\\n\\n  Row() {\\n    // 400条文本数据\\n  }\\n}.width(this.testWidth )",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "      我们通过修改以下示例代码中Column的宽度，对比给Row设置固定宽度.width(300).height(400)、百分比.width('100%').height('70%')以及不设置宽高的情况下的页面绘制、Measure、Layout时间。       ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>      我们通过修改以下示例代码中Column的宽度，对比给Row设置固定宽度.width(300).height(400)、百分比.width('100%').height('70%')以及不设置宽高的情况下的页面绘制、Measure、Layout时间。       </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-improve-layout-performance.html"
    },
    {
        "id": 421,
        "pre": " Row() {\\n    Text(\\\"Hello World\\\")\\n    if(this.visible) {\\n      Column() {\\n        ... // 100个Image组件\\n      }\\n    }\\n  }",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]合理控制元素显示与隐藏",
        "parent_text": "  [h2]合理控制元素显示与隐藏 控制元素显示与隐藏是一种常见的场景，使用Visibility.None、if条件判断等都能够实现该效果。其中if条件判断控制的是组件的创建、布局阶段，visibility属性控制的是元素在布局阶段是否参与布局渲染。使用时如果使用的方式不当，将引起性能上的问题。 对于不同的场景下，需要选择合适的手段，根据性能或者内存要求选择不同的实现方式：  只有初始的一次渲染或者交互次数很少的情况下，建议使用if条件判断来控制元素的显示与隐藏效果，对于内存有较大提升。 如果会频繁响应显示与隐藏的交互效果，建议使用切换Visibility.None和Visibility.Visible来控制元素显示与隐藏，提高性能。  通过对一个复杂的视图结构，例如以下示例代码中，对包含100个Image组件的Column容器进行显示与隐藏控制，分别采用if条件判断和visibility属性的方式进行控制。        通过visibility属性控制的示例代码如下：       Row() {\\n    Text(\\\"Hello World\\\")\\n    Column() {\\n      ... // 100个Image组件\\n    }.visibility(this.visible?Visibility.Visible:Visibility.None)\\n  }  在相同的测试环境下，分别测试在初次加载页面，以及改变状态变量this.visible的值来修改显示隐藏的情况下，通过Profiler工具抓取的布局时Measure、Layout以及组件创建的时长。 在初次加载的情况下的测试结果如下：    表3 使用if/else和visibility属性控制显隐的布局时间对比    对比指标 if判断条件为true if判断条件为false Visibility.Visible Visibility.None    组件创建时间 13.67ms 3.83ms 13.38ms 13.26ms   Measure 2.83ms 0.92ms 2.58ms 2.24ms   Layout 3.79ms 0.30ms 2.14ms 0.39ms        以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。   通过以上数据可以发现：  通过if条件判断控制显示与隐藏的方式：        对比判断值为true和false时，初次加载过程中Measure、Layout时间明显存在区别，并且从组件创建时间可以判断，加载时会根据初始值判断是否创建对应组件内容。 当条件为false时，对应的组件内容不参与创建、Measure和Layout阶段。  通过visibility控制显示与隐藏的方式：        在初次加载时，无论visibility的值为Visibility.None还是Visibility.Visible都会创建对应组件内容。 visibility属性控制的是Measure和Layout阶段，当visibility属性为Visibility.None时，对应的组件不参与Layout。   在切换显示状态的情况下的结果如下：    表4 使用if条件判断和visibility控制显隐的Measure/Layout时间对比    对比指标 if判断条件为true if判断条件为false Visibility.Visible Visibility.None    组件创建时间 13.67ms 3.83ms \\\\ \\\\   Measure 3.10ms 0.13ms 0.19ms 0.10ms   Layout 1.64ms 0.60ms 0.27ms 0.07ms        以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。   在切换显示状态的情况下：  使用if条件判断切换显示时，组件会因为条件改变而判断是否参与创建、布局过程，切换过程会出现较大的Measure的性能消耗，原因是创建了新的组件，重新进行了Measure和Layout的过程。   使用visibility的情况下，无论是否隐藏，组件在初次已经创建完成，并一直都存在组件树上，不会出现组件重新创建的过程，并且在Measure和Layout阶段的性能消耗比使用if/else的方式性能小很多，原因是组件的计算在首帧时已经计算过，不需要重复计算。  综上所述，在控制组件显示与隐藏时，建议遵循以下原则来选择使用控制方式：  在对性能要求较高，并且会频繁切换元素的显示与隐藏的情况下，应该避免使用if条件判断，而改为通过visibility的属性控制，这样在切换Visibility.None和Visibility.Visible时，可以省去组件创建的时间，直接进入渲染过程。 如果组件的创建非常消耗资源，且不会立即使用，也并非频繁切换交互的情况下，只在特定条件下才会出现时，可以通过if/else来进行内容的显示与隐藏控制，来达到懒加载的效果。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section14111154271\\\"'> <a name='\\\"section14111154271\\\"'></a><a name='\\\"section14111154271\\\"'></a> <h4>[h2]合理控制元素显示与隐藏</h4> <p>控制元素显示与隐藏是一种常见的场景，使用Visibility.None、if条件判断等都能够实现该效果。其中if条件判断控制的是组件的创建、布局阶段，visibility属性控制的是元素在布局阶段是否参与布局渲染。使用时如果使用的方式不当，将引起性能上的问题。</p> <p>对于不同的场景下，需要选择合适的手段，根据性能或者内存要求选择不同的实现方式：</p> <ul> <li>只有初始的一次渲染或者交互次数很少的情况下，建议使用if条件判断来控制元素的显示与隐藏效果，对于内存有较大提升。</li> <li>如果会频繁响应显示与隐藏的交互效果，建议使用切换Visibility.None和Visibility.Visible来控制元素显示与隐藏，提高性能。</li> </ul> <p>通过对一个复杂的视图结构，例如以下示例代码中，对包含100个Image组件的Column容器进行显示与隐藏控制，分别采用if条件判断和visibility属性的方式进行控制。</p>  <div class='\\\"p\\\"'>      通过visibility属性控制的示例代码如下：      <pre class='\\\"screen\\\"'> Row() {\\n    Text(\\\"Hello World\\\")\\n    Column() {\\n      ... // 100个Image组件\\n    }.visibility(this.visible?Visibility.Visible:Visibility.None)\\n  }</pre> </div> <p>在相同的测试环境下，分别测试在初次加载页面，以及改变状态变量this.visible的值来修改显示隐藏的情况下，通过Profiler工具抓取的布局时Measure、Layout以及组件创建的时长。</p> <p>在初次加载的情况下的测试结果如下：</p> <div class='\\\"tablenoborder\\\"'> <table> <caption> <b>表3 </b><strong>使用if/else和visibility属性控制显隐的布局时间对比</strong> </caption> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.10.2.6.1.1\\\"' valign='\\\"top\\\"' width='\\\"22.694538907781556%\\\"'><p>对比指标</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.10.2.6.1.2\\\"' valign='\\\"top\\\"' width='\\\"18.55371074214843%\\\"'><p>if判断条件为true</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.10.2.6.1.3\\\"' valign='\\\"top\\\"' width='\\\"19.89397879575915%\\\"'><p>if判断条件为false</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.10.2.6.1.4\\\"' valign='\\\"top\\\"' width='\\\"19.02380476095219%\\\"'><p>Visibility.Visible</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.10.2.6.1.5\\\"' valign='\\\"top\\\"' width='\\\"19.83396679335867%\\\"'><p>Visibility.None</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.694538907781556%\\\"'><p>组件创建时间</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.55371074214843%\\\"'><p>13.67ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.89397879575915%\\\"'><p><strong>3.83ms</strong></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.02380476095219%\\\"'><p>13.38ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.83396679335867%\\\"'><p>13.26ms</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.694538907781556%\\\"'><p>Measure</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.55371074214843%\\\"'><p>2.83ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.89397879575915%\\\"'><p><strong>0.92ms</strong></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.02380476095219%\\\"'><p>2.58ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.83396679335867%\\\"'><p>2.24ms</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.694538907781556%\\\"'><p>Layout</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.55371074214843%\\\"'><p>3.79ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.89397879575915%\\\"'><p><strong>0.30ms</strong></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.02380476095219%\\\"'><p>2.14ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.83396679335867%\\\"'><p>0.39ms</p></td> </tr> </tbody></table> </div> <div class='\\\"note\\\"'> <img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161106.54963933913003640300275626495018:50001231000000:2800:A9B8B2C86B6276DA8CF2FFBAAB73827D75DC0102EC25C7853950942FF630E939.png\\\"'/><span class='\\\"notetitle\\\"'> </span> <div class='\\\"notebody\\\"'> <p>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</p> </div> </div> <p>通过以上数据可以发现：</p> <ul> <li>通过if条件判断控制显示与隐藏的方式：       <ul> <li>对比判断值为true和false时，初次加载过程中Measure、Layout时间明显存在区别，并且从组件创建时间可以判断，加载时会根据初始值判断是否创建对应组件内容。</li> <li>当条件为false时，对应的组件内容不参与创建、Measure和Layout阶段。</li> </ul></li> <li>通过visibility控制显示与隐藏的方式：       <ul> <li>在初次加载时，无论visibility的值为Visibility.None还是Visibility.Visible都会创建对应组件内容。</li> <li>visibility属性控制的是Measure和Layout阶段，当visibility属性为Visibility.None时，对应的组件不参与Layout。</li> </ul></li> </ul> <p>在切换显示状态的情况下的结果如下：</p> <div class='\\\"tablenoborder\\\"'> <table> <caption> <b>表4 </b><strong>使用if条件判断和visibility控制显隐的Measure/Layout时间对比</strong> </caption> <thead> <tr> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.15.2.6.1.1\\\"' valign='\\\"top\\\"' width='\\\"22.694538907781556%\\\"'><p>对比指标</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.15.2.6.1.2\\\"' valign='\\\"top\\\"' width='\\\"18.55371074214843%\\\"'><p>if判断条件为true</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.15.2.6.1.3\\\"' valign='\\\"top\\\"' width='\\\"19.89397879575915%\\\"'><p>if判断条件为false</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.15.2.6.1.4\\\"' valign='\\\"top\\\"' width='\\\"19.02380476095219%\\\"'><p>Visibility.Visible</p></th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.18.15.2.6.1.5\\\"' valign='\\\"top\\\"' width='\\\"19.83396679335867%\\\"'><p>Visibility.None</p></th> </tr> </thead> <tbody><tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.694538907781556%\\\"'><p>组件创建时间</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.55371074214843%\\\"'><p>13.67ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.89397879575915%\\\"'><p><strong>3.83ms</strong></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.02380476095219%\\\"'><p>\\\\</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.83396679335867%\\\"'><p>\\\\</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.694538907781556%\\\"'><p>Measure</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.55371074214843%\\\"'><p><strong>3.10ms</strong></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.89397879575915%\\\"'><p>0.13ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.02380476095219%\\\"'><p>0.19ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.83396679335867%\\\"'><p>0.10ms</p></td> </tr> <tr> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"22.694538907781556%\\\"'><p>Layout</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"18.55371074214843%\\\"'><p><strong>1.64ms</strong></p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.89397879575915%\\\"'><p>0.60ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.02380476095219%\\\"'><p>0.27ms</p></td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"19.83396679335867%\\\"'><p>0.07ms</p></td> </tr> </tbody></table> </div> <div class='\\\"note\\\"'> <img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161106.93361073623314640592823931542782:50001231000000:2800:D70D6F0F52BFECBF642DF67D475374FE87F17D86A456FA262BA13816F6671F35.png\\\"'/><span class='\\\"notetitle\\\"'> </span> <div class='\\\"notebody\\\"'> <p>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</p> </div> </div> <p>在切换显示状态的情况下：</p> <ul> <li>使用if条件判断切换显示时，组件会因为条件改变而判断是否参与创建、布局过程，切换过程会出现较大的Measure的性能消耗，原因是创建了新的组件，重新进行了Measure和Layout的过程。</li> </ul> <ul> <li>使用visibility的情况下，无论是否隐藏，组件在初次已经创建完成，并一直都存在组件树上，不会出现组件重新创建的过程，并且在Measure和Layout阶段的性能消耗比使用if/else的方式性能小很多，原因是组件的计算在首帧时已经计算过，不需要重复计算。</li> </ul> <p>综上所述，在控制组件显示与隐藏时，建议遵循以下原则来选择使用控制方式：</p> <ul> <li>在对性能要求较高，并且会频繁切换元素的显示与隐藏的情况下，应该避免使用if条件判断，而改为通过visibility的属性控制，这样在切换Visibility.None和Visibility.Visible时，可以省去组件创建的时间，直接进入渲染过程。</li> <li>如果组件的创建非常消耗资源，且不会立即使用，也并非频繁切换交互的情况下，只在特定条件下才会出现时，可以通过if/else来进行内容的显示与隐藏控制，来达到懒加载的效果。</li> </ul> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-improve-layout-performance.html"
    },
    {
        "id": 422,
        "pre": "// VisibleComponent/entry/src/main/ets/pages/Index.ets\\nimport { apng, ApngController } from '@ohos/apng';\\nimport { hilog } from '@kit.PerformanceAnalysisKit';\\n\\n@Entry\\n@Component\\nstruct RefreshExample {\\n  @State isRefreshing: boolean = false;\\n  @State isRunning: boolean = false;\\n  @State arr: string[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];\\n  controller: ApngController = new ApngController();\\n\\n  @Builder\\n  customRefreshComponent() {\\n    Stack() {\\n      Row() {\\n        Column() {\\n          apng({\\n            src: $r('app.media.stack'),\\n            controller: this.controller\\n          })\\n            .margin({ top: 40 })\\n        }\\n      }\\n      .alignItems(VerticalAlign.Center)\\n    }\\n    .align(Alignment.Center)\\n    .clip(true)\\n    .constraintSize({ minHeight: 32 })\\n    .width('100%')\\n  }\\n\\n  build() {\\n    Column() {\\n      Refresh({ refreshing: $$this.isRefreshing, builder: this.customRefreshComponent() }) {\\n        Scroll() {\\n          Column() {\\n            ImageAnimatorTest()\\n            ForEach(this.arr, (item: string) => {\\n              ListItem() {\\n                Text('' + item)\\n                  .height(80)\\n                  .fontSize(16)\\n                  .textAlign(TextAlign.Center)\\n                  .fontColor(0xF1F3F5)\\n              }\\n            }, (item: string) => item)\\n          }\\n        }\\n        .scrollBar(BarState.Off)\\n      }\\n      .backgroundColor(0xF1F3F5)\\n      .pullToRefresh(true)\\n      .refreshOffset(64)\\n      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])\\n      // Use onStateChange and apngcontroller to control play and stop\\n      .onStateChange((refreshStatus: RefreshStatus) => {\\n        if (refreshStatus >= 1 && refreshStatus < 4) {\\n          this.controller.play();\\n        } else {\\n          this.controller.stop();\\n        }\\n        hilog.info(0x0000, 'testTag', 'Refresh onStatueChange state is ' + refreshStatus);\\n      })\\n      .onRefreshing(() => {\\n        setTimeout(() => {\\n          this.isRefreshing = false;\\n        }, 2000)\\n        hilog.info(0x0000, 'testTag', 'onRefreshing test')\\n      })\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "getUIContext()",
        "function_name": "开发参考",
        "parent_text": "开发参考 表1 当前推荐用于预防组件进入不可见状态后依然空跑的问题大致有两种思路   监听法：监听容器状态，传递关键变量  可见法：通过组件可见性计算，判断显示/隐藏时机    原理简介  通过监听一些有明显特征的容器组件的一些相关事件，触发回调并修改状态变量或动画控制器，例如： Navigation容器下onHidden()/onShown()，tab的onChange()Refresh的onStateChange() 当触发这些回调时，通过修改状态变量的方式，控制容器内动图、动效组件的播放/停止。  组件的显示状态决定了它是否出现在屏幕上，是否需要进行刷新与绘制。可以通过绑定回调接口（如onVisibleAreaChange()或setOnVisibleAreaApproximateChange()），让其在显示/隐藏时回调，开发者可以在回调中实现对动图或动效组件的播放/停止控制。    开发优势  稳定可靠，能够对特定页面的动画动效根据具体的用户行为进行管控，同时接口回调不需要额外的计算负载，对性能十分友好。  该接口可以与组件一起封装使用，易于开发、维护。 组件结构正常深度情况下，算法负载不影响性能。   不适用场景  当场景内所有的动画、动效规格可能发生变化的情况下，例如动画框架与业务开发分离，同一页面下可能存在不同类型、不同数量的动画时，变量的传递变得难以定位，不推荐用该方法。  该接口依赖可见性算法，当组件并非被一个来自其父组件的组件遮挡时，会存在无法使能的场景： 被兄弟节点盖住不通知Stack堆叠不通知，z序被遮挡不通知 在此类情况下，当动画在可视区域上显示/隐藏时，回调不会触发。     需额外留意的是，当前系统为了便利开发者，对一些常用的动图，内置了可见性接口防止其空跑，如lottie库版本在2.0.14及以上、apng库版本在1.1.2及以上。若开发者并未对此类三方动画库的播放控制进行封装、修改，可直接通过更新库来避免不可见时的空跑问题。若有对此类三方动画库的播放控制进行封装、修改，则建议按照本文提到的方法进行修改。下面展示监听法与可见法的经典示例： 方法1-监听法：下方展示了一个列表组件下拉刷新时，管理刷新动画的不可见现象的场景。有一个用Canvas实现的apng组件，置于Refresh组件中，默认处于隐藏状态。留意到Refresh组件有多种状态可以监听，故添加onStateChange()方法，监听RefreshStatus值。当Refresh组件处于收起状态时，对应RefreshStatus中的0和4，此时控制apngcontroller停止播放动画，而当RefreshStatus处于拉起、回弹等状态时，对应RefreshStatus的1、2和3，此时播放该动画。  方法2-可见法：下方展示了用一个ImageAnimator实现的动画组件，通过duration设置多个Pixelmap循环播放的案例，例如，当这个组件被放置在一个Scroll容器时，为了应对该组件可能会划出屏幕而导致的不可见空跑的问题，可以通过可见性接口的办法监听组件移出屏幕的事件，从而修改动画播放状态，以达到控制空跑的目的。下方给出了几种可供开发者参考的实现方式来接入可见性接口，接入的位置和方法有所不同，开发者选择一种即可： onVisibleAreaChange()：可直接绑定至组件，当组件可见时每帧进行一次可见性计算，当计算结果达到阈值时触发回调。setOnVisibleAreaApproximateChange()是onVisibleAreaChange()的低频优化版，可以通过参数设置执行可见性计算的周期，如下方案例中设置expectedUpdateInterval为500ms。 需注意，由于onVisibleAreaChange()在可见时会每帧进行一次计算检测，当组件量较大、节点数较深且帧率较高时，使用setOnVisibleAreaApproximateChange()可以减少计算负载，获得可观的性能和功耗收益。// VisibleComponent/entry/src/main/ets/pages/Index.ets\\n@Component\\nstruct ImageAnimatorTest {\\n  private uid: number = -1;\\n  private index: number = 0;\\n  @State running: boolean = false;\\n  @State animState: AnimationStatus = AnimationStatus.Initial;\\n\\n  // Method 1: use aboutToAppear to register a setOnVisibleAreaApproximateChange\\n  aboutToAppear(): void {\\n    this.uid = this.getUniqueId();\\n    hilog.info(0x0000, 'testTag', `getUniqueId in ImageAnimatorTest aboutAppear is ${this.uid}`);\\n    let node = this.getUIContext().getFrameNodeByUniqueId(this.uid);\\n    node?.commonEvent.setOnVisibleAreaApproximateChange(\\n      { ratios: [0], expectedUpdateInterval: 500 },\\n      (isVisible, currentRatio) => {\\n        hilog.info(0x0000, 'testTag',\\n          `Method aboutToAppear: setOnVisibleAreaApproximateChange isVisible:${isVisible}, currentRatio:${currentRatio}`);\\n        this.running = isVisible;\\n      })\\n  }\\n\\n  build() {\\n    Column() {\\n      ImageAnimator()\\n        .images([\\n          { src: $r('app.media.background') },\\n          { src: $r('app.media.foreground') }\\n        ])\\n        .id(`ImageAnimator${this.index}}`)\\n        .width('100%')\\n        .height('30%')\\n        .duration(3000)\\n        .fillMode(FillMode.None)\\n        .iterations(-1)\\n        .state(this.running ? AnimationStatus.Running :\\n        AnimationStatus.Paused)// Method 2: Directly use onVisibleAreaChange\\n        .onVisibleAreaChange([0.0, 1.0], (isVisible: boolean, currentRatio: number) => {\\n          hilog.info(0x0000, 'testTag',\\n            `Method Direct: onVisibleAreaChange isVisible:${isVisible}, currentRatio:${currentRatio}`);\\n          if (isVisible && currentRatio >= 1.0) {\\n            this.running = true;\\n          }\\n          if (!isVisible && currentRatio <= 0.0) {\\n            this.running = false;\\n          }\\n        })// Method 3: use onAppear to register a setOnVisibleAreaApproximateChange\\n        .onAppear(() => {\\n          let node = this.getUIContext().getFrameNodeById(`ImageAnimator${this.index}`);\\n          node?.commonEvent.setOnVisibleAreaApproximateChange(\\n            { ratios: [0], expectedUpdateInterval: 500 },\\n            (isVisible, currentRatio) => {\\n              this.running = isVisible;\\n              hilog.info(0x0000, 'testTag',\\n                `Method onAppear: setOnVisibleAreaApproximateChange isVisible:${isVisible}, currentRatio:${currentRatio}`);\\n            }\\n          )\\n        })\\n    }\\n  }\\n}  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section23191023416\\\"'><a name='\\\"section23191023416\\\"'></a><a name='\\\"section23191023416\\\"'></a><h4>开发参考</h4> <div class='\\\"tablenoborder\\\"'><table><caption><b>表1 </b>当前推荐用于预防组件进入不可见状态后依然空跑的问题大致有两种思路</caption><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.2.2.4.1.1\\\"' valign='\\\"top\\\"' width='\\\"7.4007400740074%\\\"'>  </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.2.2.4.1.2\\\"' valign='\\\"top\\\"' width='\\\"43.204320432043204%\\\"'><p><strong>监听法</strong>：监听容器状态，传递关键变量</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.3.2.2.4.1.3\\\"' valign='\\\"top\\\"' width='\\\"49.394939493949394%\\\"'><p><strong>可见法</strong>：通过组件可见性计算，判断显示/隐藏时机</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.4007400740074%\\\"'><p>原理简介</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"43.204320432043204%\\\"'><p>通过监听一些有明显特征的容器组件的一些相关事件，触发回调并修改状态变量或动画控制器，例如：</p> <ol><li>Navigation容器下onHidden()/onShown()，</li><li>tab的onChange()</li><li>Refresh的onStateChange()</li></ol> <p>当触发这些回调时，通过修改状态变量的方式，控制容器内动图、动效组件的播放/停止。</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"49.394939493949394%\\\"'><p>组件的显示状态决定了它是否出现在屏幕上，是否需要进行刷新与绘制。可以通过绑定回调接口（如onVisibleAreaChange()或setOnVisibleAreaApproximateChange()），让其在显示/隐藏时回调，开发者可以在回调中实现对动图或动效组件的播放/停止控制。</p> <p></p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.4007400740074%\\\"'><p>开发优势</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"43.204320432043204%\\\"'><p>稳定可靠，能够对特定页面的动画动效根据具体的用户行为进行管控，同时接口回调不需要额外的计算负载，对性能十分友好。</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"49.394939493949394%\\\"'><p>该接口可以与组件一起封装使用，易于开发、维护。</p> <p>组件结构正常深度情况下，算法负载不影响性能。</p> </td> </tr> <tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"7.4007400740074%\\\"'><p>不适用场景</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"43.204320432043204%\\\"'><p>当场景内所有的动画、动效规格可能发生变化的情况下，例如动画框架与业务开发分离，同一页面下可能存在不同类型、不同数量的动画时，变量的传递变得难以定位，不推荐用该方法。</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"49.394939493949394%\\\"'><p>该接口依赖可见性算法，当组件并非被一个来自其父组件的组件遮挡时，会存在无法使能的场景：</p> <ol><li>被兄弟节点盖住不通知</li><li>Stack堆叠不通知，z序被遮挡不通知</li></ol> <p>在此类情况下，当动画在可视区域上显示/隐藏时，回调不会触发。</p> </td> </tr> </tbody></table> </div> <p>需额外留意的是，当前系统为了便利开发者，对一些常用的动图，内置了可见性接口防止其空跑，如lottie库版本在2.0.14及以上、apng库版本在1.1.2及以上。若开发者并未对此类三方动画库的播放控制进行封装、修改，可直接通过更新库来避免不可见时的空跑问题。若有对此类三方动画库的播放控制进行封装、修改，则建议按照本文提到的方法进行修改。下面展示监听法与可见法的经典示例：</p> <p><strong>方法1-监听法：</strong>下方展示了一个列表组件下拉刷新时，管理刷新动画的不可见现象的场景。有一个用Canvas实现的apng组件，置于Refresh组件中，默认处于隐藏状态。留意到Refresh组件有多种状态可以监听，故添加onStateChange()方法，监听RefreshStatus值。当Refresh组件处于收起状态时，对应RefreshStatus中的0和4，此时控制apngcontroller停止播放动画，而当RefreshStatus处于拉起、回弹等状态时，对应RefreshStatus的1、2和3，此时播放该动画。</p>  <p><strong>方法2-可见法：</strong>下方展示了用一个ImageAnimator实现的动画组件，通过duration设置多个Pixelmap循环播放的案例，例如，当这个组件被放置在一个Scroll容器时，为了应对该组件可能会划出屏幕而导致的不可见空跑的问题，可以通过可见性接口的办法监听组件移出屏幕的事件，从而修改动画播放状态，以达到控制空跑的目的。下方给出了几种可供开发者参考的实现方式来接入可见性接口，接入的位置和方法有所不同，开发者选择一种即可：</p> <ol><li>onVisibleAreaChange()：可直接绑定至组件，当组件可见时每帧进行一次可见性计算，当计算结果达到阈值时触发回调。</li><li>setOnVisibleAreaApproximateChange()是onVisibleAreaChange()的低频优化版，可以通过参数设置执行可见性计算的周期，如下方案例中设置expectedUpdateInterval为500ms。</li></ol> <div class='\\\"p\\\"'>需注意，由于onVisibleAreaChange()在可见时会每帧进行一次计算检测，当组件量较大、节点数较深且帧率较高时，使用setOnVisibleAreaApproximateChange()可以减少计算负载，获得可观的性能和功耗收益。<pre class='\\\"screen\\\"'>// VisibleComponent/entry/src/main/ets/pages/Index.ets\\n@Component\\nstruct ImageAnimatorTest {\\n  private uid: number = -1;\\n  private index: number = 0;\\n  @State running: boolean = false;\\n  @State animState: AnimationStatus = AnimationStatus.Initial;\\n\\n  // Method 1: use aboutToAppear to register a setOnVisibleAreaApproximateChange\\n  aboutToAppear(): void {\\n    this.uid = this.getUniqueId();\\n    hilog.info(0x0000, 'testTag', `getUniqueId in ImageAnimatorTest aboutAppear is ${this.uid}`);\\n    let node = this.getUIContext().getFrameNodeByUniqueId(this.uid);\\n    node?.commonEvent.setOnVisibleAreaApproximateChange(\\n      { ratios: [0], expectedUpdateInterval: 500 },\\n      (isVisible, currentRatio) =&gt; {\\n        hilog.info(0x0000, 'testTag',\\n          `Method aboutToAppear: setOnVisibleAreaApproximateChange isVisible:${isVisible}, currentRatio:${currentRatio}`);\\n        this.running = isVisible;\\n      })\\n  }\\n\\n  build() {\\n    Column() {\\n      ImageAnimator()\\n        .images([\\n          { src: $r('app.media.background') },\\n          { src: $r('app.media.foreground') }\\n        ])\\n        .id(`ImageAnimator${this.index}}`)\\n        .width('100%')\\n        .height('30%')\\n        .duration(3000)\\n        .fillMode(FillMode.None)\\n        .iterations(-1)\\n        .state(this.running ? AnimationStatus.Running :\\n        AnimationStatus.Paused)// Method 2: Directly use onVisibleAreaChange\\n        .onVisibleAreaChange([0.0, 1.0], (isVisible: boolean, currentRatio: number) =&gt; {\\n          hilog.info(0x0000, 'testTag',\\n            `Method Direct: onVisibleAreaChange isVisible:${isVisible}, currentRatio:${currentRatio}`);\\n          if (isVisible &amp;&amp; currentRatio &gt;= 1.0) {\\n            this.running = true;\\n          }\\n          if (!isVisible &amp;&amp; currentRatio &lt;= 0.0) {\\n            this.running = false;\\n          }\\n        })// Method 3: use onAppear to register a setOnVisibleAreaApproximateChange\\n        .onAppear(() =&gt; {\\n          let node = this.getUIContext().getFrameNodeById(`ImageAnimator${this.index}`);\\n          node?.commonEvent.setOnVisibleAreaApproximateChange(\\n            { ratios: [0], expectedUpdateInterval: 500 },\\n            (isVisible, currentRatio) =&gt; {\\n              this.running = isVisible;\\n              hilog.info(0x0000, 'testTag',\\n                `Method onAppear: setOnVisibleAreaApproximateChange isVisible:${isVisible}, currentRatio:${currentRatio}`);\\n            }\\n          )\\n        })\\n    }\\n  }\\n}</pre> </div> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/low-power-consumption-suggestions.html"
    },
    {
        "id": 423,
        "pre": "\\\"arkOptions\\\": {\\n  \\\"obfuscation\\\": {\\n    \\\"ruleOptions\\\": {\\n      \\\"enable\\\": true  // 配置true，即可开启代码混淆功能\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "混淆开启",
        "parent_text": "混淆开启从DevEco Studio版本：4.0 Beta1开始hvigor插件提供代码混淆功能。混淆开启条件如下： 工程为Stage模型在Release编译模式下模块build-profile.json5文件中开启混淆配置   enable默认为false，默认不开启代码混淆功能。  满足上述开启混淆条件后，选择目标模块点击Build -> Make Module选项开始编译。 如果你的工程或者模块是Static Library，那么该工程或模块是一个HAR。 构建HAR时有以下三种方式： 以Debug模式构建HAR，会直接将源码打包，同时不会进行代码混淆。以Release模式构建HAR，会对代码进行编译、混淆及压缩处理。构建字节码格式的HAR，开启混淆时编译过程中的源码中间文件会被混淆，然后编译器以混淆后的代码生成abc字节码。 图1 DevEco Studio选择release编译模式  图2 DevEco Studio指定模块编译  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section13780943192313\\\"'><a name='\\\"section13780943192313\\\"'></a><a name='\\\"section13780943192313\\\"'></a><h4>混淆开启</h4><p>从DevEco Studio版本：4.0 Beta1开始hvigor插件提供代码混淆功能。混淆开启条件如下：</p> <ul><li>工程为Stage模型</li><li>在Release编译模式下</li><li>模块build-profile.json5文件中开启混淆配置</li></ul>  <div class='\\\"caution\\\"'><span class='\\\"cautiontitle\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161229.50629638040018303759039051091600:50001231000000:2800:5C41CF7A452F351454481918B1C1CA8F5C6186CC9EE74B798BC64E535C41157C.png\\\"'/> </span><div class='\\\"cautionbody\\\"'><p>enable默认为false，默认不开启代码混淆功能。</p> </div></div> <p>满足上述开启混淆条件后，选择目标模块点击Build -&gt; Make Module选项开始编译。</p> <p>如果你的工程或者模块是Static Library，那么该工程或模块是一个HAR。</p> <p><a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-build-har#section16598338112415\\\"' target='\\\"_blank\\\"'>构建HAR</a>时有以下三种方式：</p> <ol><li>以Debug模式构建HAR，会直接将源码打包，同时不会进行代码混淆。</li><li>以Release模式构建HAR，会对代码进行编译、混淆及压缩处理。</li><li>构建字节码格式的HAR，开启混淆时编译过程中的源码中间文件会被混淆，然后编译器以混淆后的代码生成abc字节码。</li></ol> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图1 </b>DevEco Studio选择release编译模式</span></div> <p><span><img height='\\\"386.0325\\\"' originheight='\\\"407\\\"' originwidth='\\\"552\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161229.32081106507147982653688696402251:50001231000000:2800:6B042C0CDFA35AB15A07A3F566A58969C122F4904C80F2032EB4A3F8A0109A38.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图2 </b>DevEco Studio指定模块编译</span></div> <p><span><img height='\\\"251.35670000000002\\\"' originheight='\\\"621\\\"' originwidth='\\\"1299\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161229.39569016090082557494549995929794:50001231000000:2800:AFEBD9908A418FB712429C861ADEF9A4D6C38C95823B2563963822E3B351B5B7.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-code-ob.html"
    },
    {
        "id": 424,
        "pre": "let `listRules` 表示上面提到的所有混淆规则文件的列表\\nlet finalRule = {\\n    disableObfuscation: false,\\n    enablePropertyObfuscation: false,\\n    keepPropertyName: [],\\n    printNamecache: string,\\n}\\nfor each file in `listRules`:\\n    for each option in file:\\n        switch(option) {\\n            case -disable-obfuscation:\\n                finalRule.disableObfuscation = true;\\n                continue;\\n            case -enable-property-obfuscation:\\n                finalRule.enablePropertyObfuscation = true;\\n                continue;\\n            case -keep-property-name:\\n                finalRule.keepPropertyName.push(#{指定的名称});\\n                continue;\\n            case -print-namecache:\\n                finalRule.printNamecache = #{指定的路径名};\\ncase -keep-dts:\\n                finalRule.keepDts.push(#{指定的路径});\\n                continue;\\n        }\\n    end-for\\nend-for",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]混淆规则合并策略",
        "parent_text": "[h2]混淆规则合并策略编译工程中的某个模块时，其最终所应用的混淆规则是来自以下三个地方文件中配置的混淆规则的合并: 被编译模块的build-profile.json5文件中ruleOptions.files字段指定的文件本地依赖的library中的consumerFiles选项中指定的文件远程依赖的HAR包中的obfuscation.txt文件 HAR模块的build-profile.json5中consumerFiles配置了共享混淆配置文件，该文件生效条件： HAR模块被依赖HAR模块开启混淆 图5 HAR模块的共享混淆配置文件consumer-rules.txt 图6 远程HAR包中obfuscation.txt文件 合并规则（以下面四个选项为例，其它选项合并规则与其一致）：  布尔型选项使用或运算进行合并，即存在配置文件中开启此选项，则此选项生效。名单类型中的白名单列表会进行合并输出与复用nameCache文件路径会被覆盖-keep-dts文件中的白名单分别被收集，然后合并白名单 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1842224516252\\\"'><a name='\\\"section1842224516252\\\"'></a><a name='\\\"section1842224516252\\\"'></a><h4>[h2]混淆规则合并策略</h4><p>编译工程中的某个模块时，其最终所应用的混淆规则是来自以下三个地方文件中配置的混淆规则的合并:</p> <ul><li>被编译模块的build-profile.json5文件中ruleOptions.files字段指定的文件</li><li>本地依赖的library中的consumerFiles选项中指定的文件</li><li>远程依赖的HAR包中的obfuscation.txt文件</li></ul> <p>HAR模块的build-profile.json5中consumerFiles配置了共享混淆配置文件，该文件生效条件：</p> <ul><li>HAR模块被依赖</li><li>HAR模块开启混淆</li></ul> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图5 </b>HAR模块的共享混淆配置文件consumer-rules.txt</span><br/><span><img height='\\\"312.21750000000003\\\"' originheight='\\\"538\\\"' originwidth='\\\"900\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161229.58069744630076181473743384428012:50001231000000:2800:4F93C0FD3317C0DBD8ECEA8257DC038344ED0B7C308335AE06D1BEADED4F737E.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></div> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图6 </b>远程HAR包中obfuscation.txt文件</span><br/><span><img height='\\\"191.52\\\"' originheight='\\\"261\\\"' originwidth='\\\"710\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161229.79017463171437719993433374628451:50001231000000:2800:26E2A2606C52545CA91E96C7F7EB06A981447CA8F5FAA302BBBDADF93975C0EB.png\\\"' title='\\\"点击放大\\\"' width='\\\"523.6875\\\"'/></span></div> <p>合并规则（以下面四个选项为例，其它选项合并规则与其一致）：</p>  <ul><li>布尔型选项使用或运算进行合并，即存在配置文件中开启此选项，则此选项生效。</li><li>名单类型中的白名单列表会进行合并</li><li>输出与复用nameCache文件路径会被覆盖</li><li>-keep-dts文件中的白名单分别被收集，然后合并白名单</li></ul> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-app-code-ob.html"
    },
    {
        "id": 425,
        "pre": "# Compile and link third-party SO libraries\\ntarget_link_libraries(entry PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libs/${OHOS_ARCH}/libnativeAdd.so)",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "修改src/main/cpp目录下CMakeLists.txt文件配置，使用target_link_libraries命令将需要预加载的加法so库链接到项目中。 ",
        "import_module": null,
        "parent": "<li>修改src/main/cpp目录下CMakeLists.txt文件配置，使用target_link_libraries命令将需要预加载的加法so库链接到项目中。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-dynamic-link-library.html"
    },
    {
        "id": 426,
        "pre": "// src/main/ets/pages/index.ets\\nimport testNapi from 'libentry.so';\\n\\nlet projectPath = getContext(this).bundleCodeDir; // 获取项目路径\\nlet abiPath = deviceInfo.abiList === 'x86_64' ? 'x86_64' : 'arm64';\\nlet soLibPath = `${projectPath}/libs/${abiPath}/libnativeSub.so`; // 获取so库沙箱路径",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在ArkTS侧将so库的沙箱路径传递至Native侧。 此处需要使用so库的沙箱路径，而不是其真实路径。   ",
        "import_module": null,
        "parent": "<li>在ArkTS侧将so库的<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-sandbox-directory\\\"' target='\\\"_blank\\\"'>沙箱路径</a>传递至Native侧。<div class='\\\"note\\\"'><img originheight='\\\"38\\\"' originwidth='\\\"102\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161153.97802899464208276383747295381265:50001231000000:2800:7273385799E69492B52C3EBCDD7329A32C7302C43B2F12CB5BEAAD66316DF3E5.png\\\"'/><span class='\\\"notetitle\\\"'> </span><div class='\\\"notebody\\\"'><p>此处需要使用so库的沙箱路径，而不是其真实路径。</p> </div></div>  </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-dynamic-link-library.html"
    },
    {
        "id": 427,
        "pre": "// src/main/cpp/CMakeLists.txt\\ninclude_directories(${NATIVERENDER_ROOT_PATH}/../../..)  // 添加entry根目录\\ntarget_link_libraries(entry PUBLIC ${NATIVERENDER_ROOT_PATH}/../../../libnativeAdd.so)  // 修改加法so库路径",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]在集成三方so库时，.so库文件和.h头文件一定要置于上述方法的路径下吗？",
        "parent_text": "[h2]在集成三方so库时，.so库文件和.h头文件一定要置于上述方法的路径下吗？不一定。原则上.so库文件和.h头文件可以置于需要引用so库的工程目录的任意位置，但是需要在工程的CMakeLists.txt文件中修改文件配置。如：将add.h头文件和libnativeAdd.so库文件放置在entry的根目录下，需要在CMakeLists.txt文件中通过include_directories命令添加entry的根目录作为头文件路径，并修改target_link_libraries命令中需要预加载的加法so库的路径，才能保证so库链接成功。 代码示例  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section15862162419491\\\"'><a name='\\\"section15862162419491\\\"'></a><a name='\\\"section15862162419491\\\"'></a><h4>[h2]在集成三方so库时，.so库文件和.h头文件一定要置于上述方法的路径下吗？</h4><p>不一定。原则上.so库文件和.h头文件可以置于需要引用so库的工程目录的任意位置，但是需要在工程的CMakeLists.txt文件中修改文件配置。如：将add.h头文件和libnativeAdd.so库文件放置在entry的根目录下，需要在CMakeLists.txt文件中通过include_directories命令添加entry的根目录作为头文件路径，并修改target_link_libraries命令中需要预加载的加法so库的路径，才能保证so库链接成功。</p> <p><strong>代码示例</strong></p>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-dynamic-link-library.html"
    },
    {
        "id": 428,
        "pre": "<template>\\n  <div>\\n    <embed\\n      id= \\\"embedId\\\"\\n      type=\\\"native/lottie\\\"\\n      :width=\\\"300\\\" :height=\\\"150\\\" />\\n  </div>\\n</template>\\n  \\n<script>\\nexport default {\\n  name: \\\"HlLottie\\\",\\n  props: {\\n    sourceJson: {\\n      type: String,\\n      required: false,\\n    },\\n  },\\n  // ...\\n  methods: {\\n    play() { /*..*/ },\\n  },\\n}\\n</script>",
        "type": "Reference",
        "function_call": "getFrameNode()",
        "function_name": "[h2]组件鸿蒙化",
        "parent_text": "[h2]组件鸿蒙化HarmonyOS提供同层渲染能力把原生组件直接渲染到WebView层级，从而获得更大的灵活性以及性能上获得更好表现。开发者可通过Web组件同层渲染相关属性来进行控制：enableNativeEmbedMode开关控制；onNativeEmbedLifecycleChange处理同层渲染生命周期：CREATE/UPDATE/DESTROY；onNativeEmbedGestureEvent处理交互事件。同层渲染功能要求前端页面文件中显式使用embed标签，并且embed标签内type必须以“native/”开头。使用Vue等框架可以方便地进一步封装embed标签生成自定义组件，并增加更多属性、事件和方法，通过JSBridge与ArkTS侧进行同步。在ArkTS侧，对应地需要自定义实现一个原生组件或者使用系统内置组件，通过NodeContainer组件进行动态挂载。同层渲染的原理如下： 开发角度：前端页面开发者使用<embed>标签来表示使用原生组件；应用开发者使用NodeContainer关联离屏节点树，使用makeNode接口在H5页面上渲染出组件。  离屏节点动态上下树：  1）开发者初始构建一个NodeContainer对象表示一个空的占位符。NodeContainer里面内容为空时，在初始化的时候大小为0，不参与布局。 2）NodeController持有buildnode对象，通过makeNode接口将buildnode对象 返回给NodeContainer，来实现动态上树。 3） NodeController里面rebuild方法，触发NodeContainer重新调用makeNode接口。 makeNode接口若返回空，则实现动态下树。 使用Vue框架结合embed标签示例：  在ArkTS侧，可以扩展NodeController来统一管理同层渲染节点。其makeNode接口实现示例如下： makeNode(uiContext: UIContext): FrameNode | null {\\n  if (this.rootNode === null) {\\n    // 动态下树\\n    return null;\\n  }\\n  if (!this.embedType || !this.componentId) {\\n    return null;\\n  }\\n  // 未定义根节点则创建\\n  if (!this.rootNode) {\\n    this.rootNode = new BuilderNode<[Object]>(uiContext, { surfaceId: this.surfaceId, type: this.renderType });\\n    if (nativeComponentBuilderMap.get(this.embedType)) {\\n      const wrapBuilder: WrappedBuilder<[Object]> = new WrappedBuilder(nativeComponentBuilderMap.get(this.embedType) as (...args: Object[]) => void);\\n      this.rootNode.build(wrapBuilder, sameLayerArgsMap.get(this.componentId));\\n    } else {\\n      return null;\\n    }\\n  }\\n\\n  // 动态上树\\n  return this.rootNode.getFrameNode();\\n} 实现中可以使用map容器把embedType和离屏节点的builder函数进行关联，当makeNode执行时，取出embedType对应的builder函数来创建rootNode节点，最后把rootNode节点关联的FrameNode返回，达到离屏节点动态上树、H5渲染出原生组件的效果。同层渲染可以参考文档《同层渲染绘制Video和Button组件》 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1566293815469\\\"'><a name='\\\"section1566293815469\\\"'></a><a name='\\\"section1566293815469\\\"'></a><h4>[h2]组件鸿蒙化</h4><p>HarmonyOS提供同层渲染能力把原生组件直接渲染到WebView层级，从而获得更大的灵活性以及性能上获得更好表现。开发者可通过Web组件同层渲染相关属性来进行控制：enableNativeEmbedMode开关控制；onNativeEmbedLifecycleChange处理同层渲染生命周期：CREATE/UPDATE/DESTROY；onNativeEmbedGestureEvent处理交互事件。同层渲染功能要求前端页面文件中显式使用embed标签，并且embed标签内type必须以“native/”开头。使用Vue等框架可以方便地进一步封装embed标签生成自定义组件，并增加更多属性、事件和方法，通过JSBridge与ArkTS侧进行同步。在ArkTS侧，对应地需要自定义实现一个原生组件或者使用系统内置组件，通过NodeContainer组件进行动态挂载。同层渲染的原理如下：</p> <p>开发角度：前端页面开发者使用&lt;embed&gt;标签来表示使用原生组件；应用开发者使用NodeContainer关联离屏节点树，使用makeNode接口在H5页面上渲染出组件。</p> <p><span><img originheight='\\\"348\\\"' originwidth='\\\"812\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161146.77766235202888366816166658098138:50001231000000:2800:F56EAB81F1456FA571783B44BD9CEF8BE86738F29E544E7FC4A07312A6F6CD55.png\\\"'/></span></p> <p>离屏节点动态上下树：</p> <p><span><img originheight='\\\"505\\\"' originwidth='\\\"758\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161146.11845178590457886503297736715217:50001231000000:2800:23AF715E33EB73BECA4FE828A44F344CA76D790D228970873A7C2A2D894945E1.png\\\"'/></span></p> <p>1）开发者初始构建一个NodeContainer对象表示一个空的占位符。NodeContainer里面内容为空时，在初始化的时候大小为0，不参与布局。</p> <p>2）NodeController持有buildnode对象，通过makeNode接口将buildnode对象 返回给NodeContainer，来实现动态上树。</p> <p>3） NodeController里面rebuild方法，触发NodeContainer重新调用makeNode接口。 makeNode接口若返回空，则实现动态下树。</p> <p>使用Vue框架结合embed标签示例：</p>  <p>在ArkTS侧，可以扩展NodeController来统一管理同层渲染节点。其makeNode接口实现示例如下：</p> <pre class='\\\"screen\\\"'>makeNode(uiContext: UIContext): FrameNode | null {\\n  if (this.rootNode === null) {\\n    // 动态下树\\n    return null;\\n  }\\n  if (!this.embedType || !this.componentId) {\\n    return null;\\n  }\\n  // 未定义根节点则创建\\n  if (!this.rootNode) {\\n    this.rootNode = new BuilderNode&lt;[Object]&gt;(uiContext, { surfaceId: this.surfaceId, type: this.renderType });\\n    if (nativeComponentBuilderMap.get(this.embedType)) {\\n      const wrapBuilder: WrappedBuilder&lt;[Object]&gt; = new WrappedBuilder(nativeComponentBuilderMap.get(this.embedType) as (...args: Object[]) =&gt; void);\\n      this.rootNode.build(wrapBuilder, sameLayerArgsMap.get(this.componentId));\\n    } else {\\n      return null;\\n    }\\n  }\\n\\n  // 动态上树\\n  return this.rootNode.getFrameNode();\\n}</pre> <p>实现中可以使用map容器把embedType和离屏节点的builder函数进行关联，当makeNode执行时，取出embedType对应的builder函数来创建rootNode节点，最后把rootNode节点关联的FrameNode返回，达到离屏节点动态上树、H5渲染出原生组件的效果。同层渲染可以参考文档《<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-same-layer\\\"' target='\\\"_blank\\\"'>同层渲染绘制Video和Button组件</a>》</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-arkweb_rendering_framework.html"
    },
    {
        "id": 429,
        "pre": "export abstract class NodeController {\\n  abstract makeNode(uiContext: UIContext): FrameNode | null;\\n  aboutToResize?(size: Size): void;\\n  aboutToAppear?(): void;\\n  aboutToDisappear?(): void;\\n  rebuild(): void;\\n  onTouchEvent?(event: TouchEvent): void;\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]NodeController生命周期",
        "parent_text": "[h2]NodeController生命周期NodeController用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用。下面，对其常用生命周期函数进行说明。 makeNode必须要重写的方法，用于构建节点树、返回节点挂载在对应NodeContainer中。在对应NodeContainer创建绑定当前NodeController的时候调用、或者通过rebuild方法调用刷新。aboutToResize当controller对应的NodeContainer在Mesure的时候进行回调，入参为节点的布局大小。aboutToAppear当controller对应的NodeContainer在onAppear的时候进行回调。aboutToDisappear当controller对应的NodeContainer在onDisappear的时候进行回调。  ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1839413474109\\\"'><a name='\\\"section1839413474109\\\"'></a><a name='\\\"section1839413474109\\\"'></a><h4>[h2]NodeController生命周期</h4><p>NodeController用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用。下面，对其常用生命周期函数进行说明。</p> <ul><li>makeNode必须要重写的方法，用于构建节点树、返回节点挂载在对应NodeContainer中。在对应NodeContainer创建绑定当前NodeController的时候调用、或者通过rebuild方法调用刷新。</li><li><span>aboutToResize当controller对应的NodeContainer在Mesure的时候进行回调，入参为节点的布局大小。</span></li><li>aboutToAppear<span>当controller对应的NodeContainer在onAppear的时候进行回调。</span></li><li>aboutToDisappear<span>当controller对应的NodeContainer在onDisappear的时候进行回调。</span></li></ul>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-dynamic-operations.html"
    },
    {
        "id": 430,
        "pre": "// entry/src/main/ets/pages/MainPage.ets\\naboutToAppear() {\\n  for (let i = 0; i <= 100; i++) {\\n    let id = i.toString();\\n    // In actual services, data is obtained from the cloud, a card list is generated,\\n    // and the node where the advertisement is located is marked.\\n    if (i % 7 === 6) {\\n      // Node where the advertisement is located\\n      this.data.pushData(new CardData(true, id));\\n      this.idList.add(id);\\n    } else {\\n      this.data.pushData(new CardData(false, id));\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "constructor(isAdCard: boolean, id: string)",
        "function_name": null,
        "parent_text": "加载列表数据：模拟从服务器端获取列表数据，分别生成列表数据对象和广告数据对象。 示例代码中用CardData(true, id)表示广告数据对象。 // entry/src/main/ets/model/CardData.ets\\nexport class CardData {\\n  private id: string = '';\\n  private mIsAdCard: boolean = false;\\n\\n  constructor(isAdCard: boolean, id: string) {\\n    this.mIsAdCard = isAdCard;\\n    this.id = id;\\n  }\\n  // ...\\n} ",
        "import_module": null,
        "parent": "<li><span>加载列表数据：模拟从服务器端获取列表数据，分别生成列表数据对象和广告数据对象。</span><p></p> <p>示例代码中用CardData(true, id)表示广告数据对象。</p> <pre class='\\\"screen\\\"'>// entry/src/main/ets/model/CardData.ets\\nexport class CardData {\\n  private id: string = '';\\n  private mIsAdCard: boolean = false;\\n\\n  constructor(isAdCard: boolean, id: string) {\\n    this.mIsAdCard = isAdCard;\\n    this.id = id;\\n  }\\n  // ...\\n}</pre> <p></p></li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-ui-dynamic-operations.html"
    },
    {
        "id": 431,
        "pre": "// src/main/ets/pages/Home.ets\\nGridRow({\\n  gutter: {\\n    x: {\\n      sm: 30,\\n      md: 41,\\n      lg: 58\\n    }\\n  }\\n}) {\\n  ForEach(this.quickFunctions, (item: QuickFunctionItem) => {\\n    GridCol({ span: 3 }) {\\n      if (this.curBp === 'sm') {\\n        QuickFunctionCardCircle({ quickFunctionItem: item })\\n      } else {\\n        QuickFunctionCardSquare({ quickFunctionItem: item })\\n      }\\n    }\\n    // ...\\n  }, (item: QuickFunctionItem) => item.getText())\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "使用栅格布局配合断点控制对应的快捷功能的显示形态，在sm断点下按钮显示为圆形图标且上图标下文字的形式，在mg、lg断点下显示为圆角矩形且左图标右文字形式。 示意图  sm  md  lg    效果图            ",
        "import_module": null,
        "parent": "<div class='\\\"p\\\"'>使用栅格布局配合断点控制对应的快捷功能的显示形态，在sm断点下按钮显示为圆形图标且上图标下文字的形式，在mg、lg断点下显示为圆角矩形且左图标右文字形式。 <div class='\\\"tablenoborder\\\"'><table><thead><tr><th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.4.1.1.1.1.5.1.1\\\"' valign='\\\"top\\\"' width='\\\"6.848644946678408%\\\"'><p>示意图</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.4.1.1.1.1.5.1.2\\\"' valign='\\\"top\\\"' width='\\\"20.281772820663342%\\\"'><p>sm</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.4.1.1.1.1.5.1.3\\\"' valign='\\\"top\\\"' width='\\\"27.75657959103806%\\\"'><p>md</p> </th> <th align='\\\"left\\\"' class='\\\"cellrowborder\\\"' id='\\\"mcps1.3.5.4.1.1.1.1.5.1.4\\\"' valign='\\\"top\\\"' width='\\\"45.11300264162019%\\\"'><p>lg</p> </th> </tr> </thead> <tbody><tr><td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"6.848644946678408%\\\"'><p>效果图</p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"20.281772820663342%\\\"'><p><span><img originheight='\\\"89\\\"' originwidth='\\\"320\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161337.62451750523498797985982072113035:50001231000000:2800:73DF95B0F123AA3A830AC2C3AF8AFD22C99D34C04C8689D0BF4A173BDAEAAA06.png\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"27.75657959103806%\\\"'><p><span><img originheight='\\\"59\\\"' originwidth='\\\"480\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161337.42065614484213884585147478498754:50001231000000:2800:7E4D66670F931F1E66FF570A0B1F8CF56831C5AECBAF88A33CC278DB703DEBE5.png\\\"'/></span></p> </td> <td class='\\\"cellrowborder\\\"' valign='\\\"top\\\"' width='\\\"45.11300264162019%\\\"'><p><span><img originheight='\\\"79\\\"' originwidth='\\\"800\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161337.62703661863843789999540081262443:50001231000000:2800:FF0CD2571B2286F2395A79857E7569761B228D28E3CF4F8F2911DB596021DBF9.png\\\"'/></span></p> </td> </tr> </tbody></table> </div>  </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/multi-mobile-payment.html"
    },
    {
        "id": 432,
        "pre": "Row() {\\n  Text('北京')\\n    // ...\\n  TextInput({ placeholder: '猜你想搜...' })\\n    // ...\\n  Text('更多')\\n    // ...\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "顶部搜索框区域。 实现效果：  ",
        "import_module": null,
        "parent": "<li>顶部搜索框区域。 <p>实现效果：</p> <p><span><img height='\\\"37.492700000000006\\\"' originheight='\\\"179\\\"' originwidth='\\\"1260\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161140.17167546685104164608134424609519:50001231000000:2800:07955D70B7FD16E076302181F404B9D65821061DF1B25602485E7635CD950AFB.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-common-list-flows.html"
    },
    {
        "id": 433,
        "pre": "@Builder\\ntabBuilder(img: Resource, title: Resource, index: number) {\\n  Column() {\\n    Image(img)\\n      // ...\\n      .fillColor(this.currentIndex === index ? '#0a59f7' : '#66000000')\\n    Text(title)\\n      // ...\\n      .fontColor(this.currentIndex === index ? '#0a59f7' : '#66000000')\\n  }\\n  // ...\\n  .onClick(() => {\\n    this.currentIndex = index;\\n    this.tabsController.changeIndex(this.currentIndex);\\n  })\\n}",
        "type": "Reference",
        "function_call": "TabContent()",
        "function_name": null,
        "parent_text": "构建Tabs的自定义tabBar内容。 Tabs({ barPosition: BarPosition.End, controller: this.tabsController }) {\\n  TabContent() {\\n    // ...\\n  }\\n  .tabBar('tabBar1', $r('app.string.mine'), 0)\\n\\n  // 其它tabBar内容\\n}\\n// ...\\n.onChange((index: number) => {\\n  this.currentIndex = index;\\n}) 实现效果：  ",
        "import_module": null,
        "parent": "<li>构建Tabs的自定义tabBar内容。 <pre class='\\\"screen\\\"'>Tabs({ barPosition: BarPosition.End, controller: this.tabsController }) {\\n  TabContent() {\\n    // ...\\n  }\\n  .tabBar('tabBar1', $r('app.string.mine'), 0)\\n\\n  // 其它tabBar内容\\n}\\n// ...\\n.onChange((index: number) =&gt; {\\n  this.currentIndex = index;\\n})</pre> <p>实现效果：</p> <p><span><img height='\\\"56.2457\\\"' originheight='\\\"267\\\"' originwidth='\\\"1260\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161141.26186658602648205058302734635474:50001231000000:2800:3A0E773AA6938898DAE2D77AA12A43E01DE92E5213793B9D38A4928AE965C8B8.png\\\"' title='\\\"点击放大\\\"' width='\\\"266\\\"'/></span></p> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-common-list-flows.html"
    },
    {
        "id": 434,
        "pre": "// 列表数据内容\\n@Builder\\ntextContent(content: string) {\\n  Text(content)\\n    // ...\\n}",
        "type": "Reference",
        "function_call": "ListItem()",
        "function_name": null,
        "parent_text": "城市列表使用ListItemGroup，对“当前城市”“热门城市”“城市数据”进行分组，并通过ListItem展示每个分组中的具体数据。 List({ scroller: this.cityScroller }) {\\n  // 当前城市\\n  ListItemGroup({ header: this.itemHead('当前城市') }) {\\n    ListItem() {\\n      this.textContent(this.currentCity);\\n    }\\n  }\\n\\n  // 热门城市\\n  ListItemGroup({ header: this.itemHead('热门城市') }) {\\n    ForEach(this.hotCities, (item: string) => {\\n      ListItem() {\\n        this.textContent(item);\\n      }\\n    }, (item: string) => item)\\n  }\\n  .divider({\\n    strokeWidth: 1,\\n    color: '#EDEDED',\\n    startMargin: 10,\\n    endMargin: 45\\n  })\\n\\n  // 城市列表数据\\n  ForEach(this.groupWorldList, (item: string) => {\\n    // 遍历城市首字母内容，并将其作为城市分组的标题\\n    ListItemGroup({ header: this.itemHead(item) }) {\\n      // 展示字母对应城市数据\\n      ForEach(this.getCitiesWithGroupName(item), (cityItem: City) => {\\n        ListItem() {\\n          this.textContent(cityItem.city);\\n        }\\n      }, (cityItem: City) => cityItem.city)\\n    }\\n  })\\n} ",
        "import_module": null,
        "parent": "<li>城市列表使用ListItemGroup，对“当前城市”“热门城市”“城市数据”进行分组，并通过ListItem展示每个分组中的具体数据。 <pre class='\\\"screen\\\"'>List({ scroller: this.cityScroller }) {\\n  // 当前城市\\n  ListItemGroup({ header: this.itemHead('当前城市') }) {\\n    ListItem() {\\n      this.textContent(this.currentCity);\\n    }\\n  }\\n\\n  // 热门城市\\n  ListItemGroup({ header: this.itemHead('热门城市') }) {\\n    ForEach(this.hotCities, (item: string) =&gt; {\\n      ListItem() {\\n        this.textContent(item);\\n      }\\n    }, (item: string) =&gt; item)\\n  }\\n  .divider({\\n    strokeWidth: 1,\\n    color: '#EDEDED',\\n    startMargin: 10,\\n    endMargin: 45\\n  })\\n\\n  // 城市列表数据\\n  ForEach(this.groupWorldList, (item: string) =&gt; {\\n    // 遍历城市首字母内容，并将其作为城市分组的标题\\n    ListItemGroup({ header: this.itemHead(item) }) {\\n      // 展示字母对应城市数据\\n      ForEach(this.getCitiesWithGroupName(item), (cityItem: City) =&gt; {\\n        ListItem() {\\n          this.textContent(cityItem.city);\\n        }\\n      }, (cityItem: City) =&gt; cityItem.city)\\n    }\\n  })\\n}</pre> </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-common-list-flows.html"
    },
    {
        "id": 435,
        "pre": "// 左侧分类导航数据\\nList({ scroller: this.navTitleScroller }) {\\n  ForEach(this.categoryList, (item: NavTitleModel, index: number) => {\\n    ListItem() {\\n      Text(item.titleName)\\n        // ...\\n    }\\n  }, (item: NavTitleModel) => item.titleName)\\n}\\n// ...\\n\\n// 右侧分类内容数据\\nList({ scroller: this.goodsListScroller }) {\\n  ForEach(this.categoryList, (item: NavTitleModel) => {\\n    ListItemGroup({ space: 12, header: this.goodsHeaderBuilder(item.titleName) }) {\\n      ForEach(item.goodsList, (goodsItem: GoodsDataModel) => {\\n        ListItem() {\\n          Row() {\\n            Image(goodsItem.imgUrl)\\n              // ...\\n            Column() {\\n              Text(goodsItem.goodsName)\\n                // ...\\n              Text('￥' + goodsItem.price)\\n                // ...\\n            }\\n            // ...\\n          }\\n          // ...\\n        }\\n      }, (goodsItem: GoodsDataModel) => JSON.stringify(goodsItem.goodsId))\\n    }\\n  }, (item: NavTitleModel) => JSON.stringify(item.goodsList))\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "分别通过List组件构建左侧分类导航数据和右侧分类内容数据。 ",
        "import_module": null,
        "parent": "<li>分别通过List组件构建左侧分类导航数据和右侧分类内容数据。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-common-list-flows.html"
    },
    {
        "id": 436,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { sensor } from '@kit.SensorServiceKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onForeground(): void {\\n    //在前台时按业务所需监听所需类型的sensor\\n    sensor.on(sensor.SensorId.ACCELEROMETER, (data: sensor.AccelerometerResponse) => {\\n      console.info(\\\"Succeededinobtainingdata.x:\\\" + data.x + \\\"y:\\\" + data.y + \\\"z:\\\" + data.z);\\n    }, {\\n      interval: 100000000\\n    });\\n  }\\n\\n  onBackground(): void {\\n    //退后台取消监听\\n    sensor.off(sensor.SensorId.ACCELEROMETER);\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "示例",
        "parent_text": "示例 有关传感器开发相关接口的使用，详情可以参考传感器开发指导。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section19507192211578\\\"'><a name='\\\"section19507192211578\\\"'></a><a name='\\\"section19507192211578\\\"'></a><h4>示例</h4> <p>有关传感器开发相关接口的使用，详情可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/sensor-guidelines\\\"' target='\\\"_blank\\\"'>传感器开发指导</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-sensor-use.html"
    },
    {
        "id": 437,
        "pre": "// har_common/src/main/ets/utils/Utils.ets\\nconst LARGE_NUMBER = 100000000;\\nfunction func(): number {\\n  let count = 0;\\n  while (count < LARGE_NUMBER) {\\n    count++;\\n  }\\n  return count;\\n}\\nexport let funcResult = func();",
        "type": "Reference",
        "function_call": null,
        "function_name": null,
        "parent_text": "在被引用HAR_COMMON包中写入功能示例。 ",
        "import_module": null,
        "parent": "<li>在被引用HAR_COMMON包中写入功能示例。 </li>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-modular-design.html"
    },
    {
        "id": 438,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { http } from '@kit.NetworkKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  onForeground(): void {\\n    //在前台时按业务所需创建http请求\\n    let httpRequest = http.createHttp();\\n    // ...\\n  }\\n\\n  onBackground(): void {\\n    //退到后台释放http请求\\n    httpRequest.destroy();\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]HTTP数据请求",
        "parent_text": "[h2]HTTP数据请求 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section729719151210\\\"'><a name='\\\"section729719151210\\\"'></a><a name='\\\"section729719151210\\\"'></a><h4>[h2]HTTP数据请求</h4> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-network-use.html"
    },
    {
        "id": 439,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { socket } from '@kit.NetworkKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  // ...\\n  tcp: socket.TCPSocket = socket.constructTCPSocketInstance();\\n\\n  onForeground(): void {\\n    //在前台时按业务所需创建socket连接并发送业务数据\\n    this.tcp.bind(ipAddress, (err: BusinessError) => {})\\n    this.tcp.connect(tcpConnect, (err: BusinessError) => {})\\n    this.tcp.send(tcpSendOptions, (err: BusinessError) => {})\\n  }\\n\\n  onBackground(): void {\\n    //退到后台关闭socket连接\\n    this.tcp.close((err: BusinessError) => {})\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]Socket连接",
        "parent_text": "[h2]Socket连接 有关网络Socket相关接口的使用，详情可以参考Socket连接。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section10599349181310\\\"'><a name='\\\"section10599349181310\\\"'></a><a name='\\\"section10599349181310\\\"'></a><h4>[h2]Socket连接</h4> <p>有关网络Socket相关接口的使用，详情可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/socket-connection\\\"' target='\\\"_blank\\\"'>Socket连接</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-network-use.html"
    },
    {
        "id": 440,
        "pre": "import { UIAbility } from '@kit.AbilityKit';\\nimport { webSocket } from '@kit.NetworkKit';\\nimport { BusinessError } from '@kit.BasicServicesKit';\\n\\nexport default class EntryAbility extends UIAbility {\\n  //按业务所需创建websocket\\n  ws = webSocket.createWebSocket();\\n\\n  onForeground(): void {\\n    //在前台时通过websocket发送数据\\n    this.ws.on('open', (err: BusinessError, value: Object) => {\\n      console.log(\\\"onopen,status:\\\" + JSON.stringify(value));\\n      //当收到on('open')事件时，可以通过send()方法与服务器进行通信\\n      this.ws.send(\\\"Hello,server!\\\", (err: BusinessError, value: boolean) => {\\n        if (!err) {\\n          console.log(\\\"Messagesentsuccessfully\\\");\\n        } else {\\n          console.log(\\\"Failedtosendthemessage.Err:\\\" + JSON.stringify(err));\\n        }\\n      });\\n    });\\n  }\\n\\n  onBackground(): void {\\n    //退后台关闭websocket\\n    this.ws.close((err: BusinessError) => {});\\n  }\\n}",
        "type": "Reference",
        "function_call": null,
        "function_name": "[h2]WebSocket连接",
        "parent_text": "[h2]WebSocket连接 有关网络WebSocket相关接口的使用，详情可以参考WebSocket连接。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section18297231141\\\"'><a name='\\\"section18297231141\\\"'></a><a name='\\\"section18297231141\\\"'></a><h4>[h2]WebSocket连接</h4> <p>有关网络WebSocket相关接口的使用，详情可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/websocket-connection\\\"' target='\\\"_blank\\\"'>WebSocket连接</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-reasonable-network-use.html"
    },
    {
        "id": 441,
        "pre": "@Component\\nexport struct example {\\n  build() {\\n    Column(){\\n      Text('自定义组件示例代码')\\n      // ...\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]优先使用@Builder方法代替自定义组件",
        "parent_text": "[h2]优先使用@Builder方法代替自定义组件自定义组件与自定义构建函数概念定义如下： 自定义组件：用@Component修饰的struct结构体称为自定义组件，在自定义组件中可以定义函数/变量、build()方法、组件的生命周期回调等。自定义组件具有可组合、可重用和数据驱动UI更新的特点。 自定义构建函数：@Builder装饰的函数称为“自定义构建函数”，分为组件内自定义构建函数和全局自定义构建函数。@Builder所装饰的函数遵循build()函数语法规则，开发者可以将重复使用的UI元素抽象成一个方法，在build方法里调用。  自定义组件和自定义构建函数（@Builder）的主要区别如下： 自定义构建函数（@Builder）更轻量，其作为UI元素抽象的方法，实现和调用相较于自定义组件比较简洁。在自定义组件中，可以定义成员函数/变量、自定义组件生命周期等。自定义构建函数（@Builder）不支持定义状态变量和自定义生命周期。在自定义组件中，可直接通过状态变量的改变，来驱动UI的刷新。而自定义构建函数（@Builder）默认的按值参数传递方式不支持动态改变组件，当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新，要实现UI动态刷新需要按引用传递参数。在自定义组件中要实现插槽功能，需要使用@Builder和@BuilderParams实现。具体实现可参考：@BuilderParam装饰器：引用@Builder函数。自定义构建函数（@Builder）中使用了自定义组件，那么该方法每次被调用时，对应的自定义组件均会重新创建。 整体上，自定义组件在实际应用开发场景中更加通用、灵活。自定义构建函数（@Builder）由于不支持定义变量和生命周期等限制，在使用场景上灵活性受限，多用在插槽或系统提供的组件/方法里面属性传值类型为Builder类型场景中。 根据上面自定义组件与自定义构建函数的区别可以看出，由于@Builder不涉及生命周期，在自定义组件大量嵌套的场景中，更加轻量级的@Builder在性能方面更加出色。 因此，当自定义组件不涉及到状态变量和自定义生命周期时，可以优先使用@Builder替换自定义组件，提升性能。 优化策略 自定义组件示例代码：  自定义构建函数示例代码： @Builder\\nexport function example(){\\n  Column(){\\n    Text('自定义构建函数示例代码')\\n      // ...\\n  }\\n} 具体可以参考UI组件性能优化-优先使用@Builder方法代替自定义组件。 ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1012953161217\\\"'><a name='\\\"section1012953161217\\\"'></a><a name='\\\"section1012953161217\\\"'></a><h4>[h2]优先使用@Builder方法代替自定义组件</h4><p>自定义组件与自定义构建函数概念定义如下：</p> <p>自定义组件：用@Component修饰的struct结构体称为自定义组件，在自定义组件中可以定义函数/变量、build()方法、组件的生命周期回调等。自定义组件具有可组合、可重用和数据驱动UI更新的特点。</p> <p>自定义构建函数：@Builder装饰的函数称为“自定义构建函数”，分为组件内自定义构建函数和全局自定义构建函数。@Builder所装饰的函数遵循build()函数语法规则，开发者可以将重复使用的UI元素抽象成一个方法，在build方法里调用。</p> <p></p> <p>自定义组件和自定义构建函数（@Builder）的主要区别如下：</p> <ol><li>自定义构建函数（@Builder）更轻量，其作为UI元素抽象的方法，实现和调用相较于自定义组件比较简洁。</li><li>在自定义组件中，可以定义成员函数/变量、自定义组件生命周期等。自定义构建函数（@Builder）不支持定义状态变量和自定义生命周期。</li><li>在自定义组件中，可直接通过状态变量的改变，来驱动UI的刷新。而自定义构建函数（@Builder）默认的按值参数传递方式不支持动态改变组件，当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新，要实现UI动态刷新需要按引用传递参数。</li><li>在自定义组件中要实现插槽功能，需要使用@Builder和@BuilderParams实现。具体实现可参考：<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builderparam\\\"' target='\\\"_blank\\\"'>@BuilderParam装饰器：引用@Builder函数</a>。</li><li>自定义构建函数（@Builder）中使用了自定义组件，那么该方法每次被调用时，对应的自定义组件均会重新创建。</li></ol> <p>整体上，自定义组件在实际应用开发场景中更加通用、灵活。自定义构建函数（@Builder）由于不支持定义变量和生命周期等限制，在使用场景上灵活性受限，多用在插槽或系统提供的组件/方法里面属性传值类型为Builder类型场景中。</p> <p>根据上面自定义组件与自定义构建函数的区别可以看出，由于@Builder不涉及生命周期，在自定义组件大量嵌套的场景中，更加轻量级的@Builder在性能方面更加出色。</p> <p>因此，当自定义组件不涉及到状态变量和自定义生命周期时，可以优先使用@Builder替换自定义组件，提升性能。</p> <p>优化策略</p> <p>自定义组件示例代码：</p>  <p>自定义构建函数示例代码：</p> <pre class='\\\"screen\\\"'>@Builder\\nexport function example(){\\n  Column(){\\n    Text('自定义构建函数示例代码')\\n      // ...\\n  }\\n}</pre> <p>具体可以参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ui-component-performance-optimization#section18773182614502\\\"' target='\\\"_blank\\\"'>UI组件性能优化-优先使用@Builder方法代替自定义组件</a>。</p> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-nesting-optimization.html"
    },
    {
        "id": 442,
        "pre": "@Component\\nexport struct Example {\\n  build() {\\n    Column() {\\n      // 自定义组件\\n      FlowListStruct({\\n        // 自定义组件传递参数\\n        // ...\\n      }).backgroundColor('#FFFFFF')\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "applyNormalAttribute(instance: ColumnAttribute): void",
        "function_name": "[h2]减少自定义组件产生多余节点",
        "parent_text": "[h2]减少自定义组件产生多余节点自定义组件自身为非渲染节点，仅是组件树和状态数据的组合，常规使用自定义组件时并不会产生多余的节点。但是给自定义组件添加属性后，会将自定义组件作为一个整体节点进行处理。对内部的组件树进行操作，如背景色绘制、圆角绘制等都会作用在该节点上。 通过DevEco Studio内置ArkUI Inspector工具，查看组件树结构可以看到，相比使用@Builder方法，组件树多一个自定义组件节点，所以优先使用@Builder方法代替自定义组件减少了自定义组件节点数量。而给自定义组件添加属性，会在自定义组件外部会创建一个“__Common__”类型的节点，如下图所示。为了避免这类“__Common__”节点的创建，可以将自定义组件的属性移至内部，或者动态设置自定义组件的属性。减少自定义组件产生多余节点，可以使总节点数量降低，从而提升性能。 图1 自定义组件树变化示意图 将自定义组件的属性移至内部 当需要给自定义组件添加属性时，一般少量属性的场景下，可以将这些属性移至自定义组件内部，具体优化示例如下所示。 反例：  正例： @Component\\nexport struct FlowListStruct {\\n  build(){\\n    Column(){\\n      // ...\\n    }\\n    .backgroundColor('#FFFFFF')\\n  }\\n} 动态设置自定义组件的属性 ArkUI提供了动态属性设置的接口，支持使用自定义AttributeModifier构建组件并配置属性。当需要给自定义组件设置较多属性时，如果将所有的属性设置都内移，会出现传递参数过多的问题，同时也会创建更多状态变量，增加参数的传递耗时。虽然减少了节点数量，但是性能没有得到有效提升。推荐使用自定义AttributeModifier的方式来动态设置自定义组件的属性，减少节点数量的同时，也避免了参数过多导致耗时的问题，具体优化示例如下所示。 @Entry\\n@Component\\nstruct CustomComponentModifier {\\n  modifier: ColumnModifier = new ColumnModifier();\\n\\n  aboutToAppear(): void {\\n    this.modifier.width = 100;\\n    this.modifier.height = 100;\\n    this.modifier.backgroundColor = Color.Red;\\n  }\\n\\n  build() {\\n    Column() {\\n      ModifierCustom({ modifier: this.modifier })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ModifierCustom {\\n  @Require @Prop modifier: AttributeModifier<ColumnAttribute>;\\n\\n  build() {\\n    Column() {\\n      Text('Hello Word')\\n    }.attributeModifier(this.modifier)\\n  }\\n}\\n// 使用动态属性设置时，需要继承AttributeModifier，自行实现一个Modifier，然后设置到需要的组件上\\nclass ColumnModifier implements AttributeModifier<ColumnAttribute> {\\n  width: number = 0;\\n  height: number = 0;\\n  backgroundColor: ResourceColor | undefined = undefined;\\n\\n  applyNormalAttribute(instance: ColumnAttribute): void {\\n    instance.width(this.width);\\n    instance.height(this.height);\\n    instance.backgroundColor(this.backgroundColor);\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section25911641123713\\\"'><a name='\\\"section25911641123713\\\"'></a><a name='\\\"section25911641123713\\\"'></a><h4>[h2]减少自定义组件产生多余节点</h4><p>自定义组件自身为非渲染节点，仅是组件树和状态数据的组合，常规使用自定义组件时并不会产生多余的节点。但是给自定义组件添加属性后，会将自定义组件作为一个整体节点进行处理。对内部的组件树进行操作，如背景色绘制、圆角绘制等都会作用在该节点上。</p> <p>通过DevEco Studio内置ArkUI Inspector工具，查看组件树结构可以看到，相比使用@Builder方法，组件树多一个自定义组件节点，所以<a href='\\\"#section1012953161217\\\"'>优先使用@Builder方法代替自定义组件</a>减少了自定义组件节点数量。而给自定义组件添加属性，会在自定义组件外部会创建一个“__Common__”类型的节点，如下图所示。为了避免这类“__Common__”节点的创建，可以将自定义组件的属性移至内部，或者动态设置自定义组件的属性。减少自定义组件产生多余节点，可以使总节点数量降低，从而提升性能。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图1 </b>自定义组件树变化示意图</span><br/><span><img height='\\\"418.30960500000003\\\"' originheight='\\\"663\\\"' originwidth='\\\"1249\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161107.37447997651765978999809852804880:50001231000000:2800:35A2DFE7D8B557B2755A1D0F84DAB994B3F76B88341585DD4FB4790C46AEF6D9.png\\\"' title='\\\"点击放大\\\"' width='\\\"788.0250000000001\\\"'/></span></div> <p><strong>将自定义组件的属性移至内部</strong></p> <p>当需要给自定义组件添加属性时，一般少量属性的场景下，可以将这些属性移至自定义组件内部，具体优化示例如下所示。</p> <p>反例：</p>  <p>正例：</p> <pre class='\\\"screen\\\"'>@Component\\nexport struct FlowListStruct {\\n  build(){\\n    Column(){\\n      // ...\\n    }\\n    .backgroundColor('#FFFFFF')\\n  }\\n}</pre> <p><strong>动态设置自定义组件的属性</strong></p> <p>ArkUI提供了<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-attribute-modifier\\\"' target='\\\"_blank\\\"'>动态属性设置</a>的接口，支持使用自定义AttributeModifier构建组件并配置属性。当需要给自定义组件设置较多属性时，如果将所有的属性设置都内移，会出现传递参数过多的问题，同时也会创建更多状态变量，增加参数的传递耗时。虽然减少了节点数量，但是性能没有得到有效提升。推荐使用自定义AttributeModifier的方式来动态设置自定义组件的属性，减少节点数量的同时，也避免了参数过多导致耗时的问题，具体优化示例如下所示。</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct CustomComponentModifier {\\n  modifier: ColumnModifier = new ColumnModifier();\\n\\n  aboutToAppear(): void {\\n    this.modifier.width = 100;\\n    this.modifier.height = 100;\\n    this.modifier.backgroundColor = Color.Red;\\n  }\\n\\n  build() {\\n    Column() {\\n      ModifierCustom({ modifier: this.modifier })\\n    }\\n  }\\n}\\n\\n@Component\\nstruct ModifierCustom {\\n  @Require @Prop modifier: AttributeModifier&lt;ColumnAttribute&gt;;\\n\\n  build() {\\n    Column() {\\n      Text('Hello Word')\\n    }.attributeModifier(this.modifier)\\n  }\\n}\\n// 使用动态属性设置时，需要继承AttributeModifier，自行实现一个Modifier，然后设置到需要的组件上\\nclass ColumnModifier implements AttributeModifier&lt;ColumnAttribute&gt; {\\n  width: number = 0;\\n  height: number = 0;\\n  backgroundColor: ResourceColor | undefined = undefined;\\n\\n  applyNormalAttribute(instance: ColumnAttribute): void {\\n    instance.width(this.width);\\n    instance.height(this.height);\\n    instance.backgroundColor(this.backgroundColor);\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-nesting-optimization.html"
    },
    {
        "id": 443,
        "pre": "@Component\\nexport struct example {\\n  build() {\\n    Column(){\\n     Row(){\\n       // 自定义组件\\n       FlowListStruct({\\n         // 自定义组件传递参数\\n         // ...\\n       })\\n     }\\n     .width('100%')\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}",
        "type": "Reference",
        "function_call": "Column()",
        "function_name": "[h2]删除无用的Stack/Column/Row嵌套，移除冗余节点",
        "parent_text": "[h2]删除无用的Stack/Column/Row嵌套，移除冗余节点在组件嵌套的情况中，可以找到一些无用的容器组件嵌套。在考虑组件嵌套优化中，可以删除掉无用容器组件嵌套，移除冗余节点，从而避免冗余节点对性能的消耗。 优化方式： 反例：  正例： @Component\\nexport struct example {\\n  build() {\\n    Column() {\\n      // 自定义组件\\n      FlowListStruct({\\n        // 自定义组件传递参数\\n        // ...\\n      })\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section1012993119126\\\"'><a name='\\\"section1012993119126\\\"'></a><a name='\\\"section1012993119126\\\"'></a><h4>[h2]删除无用的Stack/Column/Row嵌套，移除冗余节点</h4><p>在组件嵌套的情况中，可以找到一些无用的容器组件嵌套。在考虑组件嵌套优化中，可以删除掉无用容器组件嵌套，移除冗余节点，从而避免冗余节点对性能的消耗。</p> <p>优化方式：</p> <p>反例：</p>  <p>正例：</p> <pre class='\\\"screen\\\"'>@Component\\nexport struct example {\\n  build() {\\n    Column() {\\n      // 自定义组件\\n      FlowListStruct({\\n        // 自定义组件传递参数\\n        // ...\\n      })\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-nesting-optimization.html"
    },
    {
        "id": 444,
        "pre": "@Entry\\n@Component\\nstruct StackNesting {\\n  build() {\\n    Column() {\\n      Stack() {\\n        Image($r('app.media.example_image'))\\n          .objectFit(ImageFit.Contain)\\n        Text($r('app.string.example_text'))\\n          .fontSize(20)\\n          .fontColor(Color.Black)\\n      }\\n    }\\n  }\\n}",
        "type": "Reference",
        "function_call": "OverlayNode()",
        "function_name": "[h2]优先使用组件属性代替嵌套组件",
        "parent_text": "[h2]优先使用组件属性代替嵌套组件在实现文本浮层、按压遮罩或颜色叠加等场景时，通常会采用Stack布局嵌套组件的方式。实际上有些场景直接使用组件属性或借助系统API的能力就能实现，例如使用overlay属性可以实现浮层场景，使用ColorMetrics可以实现颜色叠加效果。直接使用组件属性的方式可以减少Stack布局嵌套组件的使用，从而减少嵌套组件带来的节点数。以文本浮层场景为例，如下图所示，使用overlay属性实现文本浮层比Stack组件嵌套方式少了一层Stack节点。开发这一类场景时，推荐优先使用组件属性代替嵌套组件。 图2 使用组件属性代替嵌套组件示意图 使用overlay属性实现浮层 使用overlay属性可以直接给组件添加浮层，实现堆叠的效果，常见的场景有文本浮层、按压遮罩等。相较于Stack布局嵌套组件的方式，使用overlay属性减少了Stack组件节点的创建。以增加文本浮层为例，具体优化示例如下所示。更多使用overlay属性实现浮层场景的示例可参考浮层-示例。 反例：  正例： @Entry\\n@Component\\nstruct OverlayExample {\\n  @Builder\\n  OverlayNode() {\\n    Text($r('app.string.example_text'))\\n      .fontSize(20)\\n      .fontColor(Color.Black)\\n  }\\n\\n  build() {\\n    Column() {\\n      Image($r('app.media.example_image'))\\n        .overlay(this.OverlayNode(), { align: Alignment.Center })\\n        .objectFit(ImageFit.Contain)\\n    }\\n  }\\n} ",
        "import_module": null,
        "parent": "<div class='\\\"section\\\"' id='\\\"section78181114123811\\\"'><a name='\\\"section78181114123811\\\"'></a><a name='\\\"section78181114123811\\\"'></a><h4>[h2]优先使用组件属性代替嵌套组件</h4><p>在实现文本浮层、按压遮罩或颜色叠加等场景时，通常会采用Stack布局嵌套组件的方式。实际上有些场景直接使用组件属性或借助系统API的能力就能实现，例如使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-overlay#overlay\\\"' target='\\\"_blank\\\"'>overlay</a>属性可以实现浮层场景，使用<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-graphics#colormetrics12\\\"' target='\\\"_blank\\\"'>ColorMetrics</a>可以实现颜色叠加效果。直接使用组件属性的方式可以减少Stack布局嵌套组件的使用，从而减少嵌套组件带来的节点数。以文本浮层场景为例，如下图所示，使用overlay属性实现文本浮层比Stack组件嵌套方式少了一层Stack节点。开发这一类场景时，推荐优先使用组件属性代替嵌套组件。</p> <div class='\\\"fignone\\\"'><span class='\\\"figcap\\\"'><b>图2 </b>使用组件属性代替嵌套组件示意图</span><br/><span><img height='\\\"461.84250000000003\\\"' originheight='\\\"659\\\"' originwidth='\\\"1130\\\"' src='\\\"https://communityfile-drcn.op.dbankcloud.cn/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250411161107.65722989630831518885107780798623:50001231000000:2800:412AF59EB00926099D6EB91C9F429E3FE2A2DA496A6B4F7DFF0BE8A0E5320644.png\\\"' title='\\\"点击放大\\\"' width='\\\"791.7297149999999\\\"'/></span></div> <p><strong>使用overlay属性实现浮层</strong></p> <p>使用overlay属性可以直接给组件添加浮层，实现堆叠的效果，常见的场景有文本浮层、按压遮罩等。相较于Stack布局嵌套组件的方式，使用overlay属性减少了Stack组件节点的创建。以增加文本浮层为例，具体优化示例如下所示。更多使用overlay属性实现浮层场景的示例可参考<a href='\\\"https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-overlay#示例\\\"' target='\\\"_blank\\\"'>浮层-示例</a>。</p> <p>反例：</p>  <p>正例：</p> <pre class='\\\"screen\\\"'>@Entry\\n@Component\\nstruct OverlayExample {\\n  @Builder\\n  OverlayNode() {\\n    Text($r('app.string.example_text'))\\n      .fontSize(20)\\n      .fontColor(Color.Black)\\n  }\\n\\n  build() {\\n    Column() {\\n      Image($r('app.media.example_image'))\\n        .overlay(this.OverlayNode(), { align: Alignment.Center })\\n        .objectFit(ImageFit.Contain)\\n    }\\n  }\\n}</pre> </div>",
        "file_path": "/Users/liuxuejin/Desktop/Projects/HMDataAugmentation/best-practices/bpta-component-nesting-optimization.html"
    }
]

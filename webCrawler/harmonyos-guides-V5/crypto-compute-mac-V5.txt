消息认证码计算
MAC（Message Authentication Code，消息认证码）可以对消息进行完整性校验，通过使用双方共享的密钥，识别出信息伪装篡改等行为。
HMAC（Hash-based Message Authentication Code）是一种基于哈希的消息认证码算法。
HMAC通过指定摘要算法，以通信双方共享密钥与消息作为输入，生成消息认证码用于检验传递报文的完整性。HMAC在消息摘要算法的基础上增加了密钥的输入，确保了信息的正确性。生成的消息认证码为固定长度。
支持的算法与规格
当创建HMAC消息认证码时，需要使用表中“支持种类”一列，指定HMAC消息认证码算法规格。
开发步骤
在调用update接口传入数据时，可以一次性传入所有数据，也可以把数据人工分段，然后分段update。对于同一段数据而言，是否分段，计算结果没有差异。对于数据量较大的数据，开发者可以根据实际需求选择是否分段传入。
下面分别提供两种方式的示例代码。
[h2]HMAC（一次性传入）
 调用cryptoFramework.createMac，指定摘要算法SHA256，生成消息认证码实例（Mac）。 调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.convertKey，生成密钥算法为HMAC的对称密钥（SymKey）。 生成对称密钥的详细开发指导，请参考指定二进制数据生成对称密钥。 调用Mac.init，指定共享对称密钥（SymKey），初始化Mac对象。 调用Mac.update，传入自定义消息，进行消息认证码计算。单次update长度没有限制。 调用Mac.doFinal，获取Mac计算结果。 调用Mac.getMacLength，获取Mac消息认证码的长度，单位为字节。 
 以使用await方式一次性传入数据，获取消息认证码计算结果为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nasync function genSymKeyByData(symKeyData: Uint8Array) {\n  let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };\n  let aesGenerator = cryptoFramework.createSymKeyGenerator('HMAC');\n  let symKey = await aesGenerator.convertKey(symKeyBlob);\n  console.info('convertKey success');\n  return symKey;\n}\nasync function doHmac() {\n  // 把字符串按utf-8解码为Uint8Array，使用固定的128位的密钥，即16字节\n  let keyData = new Uint8Array(buffer.from(\"12345678abcdefgh\", 'utf-8').buffer);\n  let key = await genSymKeyByData(keyData);\n  let macAlgName = 'SHA256'; // 摘要算法名\n  let message = 'hmacTestMessgae'; // 待进行HMAC的数据\n  let mac = cryptoFramework.createMac(macAlgName);\n  await mac.init(key);\n  // 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制\n  await mac.update({ data: new Uint8Array(buffer.from(message, 'utf-8').buffer) });\n  let macResult = await mac.doFinal();\n  console.info('HMAC result:' + macResult.data);\n  let macLen = mac.getMacLength();\n  console.info('HMAC len:' + macLen);\n} 以使用同步方式一次性传入数据，获取消息认证码计算结果为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nfunction genSymKeyByData(symKeyData: Uint8Array) {\n  let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };\n  let aesGenerator = cryptoFramework.createSymKeyGenerator('HMAC');\n  let symKey =  aesGenerator.convertKeySync(symKeyBlob);\n  console.info('[Sync]convertKey success');\n  return symKey;\n}\nfunction doHmacBySync() {\n  // 把字符串按utf-8解码为Uint8Array，使用固定的128位的密钥，即16字节\n  let keyData = new Uint8Array(buffer.from(\"12345678abcdefgh\", 'utf-8').buffer);\n  let key = genSymKeyByData(keyData);\n  let macAlgName = 'SHA256'; // 摘要算法名\n  let message = 'hmacTestMessgae'; // 待进行HMAC的数据\n  let mac = cryptoFramework.createMac(macAlgName);\n  mac.initSync(key);\n  // 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制\n  mac.updateSync({ data: new Uint8Array(buffer.from(message, 'utf-8').buffer) });\n  let macResult = mac.doFinalSync();\n  console.info('[Sync]HMAC result:' + macResult.data);\n  let macLen = mac.getMacLength();\n  console.info('HMAC len:' + macLen);\n} 
[h2]分段HMAC
 调用cryptoFramework.createMac，指定摘要算法SHA256，生成消息认证码实例（Mac）。 调用cryptoFramework.createSymKeyGenerator、SymKeyGenerator.convertKey，生成密钥算法为HMAC的对称密钥（SymKey）。 生成对称密钥的详细开发指导，请参考指定二进制数据生成对称密钥。 调用Mac.init，指定共享对称密钥（SymKey），初始化Mac对象。 传入自定义消息，将一次传入数据量设置为20字节，多次调用Mac.update，进行消息认证码计算。 调用Mac.doFinal，获取Mac计算结果。 调用Mac.getMacLength，获取Mac消息认证码的长度，单位为字节。 
 以使用await方式分段传入数据，获取消息认证码计算结果为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nasync function genSymKeyByData(symKeyData: Uint8Array) {\n  let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };\n  let aesGenerator = cryptoFramework.createSymKeyGenerator('HMAC');\n  let symKey = await aesGenerator.convertKey(symKeyBlob);\n  console.info('convertKey success');\n  return symKey;\n}\nasync function doLoopHmac() {\n  // 把字符串按utf-8解码为Uint8Array，使用固定的128位的密钥，即16字节\n  let keyData = new Uint8Array(buffer.from(\"12345678abcdefgh\", 'utf-8').buffer);\n  let key = await genSymKeyByData(keyData);\n  let macAlgName = \"SHA256\"; // 摘要算法名\n  let mac = cryptoFramework.createMac(macAlgName);\n  // 假设信息总共43字节，根据utf-8解码后，也是43字节\n  let messageText = \"aaaaa.....bbbbb.....ccccc.....ddddd.....eee\";\n  let messageData = new Uint8Array(buffer.from(messageText, 'utf-8').buffer);\n  let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求\n  await mac.init(key);\n  for (let i = 0; i < messageData.length; i += updateLength) {\n    let updateMessage = messageData.subarray(i, i + updateLength);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    await mac.update(updateMessageBlob);\n  }\n  let macOutput = await mac.doFinal();\n  console.info(\"HMAC result: \" + macOutput.data);\n  let macLen = mac.getMacLength();\n  console.info('HMAC len:' + macLen);\n} 以使用同步方式分段传入数据，获取消息认证码计算结果为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nfunction genSymKeyByData(symKeyData: Uint8Array) {\n  let symKeyBlob: cryptoFramework.DataBlob = { data: symKeyData };\n  let aesGenerator = cryptoFramework.createSymKeyGenerator('HMAC');\n  let symKey = aesGenerator.convertKeySync(symKeyBlob);\n  console.info('[Sync]convertKey success');\n  return symKey;\n}\nfunction doLoopHmacBySync() {\n  // 把字符串按utf-8解码为Uint8Array，使用固定的128位的密钥，即16字节\n  let keyData = new Uint8Array(buffer.from(\"12345678abcdefgh\", 'utf-8').buffer);\n  let key = genSymKeyByData(keyData);\n  let macAlgName = \"SHA256\"; // 摘要算法名\n  let mac = cryptoFramework.createMac(macAlgName);\n  // 假设信息总共43字节，根据utf-8解码后，也是43字节\n  let messageText = \"aaaaa.....bbbbb.....ccccc.....ddddd.....eee\";\n  let messageData = new Uint8Array(buffer.from(messageText, 'utf-8').buffer);\n  let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求\n  mac.initSync(key);\n  for (let i = 0; i < messageData.length; i += updateLength) {\n    let updateMessage = messageData.subarray(i, i + updateLength);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    mac.updateSync(updateMessageBlob);\n  }\n  let macOutput = mac.doFinalSync();\n  console.info(\"[Sync]HMAC result: \" + macOutput.data);\n  let macLen = mac.getMacLength();\n  console.info('HMAC len:' + macLen);\n} 

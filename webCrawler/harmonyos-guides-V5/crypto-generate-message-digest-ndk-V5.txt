消息摘要计算(C/C++)
对应的算法规格请查看消息摘要计算算法规格。
在CMake脚本中链接相关动态库
   target_link_libraries(entry PUBLIC libohcrypto.so)
开发步骤
在调用update接口传入数据时，可以一次性传入所有数据，也可以把数据人工分段，然后分段update。对于同一段数据而言，计算结果没有差异。对于数据量较大的数据，开发者可以根据实际需求选择是否分段传入。
下面分别提供两种方式的示例代码。
[h2]摘要算法（一次性传入）
 调用OH_CryptoDigest_Create，指定摘要算法SHA256，生成摘要实例（OH_CryptoDigest）。 调用OH_CryptoDigest_Update，传入自定义消息，进行摘要更新计算。单次update长度没有限制。 调用OH_CryptoDigest_Final，获取摘要计算结果。 调用OH_CryptoDigest_GetLength，获取摘要计算长度，单位为字节。 调用OH_DigestCrypto_Destroy，销毁摘要实例（OH_CryptoDigest）。 
 以下使用单次传入数据，获取摘要计算结果为例： 
#include \"CryptoArchitectureKit/crypto_common.h\"\n#include \"CryptoArchitectureKit/crypto_digest.h\"\n#include <string.h>\n\nstatic OH_Crypto_ErrCode doTestMd()\n{\n    OH_Crypto_ErrCode ret;\n    OH_CryptoDigest *ctx = nullptr;\n    char *testData = const_cast<char *>(\"0123456789\");\n    Crypto_DataBlob in = {.data = (uint8_t *)(testData), .len = strlen(testData)};\n    Crypto_DataBlob out = {.data = nullptr, .len = 0};\n    int mdLen = 0;\n    ret = OH_CryptoDigest_Create(\"SHA256\", &ctx);\n    if (ret != CRYPTO_SUCCESS) {\n        return ret;\n    }\n    do {\n        ret = OH_CryptoDigest_Update(ctx, &in);\n        if (ret != CRYPTO_SUCCESS) {\n            break;\n        }\n        ret = OH_CryptoDigest_Final(ctx, &out);\n        if (ret != CRYPTO_SUCCESS) {\n            break;\n        }\n        mdLen = OH_CryptoDigest_GetLength(ctx);\n    } while (0);\n    OH_Crypto_FreeDataBlob(&out);\n    OH_DigestCrypto_Destroy(ctx);\n    return ret;\n}
[h2]分段摘要算法
 调用OH_CryptoDigest_Create，指定摘要算法SHA256，生成摘要实例（OH_CryptoDigest）。 传入自定义消息，将一次传入数据量设置为20字节，多次调用OH_CryptoDigest_Update，进行摘要更新计算。 调用OH_CryptoDigest_Final，获取摘要计算结果。 调用OH_CryptoDigest_GetLength，获取摘要计算长度，单位为字节。 调用OH_DigestCrypto_Destroy，销毁摘要实例（OH_CryptoDigest）。 
 以下使用分段传入数据，获取摘要计算结果为例： 
#include <stdlib.h>\n#include \"CryptoArchitectureKit/crypto_common.h\"\n#include \"CryptoArchitectureKit/crypto_digest.h\"\n#define OH_CRYPTO_DIGEST_DATA_MAX (1024 * 1024 * 100)\n\nstatic OH_Crypto_ErrCode doLoopMd()\n{\n    OH_Crypto_ErrCode ret;\n    OH_CryptoDigest *ctx = nullptr;\n    uint8_t *testData = (uint8_t *)malloc(OH_CRYPTO_DIGEST_DATA_MAX);\n    Crypto_DataBlob out = {.data = nullptr, .len = 0};\n    int mdLen = 0;\n    int isBlockSize = 20;\n    int offset = 0;\n\n    ret = OH_CryptoDigest_Create(\"SHA256\", &ctx);\n    if (ret != CRYPTO_SUCCESS) {\n        return ret;\n    }\n    do {\n        for (int i = 0; i < 640 / isBlockSize; i++) {\n            Crypto_DataBlob in = {.data = reinterpret_cast<uint8_t *>(testData + offset),\n                                .len = static_cast<size_t>(isBlockSize)};\n            ret = OH_CryptoDigest_Update(ctx, &in);\n            if (ret != CRYPTO_SUCCESS) {\n                break;\n            }\n            offset += isBlockSize;\n        }\n        ret = OH_CryptoDigest_Final(ctx, &out);\n        if (ret != CRYPTO_SUCCESS) {\n            break;\n        }\n        mdLen = OH_CryptoDigest_GetLength(ctx);\n    } while (0);\n    OH_Crypto_FreeDataBlob(&out);\n    OH_DigestCrypto_Destroy(ctx);\n    return ret;\n}

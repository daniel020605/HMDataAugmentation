使用JSVM-API接口进行WebAssembly模块相关开发
简介
JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。
基本概念
wasm module：表示一个 WebAssembly 模块，(WebAssembly 简称为wasm)，通过 OH_JSVM_CompileWasmModule 接口可以从 wasm 字节码或 wasm cache 创建 wasm module。通过 OH_JSVM_IsWasmModuleObject 接口可以判断一个 JSVM_Value 是否是一个 wasm module。wasm function：表示 wasm module 中定义的函数，wasm function 在导出后被外部代码使用。OH_JSVM_CompileWasmFunction 接口提供了将 wasm function 编译为优化后的机器码的能力，方便开发者对指定 wasm function 提前编译和函数粒度的并行编译。wasm cache：对 wasm module 中的机器码进行序列化，生成的数据被称为 wasm cache。wasm cache 的创建和释放接口分别为 OH_JSVM_CreateWasmCache 和 OH_JSVM_ReleaseCache (对应的 cacheType 为 JSVM_CACHE_TYPE_WASM)。
接口说明
使用示例
JSVM-API 接口开发流程参考 使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应 C++ 相关代码进行展示。
cpp 部分代码：
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n\n#ifndef CHECK\n#define CHECK(cond)                                  \\\n    do {                                             \\\n        if (!(cond)) {                               \\\n            OH_LOG_ERROR(LOG_APP, \"CHECK FAILED\");   \\\n            abort();                                 \\\n        }                                            \\\n    } while (0)\n#endif\n\n// 判断一个 JSVM_Value 是否是 wasm module\nstatic bool IsWasmModuleObject(JSVM_Env env, JSVM_Value value) {\n    bool result;\n    JSVM_Status status = OH_JSVM_IsWasmModuleObject(env, value, &result);\n    CHECK(status == JSVM_OK);\n    return result;\n}\n\n// 由 C 字符串创建 JSVM string\nstatic JSVM_Value CreateString(JSVM_Env env, const char *str) {\n    JSVM_Value jsvmStr;\n    JSVM_Status status = OH_JSVM_CreateStringUtf8(env, str, JSVM_AUTO_LENGTH, &jsvmStr);\n    CHECK(status == JSVM_OK);\n    return jsvmStr;\n}\n\n// 由 C int32_t 创建 JSVM number\nstatic JSVM_Value CreateInt32(JSVM_Env env, int32_t val) {\n    JSVM_Value jsvmInt32;\n    JSVM_Status status = OH_JSVM_CreateInt32(env, val, &jsvmInt32);\n    CHECK(status == JSVM_OK);\n    return jsvmInt32;\n}\n\n// 对 wasm module 进行实例化\nstatic JSVM_Value InstantiateWasmModule(JSVM_Env env, JSVM_Value wasmModule) {\n    JSVM_Status status = JSVM_OK;\n    JSVM_Value globalThis;\n    status = OH_JSVM_GetGlobal(env, &globalThis);\n    CHECK(status == JSVM_OK);\n\n    JSVM_Value webAssembly;\n    status = OH_JSVM_GetProperty(env, globalThis, CreateString(env, \"WebAssembly\"), &webAssembly);\n    CHECK(status == JSVM_OK);\n\n    JSVM_Value webAssemblyInstance;\n    status = OH_JSVM_GetProperty(env, webAssembly, CreateString(env, \"Instance\"), &webAssemblyInstance);\n    CHECK(status == JSVM_OK);\n\n    JSVM_Value instance;\n    JSVM_Value argv[] = {wasmModule};\n    status = OH_JSVM_NewInstance(env, WebAssemblyInstance, 1, argv, &instance);\n    CHECK(status == JSVM_OK);\n    return instance;\n}\n\n// 获取 wasm 字节码 (add 模块)\nstatic std::vector<uint8_t> GetAddWasmBuffer() {\n    // 以下 wasmBuffer 对应的 wasm 字节码文本格式如下所示，只包含了一个函数 add\n    // (module\n    //   (func $add (param $lhs i32) (param $rhs i32) (result i32)\n    //     local.get $lhs\n    //     local.get $rhs\n    //     i32.add\n    //   )\n    //   (export \"add\" (func $add))\n    // )\n    std::vector<uint8_t> wasmBuffer = {0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01,\n                                       0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07,\n                                       0x07, 0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00, 0x0a, 0x09, 0x01,\n                                       0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b};\n    return wasmBuffer;\n}\n\n// 验证 wasm instance 功能 (add 模块)\nstatic void VerifyAddWasmInstance(JSVM_Env env, JSVM_Value wasmInstance) {\n    JSVM_Status status = JSVM_OK;\n    // 从 wasm instance 获取 exports.add 函数\n    JSVM_Value exports;\n    status = OH_JSVM_GetProperty(env, wasmInstance, CreateString(env, \"exports\"), &exports);\n    CHECK(status == JSVM_OK);\n\n    JSVM_Value add;\n    status = OH_JSVM_GetProperty(env, exports, CreateString(env, \"add\"), &add);\n    CHECK(status == JSVM_OK);\n\n    // 执行 exports.add(1, 2)，期望得到结果 3\n    JSVM_Value undefined;\n    OH_JSVM_GetUndefined(env, &undefined);\n    JSVM_Value one = CreateInt32(env, 1);\n    JSVM_Value two = CreateInt32(env, 2);\n    JSVM_Value argv[] = {one, two};\n    JSVM_Value result;\n    status = OH_JSVM_CallFunction(env, undefined, add, 2, argv, &result);\n    CHECK(status == JSVM_OK);\n    int32_t resultInt32;\n    OH_JSVM_GetValueInt32(env, result, &resultInt32);\n    CHECK(resultInt32 == 3);\n}\n\n// WebAssembly demo 主函数\nstatic JSVM_Value WasmDemo(JSVM_Env env, JSVM_CallbackInfo info) {\n    JSVM_Status status = JSVM_OK;\n    std::vector<uint8_t> wasmBuffer = GetAddWasmBuffer();\n    uint8_t *wasmBytecode = wasmBuffer.data();\n    size_t wasmBytecodeLength = wasmBuffer.size();\n    JSVM_Value wasmModule;\n    // 根据 wasm 字节码得到 wasm module\n    status = OH_JSVM_CompileWasmModule(env, wasmBytecode, wasmBytecodeLength, NULL, 0, NULL, &wasmModule);\n    CHECK(status == JSVM_OK);\n    CHECK(IsWasmModuleObject(env, wasmModule));\n\n    // 对当前 wasm module 中定义的第一个函数 (即 add) 执行编译优化\n    int32_t functionIndex = 0;\n    // 注意：当前只支持 high level optimization，即传入 JSVM_WASM_OPT_BASELINE 和传入 JSVM_WASM_OPT_HIGH 效果是一样的\n    status = OH_JSVM_CompileWasmFunction(env, wasmModule, functionIndex, JSVM_WASM_OPT_HIGH);\n    CHECK(status == JSVM_OK);\n    // 对编译得到的 wasm module 进行实例化\n    JSVM_Value wasmInstance = InstantiateWasmModule(env, wasmModule);\n    // 对实例化的 wasm instance 中的函数进行功能验证\n    VerifyAddWasmInstance(env, wasmInstance);\n\n    // 创建 wasm cache\n    const uint8_t *wasmCacheData = NULL;\n    size_t wasmCacheLength = 0;\n    status = OH_JSVM_CreateWasmCache(env, wasmModule, &wasmCacheData, &wasmCacheLength);\n    CHECK(status == JSVM_OK);\n    // 期望 wasm cache 创建成功\n    CHECK(wasmCacheData != NULL);\n    CHECK(wasmCacheLength > 0);\n\n    // 通过将 wasm cache 赋值来模拟 cache 持久化，实际使用场景可能将 wasm cache 保存到文件\n    std::vector<uint8_t> cacheBuffer(wasmCacheData, wasmCacheData + wasmCacheLength);\n\n    // cache 一旦保存完成后，需要显式释放，以免发生内存泄露\n    // 注意：传入的 JSVM_CacheType 必须匹配\n    status = OH_JSVM_ReleaseCache(env, wasmCacheData, JSVM_CACHE_TYPE_WASM);\n    CHECK(status == JSVM_OK);\n\n    // 使用 wasm code 反序列化来生成 wasm module\n    bool cacheRejected;\n    JSVM_Value wasmModule2;\n    status = OH_JSVM_CompileWasmModule(env, wasmBytecode, wasmBytecodeLength, cacheBuffer.data(), cacheBuffer.size(),\n                                       &cacheRejected, &wasmModule2);\n    CHECK(status == JSVM_OK);\n    // 传入的 wasm cache 如果是匹配的，且内部校验通过 (如版本)，则会接受 cache\n    CHECK(cacheRejected == false);\n    CHECK(IsWasmModuleObject(env, wasmModule2));\n\n    // 对反序列化得到的 wasmModule2 进行同样的操作：函数编译、实例化、验证功能，期望也都是通过的\n    status = OH_JSVM_CompileWasmFunction(env, wasmModule2, functionIndex, JSVM_WASM_OPT_HIGH);\n    CHECK(status == JSVM_OK);\n    JSVM_Value wasmInstance2 = InstantiateWasmModule(env, wasmModule);\n    VerifyAddWasmInstance(env, wasmInstance2);\n\n    JSVM_Value result;\n    OH_JSVM_GetBoolean(env, true, &result);\n    return result;\n}\n\n// WasmDemo 方法注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = WasmDemo}\n};\nstatic JSVM_CallbackStruct *method = param;\n// 将 C++ callback WasmDemo 函数注册为 JSVM globalThis.wasmDemo 属性，供 JS 侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"wasmDemo\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n\n// 样例测试js\nconst char *srcCallNative = R\"JS(wasmDemo())JS\";

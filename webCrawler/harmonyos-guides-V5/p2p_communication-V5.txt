应用间消息通信
在手机侧与穿戴设备侧构建应用到应用的通信隧道，用于收发应用自定义的报文消息以及文件。实现手机应用和穿戴设备应用间的交互，为用户提供分布式场景和体验。比如手机应用发送音频文件到穿戴设备侧应用，实现在穿戴设备侧应用上播放音乐；手机应用发送暂停指令，实现穿戴设备音乐播放暂停等。
收发点对点消息前，需要确保应用已在开发者联盟申请获取设备基础信息权限权限（参见申请接入WearEngine服务），否则接口将调用失败。
使用该功能前，请确保穿戴设备支持应用安装能力（参见目标设备选择），同时穿戴设备侧已有对应的应用（参见穿戴侧应用开发）。
 手机App和穿戴设备App必须同时处于启动状态。 当手机App启动且穿戴设备App没有启动时，手机App可以通过startRemoteApp方法拉起穿戴设备App。 
手机侧应用检测穿戴设备侧应用是否安装
该接口的调用需要在开发者联盟申请设备基础信息权限（请参考申请接入Wear Engine服务）。
 参见查询可用穿戴设备章节，获取已连接设备列表。 参见目标设备选择章节，从已连接设备列表中选定需要通信的设备。 
 调用wearEngine中的getP2pClient方法，获取P2pClient对象。 调用isRemoteAppInstalled方法，查看是否安装指定的设备应用。// 将设备侧应用包名定义为remoteBundleName\nlet remoteBundleName: string = '';\n\n// 步骤3 获取P2pClient对象\nlet p2pClient: wearEngine.P2pClient = wearEngine.getP2pClient(getContext(this));\n\n// 步骤4 查看是否安装指定的设备侧应用\np2pClient.isRemoteAppInstalled(targetDevice.randomId, remoteBundleName).then((isInstall) => {\n  console.info(`Succeeded in checking remote app install, result is ${isInstall}.`);\n}).catch((error: BusinessError) => {\n  console.error(`Failed to check remote app install. Code is ${error.code}, message is ${error.message}.`);\n})  
手机侧应用获取穿戴设备侧应用的版本号
该接口的调用需要在开发者联盟申请设备基础信息权限（请参考申请接入Wear Engine服务）。
 参见查询可用穿戴设备章节，获取已连接设备列表。 参见目标设备选择章节，从已连接设备列表中选定需要通信的设备。 
 调用wearEngine中的getP2pClient方法，获取P2pClient对象。 调用getRemoteAppVersion方法，获取指定设备对应的应用版本号。// 将设备侧应用包名定义为remoteBundleName\nlet remoteBundleName: string = '';\n\n// 步骤3 获取P2pClient对象\nlet p2pClient: wearEngine.P2pClient = wearEngine.getP2pClient(getContext(this));\n\n// 步骤4 获取指定设备对应的应用版本号\np2pClient.getRemoteAppVersion(targetDevice.randomId, remoteBundleName).then((version) => {\n  console.info(`Succeeded in getting remote app version, version is ${version}.`);\n}).catch((error: BusinessError) => {\n  console.error(`Failed to check get remote app version. Code is ${error.code}, message is ${error.message}.`);\n})  
手机侧应用拉起设备侧应用
该接口的调用需要在开发者联盟申请设备基础信息权限（请参考申请接入Wear Engine服务）。
在发送点对点消息前，可以用startRemoteApp方法拉起设备侧应用。
 参见查询可用穿戴设备章节，获取已连接设备列表。 参见目标设备选择章节，从已连接设备列表中选定需要通信的设备。 调用wearEngine中的getP2pClient方法，获取P2pClient对象。 调用startRemoteApp方法，指定需要拉起设备侧应用包名。transformLocalBundleName默认值为false，传入为true时，wearEngine会将本地的应用包名和指纹转换为兼容应用在云侧存储的包名和指纹，可参考申请接入Wear Engine服务章节。// 将设备侧应用包名定义为remoteBundleName\nlet remoteBundleName: string = '';\n\n// 步骤3 获取P2pClient对象\nlet p2pClient: wearEngine.P2pClient = wearEngine.getP2pClient(getContext(this));\n  \n// 步骤4 拉起设备侧指定应用(transformLocalBundleName不传入参数，默认为false)\np2pClient.startRemoteApp(targetDevice.randomId, remoteBundleName).then((p2pResult) => {\n  console.info(`Succeeded in starting remote app, result is ${p2pResult.code}.`);\n}).catch((error: BusinessError) => {\n  console.error(`Failed to start remote app. Code is ${error.code}, message is ${error.message}.`);\n})  
手机侧应用发送点对点消息或文件到穿戴设备侧应用
该接口的调用需要在开发者联盟申请设备基础信息权限（请参考申请接入Wear Engine服务）。
消息长度大小的限制为4096字节。针对消息长度超过限制的情况可以采用发送文件（文件大小不超过100MB）的方式或进行消息分包控制。
手机侧实现发送消息和文件功能后，穿戴设备侧应用需要对应实现接收消息和文件的功能。
[h2]发送点对点消息
为了使用工具类构造消息体，请先导入所需模块。
import { util } from '@kit.ArkTS';
 参见查询可用穿戴设备章节，获取已连接设备列表。 参见目标设备选择章节，从已连接设备列表中选定需要通信的设备。 构造设备侧应用参数P2pAppParam。 构造需要发送的消息P2pMessage。 
 调用wearEngine中的getP2pClient方法，获取P2pClient对象。 调用sendMessage方法，从手机上的应用发送简短消息到穿戴设备侧对应的应用。设备侧已注册监听消息接收后，即可收到手机发送的消息。// 步骤3 构造设备侧应用参数\nlet appInfo: wearEngine.AppInfo = {\n  // 设置设备侧应用的应用信息：包名与指纹\n  bundleName: '',\n  fingerprint: ''\n}\nlet appParam: wearEngine.P2pAppParam = {\n  remoteApp: appInfo\n  // transformLocalAppInfo默认为false，不转换包名指纹\n}\n\n// 设置需要发送的消息内容，长度限制为4096字节\nlet messageContent: string = 'this is message';\n\n// 步骤4 构造消息结构体\nlet textEncoder: util.TextEncoder = new util.TextEncoder;\nlet message: wearEngine.P2pMessage = {\n  content: textEncoder.encodeInto(messageContent)\n}\n\n// 步骤5 获取P2pClient对象\nlet p2pClient: wearEngine.P2pClient = wearEngine.getP2pClient(getContext(this));\n\n// 步骤6 发送消息\np2pClient.sendMessage(targetDevice.randomId, appParam, message).then((p2pResult) => {\n  console.info(`Succeeded in sending message, result is ${p2pResult.code}.`);\n}).catch((error: BusinessError) => {\n  console.error(`Failed to send message. Code is ${error.code}, message is ${error.message}.`);\n})  
[h2]发送文件
为能正确打开文件描述符，请先导入模块。
import { fileIo } from '@kit.CoreFileKit';
 参见查询可用穿戴设备章节，获取已连接设备列表。 参见目标设备选择章节，从已连接设备列表中选定需要通信的设备。 构造设备侧应用参数P2pAppParam。 
 根据文件路径filePath，构造需要发送的文件P2pFile。 调用wearEngine中的getP2pClient方法，获取P2pClient对象。 调用transferFile方法，从手机上的应用发送文件到穿戴设备侧对应的应用。// 步骤3 构造设备侧应用参数\nlet appInfo: wearEngine.AppInfo = {\n  // 设置设备侧应用的应用信息：包名与指纹\n  bundleName: '',\n  fingerprint: ''\n}\nlet appParam: wearEngine.P2pAppParam = {\n  remoteApp: appInfo\n  // transformLocalAppInfo默认为false，不转换包名指纹\n}\n\n// 步骤4 构造需要发送的文件\nlet p2pfile: wearEngine.P2pFile = {\n  // 设置需要发送的文件路径，其中不能包含'..'\n  file: fileIo.openSync('')\n}\n\n// 步骤5 获取P2pClient对象\nlet p2pClient: wearEngine.P2pClient = wearEngine.getP2pClient(getContext(this));\n\n// 步骤6 发送指定文件至设备\np2pClient.transferFile(targetDevice.randomId, appParam, p2pfile, (error: BusinessError, p2pResult: wearEngine.P2pResult) => {\n  // callback处理逻辑\n  if (error) {\n    console.error(`Failed to transfer file. Code is ${error.code}, message is ${error.message}.`);\n    return;\n  }\n  if (p2pResult.code) {\n    if (p2pResult.code === wearEngine.P2pResultCode.COMMUNICATION_SUCCESS) {\n      console.info(`Succeeded in transfering file, the result is ${p2pResult.code}.`);\n    }\n    console.info(`Failed to transfer file, the error code is ${p2pResult.code}.`);\n  }\n  if (p2pResult.progress) {\n    console.info(`Succeeded in transfering file, the progress is ${p2pResult.progress}.`);\n  }\n});\n\nfileIo.close(p2pfile.file);  
[h2]取消发送文件
 参见查询可用穿戴设备章节，获取已连接设备列表。 参见目标设备选择章节，从已连接设备列表中选定需要通信的设备。 构造设备侧应用参数P2pAppParam。 
 根据文件路径filePath，构造需要取消发送的文件P2pFile。 调用wearEngine中的getP2pClient方法，获取P2pClient对象。 调用cancelFileTransfer方法，取消从手机上的应用到穿戴设备侧对应的应用的文件发送。// 步骤3 构造设备侧应用参数\nlet appInfo: wearEngine.AppInfo = {\n  // 设置设备侧应用的应用信息：包名与指纹\n  bundleName: '',\n  fingerprint: ''\n}\nlet appParam: wearEngine.P2pAppParam = {\n  remoteApp: appInfo\n  // transformLocalAppInfo默认为false，不转换包名指纹\n}\n\n// 步骤4 构造需要发送的文件\nlet p2pfile: wearEngine.P2pFile = {\n  // 设置需要发送的文件路径，其中不能包含'..'\n  file: fileIo.openSync('')\n}\n\n// 步骤5 获取P2pClient对象\nlet p2pClient: wearEngine.P2pClient = wearEngine.getP2pClient(getContext(this));\n\n// 发送指定文件至设备\np2pClient.transferFile(targetDevice.randomId, appParam, p2pfile, () => {\n  // 回调函数执行逻辑\n})\n\n// 步骤6 取消发送文件\np2pClient.cancelFileTransfer(targetDevice.randomId, appParam, p2pfile).then((p2pResult) => {\n  if (p2pResult.code === wearEngine.P2pResultCode.COMMUNICATION_SUCCESS) {\n    console.info(`Succeeded in cancelling transfer file, the result is ${p2pResult.code}.`);\n  }\n}).catch((error: BusinessError) => {\n  console.error(`Failed to cancel transfer file. Code is ${error.code}, message is ${error.message}.`);\n})\n\nfileIo.close(p2pfile.file);  
订阅接收穿戴设备侧应用发过来的消息
该接口的调用需要在开发者联盟申请设备基础信息权限（请参考申请接入Wear Engine服务）。
 参见查询可用穿戴设备章节，获取已连接设备列表。 参见目标设备选择章节，从已连接设备列表中选定需要通信的设备。 调用wearEngine中的getP2pClient方法，获取P2pClient对象。 构造设备侧应用参数P2pAppParam。 构造接收到设备侧传来消息后的回调函数callback。 调用registerMessageReceiver方法，订阅监听消息接收事件。// 步骤3 获取P2pClient对象\nlet p2pClient: wearEngine.P2pClient = wearEngine.getP2pClient(getContext(this));\n\n// 步骤4 构造设备侧应用参数\nlet appInfo: wearEngine.AppInfo = {\n  bundleName: '',\n  fingerprint: ''\n}\n// 将设备侧应用参数类定义为appParam\nlet appParam: wearEngine.P2pAppParam = {\n  remoteApp: appInfo\n  // transformLocalAppInfo默认为false，不转换包名指纹\n}\n\n// 步骤5 构造回调函数\nlet callback = (p2pMessage: wearEngine.P2pMessage) => {\n  console.info(`Succeeded in receiving message, the message is ${p2pMessage.content}.`);\n}\n\n// 步骤6 订阅监听消息接收事件\np2pClient.registerMessageReceiver(targetDevice.randomId, appParam, callback).then(() => {\n  console.info(`Succeeded in registering message receiver.`);\n}).catch((error: BusinessError) => {\n  console.error(`Failed to register message receiver. Code is ${error.code}, message is ${error.message}.`);\n})  
 调用unregisterMessageReceiver方法，手机应用取消接收穿戴设备侧应用发过来的消息，需要传入订阅监听时的同一个回调函数对象。p2pClient.unregisterMessageReceiver(targetDevice.randomId, appParam, callback).then(() => {\n  console.info(`Succeeded in unregistering message receiver.`);\n}).catch((error: BusinessError) => {\n  console.error(`Failed to unregister message receiver. Code is ${error.code}, message is ${error.message}.`);\n})  
订阅接收穿戴设备侧发送过来的文件
 参见查询可用穿戴设备章节，获取已连接设备列表。 参见目标设备选择章节，从已连接设备列表中选定需要通信的设备。 调用wearEngine中的getP2pClient方法，获取P2pClient对象。 构造设备侧应用参数P2pAppParam。 构造接收到设备侧传来文件后的回调函数callback。 调用registerFileReceiver方法，订阅监听文件接收事件。// 步骤3 获取P2pClient对象\nlet p2pClient: wearEngine.P2pClient = wearEngine.getP2pClient(getContext(this));\n\n// 步骤4 构造设备侧应用参数\nlet appInfo: wearEngine.AppInfo = {\n  bundleName: '',\n  fingerprint: ''\n}\n// 将设备侧应用参数类定义为appParam\nlet appParam: wearEngine.P2pAppParam = {\n  remoteApp: appInfo\n  // transformLocalAppInfo默认为false，不转换包名指纹\n}\n\n// 步骤5 构造回调函数\nlet callback = (p2pMessage: wearEngine.P2pFile) => {\n  console.info(`Succeeded in receiving file.`);\n}\n\n// 步骤6 订阅监听文件接收事件\np2pClient.registerFileReceiver(targetDevice.randomId, appParam, callback).then(() => {\n  console.info(`Succeeded in registering file receiver.`);\n}).catch((error: BusinessError) => {\n  console.error(`Failed to register file receiver. Code is ${error.code}, message is ${error.message}.`);\n})  
 调用unregisterFileReceiver方法，手机应用取消接收穿戴设备侧应用发过来的文件，需要传入订阅监听时的同一个回调函数对象。p2pClient.unregisterFileReceiver(targetDevice.randomId, appParam, callback).then(() => {\n  console.info(`Succeeded in unregistering file receiver.`);\n}).catch((error: BusinessError) => {\n  console.error(`Failed to unregister file receiver. Code is ${error.code}, message is ${error.message}.`);\n})  

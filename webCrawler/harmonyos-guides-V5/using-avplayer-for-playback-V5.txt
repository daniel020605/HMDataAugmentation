使用AVPlayer播放音频(ArkTS)
使用AVPlayer可以实现端到端播放原始媒体资源，本开发指导将以完整地播放一首音乐作为示例，向开发者讲解AVPlayer音频播放相关功能。如需播放PCM音频数据，请使用AudioRenderer。
播放的全流程包含：创建AVPlayer，设置播放资源，设置播放参数（音量/倍速/焦点模式），播放控制（播放/暂停/跳转/停止），重置，销毁资源。
在进行应用开发的过程中，开发者可以通过AVPlayer的state属性主动获取当前状态或使用on('stateChange')方法监听状态变化。如果应用在音频播放器处于错误状态时执行操作，系统可能会抛出异常或生成其他未定义的行为。
图1 播放状态变化示意图
状态的详细说明请参考AVPlayerState。当播放处于prepared / playing / paused / completed状态时，播放引擎处于工作状态，这需要占用系统较多的运行内存。当客户端暂时不使用播放器时，调用reset()或release()回收内存资源，做好资源利用。
开发建议
当前指导仅介绍如何实现媒体资源播放，在应用开发过程中可能会涉及后台播放、播放冲突等情况，请根据实际需要参考以下说明。
 如果要实现后台播放或熄屏播放，需要接入AVSession（媒体会话）和申请长时任务，避免播放被系统强制中断。 应用在播放过程中，若播放的媒体数据涉及音频，根据系统音频管理策略（参考处理音频焦点事件），可能会被其他应用打断，建议应用主动监听音频打断事件，根据其内容提示，做出相应的处理，避免出现应用状态与预期效果不一致的问题。 面对设备同时连接多个音频输出设备的情况，应用可以通过on('audioOutputDeviceChangeWithInfo')监听音频输出设备的变化，从而做出相应处理。 如果需要访问在线媒体资源，需要申请 ohos.permission.INTERNET 权限。 
开发步骤及注意事项
详细的API说明请参考AVPlayer API参考。
 创建实例createAVPlayer()，AVPlayer初始化idle状态。 设置业务需要的监听事件，搭配全流程场景使用。支持的监听事件包括：     事件类型 说明    stateChange 必要事件，监听播放器的state属性改变。   error 必要事件，监听播放器的错误信息。   durationUpdate 用于进度条，监听进度条长度，刷新资源时长。   timeUpdate 用于进度条，监听进度条当前位置，刷新当前时间。   seekDone 响应API调用，监听seek()请求完成情况。 当使用seek()跳转到指定播放位置后，如果seek操作成功，将上报该事件。   speedDone 响应API调用，监听setSpeed()请求完成情况。 当使用setSpeed()设置播放倍速后，如果setSpeed操作成功，将上报该事件。   volumeChange 响应API调用，监听setVolume()请求完成情况。 当使用setVolume()调节播放音量后，如果setVolume操作成功，将上报该事件。   bufferingUpdate 用于网络播放，监听网络播放缓冲信息，用于上报缓冲百分比以及缓存播放进度。   audioInterrupt 监听音频焦点切换信息，搭配属性audioInterruptMode使用。 如果当前设备存在多个音频正在播放，音频焦点被切换（即播放其他媒体如通话等）时将上报该事件，应用可以及时处理。    设置资源：设置属性url，AVPlayer进入initialized状态。     下面代码示例中的url仅作示意使用，开发者需根据实际情况，确认资源有效性并设置：  如果使用本地资源播放，必须确认资源文件可用，并使用应用沙箱路径访问对应资源，参考获取应用文件路径。应用沙箱的介绍及如何向应用沙箱推送文件，请参考文件管理。 如果使用网络播放路径，需声明权限：ohos.permission.INTERNET。 如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法可参考ResourceManager API参考。 需要使用支持的播放格式与协议。  此外，如果需要设置音频渲染信息，则只允许在initialized状态下，第一次调用prepare()之前设置，以便音频渲染器信息在之后生效。若媒体源包含视频，则usage默认值为STREAM_USAGE_MOVIE，否则usage默认值为STREAM_USAGE_MUSIC。rendererFlags默认值为0。若默认usage不满足需求，则须主动配置audio.AudioRendererInfo。   准备播放：调用prepare()，AVPlayer进入prepared状态，此时可以获取duration，设置音量。 音频播控：播放play()，暂停pause()，跳转seek()，停止stop() 等操作。 （可选）更换资源：调用reset()重置资源，AVPlayer重新进入idle状态，允许更换资源url。 退出播放：调用release()销毁实例，AVPlayer进入released状态，退出播放。 
完整示例
参考以下示例，完整地播放一首音乐，实现起播后3s暂停，暂停3s重新播放的效果。
import { media } from '@kit.MediaKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { audio } from '@kit.AudioKit';\n\nexport class AVPlayerDemo {\n  private count: number = 0;\n  private isSeek: boolean = true; // 用于区分模式是否支持seek操作\n  private fileSize: number = -1;\n  private fd: number = 0;\n  // 注册avplayer回调函数\n  setAVPlayerCallback(avPlayer: media.AVPlayer) {\n    // seek操作结果回调函数\n    avPlayer.on('seekDone', (seekDoneTime: number) => {\n      console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);\n    });\n    // error回调监听函数,当avPlayer在操作过程中出现错误时调用 reset接口触发重置流程\n    avPlayer.on('error', (err: BusinessError) => {\n      console.error(`Invoke avPlayer failed, code is ${err.code}, message is ${err.message}`);\n      avPlayer.reset(); // 调用reset重置资源，触发idle状态\n    });\n    // 状态机变化回调函数\n    avPlayer.on('stateChange', async (state: string, reason: media.StateChangeReason) => {\n      switch (state) {\n        case 'idle': // 成功调用reset接口后触发该状态机上报\n          console.info('AVPlayer state idle called.');\n          avPlayer.release(); // 调用release接口销毁实例对象\n          break;\n        case 'initialized': // avplayer 设置播放源后触发该状态上报\n          console.info('AVPlayer state initialized called.');\n          avPlayer.audioRendererInfo = {\n            usage: audio.StreamUsage.STREAM_USAGE_MUSIC,\n            rendererFlags: 0\n          };\n          avPlayer.prepare();\n          break;\n        case 'prepared': // prepare调用成功后上报该状态机\n          console.info('AVPlayer state prepared called.');\n          avPlayer.play(); // 调用播放接口开始播放\n          break;\n        case 'playing': // play成功调用后触发该状态机上报\n          console.info('AVPlayer state playing called.');\n          if (this.count !== 0) {\n            if (this.isSeek) {\n              console.info('AVPlayer start to seek.');\n              avPlayer.seek(avPlayer.duration); //seek到音频末尾\n            } else {\n              // 当播放模式不支持seek操作时继续播放到结尾\n              console.info('AVPlayer wait to play end.');\n            }\n          } else {\n            setTimeout(() => {\n              console.info('AVPlayer is playing wait to pause');\n              avPlayer.pause(); // 播放3s后调用暂停接口暂停播放\n            }, 3000);\n          }\n          this.count++;\n          break;\n        case 'paused': // pause成功调用后触发该状态机上报\n          console.info('AVPlayer state paused called.');\n          setTimeout(() => {\n              console.info('AVPlayer paused wait to play again');\n              avPlayer.play(); // 暂停3s后再次调用播放接口开始播放\n            }, 3000);\n          break;\n        case 'completed': // 播放结束后触发该状态机上报\n          console.info('AVPlayer state completed called.');\n          avPlayer.stop(); //调用播放结束接口\n          break;\n        case 'stopped': // stop接口成功调用后触发该状态机上报\n          console.info('AVPlayer state stopped called.');\n          avPlayer.reset(); // 调用reset接口初始化avplayer状态\n          break;\n        case 'released':\n          console.info('AVPlayer state released called.');\n          break;\n        default:\n          console.info('AVPlayer state unknown called.');\n          break;\n      }\n    });\n  }\n\n  // 以下demo为使用fs文件系统打开沙箱地址获取媒体文件地址并通过url属性进行播放示例\n  async avPlayerUrlDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    let fdPath = 'fd://';\n    // 通过UIAbilityContext获取沙箱地址filesDir，以Stage模型为例\n    let context = getContext(this) as common.UIAbilityContext;\n    let pathDir = context.filesDir;\n    let path = pathDir + '/01.mp3';\n    // 打开相应的资源文件地址获取fd，并为url赋值触发initialized状态机上报\n    let file = await fs.open(path);\n    fdPath = fdPath + '' + file.fd;\n    this.isSeek = true; // 支持seek操作\n    avPlayer.url = fdPath;\n  }\n\n  // 以下demo为使用资源管理接口获取打包在HAP内的媒体资源文件并通过fdSrc属性进行播放示例\n  async avPlayerFdSrcDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    // 通过UIAbilityContext的resourceManager成员的getRawFd接口获取媒体资源播放地址\n    // 返回类型为{fd,offset,length},fd为HAP包fd地址，offset为媒体资源偏移量，length为播放长度\n    let context = getContext(this) as common.UIAbilityContext;\n    let fileDescriptor = await context.resourceManager.getRawFd('01.mp3');\n    let avFileDescriptor: media.AVFileDescriptor =\n      { fd: fileDescriptor.fd, offset: fileDescriptor.offset, length: fileDescriptor.length };\n    this.isSeek = true; // 支持seek操作\n    // 为fdSrc赋值触发initialized状态机上报\n    avPlayer.fdSrc = avFileDescriptor;\n  }\n\n  // 以下demo为使用fs文件系统打开沙箱地址获取媒体文件地址并通过dataSrc属性进行播放(seek模式)示例\n  async avPlayerDataSrcSeekDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    // dataSrc播放模式的的播放源地址，当播放为Seek模式时fileSize为播放文件的具体大小，下面会对fileSize赋值\n    let src: media.AVDataSrcDescriptor = {\n      fileSize: -1,\n      callback: (buf: ArrayBuffer, length: number, pos: number | undefined) => {\n        let num = 0;\n        if (buf == undefined || length == undefined || pos == undefined) {\n          return -1;\n        }\n        num = fs.readSync(this.fd, buf, { offset: pos, length: length });\n        if (num > 0 && (this.fileSize >= pos)) {\n          return num;\n        }\n        return -1;\n      }\n    };\n    let context = getContext(this) as common.UIAbilityContext;\n    // 通过UIAbilityContext获取沙箱地址filesDir，以Stage模型为例\n    let pathDir = context.filesDir;\n    let path = pathDir  + '/01.mp3';\n    await fs.open(path).then((file: fs.File) => {\n      this.fd = file.fd;\n    });\n    // 获取播放文件的大小\n    this.fileSize = fs.statSync(path).size;\n    src.fileSize = this.fileSize;\n    this.isSeek = true; // 支持seek操作\n    avPlayer.dataSrc = src;\n  }\n\n  // 以下demo为使用fs文件系统打开沙箱地址获取媒体文件地址并通过dataSrc属性进行播放(No seek模式)示例\n  async avPlayerDataSrcNoSeekDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    let context = getContext(this) as common.UIAbilityContext;\n    let src: media.AVDataSrcDescriptor = {\n      fileSize: -1,\n      callback: (buf: ArrayBuffer, length: number) => {\n        let num = 0;\n        if (buf == undefined || length == undefined) {\n          return -1;\n        }\n        num = fs.readSync(this.fd, buf);\n        if (num > 0) {\n          return num;\n        }\n        return -1;\n      }\n    };\n    // 通过UIAbilityContext获取沙箱地址filesDir，以Stage模型为例\n    let pathDir = context.filesDir;\n    let path = pathDir  + '/01.mp3';\n    await fs.open(path).then((file: fs.File) => {\n      this.fd = file.fd;\n    });\n    this.isSeek = false; // 不支持seek操作\n    avPlayer.dataSrc = src;\n  }\n\n  // 以下demo为通过url设置网络地址来实现播放直播码流的demo\n  async avPlayerLiveDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    this.isSeek = false; // 不支持seek操作\n    avPlayer.url = 'http://xxx.xxx.xxx.xxx:xx/xx/index.m3u8';\n  }\n}
示例代码
 视频播放 

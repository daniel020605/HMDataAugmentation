密钥协商(ArkTS)
以协商密钥类型为X25519，并密钥仅在HUKS内使用为例，完成密钥协商。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
开发步骤
生成密钥
设备A、设备B各自生成一个非对称密钥，具体请参考密钥生成或密钥导入。
密钥生成时，可指定参数HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识基于该密钥协商出的密钥是否由HUKS管理。
当TAG设置为HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥协商出的密钥，由HUKS管理，可保证协商密钥全生命周期不出安全环境。 当TAG设置为HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥协商出的密钥，返回给调用方管理，由业务自行保证密钥安全。 若业务未设置TAG的具体值，表示基于该密钥协商出的密钥，可由HUKS管理，也可返回给调用方管理，业务可在后续协商时再选择使用何种方式保护密钥。 
导出密钥
设备A、B导出非对称密钥对的公钥材料，具体请参考密钥导出。
密钥协商
设备A、B分别基于本端私钥和对端设备的公钥，协商出共享密钥。
密钥协商时，可指定参数HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识协商得到的密钥是否由HUKS管理。
注：协商时指定的TAG值，不可与生成时指定的TAG值冲突。表格中仅列举有效的指定方式。
删除密钥
当密钥废弃不用时，设备A、B均需要删除密钥，具体请参考密钥删除。
下面分别以X25519 与 DH密钥为例，进行协商。 
X25519非对称密钥协商用例 /*\n*以下以X25519密钥的Promise操作使用为例\n*/\nimport { huks } from '@kit.UniversalKeystoreKit';\n\n/*\n* 确定密钥别名和封装密钥属性参数集\n*/\nlet srcKeyAliasFirst = \"AgreeX25519KeyFirstAlias\";\nlet srcKeyAliasSecond = \"AgreeX25519KeySecondAlias\";\nlet agreeX25519InData = 'AgreeX25519TestIndata';\nlet finishOutData: Uint8Array;\nlet handle: number;\nlet exportKey: Uint8Array;\nlet exportKeyFirst: Uint8Array;\nlet exportKeySecond: Uint8Array;\n/* 集成生成密钥参数集 */\nlet properties: Array<huks.HuksParam> = [{\n  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n  value: huks.HuksKeyAlg.HUKS_ALG_X25519,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n  value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_DIGEST,\n  value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PADDING,\n  value: huks.HuksKeyPadding.HUKS_PADDING_NONE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n  value: huks.HuksCipherMode.HUKS_MODE_CBC,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n  value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,\n}];\nlet HuksOptions: huks.HuksOptions = {\n  properties: properties,\n  inData: new Uint8Array(new Array())\n}\n/* 集成第一个协商参数集 */\nconst finishProperties: Array<huks.HuksParam> = [{\n  tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n  value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS,\n  value: true\n}, {\n  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n  value: huks.HuksKeyAlg.HUKS_ALG_AES,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n  value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n  value:\n  huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |\n  huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_DIGEST,\n  value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PADDING,\n  value: huks.HuksKeyPadding.HUKS_PADDING_NONE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n  value: huks.HuksCipherMode.HUKS_MODE_ECB,\n}];\nlet finishOptionsFirst: huks.HuksOptions = {\n  properties: [\n    ...finishProperties, {\n    tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,\n    value: StringToUint8Array(srcKeyAliasFirst + 'final'),\n  }],\n  inData: StringToUint8Array(agreeX25519InData)\n}\n/* 集成第二个协商参数集 */\nlet finishOptionsSecond: huks.HuksOptions = {\n  properties: [\n    ...finishProperties, {\n    tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,\n    value: StringToUint8Array(srcKeyAliasSecond + 'final'),\n  }],\n  inData: StringToUint8Array(agreeX25519InData)\n}\n\nfunction StringToUint8Array(str: string) {\n  let arr: number[] = new Array();\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  return new Uint8Array(arr);\n}\n\nclass throwObject {\n  isThrow: boolean = false\n}\n\n/* 生成密钥 */\nfunction generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\n/* 调用generateKeyItem生成密钥 */\nasync function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise generateKeyItem`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await generateKeyItem(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: generateKeyItem failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: generateKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\n/*初始化密钥会话接口，并获取一个句柄（必选）和挑战值（可选）*/\nfunction initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksSessionHandle>((resolve, reject) => {\n    try {\n      huks.initSession(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\n/*调用initSession获取handle*/\nasync function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doInit`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await initSession(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);\n        handle = data.handle;\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doInit failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\n/* 分段添加密钥操作的数据并进行相应的密钥操作，输出处理数据 */\nfunction updateSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksReturnResult>((resolve, reject) => {\n    try {\n      huks.updateSession(handle, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\n/* 调用updateSession进行协商操作 */\nasync function publicUpdateFunc(handle: number, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doUpdate`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await updateSession(handle, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\n/* 结束密钥会话并进行相应的密钥操作，输出处理数据 */\nfunction finishSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksReturnResult>((resolve, reject) => {\n    try {\n      huks.finishSession(handle, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\n/* 调用finishSession结束操作 */\nasync function publicFinishFunc(handle: number, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doFinish`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await finishSession(handle, huksOptions, throwObject)\n      .then((data) => {\n        finishOutData = data.outData as Uint8Array;\n        console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doFinish failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doFinish input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\n/* 导出密钥 */\nfunction exportKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksReturnResult>((resolve, reject) => {\n    try {\n      huks.exportKeyItem(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\n/* 调用exportKeyItem导出公钥操作 */\nasync function publicExportKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise export`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await exportKeyItem(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: exportKeyItem success, data = ${JSON.stringify(data)}`);\n        exportKey = data.outData as Uint8Array;\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: exportKeyItem failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: exportKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\n/* 删除密钥操作 */\nfunction deleteKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      huks.deleteKeyItem(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\n/* 调用deleteKeyItem删除密钥操作 */\nasync function publicDeleteKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise deleteKeyItem`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await deleteKeyItem(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: deleteKeyItem failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nasync function testAgree() {\n  /* 1.确定密钥别名并集成并集成要参数集 A设备：srcKeyAliasFirst  B设备：srcKeyAliasSecond*/\n  /* 2.设备A生成密钥 */\n  await publicGenKeyFunc(srcKeyAliasFirst, HuksOptions);\n  /* 3.设备B生成密钥 */\n  await publicGenKeyFunc(srcKeyAliasSecond, HuksOptions);\n  /* 4.设备A、B导出非对称密钥的公钥 */\n  await publicExportKeyFunc(srcKeyAliasFirst, HuksOptions);\n  exportKeyFirst = exportKey;\n  await publicExportKeyFunc(srcKeyAliasSecond, HuksOptions);\n  exportKeySecond = exportKey;\n  /* 5.对第一个密钥进行协商（三段式）*/\n  await publicInitFunc(srcKeyAliasFirst, HuksOptions);\n  HuksOptions.inData = exportKeySecond;\n  await publicUpdateFunc(handle, HuksOptions);\n  await publicFinishFunc(handle, finishOptionsFirst);\n  /* 5.对第二个密钥进行协商（三段式） */\n  await publicInitFunc(srcKeyAliasSecond, HuksOptions);\n  HuksOptions.inData = exportKeyFirst;\n  await publicUpdateFunc(handle, HuksOptions);\n  await publicFinishFunc(handle, finishOptionsSecond);\n  /* 6.设备A、B删除密钥 */\n  await publicDeleteKeyFunc(srcKeyAliasFirst, HuksOptions);\n  await publicDeleteKeyFunc(srcKeyAliasSecond, HuksOptions);\n} DH密钥协商用例 /*\n*以下以 DH密钥的Promise操作使用为例\n*/\nimport { huks } from '@kit.UniversalKeystoreKit'\n\nfunction StringToUint8Array(str: string) {\n  let arr: number[] = []\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i))\n  }\n  return new Uint8Array(arr)\n}\n\nfunction Uint8ArrayToBigInt(arr: Uint8Array): bigint {\n  let i = 0\n  const byteMax: bigint = BigInt('0x100')\n  let result: bigint = BigInt('0')\n  while (i < arr.length) {\n    result = result * byteMax\n    result = result + BigInt(arr[i])\n    i += 1\n  }\n  return result\n}\n\nconst dhAgree: Array<huks.HuksParam> = [{\n  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n  value: huks.HuksKeyAlg.HUKS_ALG_DH,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE,\n}]\nconst dh2048Agree: Array<huks.HuksParam> = [\n  ...dhAgree, {\n  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n  value: huks.HuksKeySize.HUKS_DH_KEY_SIZE_2048,\n}]\nconst dhGenOptions: huks.HuksOptions = {\n  properties: dh2048Agree,\n  inData: new Uint8Array([])\n}\nconst emptyOptions: huks.HuksOptions = {\n  properties: [],\n  inData: new Uint8Array([])\n}\n\nasync function HuksDhAgreeExportKey(keyAlias: string,\n  peerPubKey: huks.HuksReturnResult): Promise<huks.HuksReturnResult> {\n  const initHandle = await huks.initSession(keyAlias, dhGenOptions)\n  const dhAgreeUpdateBobPubKey: huks.HuksOptions = {\n    properties: [\n      ...dh2048Agree, {\n      tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n      value: huks.HuksKeyStorageType.HUKS_STORAGE_KEY_EXPORT_ALLOWED,\n    }],\n    inData: peerPubKey.outData\n  }\n  await huks.updateSession(initHandle.handle, dhAgreeUpdateBobPubKey)\n  return await huks.finishSession(initHandle.handle, emptyOptions)\n}\n\nasync function HuksDhAgreeExportTest(\n  aliasA: string, aliasB: string,\n  pubKeyA: huks.HuksReturnResult, pubKeyB: huks.HuksReturnResult) {\n\n  const agreedKeyFromAlice = await HuksDhAgreeExportKey(aliasA, pubKeyB)\n  console.info(`ok! agreedKeyFromAlice export is 0x${Uint8ArrayToBigInt(agreedKeyFromAlice.outData).toString(16)}`)\n\n  const agreedKeyFromBob = await HuksDhAgreeExportKey(aliasB, pubKeyA)\n  console.info(`ok! agreedKeyFromBob export is 0x${Uint8ArrayToBigInt(agreedKeyFromBob.outData).toString(16)}`)\n}\n\nasync function HuksDhAgreeInHuks(keyAlias: string, peerPubKey: huks.HuksReturnResult,\n  aliasAgreedKey: string): Promise<huks.HuksReturnResult> {\n  const onlyUsedInHuks: Array<huks.HuksParam> = [{\n    tag: huks.HuksTag.HUKS_TAG_KEY_STORAGE_FLAG,\n    value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n    value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,\n  }]\n  const dhAgreeInit: huks.HuksOptions = {\n    properties: [\n      ...dhAgree,\n      { tag: huks.HuksTag.HUKS_TAG_KEY_SIZE, value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256, },\n      ...onlyUsedInHuks],\n    inData: new Uint8Array([])\n  }\n  const dhAgreeFinishParams: Array<huks.HuksParam> = [\n    ...onlyUsedInHuks,\n    { tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS, value: true },\n    { tag: huks.HuksTag.HUKS_TAG_ALGORITHM, value: huks.HuksKeyAlg.HUKS_ALG_AES },\n    { tag: huks.HuksTag.HUKS_TAG_KEY_SIZE, value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256 },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n      value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT\n    }]\n\n  const handle = await huks.initSession(keyAlias, dhAgreeInit)\n  const dhAgreeUpdatePubKey: huks.HuksOptions = {\n    properties: [...dhAgree, ...onlyUsedInHuks],\n    inData: peerPubKey.outData\n  }\n  await huks.updateSession(handle.handle, dhAgreeUpdatePubKey)\n  const dhAgreeAliceFinnish: huks.HuksOptions = {\n    properties: [...dhAgreeFinishParams, {\n      tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS, value: StringToUint8Array(aliasAgreedKey)\n    }], inData: new Uint8Array([])\n  }\n  return await huks.finishSession(handle.handle, dhAgreeAliceFinnish)\n}\n\nasync function HuksDhAgreeInHuksTest(\n  aliasA: string, aliasB: string,\n  pubKeyA: huks.HuksReturnResult, pubKeyB: huks.HuksReturnResult,\n  aliasAgreedKeyFromA: string, aliasAgreedKeyFromB: string) {\n\n  const finishAliceResult = await HuksDhAgreeInHuks(aliasA, pubKeyB, aliasAgreedKeyFromA)\n  console.info(`ok! finishAliceResult in huks is 0x${Uint8ArrayToBigInt(finishAliceResult.outData).toString(16)}`)\n  const aliceAgreedExist = await huks.isKeyItemExist(aliasAgreedKeyFromA, emptyOptions)\n  console.info(`ok! aliceAgreedExist in huks is ${aliceAgreedExist}`)\n\n  const finishBobResult = await HuksDhAgreeInHuks(aliasB, pubKeyA, aliasAgreedKeyFromB)\n  console.info(`ok! finishBobResult in huks is 0x${Uint8ArrayToBigInt(finishBobResult.outData).toString(16)}`)\n  const bobAgreedExist = await huks.isKeyItemExist(aliasAgreedKeyFromB, emptyOptions)\n  console.info(`ok! bobAgreedExist in huks is ${bobAgreedExist}`)\n\n  await huks.deleteKeyItem(aliasAgreedKeyFromA, emptyOptions)\n  await huks.deleteKeyItem(aliasAgreedKeyFromB, emptyOptions)\n}\n\nexport default async function HuksDhAgreeTest() {\n  const aliasAlice = 'alice'\n  const aliasBob = 'bob'\n\n  /* 调用generateKeyItem生成别名为alice与bob的两个密钥 */\n  await huks.generateKeyItem(aliasAlice, dhGenOptions)\n  await huks.generateKeyItem(aliasBob, dhGenOptions)\n\n  /* 导出非对称密钥alice与bob的的公钥 */\n  const pubKeyAlice = await huks.exportKeyItem(aliasAlice, emptyOptions)\n  const pubKeyBob = await huks.exportKeyItem(aliasBob, emptyOptions)\n\n  /* 开始协商，协商生成的密钥返回给业务管理 */\n  await HuksDhAgreeExportTest(aliasAlice, aliasBob, pubKeyAlice, pubKeyBob)\n\n  /* 开始协商，协商生成的密钥由HUKS管理 */\n  await HuksDhAgreeInHuksTest(aliasAlice, aliasBob, pubKeyAlice, pubKeyBob, 'agreedKeyFromAlice', 'agreedKeyFromBob')\n\n  await huks.deleteKeyItem(aliasAlice, emptyOptions)\n  await huks.deleteKeyItem(aliasBob, emptyOptions)\n} 

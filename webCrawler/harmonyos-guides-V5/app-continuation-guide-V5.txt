应用接续开发指导
通过应用接续，可以实现将应用当前任务（包括页面控件状态变量等）迁移到目标设备，并在目标设备上接续使用。
可以实现的功能包括：
存储及恢复自定义数据（应用业务内容）。存储及恢复页面路由信息和页面控件状态数据。应用兼容性检测。支持应用根据实际使用场景动态设置迁移状态（默认迁移状态为ACTIVE激活状态）。 如编辑类应用在编辑文本的页面下才需要迁移，其他页面不需要迁移，则可以通过setMissionContinueState进行控制。 支持应用动态选择是否进行页面栈恢复（默认进行页面栈信息恢复）。 如应用希望自定义迁移到其他设备后显示的页面，则可以通过wantConstant.Params进行控制。 支持应用动态选择流转成功后是否退出迁移源端应用（默认流转成功后退出迁移源端应用）。则可以通过@ohos.app.ability.wantConstant (wantConstant)进行控制。 
约束与限制
需同时满足以下条件，才能使用该功能：
设备限制HarmonyOS NEXT Developer Preview0及以上版本的设备。 使用限制双端设备需要登录同一华为账号。双端设备需要打开Wi-Fi和蓝牙开关。条件允许时，建议双端设备接入同一个局域网，可提升数据传输的速度。 应用接续只能在同应用（UIAbility）之间触发，双端设备都需要有该应用。为了接续体验，在onContinue回调中使用wantParam传输的数据需要控制在100KB以下，大数据量请使用分布式数据对象进行同步。 
接口说明
以下为实现应用接续的主要接口，详细的接口说明可查阅参考文档。
接口名
描述
onContinue(wantParam : {[key: string]: Object}): OnContinueResult
接续源端在该回调中保存迁移所需要的数据，同时返回是否同意迁移：
AGREE：表示同意。REJECT：表示拒绝，如应用在onContinue中异常可以直接REJECT。MISMATCH：表示版本不匹配，接续源端应用可以在onContinue中获取到迁移对端应用的版本号，进行协商后，如果版本不匹配导致无法迁移，可以返回该错误。
onCreate(want: Want, param: AbilityConstant.LaunchParam): void;
接续目的端为冷启动或多实例应用热启动时，在该回调中完成数据恢复，并触发页面恢复。
onNewWant(want: Want, launchParams: AbilityConstant.LaunchParam): void;
接续目的端为单实例应用热启动时，在该回调中完成数据恢复，并触发页面恢复。
开发步骤
启用应用接续能力。在module.json5文件的abilities中，将continuable标签配置为“true”，表示该UIAbility可被迁移。配置为false的UIAbility将被系统识别为无法迁移且该配置默认值为false。 {\n  \"module\": {\n    ...\n    \"abilities\": [\n      {\n        ...\n        \"continuable\": true,\n      }\n    ]\n  }\n} 根据需要配置应用启动模式类型，配置详情请参照UIAbility组件启动模式。在源端UIAbility中实现onContinue()接口。当应用触发迁移时，onContinue()接口在源端被调用，开发者可以在该接口中保存迁移数据，实现应用兼容性检测，决定是否支持此次迁移。 保存迁移数据：开发者可以将要迁移的数据通过键值对的方式保存在wantParam中。（可选）检测应用兼容性：开发者可以在触发迁移时从onContinue()入参wantParam.version获取到迁移对端应用的版本号，与迁移源端应用版本号做兼容校验。应用在校验版本兼容性失败后，需要提示用户迁移失败的原因。 如果迁移过程中的兼容性问题对于应用迁移体验影响较小或无影响，可以跳过该步骤。  返回迁移结果：开发者可以通过onContinue()回调的返回值决定是否支持此次迁移，接口返回值详见AbilityConstant.OnContinueResult。 onContinue()接口传入的wantParam参数中，有部分字段由系统预置，开发者可以使用这些字段用于业务处理。同时，应用在保存自己的wantParam参数时，也应注意不要使用同样的key值，避免被系统覆盖导致数据获取异常。详见下表： 字段  含义    version  对端应用的版本号   targetDevice  对端设备的networkId      import { AbilityConstant, UIAbility } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { promptAction } from '@kit.ArkUI';\n\nexport default class EntryAbility extends UIAbility {\n  onContinue(wantParam: Record<string, Object>) {\n    let targetVersion  = wantParam.version;  // 获取迁移对端应用的版本号\n    // 应用可根据源端版本号设置支持接续的最小兼容版本号，源端版本号可从app.json5文件中的versionCode字段获取；防止目标端版本号过低导致不兼容。\n    let versionThreshold: number = 0; // 替换为应用自己支持兼容的最小版本号\n    // 兼容性校验    \n    if (targetVersion < versionThreshold) {\n      // 建议在校验版本兼容性失败后，提示用户拒绝迁移的原因\n      promptAction.showToast({\n           message: '目标端应用版本号过低，不支持接续，请您升级应用版本后再试',\n           duration: 2000\n      })\n      // 在兼容性校验不通过时返回MISMATCH\n      return AbilityConstant.OnContinueResult.MISMATCH;\n    }\n    console.info(`onContinue version = ${wantParam.version}, targetDevice: ${wantParam.targetDevice}`)\n    // 迁移数据保存\n    let continueInput = '迁移的数据';\n    if (continueInput) {\n      // 将要迁移的数据保存在wantParam的自定义字段（如：data）中;\n      wantParam[\"data\"] = continueInput;\n    }\n     return AbilityConstant.OnContinueResult.AGREE;\n  }\n} 在Stage模型中，应用在不同启动模式下将调用不同的接口，以恢复数据、加载界面。不同情况下的函数调用如下图所示：   在应用迁移启动时，无论是冷启动还是热启动，都会在执行完onCreate()/onNewWant()后，触发onWindowStageRestore()生命周期函数，不执行onWindowStageCreate()生命周期函数。开发者如果在onWindowStageCreate()中进行了一些应用启动时必要的初始化，那么迁移后需要在onWindowStageRestore()中执行同样的初始化操作，避免应用异常。  在目的端设UIAbility中实现onCreate()与onNewWant()接口，恢复迁移数据。onCreate实现示例目的端设备上，在onCreate中根据launchReason判断该次启动是否为迁移LaunchReason.CONTINUATION。 开发者可以从want中获取保存的迁移数据。 若开发者使用系统页面栈恢复功能，则需要在onCreate()/onNewWant()执行完成前，调用restoreWindowStage()，来触发带有页面栈的页面恢复，如果不需要迁移页面栈可以参考按需迁移页面栈部分。  import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\n\nexport default class EntryAbility extends UIAbility {\n  storage : LocalStorage = new LocalStorage();\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    if (launchParam.launchReason == AbilityConstant.LaunchReason.CONTINUATION) {\n      // 将上述的保存的数据取出恢复\n      let continueInput = '';\n      if (want.parameters != undefined) {\n        continueInput = JSON.stringify(want.parameters.data);\n        console.info(`continue input ${continueInput}`)\n      }\n      // 触发页面恢复\n      this.context.restoreWindowStage(this.storage);\n    }\n  }\n}  接口restoreWindowStage(this.storage)必须在同步接口方法中执行，如果在异步回调中执行，可能会导致应用迁移后页面加载失败。  如果是单实例应用，需要额外实现onNewWant()接口，实现方式与onCreate()的实现相同。在onNewWant()中判断迁移场景，恢复数据，并触发页面恢复 import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\n\nexport default class EntryAbility extends UIAbility {\n  storage : LocalStorage = new LocalStorage();\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    console.info(`EntryAbility onNewWant ${AbilityConstant.LaunchReason.CONTINUATION}`)\n    if (launchParam.launchReason == AbilityConstant.LaunchReason.CONTINUATION) {\n      // 将上述的保存的数据取出恢复\n      let continueInput = '';\n      if (want.parameters != undefined) {\n        continueInput = JSON.stringify(want.parameters.data);\n        console.info(`continue input ${continueInput}`);\n      }\n      this.context.restoreWindowStage(this.storage);\n    }\n  }\n}   
迁移功能可选配置
[h2]动态配置迁移能力
从API version 10起，提供了支持动态配置迁移能力的功能。即应用可以根据实际使用场景，在需要迁移功能时，设置开启应用迁移能力；在业务不需要迁移时，则可以关闭迁移能力。开发者可以通过调用setMissionContinueState接口对迁移能力进行设置。
接口状态值
含义
AbilityConstant.ContinueState.ACTIVE
应用当前可迁移能力开启
AbilityConstant.ContinueState.INACTIVE
应用当前可迁移能力关闭
设置迁移能力的时机
默认状态下，应用的迁移能力为ACTIVE状态，即可以迁移。
如果需要实现某些特殊场景，比如只在具体某个页面下支持迁移，或者只在某个事件发生时才支持迁移，可以按照如下步骤进行配置。
在Ability的onCreate生命周期回调中，关闭迁移能力。// EntryAbility.ets\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    // ...\n    this.context.setMissionContinueState(AbilityConstant.ContinueState.INACTIVE, (result) => {\n      console.info(`setMissionContinueState: ${JSON.stringify(result)}`);\n    });\n    // ...\n  }\n} 
如果需要在具体某个页面中打开迁移能力，可以在该页面的onPageShow()函数中设置。// PageName.ets\nimport { AbilityConstant, common } from '@kit.AbilityKit';\n@Entry\n@Component\nstruct PageName {\n  private context = getContext(this) as common.UIAbilityContext;\n  build() {\n    // ...\n  }\n  // ...\n  onPageShow(){\n  // 进入该页面时，将应用设置为可迁移状态\n    this.context.setMissionContinueState(AbilityConstant.ContinueState.ACTIVE, (result) => {\n      console.info('setMissionContinueState ACTIVE result: ', JSON.stringify(result));\n    });\n  }\n} 
如果在某个组件的触发事件中打开迁移能力，可以在该事件中设置。下面以Button组件的onClick事件为例进行介绍。// PageName.ets\nimport { AbilityConstant, common } from '@kit.AbilityKit';\n@Entry\n@Component\nstruct PageName {\n  private context = getContext(this) as common.UIAbilityContext;\n  build() {\n    // ...\n    Button() {\n      //...\n    }.onClick(()=>{\n    //点击该按钮时，将应用设置为可迁移状态\n      this.context.setMissionContinueState(AbilityConstant.ContinueState.ACTIVE, (result) => {\n        console.info('setMissionContinueState ACTIVE result: ', JSON.stringify(result));\n      });\n    })\n  }\n} 
保证迁移连续性
由于迁移加载时，目标端拉起的应用可能执行过自己的迁移状态设置命令（如：冷启动时目标端在onCreate中设置了INACTIVE；热启动时对端已打开了不可迁移的页面，迁移状态为INACTIVE等情况）。为了保证迁移过后的应用依然具有可以迁移回源端的能力，应在onCreate和onNewWant的迁移调用判断中，将迁移状态设置为ACTIVE。
// EntryAbility.ets\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nexport default class EntryAbility extends UIAbility {\n  // ...\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    // ...\n    // 迁移冷启动时，设置状态为可迁移\n    this.context.setMissionContinueState(AbilityConstant.ContinueState.ACTIVE, (result) => {\n      console.info(`setMissionContinueState: ${JSON.stringify(result)}`);\n    });\n  }\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    // ...\n    // 迁移热启动时，设置状态为可迁移\n    if (launchParam.launchReason == AbilityConstant.LaunchReason.CONTINUATION) {\n      this.context.setMissionContinueState(AbilityConstant.ContinueState.ACTIVE, (result) => {\n        console.info('setMissionContinueState ACTIVE result: ', JSON.stringify(result));\n      });\n    }\n  }\n  // ...\n}
[h2]按需迁移页面栈
支持应用动态选择是否进行页面栈恢复（默认进行页面栈信息恢复）。如果应用不想使用系统默认恢复的页面栈，则可以设置不进行页面栈迁移，而需要在onWindowStageRestore设置迁移后进入的页面，参数定义见SUPPORT_CONTINUE_PAGE_STACK_KEY。
当前仅支持router路由的页面栈信息自动恢复，暂不支持navigation路由的页面栈自动恢复。如果应用使用navigation路由，可以设置不进行页面栈迁移，并将需要接续的页面（或页面栈）信息保存在want中传递，然后在目标端手动加载指定页面。
应用在源端的页面栈中存在Index和Second路由，而在目标端恢复时不需要按照源端页面栈进行恢复，需要恢复到指定页面。
示例：应用迁移不需要自动迁移页面栈信息
// EntryAbility.ets\nimport { AbilityConstant, UIAbility, wantConstant } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nexport default class EntryAbility extends UIAbility {\n  // ...\n  onContinue(wantParam: Record<string, Object>) {\n    console.info(`onContinue version = ${wantParam.version}, targetDevice: ${wantParam.targetDevice}`);\n    wantParam[wantConstant.Params.SUPPORT_CONTINUE_PAGE_STACK_KEY] = false;\n    return AbilityConstant.OnContinueResult.AGREE;\n  }\n  // ...\n  onWindowStageRestore(windowStage: window.WindowStage) {\n      // 若不需要自动迁移页面栈信息，则需要在此处设置应用迁移后进入的页面\n    windowStage.loadContent('pages/Index', (err, data) => {\n      if (err.code) {\n        console.info('Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      console.info('Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n  }\n}
[h2]按需退出
支持应用动态选择迁移成功后是否退出迁移源端应用（默认迁移成功后退出迁移源端应用）。如果应用不想让系统自动退出迁移源端应用，则可以设置不退出，参数定义见SUPPORT_CONTINUE_SOURCE_EXIT_KEY。
示例：应用迁移设置不需要迁移成功后退出迁移源端应用
import { AbilityConstant, UIAbility, wantConstant } from '@kit.AbilityKit';\nexport default class EntryAbility extends UIAbility {\n  // ...\n  onContinue(wantParam: Record<string, Object>) {\n    console.info(`onContinue version = ${wantParam.version}, targetDevice: ${wantParam.targetDevice}`);\n    wantParam[wantConstant.Params.SUPPORT_CONTINUE_SOURCE_EXIT_KEY] = false;\n    return AbilityConstant.OnContinueResult.AGREE;\n  }\n  // ...\n}
[h2]支持同应用中不同Ability跨端迁移
一般情况下，跨端迁移的双端是同Ability之间，但有些应用在不同设备类型下的同一个业务Ability名称不同（即异Ability），为了支持该场景下的两个Ability之间能够完成迁移，可以通过在module.json5文件的abilities标签中配置迁移类型continueType进行关联。 需要迁移的两个Ability的continueType字段取值必须保持一致，示例如下：
continueType在本应用中要保证唯一，字符串以字母、数字和下划线组成，最大长度127个字节，不支持中文。continueType标签类型为字符串数组，如果配置了多个字段，当前仅第一个字段会生效。
 // 设备A\n   {\n     \"module\": {\n       // ...\n       \"abilities\": [\n         {\n           // ...\n           \"name\": \"Ability-deviceA\",\n           \"continueType\": ['continueType1'], // continueType标签配置\n         }\n       ]\n     }\n   }\n\n   // 设备B\n   {\n     \"module\": {\n       // ...\n       \"abilities\": [\n         {\n           // ...\n           \"name\": \"Ability-deviceB\",\n           \"continueType\": ['continueType1'], // 与设备A相同的continueType标签\n         }\n       ]\n     }\n   }
[h2]快速启动目标应用
默认情况下，发起迁移后不会立即拉起对端的目标应用，而是等待迁移数据从源端传输到对端后才会拉起应用。若应用希望在用户发起接续后立即被拉起，减少等待时间，提升体验，可以在module.json5文件的continueType标签中添加“_ContinueQuickStart”后缀，配置快速启动目标应用能力。示例如下：
{\n  \"module\": {\n    // ...\n    \"abilities\": [\n      {\n        // ...\n        \"name\": \"EntryAbility\"\n        \"continueType\": ['EntryAbility_ContinueQuickStart'], // 如果已经配置了continueType标签，可以在该标签值后添加'_ContinueQuickStart'后缀；如果没有配置continueType标签，可以使用AbilityName + '_ContinueQuickStart'作为continueType标签实现快速拉起目标应用\n      }\n    ]\n  }\n}
配置了快速拉起的应用，在用户发起接续时会立即收到一次launchReason为提前拉起（PREPARE_CONTINUATION）的onCreate()/onNewWant()请求，随后再收到一次launchReason为接续拉起（CONTINUATION）的onNewWant()请求。如下所示：
场景
生命周期函数
launchParam.launchReason
第一次启动请求
onCreate (冷启动)
或 onNewWant (热启动)
AbilityConstant.LaunchReason.PREPARE_CONTINUATION
第二次启动请求
onNewWant
AbilityConstant.LaunchReason.CONTINUATION
如果没有配置快速拉起，则触发迁移时只会收到一次启动请求：
场景
生命周期函数
launchParam.launchReason
一次启动请求
onCreate (冷启动)
或 onNewWant (热启动)
AbilityConstant.LaunchReason.CONTINUATION
配置快速拉起后，对应的 onCreate()/onNewWant() 接口实现可参考如下示例：
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\n\nconst TAG: string = '[MigrationAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class MigrationAbility extends UIAbility {\n  storage : LocalStorage = new LocalStorage();\n\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onCreate');\n\n    // 1.已配置快速拉起功能，应用立即启动时触发应用生命周期回调\n    if (launchParam.launchReason === AbilityConstant.LaunchReason.PREPARE_CONTINUATION) {\n      //若应用迁移数据较大，可在此处添加加载页面(页面中显示loading等)\n      //可处理应用自定义跳转、时序等问题\n      // ...\n    }\n  }\n\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN_NUMBER, TAG, 'onNewWant');\n\n    // 1.已配置快速拉起功能，应用立即启动时触发应用生命周期回调\n    if (launchParam.launchReason === AbilityConstant.LaunchReason.PREPARE_CONTINUATION) {\n      //若应用迁移数据较大，可在此处添加加载页面(页面中显示loading等)\n      //可处理应用自定义跳转、时序等问题\n      // ...\n    }\n\n    // 2.迁移数据恢复时触发应用生命周期回调\n    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {\n      // 将上述保存的数据从want.parameters中取出恢复\n      let continueInput = '';\n      if (want.parameters !== undefined) {\n        continueInput = JSON.stringify(want.parameters.data);\n        hilog.info(DOMAIN_NUMBER, TAG, `continue input ${JSON.stringify(continueInput)}`);\n      }\n      // 触发页面恢复\n      this.context.restoreWindowStage(this.storage);\n    }\n  }\n}
使用分布式数据对象迁移数据
当需要迁移的数据较大（100KB以上）或需要迁移文件时，可以使用分布式数据对象。原理与接口说明详见分布式数据对象跨设备数据同步。
自API 12起，由于直接使用跨设备文件访问实现文件的迁移，难以获取文件同步完成的时间。为了保证更高的成功率，文件的迁移不建议继续通过该方式实现，推荐使用分布式数据对象携带资产的方式。开发者此前通过跨设备文件访问实现的文件迁移依然生效。
[h2]申请权限
自API 12起，无需申请ohos.permission.DISTRIBUTED_DATASYNC权限。API 11及以前版本，需要执行如下操作。
声明ohos.permission.DISTRIBUTED_DATASYNC权限，详见声明权限。由于ohos.permission.DISTRIBUTED_DATASYNC权限需要用户授权，应用需在首次启动、或进入接续页面时弹窗向用户申请授权，详见向用户申请授权。
[h2]基础数据迁移
使用分布式数据对象，与上述开发步骤类似，需要在源端onContinue()接口中进行数据保存，并在对端的onCreate()/onNewWant()接口中进行数据恢复。
在源端UIAbility的onContinue()接口中创建分布式数据对象并保存数据，执行流程如下：在onContinue()接口中使用create()接口创建分布式数据对象，将所要迁移的数据填充到分布式数据对象数据中。调用genSessionId()接口生成数据对象组网id，并使用该id调用setSessionId()加入组网，激活分布式数据对象。使用save()接口将已激活的分布式数据对象持久化，确保源端退出后对端依然可以获取到数据。将生成的sessionId通过want传递到对端，供对端激活同步使用。  分布式数据对象需要先激活，再持久化，因此必须在调用setSessionId()后再调用save()接口。对于源端迁移后需要退出的应用，为了防止数据未保存完成应用就退出，应采用await的方式等待save()接口执行完毕。从API 12 起，onContinue()接口提供了async版本供该场景使用。当前，wantParams中“sessionId”字段在迁移流程中被系统占用，建议开发者在wantParams中定义其他key值存储该分布式数据对象生成的id，避免数据异常。  示例代码如下： import { distributedDataObject } from '@kit.ArkData';\nimport { UIAbility, AbilityConstant } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nconst TAG: string = '[MigrationAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\n// 业务数据定义\nclass ParentObject {\n  mother: string\n  father: string\n\n  constructor(mother: string, father: string) {\n    this.mother = mother\n    this.father = father\n  }\n}\n\n// 支持字符、数字、布尔值、对象的传递\nclass SourceObject {\n  name: string | undefined\n  age: number | undefined\n  isVis: boolean | undefined\n  parent: ParentObject | undefined\n\n  constructor(name: string | undefined, age: number | undefined, isVis: boolean | undefined, parent: ParentObject | undefined) {\n    this.name = name\n    this.age = age\n    this.isVis = isVis\n    this.parent = parent\n  }\n}\n\nexport default class MigrationAbility extends UIAbility {\n  d_object?: distributedDataObject.DataObject;\n\n  async onContinue(wantParam: Record<string, Object>): Promise<AbilityConstant.OnContinueResult> {\n    // ...\n    let parentSource: ParentObject = new ParentObject('jack mom', 'jack Dad');\n    let source: SourceObject = new SourceObject(\"jack\", 18, false, parentSource);\n\n    // 创建分布式数据对象\n    this.d_object = distributedDataObject.create(this.context, source);\n\n    // 生成数据对象组网id，激活分布式数据对象\n    let dataSessionId: string = distributedDataObject.genSessionId();\n    this.d_object.setSessionId(dataSessionId);\n\n    // 将组网id存在want中传递到对端\n    wantParam['dataSessionId'] = dataSessionId;\n\n    // 数据对象持久化，确保迁移后即使应用退出，对端依然能够恢复数据对象\n    // 从wantParam.targetDevice中获取到对端设备的networkId作为入参\n    await this.d_object.save(wantParam.targetDevice as string).then((result:\n      distributedDataObject.SaveSuccessResponse) => {\n      hilog.info(DOMAIN_NUMBER, TAG, `Succeeded in saving. SessionId: ${result.sessionId},\n        version:${result.version}, deviceId:${result.deviceId}`);\n    }).catch((err: BusinessError) => {\n      hilog.error(DOMAIN_NUMBER, TAG, 'Failed to save. Error: ', JSON.stringify(err) ?? '');\n    });\n  }\n}  在对端UIAbility的onCreate()/onNewWant()中，通过加入与源端一致的分布式数据对象组网进行数据恢复。创建空的分布式数据对象，用于接收恢复的数据；从want中读取分布式数据对象组网id；注册on()接口监听数据变更。在收到status为restore的事件的回调中，实现数据恢复完毕时需要进行的业务操作。调用setSessionId()加入组网，激活分布式数据对象。  对端加入组网的分布式数据对象不能为临时变量，因为在分布式数据对象on()接口为异步回调，可能在onCreate()/onNewWant()执行结束后才执行，临时变量被释放可能导致空指针异常。可以使用类成员变量避免该问题。对端用于创建分布式数据对象的Object，其属性应在激活分布式数据对象前置为undefined，否则会导致新数据加入组网后覆盖源端数据，数据恢复失败。应当在激活分布式数据对象之前，调用分布式数据对象的on()接口进行注册监听，防止错过restore事件导致数据恢复失败。  示例代码如下： import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { distributedDataObject } from '@kit.ArkData';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nconst TAG: string = '[MigrationAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\n// 示例数据对象定义与上同\n\nexport default class MigrationAbility extends UIAbility {\n  d_object?: distributedDataObject.DataObject;\n\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {\n      // ...\n      // 调用封装好的分布式数据对象处理函数\n      this.handleDistributedData(want);\n    }\n  }\n\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {\n      if (want.parameters !== undefined) {\n        // ...\n        // 调用封装好的分布式数据对象处理函数\n        this.handleDistributedData(want);\n      }\n    }\n  }\n\n  handleDistributedData(want: Want) {\n    // 创建空的分布式数据对象\n    let remoteSource: SourceObject = new SourceObject(undefined, undefined, undefined, undefined);\n    this.d_object = distributedDataObject.create(this.context, remoteSource);\n\n    // 读取分布式数据对象组网id\n    let dataSessionId = '';\n    if (want.parameters !== undefined) {\n      dataSessionId = want.parameters.dataSessionId as string;\n    }\n    // 添加数据变更监听\n    this.d_object.on(\"status\", (sessionId: string, networkId: string, status: 'online' | 'offline' | 'restored') => {\n      hilog.info(DOMAIN_NUMBER, TAG, \"status changed \" + sessionId + \" \" + status + \" \" + networkId);\n      if (status == 'restored') {\n        if (this.d_object) {\n          // 收到迁移恢复的状态时，可以从分布式数据对象中读取数据\n          hilog.info(DOMAIN_NUMBER, TAG, \"restored name:\" + this.d_object['name']);\n          hilog.info(DOMAIN_NUMBER, TAG, \"restored parents:\" + JSON.stringify(this.d_object['parent']));\n        }\n      }\n    });\n    // 激活分布式数据对象\n    this.d_object.setSessionId(dataSessionId);\n  }\n} 
[h2]文件资产迁移
对于图片、文档等文件类数据，需要先将其转换为资产commonType.Asset类型，再封装到分布式数据对象中进行迁移。迁移实现方式与普通的分布式数据对象类似，下面仅针对差异部分进行说明。
在源端，将需要迁移的文件资产保存到分布式数据对象DataObject中，执行流程如下：
将文件资产拷贝到分布式文件目录下，相关接口与用法详见基础文件接口。使用分布式文件目录下的文件创建Asset资产对象。将Asset资产对象作为分布式数据对象的根属性保存。
随后，与普通数据对象的迁移的源端实现相同，可以使用该数据对象加入组网，并进行持久化保存。
示例如下：
// 导入模块\nimport { UIAbility, AbilityConstant } from '@kit.AbilityKit';\nimport { distributedDataObject, commonType } from '@kit.ArkData';\nimport { fileIo, fileUri } from '@kit.CoreFileKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { BusinessError } from '@ohos.base';\nconst TAG: string = '[MigrationAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\n// 数据对象定义\nclass ParentObject {\n  mother: string\n  father: string\n\n  constructor(mother: string, father: string) {\n    this.mother = mother\n    this.father = father\n  }\n}\n\nclass SourceObject {\n  name: string | undefined\n  age: number | undefined\n  isVis: boolean | undefined\n  parent: ParentObject | undefined\n  attachment: commonType.Asset | undefined  // 新增资产属性\n\n  constructor(name: string | undefined, age: number | undefined, isVis: boolean | undefined,\n    parent: ParentObject | undefined, attachment: commonType.Asset | undefined) {\n    this.name = name\n    this.age = age\n    this.isVis = isVis\n    this.parent = parent\n    this.attachment = attachment;\n  }\n}\n\nexport default class MigrationAbility extends UIAbility {\n  d_object?: distributedDataObject.DataObject;\n\n  async onContinue(wantParam: Record<string, Object>): Promise<AbilityConstant.OnContinueResult> {\n    // ...\n\n    // 1. 将资产写入分布式文件目录下\n    let distributedDir: string = this.context.distributedFilesDir;  // 获取分布式文件目录路径\n    let fileName: string = '/test.txt';                        // 文件名\n    let filePath: string = distributedDir + fileName;          // 文件路径\n\n    try {\n      // 在分布式目录下创建文件\n      let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);\n      hilog.info(DOMAIN_NUMBER, TAG, 'Create file success.');\n      // 向文件中写入内容（若资产为图片，可将图片转换为buffer后写入）\n      fileIo.writeSync(file.fd, '[Sample] Insert file content here.');\n      // 关闭文件\n      fileIo.closeSync(file.fd);\n    } catch (error) {\n      let err: BusinessError = error as BusinessError;\n      hilog.error(DOMAIN_NUMBER, TAG, `Failed to openSync / writeSync / closeSync. Code: ${err.code}, message: ${err.message}`);\n    }\n\n    // 2. 使用分布式文件目录下的文件创建资产对象\n    let distributedUri: string = fileUri.getUriFromPath(filePath); // 获取分布式文件Uri\n\n    // 获取文件参数\n    let ctime: string = '';\n    let mtime: string = '';\n    let size: string = '';\n    await fileIo.stat(filePath).then((stat: fileIo.Stat) => {\n      ctime = stat.ctime.toString();  // 创建时间\n      mtime = stat.mtime.toString();  // 修改时间\n      size = stat.size.toString();    // 文件大小\n    })\n\n    // 创建资产对象\n    let attachment: commonType.Asset = {\n      name: fileName,\n      uri: distributedUri,\n      path: filePath,\n      createTime: ctime,\n      modifyTime: mtime,\n      size: size,\n    }\n\n    // 3. 将资产对象作为分布式数据对象的根属性，创建分布式数据对象\n    let parentSource: ParentObject = new ParentObject('jack mom', 'jack Dad');\n    let source: SourceObject = new SourceObject(\"jack\", 18, false, parentSource, attachment);\n    this.d_object = distributedDataObject.create(this.context, source);\n\n    // 生成组网id，激活分布式数据对象，save持久化保存\n    // ...\n}
对端需要先创建一个各属性为空的Asset资产对象作为分布式数据对象的根属性。在接收到on()接口status为restored的事件的回调时，表示包括资产在内的数据同步完成，可以像获取基本数据一样获取到源端的资产对象。
对端创建分布式数据对象时，SourceObject对象中的资产不能直接使用undefined初始化，需要创建一个各属性为空的Asset资产对象，否则会导致资产同步失败。
示例代码如下：
import { UIAbility, Want } from '@kit.AbilityKit';\nimport { distributedDataObject, commonType } from '@kit.ArkData';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nconst TAG: string = '[MigrationAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class MigrationAbility extends UIAbility {\n  d_object?: distributedDataObject.DataObject;\n\n  handleDistributedData(want: Want) {\n    // ...\n    // 创建一个各属性为空的资产对象\n    let attachment: commonType.Asset = {\n      name: '',\n      uri: '',\n      path: '',\n      createTime: '',\n      modifyTime: '',\n      size: '',\n    }\n\n    // 使用该空资产对象创建分布式数据对象，其余基础属性可以直接使用undefined\n    let source: SourceObject = new SourceObject(undefined, undefined, undefined, undefined, attachment);\n    this.d_object = distributedDataObject.create(this.context, source);\n\n    this.d_object.on(\"status\", (sessionId: string, networkId: string, status: 'online' | 'offline' | 'restored') => {\n        if (status == 'restored') {\n          // 收到监听的restored回调，表示分布式资产对象同步完成\n          hilog.info(DOMAIN_NUMBER, TAG, \"restored attachment:\" + JSON.stringify(this.d_object['attachment']));\n        }\n    });\n    // ...\n  }\n}
若应用想要同步多个资产，可采用两种方式实现：
可将每个资产作为分布式数据对象的一个根属性实现，适用于要迁移的资产数量固定的场景。可以将资产数组传化为Object传递，适用于需要迁移的资产个数会动态变化的场景（如用户选择了不定数量的图片）。当前不支持直接将资产数组作为根属性传递。
其中方式1的实现可以直接参照添加一个资产的方式添加更多资产。方式2的示例如下所示：
// 导入模块\nimport { distributedDataObject, commonType } from '@kit.ArkData';\nimport { UIAbility } from '@kit.AbilityKit';\n\n// 数据对象定义\nclass SourceObject {\n  name: string | undefined\n  assets: Object | undefined  // 分布式数据对象的中添加一个Object属性\n\n  constructor(name: string | undefined, assets: Object | undefined) {\n    this.name = name\n    this.assets = assets;\n  }\n}\n\n// 该函数用于将资产数组转为Record\nGetAssetsWrapper(assets: commonType.Assets): Record<string, commonType.Asset> {\n  let wrapper: Record<string, commonType.Asset> = {}\n  let num: number = assets.length;\n  for (let i: number = 0; i < num; i++) {\n    wrapper[`asset${i}`] = assets[i];\n  }\n  return wrapper;\n}\n\nexport default class MigrationAbility extends UIAbility {\n  d_object?: distributedDataObject.DataObject;\n\n  async onContinue(wantParam: Record<string, Object>): AbilityConstant.OnContinueResult {\n    // ...\n\n    // 创建了多个资产对象\n    let attachment1: commonType.Asset = {\n      // ...\n    }\n\n    let attachment2: commonType.Asset = {\n      // ...\n    }\n\n    // 将资产对象插入资产数组\n    let assets: commonType.Assets = [];\n    assets.push(attachment1);\n    assets.push(attachment2);\n\n    // 将资产数组转为Record Object，并用于创建分布式数据对象\n    let assetsWrapper: Object = this.GetAssetsWrapper(assets);\n    let source: SourceObject = new SourceObject(\"jack\", assetsWrapper);\n    this.d_object = distributedDataObject.create(this.context, source);\n\n    // ...\n}

使用ImageEffect编辑图片
场景介绍
ImageEffect提供了一系列接口用于图像的编辑。开发者可以通过ImageEffect接口处理不同图像输入类型Pixelmap、NativeWindow、NativeBuffer或Uri，获得滤镜处理效果。
针对ImageEffect，常见的开发场景如下：
 通过ImageEffect提供的Native API接口添加滤镜或滤镜链，设置输入图像，最终生效滤镜效果。 通过注册自定义滤镜，实现开发者的定制化滤镜效果。 通过EffectFilter提供的Native API接口快速实现单个滤镜的处理效果。 
接口说明
详细的接口说明请参考ImageEffect。
开发步骤
添加动态链接库
CMakeLists.txt中添加以下lib。
target_link_libraries(entry PUBLIC\n    libace_ndk.z.so\n    libimage_effect.so\n    libpixelmap.so\n    libnative_window.so\n    libnative_buffer.so\n)
根据处理的图像类型添加对应动态链接库：Pixelmap(libpixelmap.so)、NativeWindow(libnative_window.so)、NativeBuffer(libnative_buffer.so)
添加头文件
#include <multimedia/image_effect/image_effect.h>\n#include <multimedia/image_effect/image_effect_filter.h>\n#include <multimedia/image_effect/image_effect_errors.h>
[h2]通过ImageEffect提供的接口生效图像效果
 创建ImageEffect实例。 // 创建imageEffect实例，“ImageEdit”是imageEffect实例别名。\nOH_ImageEffect *imageEffect = OH_ImageEffect_Create(\"ImageEdit\"); 添加EffectFilter滤镜。 // 添加滤镜，获取 OH_EffectFilter 实例。多次调用该接口可以添加多个滤镜，组成滤镜链。\nOH_EffectFilter *filter = OH_ImageEffect_AddFilter(imageEffect, OH_EFFECT_BRIGHTNESS_FILTER);\nCHECK_AND_RETURN_LOG(filter != nullptr, \"OH_ImageEffect_AddFilter fail!\");\n\n// 设置滤镜参数, 例如：滤镜强度设置为50。\nImageEffect_Any value = { .dataType = ImageEffect_DataType::EFFECT_DATA_TYPE_FLOAT, .dataValue.floatValue = 50.f };\nImageEffect_ErrorCode errorCode = OH_EffectFilter_SetValue(filter, OH_EFFECT_FILTER_INTENSITY_KEY, &value); 设置处理数据。 场景一：设置 OH_PixelmapNative 输入类型。 OH_PixelmapNative的具体使用方法请参考Pixelmap开发指导。 // 设置输入的Pixelmap。\nerrorCode = OH_ImageEffect_SetInputPixelmap(imageEffect, inputPixelmap);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_SetInputPixelmap fail!\");\n\n// 设置输出的Pixelmap（可选），不调用该接口时会在输入Pixelmap上直接生效滤镜效果。\nerrorCode = OH_ImageEffect_SetOutputPixelmap(imageEffect, outputPixelmap);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_SetOutputPixelmap fail!\"); 场景二：设置 OH_NativeBuffer 输入类型。 OH_NativeBuffer的具体使用方法请参考NativeBuffer开发指导。 // 设置输入的NativeBuffer。\nerrorCode = OH_ImageEffect_SetInputNativeBuffer(imageEffect, inputNativeBuffer);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_SetInputNativeBuffer fail!\");\n\n// 设置输出的NativeBuffer（可选），不调用该接口时会在输入NativeBuffer上直接生效滤镜效果。\nerrorCode = OH_ImageEffect_SetOutputNativeBuffer(imageEffect, outputNativeBuffer);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_SetOutputNativeBuffer fail!\"); 场景三：设置 URI 输入类型。 // 设置输入的URI。\nerrorCode = OH_ImageEffect_SetInputUri(imageEffect, inputUri);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_SetInputUri fail!\");\n\n// 设置输出的URI（可选），不调用该接口时会在输入URI上直接生效滤镜效果。\nerrorCode = OH_ImageEffect_SetOutputUri(imageEffect, outputUri);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_SetOutputUri fail!\"); 场景四：设置 OHNativeWindow 输入类型。 以相机预览场景为例来说明OHNativeWindow输入场景。XComponent组件为相机预览流提供的SurfaceId，可在native c++层将SurfaceId转换成OHNativeWindow，下面提供一份代码示例。 XComponent模块的具体使用方法请参考XComponent组件参考。 NativeWindow模块的具体使用方法请参考OHNativeWindow。 Camera的具体使用方法请参考Camera预览参考。 (1) 在xxx.ets中添加一个XComponent组件。 XComponent({ \n    id: 'xcomponentId', \n    type: 'surface',\n    controller: this.mXComponentController, \n    libraryname: 'entry'\n})\n.onLoad(() => {\n    // 获取XComponent的SurfaceId。\n    this.mSurfaceId = this.mXComponentController.getXComponentSurfaceId()\n\n    // 调用native接口获取输入SurfaceId。\n    this.mSurfaceId = imageEffect.getSurfaceId(this.mSurfaceId)\n\n    // 调用相机接口启动预览，将获取到的输入SurfaceId传递给相机框架\n    // ...\n})\n.width('100%')\n.height('100%') (2) imageEffect.getSurfaceId的native c++层具体实现。 // 根据SurfaceId创建NativeWindow，注意创建出来的NativeWindow在使用结束后需要主动调用OH_NativeWindow_DestoryNativeWindow进行释放。\nuint64_t outputSurfaceId;\nstd::istrstream iss(outputSurfaceIdStr);\nissue >> outputSurfaceId;\nOHNativeWindow *outputNativeWindow = nullptr;\nint32_t res = OH_NativeWindow_CreateNativeWindowFromSurfaceId(outputSurfaceId, &outputNativeWindow);\nCHECK_AND_RETURN_LOG(res == 0, \"OH_NativeWindow_CreateNativeWindowFromSurfaceId fail!\");\n\n// 设置输出显示的Surface。\nImageEffect_ErrorCode errorCode = OH_ImageEffect_SetOutputSurface(imageEffect, outputNativeWindow);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_SetOutputSurface fail!\");\n\n// 获取输入的Surface。注意获取的inputNativeWindow在使用结束后需要主动调用OH_NativeWindow_DestoryNativeWindow进行释放。\nOHNativeWindow *inputNativeWindow = nullptr;\nerrorCode = OH_ImageEffect_GetInputSurface(imageEffect, &inputNativeWindow);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_GetInputSurface fail!\");\n\n// 从获取到输入的NativeWindow中获取SurfaceId。\nuint64_t inputSurfaceId = 0;\nres = OH_NativeWindow_GetSurfaceId(inputNativeWindow, &inputSurfaceId);\nCHECK_AND_RETURN_LOG(res == 0, \"OH_NativeWindow_GetSurfaceId fail!\");\n\n// 将SurfaceId转成字符串进行返回。\nstd::string inputSurfaceIdStr = std::to_string(inputSurfaceId); 启动效果器。 // 执行生效滤镜效果。\nerrorCode = OH_ImageEffect_Start(imageEffect);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_Start fail!\"); 停止生效效果（可选，仅在输入Surface场景下才有效）。 // 停止生效滤镜效果。\nerrorCode = OH_ImageEffect_Stop(imageEffect);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_Stop fail!\"); 序列化效果器（可选）。 char *info = nullptr;\nerrorCode = OH_ImageEffect_Save(imageEffect, &info);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_ImageEffect_Save fail!\"); 销毁效果器实例。 // 释放imageEffect实例资源。\nerrorCode = OH_ImageEffect_Release(imageEffect);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, result, \"OH_ImageEffect_Release fail!\"); 
[h2]自定义滤镜
以下步骤描述了如何实现并注册自定义滤镜接口：
 定义 ImageEffect_FilterDelegate。 // 图像信息结构体。\nstruct EffectBufferInfo {\n    void *addr = nullptr;\n    int32_t width = 0;\n    int32_t height = 0;\n    int32_t rowSize = 0;\n    ImageEffect_Format format = ImageEffect_Format::EFFECT_PIXEL_FORMAT_UNKNOWN;\n};\n\n// 自定义滤镜具体实现。\nImageEffect_FilterDelegate filterDelegate = {\n    .setValue = [](OH_EffectFilter *filter, const char *key, const ImageEffect_Any *value) {\n        // 参数校验，校验成功时返回true，否则返回false。\n        // ...\n        return true;\n    },\n    .render = [](OH_EffectFilter *filter, OH_EffectBufferInfo *info, OH_EffectFilterDelegate_PushData pushData) {\n        return Render(filter, info, pushData);\n    },\n    .save = [](OH_EffectFilter *filter, char **info) {\n        // 获取自定义所设置的滤镜参数，其中\"Brightness\"为自定义滤镜的Key，由开发者自己任意指定。\n        ImageEffect_Any value;\n        ImageEffect_ErrorCode errorCode = OH_EffectFilter_GetValue(filter, \"Brightness\", &value);\n        CHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, false, \"OH_EffectFilter_GetValue fail!\");\n        \n        // 生成键值对信息。\n        json values;\n        values[\"Brightness\"] = value.dataValue.floatValue;         \n        json root;\n        root[\"name\"] = \"CustomBrightness\";\n        root[\"values\"] = values;\n    \n    　　 // 将json对象转成字符串infoStr\n        // ...\n\n        // 对*info赋值序列化字符串地址。\n        *info = infoStr;\n        return true;\n    },\n    .restore = [](const char *info) {\n        // 创建 OH_EffectFilter 实例，其中\"CustomBrightness\"为自定义滤镜的滤镜名。\n        OH_EffectFilter *filter = OH_EffectFilter_Create(\"CustomBrightness\");\n        // 解析json字符串info获取key和value。\n        // ...\n    \n        // 设置滤镜参数, value为info中按json解析出来的参数。\n        ImageEffect_ErrorCode errorCode = OH_EffectFilter_SetValue(filter, \"Brightness\", &value);\n        \n        // ...\n        return filter;\n    }\n}; 其中Render接口的实现分两种场景。 场景一：自定义算法可以直接修改info中的像素数据（比如：亮度调节滤镜）。 bool Render(OH_EffectFilter *filter, OH_EffectBufferInfo *info, OH_EffectFilterDelegate_PushData pushData)\n{\n    // 获取图像信息具体参数。\n    EffectBufferInfo inputBufferInfo;\n    OH_EffectBufferInfo_GetAddr(info, &inputBufferInfo.addr);\n    OH_EffectBufferInfo_GetWidth(info, &inputBufferInfo.width);\n    OH_EffectBufferInfo_GetHeight(info, &inputBufferInfo.height);\n    OH_EffectBufferInfo_GetRowSize(info, &inputBufferInfo.rowSize);\n    OH_EffectBufferInfo_GetEffectFormat(info, &inputBufferInfo.format);\n\n    // 调用自定义滤镜算法。\n    ApplyCustomAlgo(inputBufferInfo);\n\n    // 编辑完成后调用pushData直接传递原图。\n    pushData(filter, info);\n    return true;\n} 场景二：自定义算法不能直接修改info中的像素数据（比如：裁剪滤镜）。 bool Render(OH_EffectFilter *filter, OH_EffectBufferInfo *info, OH_EffectFilterDelegate_PushData pushData)\n{\n    // 获取图像信息具体参数。\n    EffectBufferInfo inputBufferInfo;\n    OH_EffectBufferInfo_GetAddr(info, &inputBufferInfo.addr);\n    OH_EffectBufferInfo_GetWidth(info, &inputBufferInfo.width);\n    OH_EffectBufferInfo_GetHeight(info, &inputBufferInfo.height);\n    OH_EffectBufferInfo_GetRowSize(info, &inputBufferInfo.rowSize);\n    OH_EffectBufferInfo_GetEffectFormat(info, &inputBufferInfo.format);\n\n    // 创建输出像素信息。\n    EffectBufferInfo outputBufferInfo = CreateOutputBufferInfo(inputBufferInfo);\n\n    // 调用自定义滤镜算法。\n    ApplyCustomAlgo(inputBufferInfo, outputBufferInfo);\n\n    // 生成outputOhInfo。\n    OH_EffectBufferInfo *outputOhInfo = OH_EffectBufferInfo_Create();\n    OH_EffectBufferInfo_SetAddr(outputOhInfo, outputBufferInfo.addr);\n    OH_EffectBufferInfo_SetWidth(outputOhInfo, outputBufferInfo.width);\n    OH_EffectBufferInfo_SetHeight(outputOhInfo, outputBufferInfo.height);\n    OH_EffectBufferInfo_SetRowSize(outputOhInfo, outputBufferInfo.rowSize);\n    OH_EffectBufferInfo_SetEffectFormat(outputOhInfo, outputBufferInfo.format);\n\n    // 编辑完成后调用pushData传递outputOhInfo。\n    pushData(filter, outputOhInfo);\n\n    // 释放资源。\n    OH_EffectBufferInfo_Release(outputOhInfo);\n    ReleaseOutputBuffer(outputBufferInfo.addr);\n\n    return true;\n} 生成自定义滤镜信息。 // 创建 OH_EffectFilterInfo 实例。\nOH_EffectFilterInfo *customFilterInfo = OH_EffectFilterInfo_Create();\nCHECK_AND_RETURN_LOG(customFilterInfo != nullptr, \"OH_EffectFilter_GetValue fail!\");\n\n// 设置自定义滤镜滤镜名。\nOH_EffectFilterInfo_SetFilterName(customFilterInfo, \"CustomBrightness\");\n\n// 设置自定义滤镜所支持的内存类型。\nImageEffect_BufferType bufferTypeArray[] = { ImageEffect_BufferType::EFFECT_BUFFER_TYPE_PIXEL };\nOH_EffectFilterInfo_SetSupportedBufferTypes(customFilterInfo, sizeof(bufferTypeArray) / sizeof(ImageEffect_BufferType), bufferTypeArray);\n\n// 设置自定义滤镜所支持的像素格式。\nImageEffect_Format formatArray[] = { ImageEffect_Format::EFFECT_PIXEL_FORMAT_RGBA8888 };\nOH_EffectFilterInfo_SetSupportedFormats(customFilterInfo, sizeof(formatArray) / sizeof(ImageEffect_Format), formatArray); 将 ImageEffect_FilterDelegate 注册到效果器。 // 注册自定义滤镜。\nImageEffect_ErrorCode errorCode = OH_EffectFilter_Register(customFilterInfo, &filterDelegate);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_EffectFilter_Register fail!\"); 
[h2]EffectFilter快速实现单个滤镜的处理效果
 创建滤镜。 // 创建滤镜。比如：创建对比度效果器。\nOH_EffectFilter *filter = OH_EffectFilter_Create(OH_EFFECT_CONTRAST_FILTER); 设置滤镜参数。 // 设置滤镜参数, 滤镜强度设置为50。\nImageEffect_Any value = {.dataType = ImageEffect_DataType::EFFECT_DATA_TYPE_FLOAT, .dataValue.floatValue = 50.f};\nImageEffect_ErrorCode errorCode = OH_EffectFilter_SetValue(filter, OH_EFFECT_FILTER_INTENSITY_KEY, &value);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_EffectFilter_SetValue fail!\"); 生效滤镜。 // 生效滤镜效果。\nerrorCode = OH_EffectFilter_Render(filter, inputPixelmap, outputPixelmap); 销毁滤镜实例。 // 销毁滤镜实例。\nerrorCode = OH_EffectFilter_Release(filter); 
[h2]查询能力
 根据滤镜名查询滤镜信息。 // 创建 OH_EffectFilterInfo 实例。\nOH_EffectFilterInfo *filterInfo = OH_EffectFilterInfo_Create();\nCHECK_AND_RETURN_LOG(filterInfo != nullptr, \"OH_EffectFilterInfo_Create fail!\");\n\n// 根据滤镜名查询滤镜能力信息。\nImageEffect_ErrorCode errorCode = OH_EffectFilter_LookupFilterInfo(OH_EFFECT_BRIGHTNESS_FILTER, filterInfo);\nCHECK_AND_RETURN_LOG(errorCode == ImageEffect_ErrorCode::EFFECT_SUCCESS, \"OH_EffectFilter_LookupFilterInfo fail!\");\n\n// 从滤镜能力信息中获取滤镜名。\nchar *name = nullptr;\nOH_EffectFilterInfo_GetFilterName(filterInfo, &name);\n\n// 获取支持的内存类型。\nuint32_t supportedBufferTypesCnt = 0;\nImageEffect_BufferType *bufferTypeArray = nullptr;\nOH_EffectFilterInfo_GetSupportedBufferTypes(filterInfo, &supportedBufferTypesCnt, &bufferTypeArray);\n\n// 获取支持的像素类型信息。\nuint32_t supportedFormatsCnt = 0;\nImageEffect_Format *formatArray = nullptr;\nOH_EffectFilterInfo_GetSupportedFormats(filterInfo, supportedFormatsCnt, &formatArray);\n\n// 销毁 OH_EffectFilterInfo 实例。\nOH_EffectFilterInfo_Release(filterInfo); 根据条件查询满足条件的滤镜。 // 查询所有的Filter，需要主动进行资源释放。\nImageEffect_FilterNames *filterNames = OH_EffectFilter_LookupFilters(\"Default\");\n\n// ...\n\n// 释放FilterNames虚拟内存资源。\nOH_EffectFilter_ReleaseFilterNames(); 

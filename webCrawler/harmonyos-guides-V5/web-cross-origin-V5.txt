解决Web组件本地资源跨域问题
拦截本地资源跨域
为了提高安全性，ArkWeb内核不允许file协议或者resource协议访问URL上下文中来自跨域的请求。因此，在使用Web组件加载本地离线资源的时候，Web组件会拦截file协议和resource协议的跨域访问。可以通过方法二设置一个路径列表，再使用file协议访问该路径列表中的资源，允许跨域访问本地文件。当Web组件无法访问本地跨域资源时，开发者可以在DevTools控制台中看到类似以下报错信息：
Access to script at 'xxx' from origin 'xxx' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, arkweb, data, chrome-extension, chrome, https, chrome-untrusted.
本地资源跨域问题解决方法
 方法一 为了使Web组件能够成功访问跨域资源，开发者应采用http或https等协议，替代原先使用的file或resource协议进行加载。其中，替代的url域名为自定义构造的仅供个人或者组织使用的域名，以避免与互联网上实际存在的域名产生冲突。同时，开发者需利用Web组件的onInterceptRequest方法，对本地资源进行拦截和相应的替换。 以下结合示例说明如何解决本地资源跨域访问失败的问题。其中，index.html和js/script.js置于工程中的rawfile目录下。如果使用resource协议访问index.html，js/script.js将因跨域而被拦截，无法加载。在示例中，使用https://www.example.com/域名替换了原本的resource协议，同时利用onInterceptRequest接口替换资源，使得js/script.js可以成功加载，从而解决了跨域拦截的问题。 // main/ets/pages/Index.ets\nimport { webview } from '@kit.ArkWeb';\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n  webviewController: webview.WebviewController = new webview.WebviewController();\n  // 构造域名和本地文件的映射表\n  schemeMap = new Map([\n    [\"https://www.example.com/index.html\", \"index.html\"],\n    [\"https://www.example.com/js/script.js\", \"js/script.js\"],\n  ])\n  // 构造本地文件和构造返回的格式mimeType\n  mimeTypeMap = new Map([\n    [\"index.html\", 'text/html'],\n    [\"js/script.js\", \"text/javascript\"]\n  ])\n\n  build() {\n    Row() {\n      Column() {\n        // 针对本地index.html,使用http或者https协议代替file协议或者resource协议，并且构造一个属于自己的域名。\n        // 本例中构造www.example.com为例。\n        Web({ src: \"https://www.example.com/index.html\", controller: this.webviewController })\n          .javaScriptAccess(true)\n          .fileAccess(true)\n          .domStorageAccess(true)\n          .geolocationAccess(true)\n          .width(\"100%\")\n          .height(\"100%\")\n          .onInterceptRequest((event) => {\n            if (!event) {\n              return;\n            }\n            // 此处匹配自己想要加载的本地离线资源，进行资源拦截替换，绕过跨域\n            if (this.schemeMap.has(event.request.getRequestUrl())) {\n              let rawfileName: string = this.schemeMap.get(event.request.getRequestUrl())!;\n              let mimeType = this.mimeTypeMap.get(rawfileName);\n              if (typeof mimeType === 'string') {\n                let response = new WebResourceResponse();\n                // 构造响应数据，如果本地文件在rawfile下，可以通过如下方式设置\n                response.setResponseData($rawfile(rawfileName));\n                response.setResponseEncoding('utf-8');\n                response.setResponseMimeType(mimeType);\n                response.setResponseCode(200);\n                response.setReasonMessage('OK');\n                response.setResponseIsReady(true);\n                return response;\n              }\n            }\n            return null;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n} <!-- main/resources/rawfile/index.html -->\n<html>\n<head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n</head>\n<body>\n<script crossorigin src=\"./js/script.js\"></script>\n</body>\n</html> // main/resources/rawfile/js/script.js\nconst body = document.body;\nconst element = document.createElement('div');\nelement.textContent = 'success';\nbody.appendChild(element); 方法二 通过setPathAllowingUniversalAccess设置一个路径列表。当使用file协议访问该列表中的资源时，允许进行跨域访问本地文件。此外，一旦设置了路径列表，file协议将仅限于访问列表内的资源(此时，fileAccess的行为将会被此接口行为覆盖)。路径列表中的路径必须符合以下任一路径格式： 1.应用文件目录通过Context.filesDir获取，其子目录示例如下：  /data/storage/el2/base/files/example /data/storage/el2/base/haps/entry/files/example  2.应用资源目录通过Context.resourceDir获取，其子目录示例如下：  /data/storage/el1/bundle/entry/resource/resfile /data/storage/el1/bundle/entry/resource/resfile/example  当路径列表中的任一路径不满足上述条件时，系统将抛出异常码401，并判定路径列表设置失败。若设置的路径列表为空，file协议的可访问范围将遵循fileAccess的规则，具体示例如下。 // main/ets/pages/Index.ets\nimport { webview } from '@kit.ArkWeb';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n@Entry\n@Component\nstruct WebComponent {\n  controller: WebviewController = new webview.WebviewController();\n\n  build() {\n    Row() {\n      Web({ src: \"\", controller: this.controller })\n        .onControllerAttached(() => {\n          try {\n            // 设置允许可以跨域访问的路径列表\n            this.controller.setPathAllowingUniversalAccess([\n              getContext().resourceDir,\n              getContext().filesDir + \"/example\"\n            ])\n            this.controller.loadUrl(\"file://\" + getContext().resourceDir + \"/index.html\")\n          } catch (error) {\n            console.error(`ErrorCode: ${(error as BusinessError).code},  Message: ${(error as   BusinessError).message}`);\n          }\n        })\n        .javaScriptAccess(true)\n        .fileAccess(true)\n        .domStorageAccess(true)\n    }\n  }\n} <!-- main/resource/rawfile/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Demo</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no,   viewport-fit=cover\">\n    <script>\n        function getFile() {\n            var file = \"file:///data/storage/el1/bundle/entry/resources/resfile/js/script.js\";\n      // 使用file协议通过XMLHttpRequest跨域访问本地js文件。\n            var xmlHttpReq = new XMLHttpRequest();\n            xmlHttpReq.onreadystatechange = function(){\n                console.log(\"readyState:\" + xmlHttpReq.readyState);\n                console.log(\"status:\" + xmlHttpReq.status);\n                if(xmlHttpReq.readyState == 4){\n                    if (xmlHttpReq.status == 200) {\n                // 如果ets侧正确设置路径列表，则此处能正常获取资源\n                        const element = document.getElementById('text');\n                        element.textContent = \"load \" + file + \" success\";\n                    } else {\n                // 如果ets侧不设置路径列表，则此处会触发CORS跨域检查错误\n                        const element = document.getElementById('text');\n                        element.textContent = \"load \" + file + \" failed\";\n                    }\n                }\n            }\n            xmlHttpReq.open(\"GET\", file);\n            xmlHttpReq.send(null);\n        }\n    </script>\n</head>\n\n<body>\n<div class=\"page\">\n    <button id=\"example\" onclick=\"getFile()\">stealFile</button>\n</div>\n<div id=\"text\"></div>\n</body>\n\n</html> // main/resources/rawfile/js/script.js\nconst body = document.body;\nconst element = document.createElement('div');\nelement.textContent = 'success';\nbody.appendChild(element); 

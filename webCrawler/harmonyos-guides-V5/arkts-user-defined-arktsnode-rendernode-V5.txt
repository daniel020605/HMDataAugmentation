自定义渲染节点 (RenderNode)
概述
对于不具备自己的渲染环境的三方框架，尽管已实现前端解析、布局及事件处理等功能，但仍需依赖系统的基础渲染和动画能力。FrameNode上的通用属性与通用事件对这类框架而言是冗余的，会导致多次不必要的操作，涵盖布局、事件处理等逻辑。
自定义渲染节点 (RenderNode)是更加轻量的渲染节点，仅具备与渲染相关的功能。它提供了设置基础渲染属性的能力，以及节点的动态添加、删除和自定义绘制的能力。RenderNode能够为第三方框架提供基础的渲染和动画支持。
创建和删除节点
RenderNode提供了节点创建和删除的能力。可以通过RenderNode的构造函数创建自定义的RenderNode节点。通过构造函数创建的节点对应一个实体的节点。同时，可以通过RenderNode中的dispose接口来实现与实体节点的绑定关系的解除。
操作节点树
RenderNode提供了节点的增、删、查、改的能力，能够修改节点的子树结构；可以对所有RenderNode的节点的父子节点做出查询操作，并返回查询结果。
 RenderNode中查询获取得到的子树结构按照开发通过RenderNode的接口传递的参数构建。 RenderNode如果要与系统直接结合显示，使用需要依赖FrameNode中获取的RenderNode进行挂载上树。 
import { FrameNode, NodeController, RenderNode } from '@kit.ArkUI';\n\nconst TEST_TAG: string = \"RenderNode\";\nconst renderNode = new RenderNode();\nrenderNode.frame = {\n  x: 0,\n  y: 0,\n  width: 200,\n  height: 350\n};\nrenderNode.backgroundColor = 0xffff0000;\nfor (let i = 0; i < 5; i++) {\n  const node = new RenderNode();\n  // 设置node节点的Frame大小\n  node.frame = {\n    x: 10,\n    y: 10 + 60 * i,\n    width: 50,\n    height: 50\n  };\n  // 设置node节点的背景颜色\n  node.backgroundColor = 0xff00ff00;\n  // 将新增节点挂载在renderNode上\n  renderNode.appendChild(node);\n}\n\nclass MyNodeController extends NodeController {\n  private rootNode: FrameNode | null = null;\n\n  makeNode(uiContext: UIContext): FrameNode | null {\n    this.rootNode = new FrameNode(uiContext);\n\n    const rootRenderNode = this.rootNode?.getRenderNode();\n    if (rootRenderNode) {\n      rootRenderNode.appendChild(renderNode);\n    }\n    return this.rootNode;\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  private myNodeController: MyNodeController = new MyNodeController();\n\n  build() {\n    Row() {\n      NodeContainer(this.myNodeController)\n        .width(200)\n        .height(350)\n      Button('getNextSibling')\n        .onClick(() => {\n          const child = renderNode.getChild(1);\n          const nextSibling = child!.getNextSibling()\n          if (child === null || nextSibling === null) {\n            console.log(TEST_TAG + ' the child or nextChild is null');\n          } else {\n            // 获取子节点的位置信息\n            console.log(`${TEST_TAG} the position of child is x: ${child.position.x}, y: ${child.position.y}, ` +\n            `the position of nextSibling is x: ${nextSibling.position.x}, y: ${nextSibling.position.y}`);\n          }\n        })\n    }\n  }\n}
设置和获取渲染相关属性
RenderNode中可以设置渲染相关的属性，包括：backgroundColor，clipToFrame，opacity，size，position，frame，pivot，scale，translation，rotation，transform，shadowColor，shadowOffset，shadowAlpha，shadowElevation，shadowRadius，borderStyle，borderWidth，borderColor，borderRadius，shapeMask，shapeClip，markNodeGroup等。具体属性支持范围参考RenderNode接口说明。
 RenderNode中查询获取得到的属性为设置的属性值。 若未传入参数或者传入参数为非法值则查询获得的为默认值。 不建议对BuilderNode中的RenderNode进行修改操作。BuilderNode中具体属性设置是由状态管理实现的,属性更新的时序开发者不可控，BuilderNode和FrameNode中同时设置RenderNode属性可能会导致RenderNode属性设置与预期不相符。 
import { RenderNode, FrameNode, NodeController, ShapeMask, ShapeClip } from '@kit.ArkUI';\n\nconst TEST_TAG: string = \"RenderNode\";\nconst mask = new ShapeMask();\nmask.setRectShape({\n  left: 0,\n  right: 150,\n  top: 0,\n  bottom: 150\n});\nmask.fillColor = 0X55FF0000;\nmask.strokeColor = 0XFFFF0000;\nmask.strokeWidth = 24;\n\nconst clip = new ShapeClip();\nclip.setCommandPath({ commands: \"M100 0 L0 100 L50 200 L150 200 L200 100 Z\" });\n\nconst renderNode = new RenderNode();\nrenderNode.backgroundColor = 0xffff0000;\nrenderNode.size = { width: 100, height: 100 };\n\nclass MyNodeController extends NodeController {\n  private rootNode: FrameNode | null = null;\n\n  makeNode(uiContext: UIContext): FrameNode | null {\n    this.rootNode = new FrameNode(uiContext);\n\n    const rootRenderNode = this.rootNode.getRenderNode();\n    if (rootRenderNode !== null) {\n      rootRenderNode.appendChild(renderNode);\n    }\n\n    return this.rootNode;\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  private myNodeController: MyNodeController = new MyNodeController();\n\n  build() {\n    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.SpaceBetween }) {\n      Column() {\n        NodeContainer(this.myNodeController)\n      }\n\n      Button(\"position\")\n        .width(300)\n        .onClick(() => {\n          renderNode.position = { x: 10, y: 10 };\n          console.log(TEST_TAG + \" position:\" + JSON.stringify(renderNode.position));\n        })\n      Button(\"pivot\")\n        .width(300)\n        .onClick(() => {\n          renderNode.pivot = { x: 0.5, y: 0.6 };\n          console.log(TEST_TAG + \" pivot:\" + JSON.stringify(renderNode.pivot));\n        })\n      Button(\"scale\")\n        .width(300)\n        .onClick(() => {\n          renderNode.scale = { x: 0.5, y: 1 };\n          console.log(TEST_TAG + \" scale:\" + JSON.stringify(renderNode.scale));\n        })\n      Button(\"translation\")\n        .width(300)\n        .onClick(() => {\n          renderNode.translation = { x: 100, y: 0 };\n          console.log(TEST_TAG + \" translation:\" + JSON.stringify(renderNode.translation));\n        })\n      Button(\"rotation\")\n        .width(300)\n        .onClick(() => {\n          renderNode.rotation = { x: 45, y: 0, z: 0 };\n          console.log(TEST_TAG + \" rotation:\" + JSON.stringify(renderNode.rotation));\n        })\n      Button(\"transform\")\n        .width(300)\n        .onClick(() => {\n          renderNode.transform = [\n            1, 0, 0, 0,\n            0, 2, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n          ];\n          console.log(TEST_TAG + \" transform:\" + JSON.stringify(renderNode.transform));\n        })\n      Button(\"shadow\")\n        .width(300)\n        .onClick(() => {\n          renderNode.shadowElevation = 10;\n          renderNode.shadowColor = 0XFF00FF00;\n          renderNode.shadowOffset = { x: 10, y: 10 };\n          renderNode.shadowAlpha = 0.1;\n          console.log(TEST_TAG + \" shadowElevation:\" + JSON.stringify(renderNode.shadowElevation));\n          console.log(TEST_TAG + \" shadowColor:\" + JSON.stringify(renderNode.shadowColor));\n          console.log(TEST_TAG + \" shadowOffset:\" + JSON.stringify(renderNode.shadowOffset));\n          console.log(TEST_TAG + \" shadowAlpha:\" + JSON.stringify(renderNode.shadowAlpha));\n        })\n      Button(\"shadowRadius\")\n        .width(300)\n        .onClick(() => {\n          renderNode.shadowOffset = { x: 10, y: 10 };\n          renderNode.shadowAlpha = 0.7\n          renderNode.shadowRadius = 30;\n          console.log(TEST_TAG + \" shadowOffset:\" + JSON.stringify(renderNode.shadowOffset));\n          console.log(TEST_TAG + \" shadowAlpha:\" + JSON.stringify(renderNode.shadowAlpha));\n          console.log(TEST_TAG + \" shadowRadius:\" + JSON.stringify(renderNode.shadowRadius));\n        })\n      Button(\"border\")\n        .width(300)\n        .onClick(() => {\n          renderNode.borderWidth = {\n            left: 8,\n            top: 8,\n            right: 8,\n            bottom: 8\n          };\n          renderNode.borderStyle = {\n            left: BorderStyle.Solid,\n            top: BorderStyle.Dotted,\n            right: BorderStyle.Dashed,\n            bottom: BorderStyle.Solid\n          }\n          renderNode.borderColor = {\n            left: 0xFF0000FF,\n            top: 0xFF0000FF,\n            right: 0xFF0000FF,\n            bottom: 0xFF0000FF\n          };\n          renderNode.borderRadius = {\n            topLeft: 32,\n            topRight: 32,\n            bottomLeft: 32,\n            bottomRight: 32\n          };\n          console.log(TEST_TAG + \" borderWidth:\" + JSON.stringify(renderNode.borderWidth));\n          console.log(TEST_TAG + \" borderStyle:\" + JSON.stringify(renderNode.borderStyle));\n          console.log(TEST_TAG + \" borderColor:\" + JSON.stringify(renderNode.borderColor));\n          console.log(TEST_TAG + \" borderRadius:\" + JSON.stringify(renderNode.borderRadius));\n        })\n      Button(\"shapeMask\")\n        .width(300)\n        .onClick(() => {\n          renderNode.shapeMask = mask;\n          console.log(TEST_TAG + \" shapeMask:\" + JSON.stringify(renderNode.shapeMask));\n        })\n      Button(\"shapeClip\")\n        .width(300)\n        .onClick(() => {\n          renderNode.shapeClip = clip;\n          console.log(TEST_TAG + \" shapeMask:\" + JSON.stringify(renderNode.shapeMask));\n        })\n    }\n    .padding({\n      left: 35,\n      right: 35,\n      top: 35,\n      bottom: 35\n    })\n    .width(\"100%\")\n    .height(\"100%\")\n  }\n}
自定义绘制
通过重写RenderNode中的draw方法，可以自定义RenderNode的绘制内容，通过invalidate接口可以主动触发节点的重新绘制。
 同时同步触发多个invalidate仅会触发一次重新绘制。 自定义绘制有两种绘制方式：通过ArkTS接口进行调用和通过Node-API进行调用。 
ArkTS接口调用示例：
import { FrameNode, NodeController, RenderNode } from '@kit.ArkUI';\nimport { drawing } from '@kit.ArkGraphics2D';\n\nclass MyRenderNode extends RenderNode {\n  width: number = 200;\n\n  draw(context: DrawContext) {\n    // 获取canvas对象\n    const canvas = context.canvas;\n    // 创建笔刷\n    const brush = new drawing.Brush();\n    // 设置笔刷颜色\n    brush.setColor({\n      alpha: 255,\n      red: 255,\n      green: 0,\n      blue: 0\n    });\n    canvas.attachBrush(brush);\n    // 绘制矩阵\n    canvas.drawRect({\n      left: 0,\n      right: this.width,\n      top: 0,\n      bottom: 200\n    });\n    canvas.detachBrush();\n    console.log(`RenderNode draw width = ${this.width}`);\n  }\n}\n\nconst renderNode = new MyRenderNode();\nrenderNode.frame = {\n  x: 0,\n  y: 0,\n  width: 300,\n  height: 300\n};\nrenderNode.backgroundColor = 0xff0000ff;\nrenderNode.opacity = 0.5;\n\nclass MyNodeController extends NodeController {\n  private rootNode: FrameNode | null = null;\n\n  makeNode(uiContext: UIContext): FrameNode | null {\n    this.rootNode = new FrameNode(uiContext);\n\n    const rootRenderNode = this.rootNode?.getRenderNode();\n    if (rootRenderNode !== null) {\n      rootRenderNode.frame = {\n        x: 0,\n        y: 0,\n        width: 500,\n        height: 500\n      }\n      rootRenderNode.appendChild(renderNode);\n    }\n\n    return this.rootNode;\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  private myNodeController: MyNodeController = new MyNodeController();\n\n  build() {\n    Column() {\n      NodeContainer(this.myNodeController)\n        .width('100%')\n      Button('Invalidate')\n        .onClick(() => {\n          // 同步调用多次，仅触发一次重绘，draw回调中的日志仅打印一次\n          renderNode.width += 10;\n          renderNode.invalidate();\n          renderNode.invalidate();\n        })\n    }\n  }\n}
Node-API调用示例：
C++侧可通过Node-API来获取Canvas，并进行后续的自定义绘制操作。
// native_bridge.cpp\n#include \"napi/native_api.h\"\n#include <native_drawing/drawing_canvas.h>\n#include <native_drawing/drawing_color.h>\n#include <native_drawing/drawing_path.h>\n#include <native_drawing/drawing_pen.h>\n\nstatic napi_value OnDraw(napi_env env, napi_callback_info info)\n{\n    size_t argc = 4;\n    napi_value args[4] = { nullptr };\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    int32_t id;\n    napi_get_value_int32(env, args[0], &id);\n    \n    // 获取 Canvas 指针\n    void* temp = nullptr;\n    napi_unwrap(env, args[1], &temp);\n    OH_Drawing_Canvas *canvas = reinterpret_cast<OH_Drawing_Canvas*>(temp);\n    \n    // 获取 Canvas 宽度\n    int32_t width;\n    napi_get_value_int32(env, args[2], &width);\n    \n    // 获取 Canvas 高度\n    int32_t height;\n    napi_get_value_int32(env, args[3], &height);\n    \n    // 传入canvas、height、width等信息至绘制函数中进行自定义绘制\n    auto path = OH_Drawing_PathCreate();\n    OH_Drawing_PathMoveTo(path, width / 4, height / 4);\n    OH_Drawing_PathLineTo(path, width * 3 / 4, height / 4);\n    OH_Drawing_PathLineTo(path, width * 3 / 4, height * 3 / 4);\n    OH_Drawing_PathLineTo(path, width / 4, height * 3 / 4);\n    OH_Drawing_PathLineTo(path, width / 4, height / 4);\n    OH_Drawing_PathClose(path);\n    \n    auto pen = OH_Drawing_PenCreate();\n    OH_Drawing_PenSetWidth(pen, 10);\n    OH_Drawing_PenSetColor(pen, OH_Drawing_ColorSetArgb(0xFF, 0xFF, 0x00, 0x00));\n    OH_Drawing_CanvasAttachPen(canvas, pen);\n    \n    OH_Drawing_CanvasDrawPath(canvas, path);\n\n    return nullptr;\n}\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        { \"nativeOnDraw\", nullptr, OnDraw, nullptr, nullptr, nullptr, napi_default, nullptr }\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version =1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void*)0),\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void)\n{\n    napi_module_register(&demoModule);\n}
修改工程中的src/main/cpp/CMakeLists.txt文件，添加如下内容：
# the minimum version of CMake.\ncmake_minimum_required(VERSION 3.4.1)\nproject(NapiTest)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n\ninclude_directories(${NATIVERENDER_ROOT_PATH}\n                    ${NATIVERENDER_ROOT_PATH}/include)\n\nadd_library(entry SHARED native_bridge.cpp)\ntarget_link_libraries(entry PUBLIC libace_napi.z.so)\ntarget_link_libraries(entry PUBLIC libace_ndk.z.so)\ntarget_link_libraries(entry PUBLIC libnative_drawing.so)
同时在工程中的src/main/cpp/types/libentry/index.d.ts文件中，添加自定义绘制函数在ArkTS侧的定义，如：
import { DrawContext } from '@kit.ArkUI'\n\nexport const nativeOnDraw: (id: number, context: DrawContext, width: number, height: number) => number;
ArkTS侧代码：
// Index.ets\nimport bridge from \"libentry.so\" // 该 so 由 Node-API 编写并生成\nimport { DrawContext, FrameNode, NodeController, RenderNode } from '@kit.ArkUI'\n\nclass MyRenderNode extends RenderNode {\n  draw(context: DrawContext) {\n    // 需要将 context 中的宽度和高度从vp转换为px\n    bridge.nativeOnDraw(0, context, vp2px(context.size.height), vp2px(context.size.width));\n  }\n}\n\nclass MyNodeController extends NodeController {\n  private rootNode: FrameNode | null = null;\n\n  makeNode(uiContext: UIContext): FrameNode | null {\n    this.rootNode = new FrameNode(uiContext);\n\n    const rootRenderNode = this.rootNode.getRenderNode();\n    if (rootRenderNode !== null) {\n      const renderNode = new MyRenderNode();\n      renderNode.size = { width: 100, height: 100 }\n      rootRenderNode.appendChild(renderNode);\n    }\n    return this.rootNode;\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  private myNodeController: MyNodeController = new MyNodeController();\n\n  build() {\n    Row() {\n      NodeContainer(this.myNodeController)\n    }\n  }\n}
设置标签
开发者可利用label接口向RenderNode设置标签信息，这有助于在节点Inspector中更清晰地区分各节点。
import {  RenderNode, FrameNode, NodeController, UIContext } from '@kit.ArkUI';\n\nclass MyNodeController extends NodeController {\n  private rootNode: FrameNode | null = null;\n\n  makeNode(uiContext: UIContext): FrameNode | null {\n    this.rootNode = new FrameNode(uiContext);\n    const renderNode: RenderNode | null = this.rootNode.getRenderNode();\n    if (renderNode !== null) {\n      const renderChildNode: RenderNode = new RenderNode();\n      renderChildNode.frame = { x: 0, y: 0, width: 100, height: 100 };\n      renderChildNode.backgroundColor = 0xffff0000;\n      renderChildNode.label = 'customRenderChildNode';\n      console.log('label:', renderChildNode.label);\n      renderNode.appendChild(renderChildNode);\n    }\n\n    return this.rootNode;\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  private myNodeController: MyNodeController = new MyNodeController();\n\n  build() {\n    Column() {\n      NodeContainer(this.myNodeController)\n        .width(300)\n        .height(700)\n        .backgroundColor(Color.Gray)\n    }\n  }\n}

键值型数据库跨设备数据同步
场景介绍
键值型数据库适合不涉及过多数据关系和业务关系的业务数据存储，比SQL数据库存储拥有更好的读写性能，同时因其在分布式场景中降低了解决数据库版本兼容问题的复杂度，和数据同步过程中冲突解决的复杂度而被广泛使用。
基本概念
在使用键值型数据库跨设备数据同步前，请先了解以下概念。
[h2]单版本数据库
单版本是指数据在本地是以单个条目为单位的方式保存，当数据在本地被用户修改时，不管它是否已经被同步出去，均直接在这个条目上进行修改。多个设备全局只保留一份数据，多个设备的相同记录（主码相同）会按时间最新保留一条记录，数据不分设备，设备之间修改相同的key会覆盖。同步也以此为基础，按照它在本地被写入或更改的顺序将当前最新一次修改逐条同步至远端设备，常用于联系人、天气等应用存储场景。
[h2]多设备协同数据库
多设备协同分布式数据库建立在单版本数据库之上，对应用程序存入的键值型数据中的Key前面拼接了本设备的DeviceID标识符，这样能保证每个设备产生的数据严格隔离。数据以设备的维度管理，不存在冲突；支持按照设备的维度查询数据。
底层按照设备的维度管理这些数据，多设备协同数据库支持以设备的维度查询分布式数据，但是不支持修改远端设备同步过来的数据。需要分开查询各设备数据的可以使用设备协同版本数据库。常用于图库缩略图存储场景。
同步方式
数据管理服务提供了两种同步方式：手动同步和自动同步。键值型数据库可选择其中一种方式实现同应用跨设备数据同步。
[h2]手动同步
由应用程序调用sync接口来触发，需要指定同步的设备列表和同步模式。同步模式分为PULL_ONLY（将远端数据拉取到本端）、PUSH_ONLY（将本端数据推送到远端）和PUSH_PULL（将本端数据推送到远端同时也将远端数据拉取到本端）。带有Query参数的同步接口，支持按条件过滤的方法进行同步，将符合条件的数据同步到远端。
[h2]自动同步
在跨设备Call调用实现的多端协同场景中，在应用程序更新数据后，由分布式数据库自动将本端数据推送到远端，同时也将远端数据拉取到本端来完成数据同步，应用不需要主动调用sync接口。
运作机制
底层通信组件完成设备发现和认证，会通知上层应用程序设备上线。收到设备上线的消息后数据管理服务可以在两个设备之间建立加密的数据传输通道，利用该通道在两个设备之间进行数据同步。
[h2]数据跨设备同步机制
如图所示，通过put、delete接口触发自动同步，将分布式数据通过通信适配层发送给对端设备，实现分布式数据的自动同步。
手动同步则是手动调用sync接口触发同步，将分布式数据通过通信适配层发送给对端设备。
[h2]数据变化通知机制
增、删、改数据库时，会给订阅者发送数据变化的通知。主要分为本地数据变化通知和分布式数据变化通知。
 本地数据变化通知：本地设备的应用内订阅数据变化通知，数据库增删改数据时，会收到通知。 分布式数据变化通知：同一应用订阅组网内其他设备数据变化的通知，其他设备增删改数据时，本设备会收到通知。 
约束限制
 设备协同数据库，针对每条记录，Key的长度≤896 Byte，Value的长度<4 MB。 单版本数据库，针对每条记录，Key的长度≤1 KB，Value的长度<4 MB。 键值型数据库不支持应用程序自定义冲突解决策略。 每个应用程序最多支持同时打开16个键值型分布式数据库。 单个数据库最多支持注册8个订阅数据变化的回调。 
接口说明
以下是单版本键值型分布式数据库跨设备数据同步功能的相关接口，大部分为异步接口。异步接口均有callback和Promise两种返回形式，下表均以callback形式为例，更多接口及使用方式请见分布式键值数据库。
开发步骤
此处以单版本键值型数据库跨设备数据同步的开发为例。以下是具体的开发流程和开发步骤。
数据只允许向数据安全标签不高于对端设备安全等级的设备同步数据，具体规则可见跨设备同步访问控制机制。
 导入模块。 import { distributedKVStore } from '@kit.ArkData'; 请求权限。  需要申请ohos.permission.DISTRIBUTED_DATASYNC权限，配置方式请参见声明权限。 同时需要在应用首次启动时弹窗向用户申请授权，使用方式请参见向用户申请授权。  根据配置构造分布式数据库管理类实例。  根据应用上下文创建kvManagerConfig对象。 创建分布式数据库管理器实例。  // Stage模型获取context\nimport { window } from '@kit.ArkUI';\nimport { UIAbility } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet kvManager: distributedKVStore.KVManager | undefined = undefined;\n\nclass EntryAbility extends UIAbility {\n  onWindowStageCreate(windowStage:window.WindowStage) {\n    let context = this.context;\n  }\n}\n \n // FA模型获取context\nimport { featureAbility } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n \nlet context = featureAbility.getContext();\n\n// 获取context之后，构造分布式数据库管理类实例\ntry {\n  const kvManagerConfig: distributedKVStore.KVManagerConfig = {\n    bundleName: 'com.example.datamanagertest',\n    context: context\n  }\n  kvManager = distributedKVStore.createKVManager(kvManagerConfig);\n  console.info('Succeeded in creating KVManager.');\n  // 继续创建获取数据库\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`Failed to create KVManager. Code:${error.code},message:${error.message}`);\n}\n\nif (kvManager !== undefined) {\n  kvManager = kvManager as distributedKVStore.KVManager;\n  // 进行后续创建数据库等相关操作\n  // ...\n} 获取并得到指定类型的键值型数据库。  声明需要创建的分布式数据库ID描述（例如示例代码中的'storeId'）。 创建分布式数据库，建议关闭自动同步功能（autoSync:false），方便后续对同步功能进行验证，需要同步时主动调用sync接口。  let kvStore: distributedKVStore.SingleKVStore | undefined = undefined;\ntry {\n  let child1 = new distributedKVStore.FieldNode('id');\n  child1.type = distributedKVStore.ValueType.INTEGER;\n  child1.nullable = false;\n  child1.default = '1';\n  let child2 = new distributedKVStore.FieldNode('name');\n  child2.type = distributedKVStore.ValueType.STRING;\n  child2.nullable = false;\n  child2.default = 'zhangsan';\n\n  let schema = new distributedKVStore.Schema();\n  schema.root.appendChild(child1);\n  schema.root.appendChild(child2);\n  schema.indexes = ['$.id', '$.name'];\n  // 0表示COMPATIBLE模式，1表示STRICT模式。\n  schema.mode = 1;\n  // 支持在检查Value时，跳过skip指定的字节数，且取值范围为[0,4M-2]。\n  schema.skip = 0;\n\n  const options: distributedKVStore.Options = {\n    createIfMissing: true,\n    encrypt: false,\n    backup: false,\n    autoSync: false,\n    // kvStoreType不填时，默认创建多设备协同数据库\n    // 多设备协同数据库：kvStoreType: distributedKVStore.KVStoreType.DEVICE_COLLABORATION,\n    kvStoreType: distributedKVStore.KVStoreType.SINGLE_VERSION,\n    // schema 可以不填，在需要使用schema功能时可以构造此参数，例如：使用谓词查询等。\n    schema: schema,\n    securityLevel: distributedKVStore.SecurityLevel.S1\n  };\n  kvManager.getKVStore<distributedKVStore.SingleKVStore>('storeId', options, (err, store: distributedKVStore.SingleKVStore) => {\n    if (err) {\n      console.error(`Failed to get KVStore: Code:${err.code},message:${err.message}`);\n      return;\n    }\n    console.info('Succeeded in getting KVStore.');\n    kvStore = store;\n    // 请确保获取到键值数据库实例后，再进行相关数据操作\n  });\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n}\nif (kvStore !== undefined) {\n  kvStore = kvStore as distributedKVStore.SingleKVStore;\n    // 进行后续相关数据操作，包括数据的增、删、改、查、订阅数据变化等操作\n    // ...\n} 订阅分布式数据变化，如需关闭订阅分布式数据变化，调用off('dataChange')关闭。 try {\n  kvStore.on('dataChange', distributedKVStore.SubscribeType.SUBSCRIBE_TYPE_ALL, (data) => {\n    console.info(`dataChange callback call data: ${data}`);\n  });\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`An unexpected error occurred. code:${error.code},message:${error.message}`);\n} 将数据写入分布式数据库。  构造需要写入分布式数据库的Key（键）和Value（值）。 将键值数据写入分布式数据库。  const KEY_TEST_STRING_ELEMENT = 'key_test_string';\n// 如果未定义Schema则Value可以传其他符合要求的值。\nconst VALUE_TEST_STRING_ELEMENT = '{\"id\":0, \"name\":\"lisi\"}';\ntry {\n  kvStore.put(KEY_TEST_STRING_ELEMENT, VALUE_TEST_STRING_ELEMENT, (err) => {\n    if (err !== undefined) {\n      console.error(`Failed to put data. Code:${err.code},message:${err.message}`);\n      return;\n    }\n    console.info('Succeeded in putting data.');\n  });\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n} 查询分布式数据库数据。  构造需要从单版本分布式数据库中查询的Key（键）。 从单版本分布式数据库中获取数据。  try {\n  kvStore.put(KEY_TEST_STRING_ELEMENT, VALUE_TEST_STRING_ELEMENT, (err) => {\n    if (err !== undefined) {\n      console.error(`Failed to put data. Code:${err.code},message:${err.message}`);\n      return;\n    }\n    console.info('Succeeded in putting data.');\n    kvStore = kvStore as distributedKVStore.SingleKVStore;\n    kvStore.get(KEY_TEST_STRING_ELEMENT, (err, data) => {\n      if (err != undefined) {\n        console.error(`Failed to get data. Code:${err.code},message:${err.message}`);\n        return;\n      }\n      console.info(`Succeeded in getting data. Data:${data}`);\n    });\n  });\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`Failed to get data. Code:${error.code},message:${error.message}`);\n} 同步数据到其他设备。 选择同一组网环境下的设备以及同步模式（需用户在应用首次启动的弹窗中确认选择同步模式），进行数据同步。     在手动同步的方式下，其中的deviceIds通过调用devManager.getAvailableDeviceListSync方法得到。   import { distributedDeviceManager } from '@kit.DistributedServiceKit';\n \nlet devManager: distributedDeviceManager.DeviceManager;\ntry {\n  // create deviceManager\n  devManager = distributedDeviceManager.createDeviceManager(context.applicationInfo.name);\n  // deviceIds由deviceManager调用getAvailableDeviceListSync方法得到\n  let deviceIds: string[] = [];\n  if (devManager != null) {\n    let devices = devManager.getAvailableDeviceListSync();\n    for (let i = 0; i < devices.length; i++) {\n      deviceIds[i] = devices[i].networkId as string;\n    }\n  }\n  try {\n    // 1000表示最大延迟时间为1000ms\n    kvStore.sync(deviceIds, distributedKVStore.SyncMode.PUSH_ONLY, 1000);\n  } catch (e) {\n    let error = e as BusinessError;\n    console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n  }\n\n} catch (err) {\n  let error = err as BusinessError;\n  console.error(\"createDeviceManager errCode:\" + error.code + \",errMessage:\" + error.message);\n} 

非线性容器
非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的key及value的类型均满足ECMA标准。
各非线性容器类型特征对比
HashMap
HashMap可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。
HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容大小为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。
HashMap和TreeMap相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。
HashSet基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只对value对象进行处理。
需要快速存取、删除以及插入键值对数据时，推荐使用HashMap。
HashMap进行增、删、改、查操作的常用API如下：
HashSet
HashSet可用来存储一系列值的集合，存储元素中value是唯一的。
HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容大小为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet基于HashMap实现，只对value对象进行处理。底层数据结构与HashMap一致。
HashSet和TreeSet相比，HashSet中的数据无序存放，即不能由用户指定排序方式，而TreeSet是有序存放，能够依照用户给定的排序函数对元素进行排序。它们集合中的元素都不允许重复，但HashSet允许放入null值，TreeSet不建议存放null值，可能会对排序结果产生影响。
可以利用HashSet不重复的特性，当需要不重复的集合或需要去重某个集合的时候使用。
HashSet进行增、删、改、查操作的常用API如下：
TreeMap
TreeMap可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。
TreeMap依据泛型定义，集合中的key值是有序的，TreeMap的底层是一棵二叉树，可以通过树的二叉查找快速的找到键值对。key的类型满足ECMA标准中要求的类型。TreeMap中的键值是有序存储的。TreeMap底层基于红黑树实现，可以进行快速的插入和删除。
TreeMap和HashMap相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。
一般需要存储有序键值对的场景，可以使用TreeMap。
TreeMap进行增、删、改、查操作的常用API如下：
TreeSet
TreeSet可用来存储一系列值的集合，存储元素中value是唯一的。
TreeSet依据泛型定义，集合中的value值是有序的，TreeSet的底层是一棵二叉树，可以通过树的二叉查找快速的找到该value值，value的类型满足ECMA标准中要求的类型。TreeSet中的值是有序存储的。TreeSet底层基于红黑树实现，可以进行快速的插入和删除。
TreeSet基于TreeMap实现，在TreeSet中，只对value对象进行处理。TreeSet可用于存储一系列值的集合，元素中value唯一，且能够依照用户给定的排序函数对元素进行排序。
TreeSet和HashSet相比，HashSet中的数据无序存放，而TreeSet是有序存放。它们集合中的元素都不允许重复，但HashSet允许放入null值，TreeSet不建议存放null值，可能会对排序结果产生影响。
一般需要存储有序集合的场景，可以使用TreeSet。
TreeSet进行增、删、改、查操作的常用API如下：
LightWeightMap
LightWeightMap可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。LightWeightMap依据泛型定义，采用更加轻量级的结构，底层标识唯一key通过hash实现，其冲突策略为线性探测法。集合中的key值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的key值以及value值，key的类型满足ECMA标准中要求的类型。
初始默认容量大小为8，每次扩容大小为原始容量的2倍。
LightWeightMap和HashMap都是用来存储键值对的集合，LightWeightMap占用内存更小。
当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。
LightWeightMap进行增、删、改、查操作的常用API如下：
LightWeightSet
LightWeightSet可用来存储一系列值的集合，存储元素中value是唯一的。
LightWeightSet依据泛型定义，采用更加轻量级的结构，初始默认容量大小为8，每次扩容大小为原始容量的2倍。集合中的value值的查找依赖于hash以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的value值，value的类型满足ECMA标准中要求的类型。
LightWeightSet底层标识唯一value基于hash实现，其冲突策略为线性探测法，查找策略基于二分查找法。
LightWeightSet和HashSet都是用来存储键值的集合，LightWeightSet的占用内存更小。
当需要存取某个集合或是对某个集合去重时，推荐使用占用内存更小的LightWeightSet。
LightWeightSet进行增、删、改、查操作的常用API如下：
PlainArray
PlainArray可用来存储具有关联关系的键值对集合，存储元素中key是唯一的，并且对于PlainArray来说，其key的类型为number类型。每个key会对应一个value值，类型依据泛型的定义，PlainArray采用更加轻量级的结构，集合中的key值的查找依赖于二分查找算法，然后映射到其他数组中的value值。
初始默认容量大小为16，每次扩容大小为原始容量的2倍。
PlainArray和LightWeightMap都是用来存储键值对，且均采用轻量级结构，但PlainArray的key值类型只能为number类型。
当需要存储key值为number类型的键值对时，可以使用PlainArray。
PlainArray进行增、删、改、查操作的常用API如下：
非线性容器的使用
此处列举常用的非线性容器HashMap、TreeMap、LightWeightMap、PlainArray的使用示例，包括导入模块、增加元素、访问元素及修改等操作，示例代码如下所示：
// HashMap\nimport { HashMap } from '@kit.ArkTS'; // 导入HashMap模块\n\nlet hashMap1: HashMap<string, number> = new HashMap();\nhashMap1.set('a', 123); // 增加一个键为'a'，值为123的元素\nlet hashMap2: HashMap<number, number> = new HashMap();\nhashMap2.set(4, 123); // 增加一个键为4，值为123的元素\nconsole.info(`result: ${hashMap2.hasKey(4)}`); // 判断是否含有键为4的元素。输出：result: true\nconsole.info(`result: ${hashMap1.get('a')}`); // 访问键为'a'的元素。输出：result: 123\n\n// TreeMap\nimport { TreeMap } from '@kit.ArkTS'; // 导入TreeMap模块\n\nlet treeMap: TreeMap<string, number> = new TreeMap();\ntreeMap.set('a', 123); // 增加一个键为'a'，值为123的元素\ntreeMap.set('6', 356); // 增加一个键为'6'，值为356的元素\nconsole.info(`result: ${treeMap.get('a')}`); // 访问键为'a'的元素。输出：result: 123\nconsole.info(`result: ${treeMap.getFirstKey()}`); // 访问首元素。输出：result: 6\nconsole.info(`result: ${treeMap.getLastKey()}`); // 访问尾元素。输出：result: a\n\n// LightWeightMap\nimport { LightWeightMap } from '@kit.ArkTS'; // 导入LightWeightMap模块\n\nlet lightWeightMap: LightWeightMap<string, number> = new LightWeightMap();\nlightWeightMap.set('x', 123); // 增加一个键为'x'，值为123的元素\nlightWeightMap.set('8', 356); // 增加一个键为'8'，值为356的元素\nconsole.info(`result: ${lightWeightMap.get('a')}`); // 访问键为'a'的元素。输出：result: undefined\nconsole.info(`result: ${lightWeightMap.get('x')}`); // 访问键为'x'的元素，获取其值。输出：result: 123\nconsole.info(`result: ${lightWeightMap.getIndexOfKey('8')}`); // 访问键为'8'的元素，获取其索引。输出：result: 0\n\n// PlainArray\nimport { PlainArray } from '@kit.ArkTS'; // 导入PlainArray模块\n\nlet plainArray: PlainArray<string> = new PlainArray();\nplainArray.add(1, 'sdd'); // 增加一个键为1，值为'sdd'的元素\nplainArray.add(2, 'sff'); // 增加一个键为2，值为'sff'的元素\nconsole.info(`result: ${plainArray.get(1)}`); // 访问键为1的元素，获取值。输出：result: sdd\nconsole.info(`result: ${plainArray.getKeyAt(1)}`); // 访问索引为1的元素，获取键。输出：result: 2

应用端开发
接口说明
接口能力由Universal Keystore Kit提供，涉及的功能指导请参考：
Universal Keystore Kit概述查询密钥是否存在(ArkTS)查询密钥是否存在(C/C++)生成密钥(ArkTS)生成密钥(C/C++)匿名密钥证明(ArkTS)匿名密钥证明(C/C++)签名/验签(ArkTS)签名/验签(C/C++)
查询应用公私钥对是否存在
查询用于设备真实性证明的应用公私钥对是否存在，如果应用公私钥对已存在，则不需要重复创建应用公私钥对。
样例代码：
import { huks } from '@kit.UniversalKeystoreKit';\n\nlet keyAlias = 'serviceKey';  //业务密钥别名\nlet isKeyExist: Boolean;\n \nlet huksOptions: huks.HuksOptions = {\n  properties: []\n}\ntry {\n  huks.hasKeyItem(keyAlias, huksOptions, (error, data) => {\n    if (error) {\n      console.error(`callback: hasKeyItem failed, ` + JSON.stringify(error));\n    } else {\n      if (data !== null && data.valueOf() !== null) {\n        isKeyExist = data.valueOf();\n        console.info(`callback: hasKeyItem success, isKeyExist = ${isKeyExist}`);\n      }\n    }\n  });\n} catch (error) {\n  console.error(`callback: hasKeyItem input arg invalid, ` + JSON.stringify(error));\n}
创建应用公私钥对
创建一个用于证明设备真实性和应用身份的非对称算法密钥对，称为应用公私钥对（包含应用公钥和应用私钥），比如RSA、EC算法的密钥对。通过Universal Keystore Kit场景的密钥对基于硬件的安全环境进行生成和安全存储。
安全建议：对于有用户登录的应用场景，为了提高安全性，建议为终端设备中登录的每个用户生成不同的密钥对，并在应用服务器绑定用户与应用公钥之间的关系。
样例代码：
import { huks } from '@kit.UniversalKeystoreKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet keyAlias = 'serviceKey'; //业务密钥别名\n\nfunction GetGenerateProperties() {\n  let properties: Array<huks.HuksParam> = new Array();\n  let index = 0;\n  properties[index++] = {\n    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n    value: huks.HuksKeyAlg.HUKS_ALG_ECC\n  };\n  properties[index++] = {\n    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256\n  };\n  properties[index++] = {\n    tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN |\n    huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY\n  };\n  properties[index++] = {\n    tag: huks.HuksTag.HUKS_TAG_DIGEST,\n    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256\n  }\n  return properties;\n}\n\nasync function GenerateKey(keyAlias: string) {\n  let genProperties = GetGenerateProperties();\n  let options: huks.HuksOptions = {\n    properties: genProperties\n  }\n  await huks.generateKeyItem(keyAlias, options)\n    .then(() => {\n      console.info(`promise: generate Key success.`);\n    }).catch((err: BusinessError) => {\n      console.error(`promise: generate Key failed, error: ` + err.message);\n    })\n}\n
对应用公钥进行证明
应用调用Universal Keystore Kit接口对生成的应用公钥和调用的应用身份进行证明，Universal Keystore Kit会使用基于硬件的设备证书对应用公钥进行证明，证明公钥来自真实的设备。
Universal Keystore Kit返回密钥证明证书链，证书链采用X509标准格式。
安全建议：为了在发送密钥证明证书链给应用服务器时能够防重放攻击，建议应用先从应用服务器获取一次性的挑战值Challenge。应用服务器采用安全随机数生成挑战值Challenge，并缓存到服务器中。
样例代码：
import { huks } from '@kit.UniversalKeystoreKit';\n\nclass HuksProperties {\n  tag: huks.HuksTag = huks.HuksTag.HUKS_TAG_ALGORITHM;\n  value: huks.HuksKeyAlg | huks.HuksKeySize | huks.HuksKeyPurpose | huks.HuksKeyDigest |\n  huks.HuksKeyStorageType | huks.HuksKeyPadding | huks.HuksKeyGenerateType |\n  huks.HuksCipherMode | Uint8Array = huks.HuksKeyAlg.HUKS_ALG_ECC;\n}\n\nlet challenge = stringToUint8Array('challenge_data'); //从服务器获取的挑战字Challenge\nlet keyAlias = 'serviceKey'; //业务密钥别名\n\nfunction stringToUint8Array(str: string): Uint8Array {\n  let arr: number[] = [];\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  let tmpUint8Array = new Uint8Array(arr);\n  return tmpUint8Array;\n}\n\nasync function anonAttestKey(): Promise<void> {\n  let aliasString = keyAlias;\n\n  let properties: HuksProperties[] = [\n    {\n      tag: huks.HuksTag.HUKS_TAG_ATTESTATION_CHALLENGE,\n      value: challenge\n    }\n  ];\n\n  let options: huks.HuksOptions = {\n    properties: properties\n  };\n\n  try {\n    let data = await huks.anonAttestKeyItem(aliasString, options);\n    //todo：把证书链信息（data变量）发送到云侧的服务器。如下示例代码把证书链打印到日志中，供调测使用，商用代码不需要打印。\n    console.info(`anonAttestKeyItem success`);\n    data.certChains?.forEach(cert => {\n      console.info(cert);\n    });\n  } catch (error) {\n    console.error(`promise: anonAttestKeyItem fail`);\n  }\n}
使用应用私钥对业务请求进行签名
在密钥证明流程处理成功后，应用在进行一些安全敏感的端云业务时，可以使用已证明的密钥对业务请求进行安全保护。
应用可以调用Universal Keystore Kit接口使用应用私钥对业务请求数据（如HTTP请求的Body）进行签名，然后把签名数据添加到请求消息中（如HTTP的Header字段）。为了方便应用服务器查找应用公钥用于验签，可以在业务请求中携带应用公钥的密钥ID（如：通过对应用公钥计算Hash）。
安全建议：为了在发送业务请求时能够防重放攻击，建议应用先从应用服务器获取一次性的挑战值Challenge。应用服务器采用安全随机数生成挑战值Challenge，并缓存到服务器中。
样例代码：
import { huks } from '@kit.UniversalKeystoreKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { util } from '@kit.ArkTS';\n\nlet keyAlias = 'serviceKey'; //业务密钥别名\nlet handle: number;\nlet plaintext = '123456'; //待签名的明文数据，建议包含服务器端返回的Challenge\nlet signature: Uint8Array; //存储签名结果数据的变量\n\nfunction StringToUint8Array(str: String) {\n  let arr: number[] = new Array();\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  return new Uint8Array(arr);\n}\n\nfunction GetSignProperties() {\n  let properties: Array<huks.HuksParam> = new Array();\n  let index = 0;\n  properties[index++] = {\n    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n    value: huks.HuksKeyAlg.HUKS_ALG_ECC\n  };\n  properties[index++] = {\n    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256\n  };\n  properties[index++] = {\n    tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_SIGN\n  };\n  properties[index++] = {\n    tag: huks.HuksTag.HUKS_TAG_DIGEST,\n    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256\n  }\n  return properties;\n}\n\nasync function Sign(keyAlias: string, plaintext: string) {\n  let signProperties = GetSignProperties();\n  let options: huks.HuksOptions = {\n    properties: signProperties,\n    inData: StringToUint8Array(plaintext)\n  }\n  await huks.initSession(keyAlias, options)\n    .then((data) => {\n      handle = data.handle;\n    }).catch((err: BusinessError) => {\n      console.error(`promise: init sign failed, error: ` + err.message);\n    })\n  await huks.finishSession(handle, options)\n    .then((data) => {\n      signature = data.outData as Uint8Array;\n\n      let base64 = new util.Base64Helper();\n      let signatureBase64 = base64.encodeToStringSync(signature);\n      //todo：把签名结果的Base64编码（signatureBase64变量）发送到云侧的服务器。如下示例代码把签名结果打印到日志中，供调测使用，商用代码不需要打印。\n      console.info(`sign success, result:` + signatureBase64);\n\n    }).catch((err: BusinessError) => {\n      console.error(`promise: sign failed, error: ` + err.message);\n    })\n}

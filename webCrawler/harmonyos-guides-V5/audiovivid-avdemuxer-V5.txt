AudioVivid解封装
获取到Audio Vivid封装的mp4文件后，先调用解封装相关接口，选中音频轨，读取每一帧Audio Vivid，送入解码器中。详细的API请参考音频解封装API参考。
在Cmake脚本中链接到动态库
target_link_libraries(sample PUBLIC \nlibnative_media_codecbase.so libnative_media_core.so \nlibnative_media_acodec.so libnative_media_avdemuxer.so libnative_media_avsource.so\n)
添加头文件
//解封装头文件\n#include \"multimedia/player_framework/native_avdemuxer.h\"\n\n// 解封装解码传递信息结构体\nstruct AudioSampleInfo {\nstd::string audioCodecMime = \"\";\nint32_t audioSampleForamt = 0;\nint32_t audioSampleRate = 0; \nint32_t audioChannelCount = 0;\nint64_t audioChannelLayout = 0;\nuint8_t audioCodecConfig[100] = {0};\nsize_t audioCodecSize = 0;\n};\n\nAudioSampleInfo  info;
开发步骤
创建解封装实例。// ts code获取fd和size\nlet inputFile = fs.openSync(filepath,fs.OpenMode.READ_ONLY);\nif(inputFile){\n    let inputFileState = fs.stateSync(inputFile.fd);\n    let inputFileSize = inputFIleState.size;\n} //C++ code\nOH_AVSource *source = OH_AVSource_CreateWithFD(inputFd,0,inputFileSize);\nOH_AVDemuxer *demuxer = OH_AVDemuxer_CreateWithSource(source);\nauto sourceFormat = std::shared_ptr<OH_AVFormat>(OH_AVSource_GetSourceFormat(source_), OH_AVFormat_Destroy);\nint32_t trackCount = 0;\nOH_AVFormat_GetIntValue(sourceFormat.get(), OH_MD_KEY_TRACK_COUNT, &trackCount); 选中音频轨。int32_t trackCount = 0;\nOH_AVFormat_GetIntValue(sourceFormat.get(), OH_MD_KEY_TRACK_COUNT, &trackCount);\nfor (int32_t index = 0; index < trackCount; index++) {\nint trackType = -1;\nauto trackFormat =\n    std::shared_ptr<OH_AVFormat>(OH_AVSource_GetTrackFormat(source_, index), OH_AVFormat_Destroy);\n// 获取轨道类型\nOH_AVFormat_GetIntValue(trackFormat.get(), OH_MD_KEY_TRACK_TYPE, &trackType);\n// 判断当前轨道为音频轨\nif (trackType == MEDIA_TYPE_AUD) { \n    // 选中音频轨\n    OH_AVDemuxer_SelectTrackByID(demuxer, index);\n    // 获取位深\n    OH_AVFormat_GetIntValue(trackFormat.get(), OH_MD_KEY_AUDIO_SAMPLE_FORMAT, &info.audioSampleForamt);\n    // 获取声道数\n    OH_AVFormat_GetIntValue(trackFormat.get(), OH_MD_KEY_AUD_CHANNEL_COUNT, &info.audioChannelCount);\n    // 获取声道布局\n    OH_AVFormat_GetLongValue(trackFormat.get(), OH_MD_KEY_CHANNEL_LAYOUT, &info.audioChannelLayout);\n    // 获取采样率\n    OH_AVFormat_GetIntValue(trackFormat.get(), OH_MD_KEY_AUD_SAMPLE_RATE, &info.audioSampleRate);\n    // 获取额外配置信息\n    uint8_t *addr = nullptr;\n    OH_AVFormat_GetBuffer(trackFormat.get(), OH_MD_KEY_CODEC_CONFIG, &addr, &info.audioCodecSize);\n    memcpy((void *)info.audioCodecConfig, (void *)addr, info.audioCodecSize);\n    // 获取解码器类型\n    char *audioCodecMime;\n    OH_AVFormat_GetStringValue(trackFormat.get(), OH_MD_KEY_CODEC_MIME, const_cast<char const **>(&audioCodecMime));\n    info.audioCodecMime = audioCodecMime;\n    int32_t trackId = index;\n    break;\n    }\n} 读取每一帧数据。OH_AVBuffer *buffer;\nint32_t ret = OH_AVDemuxer_ReadSampleBuffer(demuxer, trackId, buffer); 释放解封装实例。int32_t Release()\n{\n    if (demuxer != nullptr) {\n        OH_AVDemuxer_Destroy(demuxer);\n        demuxer = nullptr;\n    }\n    if (source != nullptr) {\n        OH_AVSource_Destroy(source);\n        source = nullptr;\n    }\n    return AVCODEC_SAMPLE_ERR_OK;\n} 

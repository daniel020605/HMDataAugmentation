产品特性按需分发
场景介绍
随着HarmonyOS应用的持续发展，应用的功能将越来越丰富，实际上80%的用户使用时长都会集中在20%的特性上，其余的功能可能也仅仅是面向部分用户。为了避免用户首次下载应用耗时过长，及过多占用用户空间，应用市场服务提供按需分发的能力，支持用户按需动态下载自己所需的增强特性。
基本概念
按需分发：一个应用程序被打包成多个安装包，安装包包含了所有的应用程序代码和静态资源。用户从应用市场下载的应用只包含基本功能的安装包，当用户需要使用增强功能时，相应安装包将会从服务器下载到设备上（应用发布请参考发布HarmonyOS应用）。
业务流程
 用户下载A应用的基础包。 用户使用增强功能。 应用通过API下载动态安装包。 下载完成。 告知用户下载结果。 
接口说明
产品特性按需分发场景提供以下接口，具体API说明详见接口文档。
接口名
描述
getInstalledModule(moduleName: string): InstalledModule
查询模块安装信息接口。
createModuleInstallRequest(context: common.UIAbilityContext | common.ExtensionContext): ModuleInstallRequest
创建按需加载请求对象。
addModule((moduleName: string): ReturnCode
添加要按需加载的模块名。
fetchModules(moduleInstallRequest: ModuleInstallRequest): Promise<ModuleInstallSessionState>
按需加载请求接口，异步返回结果。
cancelTask(taskId: string): ReturnCode
取消下载任务接口。
showCellularDataConfirmation(context: common.UIAbilityContext | common.ExtensionContext, taskId: string): ReturnCode
流量提醒弹窗接口。
on(type: 'moduleInstallStatus', callback: Callback<ModuleInstallSessionState>, timeout: number): void
监听当前应用下载任务的进度。
off(type: 'moduleInstallStatus', callback?: Callback<ModuleInstallSessionState>): void
取消监听当前应用下载任务的进度。
开发步骤
[h2]获取模块安装信息
 导入moduleInstallManager模块及相关公共模块。import { moduleInstallManager } from '@kit.StoreKit';  构造参数。         入参为需要查询的模块名称。        const moduleName: string = 'AModule';   调用getInstalledModule方法，将步骤2中构造的参数传入模块中的getInstalledModule方法。const moduleInfo: moduleInstallManager.InstalledModule = moduleInstallManager.getInstalledModule(moduleName);  
[h2]创建按需加载的请求实例
 导入moduleInstallManager模块及相关公共模块。import { moduleInstallManager } from '@kit.StoreKit';\nimport type { common } from '@kit.AbilityKit';  构造参数。         入参为当前应用的上下文context，只支持UIAbilityContext和ExtensionContext类型的上下文，其中UIAbilityContext类型的上下文是要校验当前应用是否在前台，如果不在前台，则会被拒绝调用。        const context: common.UIAbilityContext | common.ExtensionContext = getContext(this) as common.UIAbilityContext;   调用createModuleInstallRequest方法，将步骤2中构造的参数依次传入模块中的createModuleInstallRequest方法。const myModuleInstallProvider: moduleInstallManager.ModuleInstallProvider = new moduleInstallManager.ModuleInstallProvider();\nconst myModuleInstallRequest: moduleInstallManager.ModuleInstallRequest = myModuleInstallProvider.createModuleInstallRequest(context);  
[h2]请求按需加载的接口
 导入moduleInstallManager模块及相关公共模块。import type { common } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { moduleInstallManager } from '@kit.StoreKit';  构造参数。         入参为当前要按需加载的模块名。        const moduleNameA: string = 'AModule';\nconst moduleNameB: string = 'BModule';   调用ModuleInstallRequest中的addModule方法，将步骤2中构造的参数依次传入模块中的addModule方法。let myModuleInstallRequest: moduleInstallManager.ModuleInstallRequest;\ntry {\n  const myModuleInstallProvider: moduleInstallManager.ModuleInstallProvider = new moduleInstallManager.ModuleInstallProvider();\n  const context: common.UIAbilityContext | common.ExtensionContext = getContext(this) as common.UIAbilityContext;\n  myModuleInstallRequest = myModuleInstallProvider.createModuleInstallRequest(context);\n  const aResult: moduleInstallManager.ReturnCode = myModuleInstallRequest.addModule(moduleNameA);\n  const bResult: moduleInstallManager.ReturnCode = myModuleInstallRequest.addModule(moduleNameB);\n  hilog.info(0, 'TAG', 'aResult:' + aResult + ' bResult:' + bResult);\n} catch (error) {\n  hilog.error(0, 'TAG', `addModule onError.code is ${error.code}, message is ${error.message}`);\n}\n  调用fetchModules方法，将步骤三中的myModuleInstallRequest传入模块中的fetchModules方法。try {\n  moduleInstallManager.fetchModules(myModuleInstallRequest)\n    .then((data: moduleInstallManager.ModuleInstallSessionState) => {\n      hilog.info(0, 'TAG', 'Succeeded in fetching Modules data.');\n    })\n} catch (error) {\n  hilog.error(0, 'TAG', `fetching Modules onError.code is ${error.code}, message is ${error.message}`);\n}  
[h2]使用动态模块
假如应用A由entry.hap、AModulelib.hsp两个包组成，其中entry是基础包，AModulelib扩展是功能包（创建方式请参考应用程序包开发与使用）。通过应用市场下载安装只会下载安装entry包，在entry包里面可以通过fetchModules接口动态下载AModulelib包，并使用动态import技术调用AModulelib里的方法和组件。
AModulelib中主要实现如下：
 在动态模块AModulelib的module.json5中设置deliveryWithInstall为false，来标识当前AModulelib在用户主动安装应用A的时候不会一起下载安装。{\n  \"module\": {\n    \"name\": \"AModulelib\",\n    \"deliveryWithInstall\": false\n  }\n} 
 在动态模块AModulelib中定义add方法和DateComponent组件。其中add方法用于计算加法，DateComponent用于显示文本。Calc.ets定义如下： export function add(a:number, b:number) {\n  return a + b;\n}         DateComponent.ets定义如下：        @Component\nstruct DateComponent {\n  build() {\n    Column() {\n      Text('我是AModulelib中的组件')\n        .margin(10);\n    }\n    .width(300).backgroundColor(Color.Yellow);\n  }\n}\n\n@Builder\nexport function showDateComponent() {\n  DateComponent()\n}  
 在AModulelib的AModulelib/Index.ets中导出add方法和showDateComponent方法。export { add } from './src/main/ets/utils/Calc';\nexport { showDateComponent } from './src/main/ets/components/DateComponent'; 
entry中主要实现如下：
 在entry基础模块中，增加动态依赖配置。entry的oh-package.json5中使用dynamicDependencies来动态依赖AModulelib模块。{\n  \"dynamicDependencies\": {\n    \"AModulelib\": \"file:../AModulelib\"\n  }\n} 在entry中使用动态模块AModulelib模块里面的方法和组件。在调用AModulelib中的功能前需要判断AModulelib是否已经加载，未加载时请参考请求按需加载的接口完成加载。import { moduleInstallManager } from '@kit.StoreKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { BusinessError, Callback } from '@kit.BasicServicesKit';\nimport { common } from '@kit.AbilityKit';\nimport { promptAction } from '@kit.ArkUI';\n\nconst TAG: string = 'TAG';\n\n@Entry\n@Component\nstruct Index {\n  @BuilderParam AModulelibComponent: Function;\n  @State countTotal: number = 0;\n  @State isShow: boolean = false;\n\n  build() {\n    Row() {\n      Column() {\n        Button(`调用增量模块中的add功能:3+6`)\n          .onClick(() => {\n            this.initAModulelib(() => {\n              import('AModulelib').then((ns: ESObject) => {\n                this.countTotal = ns.add(3, 6);\n              }).catch((error: BusinessError) => {\n                hilog.error(0, 'TAG', `add onError.code is ${error.code}, message is ${error.message}`);\n              })\n            })\n          });\n        Text('计算结果：' + this.countTotal)\n          .margin(10);\n        Button(`调用增量模块中的showDateComponent功能`)\n          .onClick(() => {\n            this.initAModulelib(() => {\n              import('AModulelib').then((ns: ESObject) => {\n                this.AModulelibComponent = ns.showDateComponent;\n                this.isShow = true;\n              }).catch((error: BusinessError) => {\n                hilog.error(0, 'TAG', `showDateComponent onError.code is ${error.code}, message is ${error.message}`);\n              })\n            })\n          }).margin({\n          top: 10, bottom: 10\n        });\n        if (this.isShow) {\n          this.AModulelibComponent()\n        }\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n\n  private showToastInfo(msg: string) {\n    promptAction.showToast({\n      message: msg,\n      duration: 2000\n    });\n  }\n\n  /**\n   * 检查是否已加载AModulelib包\n   *\n   * @param successCallBack 回调\n   */\n  private initAModulelib(successCallBack: Callback<void>): void {\n    try {\n      const result: moduleInstallManager.InstalledModule = moduleInstallManager.getInstalledModule('AModulelib');\n      if (result?.installStatus === moduleInstallManager.InstallStatus.INSTALLED) {\n        hilog.info(0, TAG, 'AModulelib installed');\n        successCallBack && successCallBack();\n      } else {\n        // AModulelib模块未安装, 需要调用fetchModules下载AModulelib模块。\n        hilog.info(0, TAG, 'AModulelib not installed');\n        this.fetchModule('AModulelib', successCallBack)\n      }\n    } catch (error) {\n      hilog.error(0, 'TAG', `getInstalledModule onError.code is ${error.code}, message is ${error.message}`);\n    }\n  }\n\n  /**\n   * 添加监听事件\n   *\n   * @param successCallBack 回调\n   */\n  private onListenEvents(successCallBack: Callback<void>): void {\n    const timeout = 3 * 60; //单位秒， 默认最大监听时间为30min（即30*60秒）\n    moduleInstallManager.on('moduleInstallStatus', (data: moduleInstallManager.ModuleInstallSessionState) => {\n      // 返回成功\n      if (data.taskStatus === moduleInstallManager.TaskStatus.INSTALL_SUCCESSFUL) {\n        successCallBack && successCallBack();\n        this.showToastInfo('install success');\n      }\n    }, timeout)\n  }\n\n  /**\n   * 加载指定包\n   *\n   * @param moduleName 需要加载的安装包名称\n   * @param successCallBack 回调\n   */\n  private fetchModule(moduleName: string, successCallBack: Callback<void>) {\n    try {\n      hilog.info(0, TAG, 'handleFetchModules start');\n      const context = getContext(this) as common.UIAbilityContext;\n      const moduleInstallProvider: moduleInstallManager.ModuleInstallProvider =\n        new moduleInstallManager.ModuleInstallProvider();\n      const moduleInstallRequest: moduleInstallManager.ModuleInstallRequest =\n        moduleInstallProvider.createModuleInstallRequest(context);\n      if (!moduleInstallRequest) {\n        hilog.warn(0, TAG, 'moduleInstallRequest is empty');\n        return;\n      }\n      moduleInstallRequest.addModule(moduleName);\n      moduleInstallManager.fetchModules(moduleInstallRequest)\n        .then((data: moduleInstallManager.ModuleInstallSessionState) => {\n          hilog.info(0, TAG, 'Succeeded in fetching Modules result.');\n          if (data.code === moduleInstallManager.RequestErrorCode.SUCCESS) {\n            this.onListenEvents(successCallBack)\n          } else {\n            hilog.info(0, TAG, 'fetchModules failure');\n          }\n        })\n        .catch((error: BusinessError) => {\n          hilog.error(0, 'TAG', `fetchModules onError.code is ${error.code}, message is ${error.message}`);\n        })\n    } catch (error) {\n      hilog.error(0, 'TAG', `handleFetchModules onError.code is ${error.code}, message is ${error.message}`);\n    }\n  }\n}  
运行结果效果图：

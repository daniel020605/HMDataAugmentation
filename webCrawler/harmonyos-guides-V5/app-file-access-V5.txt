应用文件访问(ArkTS)
应用需要对应用文件目录下的应用文件进行查看、创建、读写、删除、移动、复制、获取属性等访问操作，下文介绍具体方法。
接口说明
开发者通过基础文件操作接口（ohos.file.fs）实现应用文件访问能力，主要功能如下表所示。
表1 基础文件操作接口功能
使用基础文件操作接口时，耗时较长的操作，例如：read、write等，建议使用异步接口，避免应用崩溃。
开发示例
在对应用文件开始访问前，开发者需要获取应用文件路径。以从UIAbilityContext获取HAP级别的文件路径为例进行说明，UIAbilityContext的获取方式请参见获取UIAbility的上下文信息。
下面介绍几种常用操作示例。
[h2]新建并读写一个文件
以下示例代码演示了如何新建一个文件并对其读写。
// pages/xxx.ets\nimport { fileIo as fs, ReadOptions } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\nimport { buffer } from '@kit.ArkTS';\n\n// 获取应用文件路径\nlet context = getContext(this) as common.UIAbilityContext;\nlet filesDir = context.filesDir;\n\nfunction createFile(): void {\n  // 文件不存在时创建并打开文件，文件存在时打开文件\n  let file = fs.openSync(filesDir + '/test.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\n  // 写入一段内容至文件\n  let writeLen = fs.writeSync(file.fd, \"Try to write str.\");\n  console.info(\"The length of str is: \" + writeLen);\n  // 创建一个大小为1024字节的ArrayBuffer对象，用于存储从文件中读取的数据\n  let arrayBuffer = new ArrayBuffer(1024);\n  // 设置读取的偏移量和长度\n  let readOptions: ReadOptions = {\n    offset: 0,\n    length: arrayBuffer.byteLength\n  };\n  // 读取文件内容到ArrayBuffer对象中，并返回实际读取的字节数\n  let readLen = fs.readSync(file.fd, arrayBuffer, readOptions);\n  // 将ArrayBuffer对象转换为Buffer对象，并转换为字符串输出\n  let buf = buffer.from(arrayBuffer, 0, readLen);\n  console.info(\"the content of file: \" + buf.toString());\n  // 关闭文件\n  fs.closeSync(file);\n}
[h2]读取文件内容并写入到另一个文件
以下示例代码演示了如何从一个文件读写内容到另一个文件。
// pages/xxx.ets\nimport { fileIo as fs, ReadOptions, WriteOptions } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\n\n// 获取应用文件路径\nlet context = getContext(this) as common.UIAbilityContext;\nlet filesDir = context.filesDir;\n\nfunction readWriteFile(): void {\n  // 打开文件\n  let srcFile = fs.openSync(filesDir + '/test.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\n  let destFile = fs.openSync(filesDir + '/destFile.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\n  // 读取源文件内容并写入至目的文件\n  let bufSize = 4096;\n  let readSize = 0;\n  let buf = new ArrayBuffer(bufSize);\n  let readOptions: ReadOptions = {\n    offset: readSize,\n    length: bufSize\n  };\n  let readLen = fs.readSync(srcFile.fd, buf, readOptions);\n  while (readLen > 0) {\n    readSize += readLen;\n    let writeOptions: WriteOptions = {\n      length: readLen\n    };\n    fs.writeSync(destFile.fd, buf, writeOptions);\n    readOptions.offset = readSize;\n    readLen = fs.readSync(srcFile.fd, buf, readOptions);\n  }\n  // 关闭文件\n  fs.closeSync(srcFile);\n  fs.closeSync(destFile);\n}
使用读写接口时，需注意可选项参数offset的设置。对于已存在且读写过的文件，文件偏移指针默认在上次读写操作的终止位置。
[h2]以流的形式读写文件
以下示例代码演示了如何使用流接口读取test.txt的文件内容并写入到destFile.txt文件中。
// pages/xxx.ets\nimport { fileIo as fs, ReadOptions } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\n\n// 获取应用文件路径\nlet context = getContext(this) as common.UIAbilityContext;\nlet filesDir = context.filesDir;\n\nasync function readWriteFileWithStream(): Promise<void> {\n  // 创建并打开输入文件流\n  let inputStream = fs.createStreamSync(filesDir + '/test.txt', 'r+');\n  // 创建并打开输出文件流\n  let outputStream = fs.createStreamSync(filesDir + '/destFile.txt', \"w+\");\n\n  let bufSize = 4096;\n  let readSize = 0;\n  let buf = new ArrayBuffer(bufSize);\n  let readOptions: ReadOptions = {\n    offset: readSize,\n    length: bufSize\n  };\n  // 以流的形式读取源文件内容并写入到目标文件\n  let readLen = await inputStream.read(buf, readOptions);\n  readSize += readLen;\n  while (readLen > 0) {\n    const writeBuf = readLen < bufSize ? buf.slice(0, readLen) : buf;\n    await outputStream.write(writeBuf);\n    readOptions.offset = readSize;\n    readLen = await inputStream.read(buf, readOptions);\n    readSize += readLen;\n  }\n  // 关闭文件流\n  inputStream.closeSync();\n  outputStream.closeSync();\n}
使用流接口时，需注意流的及时关闭。同时流的异步接口应严格遵循异步接口使用规范，避免同步、异步接口混用。流接口不支持并发读写。
[h2]查看文件列表
以下示例代码演示了如何查看文件列表。
import { fileIo as fs, Filter, ListFileOptions } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\n\n// 获取应用文件路径\nlet context = getContext(this) as common.UIAbilityContext;\nlet filesDir = context.filesDir;\n\n// 查看文件列表\nfunction getListFile(): void {\n  let listFileOption: ListFileOptions = {\n    recursion: false,\n    listNum: 0,\n    filter: {\n      suffix: [\".png\", \".jpg\", \".txt\"],\n      displayName: [\"test*\"],\n      fileSizeOver: 0,\n      lastModifiedAfter: new Date(0).getTime()\n    }\n  };\n  let files = fs.listFileSync(filesDir, listFileOption);\n  for (let i = 0; i < files.length; i++) {\n    console.info(`The name of file: ${files[i]}`);\n  }\n}
[h2]使用文件流
以下示例代码演示了如何使用文件可读流，文件可写流。
// pages/xxx.ets\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\n\n// 获取应用文件路径\nlet context = getContext(this) as common.UIAbilityContext;\nlet filesDir = context.filesDir;\n\nfunction copyFileWithReadable(): void {\n  // 创建文件可读流\n  const rs = fs.createReadStream(`${filesDir}/read.txt`);\n  // 创建文件可写流\n  const ws = fs.createWriteStream(`${filesDir}/write.txt`);\n  // 暂停模式拷贝文件。在拷贝数据时，将原始数据暂停，然后将数据复制到另一个位置，适用于对数据完整性和一致性要求较高的场景\n  rs.on('readable', () => {\n    const data = rs.read();\n    if (!data) {\n      return;\n    }\n    ws.write(data);\n  });\n}\n\nfunction copyFileWithData(): void {\n  // 创建文件可读流\n  const rs = fs.createReadStream(`${filesDir}/read.txt`);\n  // 创建文件可写流\n  const ws = fs.createWriteStream(`${filesDir}/write.txt`);\n  // 流动模式拷贝文件。数据的读取和写入是同时进行的，不需要暂停原始数据的访问，适用于对数据实时性要求较高的场景\n  rs.on('data', (emitData) => {\n    const data = emitData?.data;\n    if (!data) {\n      return;\n    }\n    ws.write(data as Uint8Array);\n  });\n}
[h2]使用文件哈希流
哈希流是一种数据传输和存储技术，可以将任意长度的数据转换为固定长度的哈希值来验证数据的完整性和一致性。以下代码演示了如何使用文件哈希处理接口（ohos.file.hash）来处理文件哈希流。
// pages/xxx.ets\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { hash } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\n\n// 获取应用文件路径\nlet context = getContext(this) as common.UIAbilityContext;\nlet filesDir = context.filesDir;\n\nfunction hashFileWithStream() {\n  const filePath = `${filesDir}/test.txt`;\n  // 创建文件可读流\n  const rs = fs.createReadStream(filePath);\n  // 创建哈希流\n  const hs = hash.createHash('sha256');\n  rs.on('data', (emitData) => {\n    const data = emitData?.data;\n    hs.update(new Uint8Array(data?.split('').map((x: string) => x.charCodeAt(0))).buffer);\n  });\n  rs.on('close', async () => {\n    const hashResult = hs.digest();\n    const fileHash = await hash.hash(filePath, 'sha256');\n    console.info(`hashResult: ${hashResult}, fileHash: ${fileHash}`);\n  });\n}

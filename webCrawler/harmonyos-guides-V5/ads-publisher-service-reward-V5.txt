激励广告
场景介绍
激励广告是一种全屏幕的视频广告，用户可以选择点击观看，以换取相应奖励。
接口说明
接口名
描述
loadAd(adParam: AdRequestParams, adOptions: AdOptions, listener: AdLoadListener): void
请求单广告位广告，通过AdRequestParams、AdOptions进行广告请求参数设置，通过AdLoadListener监听广告请求回调。
showAd(ad: Advertisement, options: AdDisplayOptions, context?: common.UIAbilityContext): void
展示广告，通过AdDisplayOptions进行广告展示参数设置。
为了保证广告能正确展示，该接口必须和请求广告接口配套使用。
开发步骤
获取OAID。如果想要为用户更精准的推送广告，可以在请求参数AdRequestParams中添加oaid属性。 如何获取OAID参见获取OAID信息。  使用以下示例中提供的测试广告位必须先获取OAID信息。  请求单广告位广告。需要先创建一个AdLoader对象，通过AdLoader的loadAd方法请求广告，最后通过AdLoadListener，来监听广告的加载状态。 请求广告关键参数如下所示： 请求广告参数名  类型  必填  说明    adType  number  是  请求广告类型，激励广告类型为7。   adId  string  是  广告位ID。 如果仅调测广告，可使用测试广告位ID：testx9dtjwj8hp。如果要接入正式广告，则需要申请正式的广告位ID。可在应用发布前进入流量变现官网，点击“开始变现”，登录鲸鸿动能媒体服务平台进行申请，具体操作详情请参见展示位创建。   oaid  string  否  开放匿名设备标识符，用于精准推送广告。不填无法获取到个性化广告。      示例代码如下所示：import { advertising, identifier } from '@kit.AdsKit';\nimport { common } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n@Entry\n@Component\nstruct Index {\n  private ads: Array<advertising.Advertisement> = [];\n  private context = getContext(this) as common.UIAbilityContext;\n  private oaid: string = '';\n\n  aboutToAppear() {\n    try {\n      // 使用Promise回调方式获取OAID\n      identifier.getOAID().then((data: string) => {\n        this.oaid = data;\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Succeeded in getting adsIdentifierInfo by promise');\n      }).catch((error: BusinessError) => {\n        hilog.error(0x0000, 'testTag', '%{public}s', `Failed to get adsIdentifierInfo, message: ${error.message}`);\n      })\n    } catch (error) {\n      hilog.error(0x0000, 'testTag', '%{public}s', `Catch err, code: ${error.code}, message: ${error.message}`);\n    }\n  }\n\n  build() {\n    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {\n      Row() {\n        Button('requestAd').onClick(() => {\n          let load: advertising.AdLoader = new advertising.AdLoader(this.context);\n          this.requestAd(load);\n        }).width('45%')\n      }\n    }\n  }\n\n  private requestAd(adLoader: advertising.AdLoader): void {\n    const adRequestParam: advertising.AdRequestParams = {\n      // 广告类型：激励广告\n      adType: 7,\n      // 'testx9dtjwj8hp'为测试专用的广告位ID，App正式发布时需要改为正式的广告位ID\n      adId: 'testx9dtjwj8hp',\n      // 开放匿名设备标识符\n      oaid: this.oaid\n    };\n    const adOption: advertising.AdOptions = {\n      // 设置是否请求非个性化广告\n      nonPersonalizedAd: 0,\n      // 是否允许流量下载0：不允许，1：允许，不设置以广告主设置为准\n      allowMobileTraffic: 0,\n      // 是否希望根据 COPPA 的规定将您的内容视为面向儿童的内容: -1默认值，不确定 0不希望 1希望\n      tagForChildProtection: -1,\n      // 是否希望按适合未达到法定承诺年龄的欧洲经济区 (EEA) 用户的方式处理该广告请求： -1默认值，不确定 0不希望 1希望\n      tagForUnderAgeOfPromise: -1,\n      // 设置广告内容分级上限: W: 3+,所有受众 PI: 7+,家长指导 J:12+,青少年 A: 16+/18+，成人受众\n      adContentClassification: 'A'\n    };\n    const adLoaderListener: advertising.AdLoadListener = {\n      onAdLoadFailure: (errorCode: number, errorMsg: string) => {\n        hilog.error(0x0000, 'testTag', '%{public}s',\n          `Failed to request ad, message: ${errorMsg}, error code: ${errorCode}`);\n      },\n      onAdLoadSuccess: (ads: Array<advertising.Advertisement>) => {\n        hilog.info(0x0000, 'testTag', '%{public}s', `Succeeded in requesting ad`);\n        this.ads.push(...ads);\n      },\n    };\n    adLoader.loadAd(adRequestParam, adOption, adLoaderListener);\n  }\n}  事件订阅。开发者需要在App中订阅com.huawei.hms.pps.action.PPS_REWARD_STATUS_CHANGED事件来监听激励广告页面变化并接收奖励信息。示例代码中的订阅方法registerPPSReceiver()需要在每次展示广告前调用 。 在订阅到公共事件后，可以从CommonEventData的parameters参数中使用\"reward_ad_status\"作为key值获取激励广告页面变化状态，使用\"reward_ad_data\"作为key值获取奖励信息，属性rewardType用来获取奖励物品的名称，rewardAmount用来获取奖励物品的数量。 示例代码如下所示： import { commonEventManager, BusinessError } from '@kit.BasicServicesKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\n\nconst KEY_REWARD_DATA = \"reward_ad_data\";\nconst KEY_REWARD_STATUS = \"reward_ad_status\";\n\nexport class RewardAdStatusHandler {\n  // 用于保存创建成功的订阅者对象，后续使用其完成订阅及退订的动作\n  private subscriber: commonEventManager.CommonEventSubscriber | null = null;\n\n  // 订阅方法，需要在每次展示广告前调用\n  public registerPPSReceiver(): void {\n    if (this.subscriber) {\n      this.unRegisterPPSReceiver();\n    }\n    // 订阅者信息\n    const subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {\n      events: ['com.huawei.hms.pps.action.PPS_REWARD_STATUS_CHANGED'],\n      // publisherBundleName被设置为\"com.huawei.hms.adsservice\",这意味着只有来自该包名的事件才会被订阅者接受和处理。\n      // 如果没有明确声明publisherBundleName，那么订阅者可能会收到来自其它包名的伪造事件，从而导致安全性问题或误导。\n      publisherBundleName: 'com.huawei.hms.adsservice'\n    };\n    // 创建订阅者回调\n    commonEventManager.createSubscriber(subscribeInfo, (err: BusinessError, commonEventSubscriber:\n      commonEventManager.CommonEventSubscriber) => {\n      if (err) {\n        hilog.error(0x0000, 'testTag', '%{public}s',\n          `createSubscriber error, code: ${err.code}, message: ${err.message}`);\n        return;\n      }\n      hilog.info(0x0000, 'testTag', '%{public}s', 'Succeeded in creating subscriber');\n      this.subscriber = commonEventSubscriber;\n      // 订阅公共事件回调\n      if (!this.subscriber) {\n        hilog.warn(0x0000, 'testTag', '%{public}s', 'Need create subscriber');\n        return;\n      }\n      commonEventManager.subscribe(this.subscriber, (err: BusinessError, commonEventSubscriber:\n        commonEventManager.CommonEventData) => {\n        if (err) {\n          hilog.error(0x0000, 'testTag', '%{public}s', `Subscribe error, code: ${err.code}, message: ${err.message}`);\n        } else {\n          hilog.info(0x0000, 'testTag', '%{public}s', 'Subscribe data');\n          const status: string = commonEventSubscriber?.parameters?.[KEY_REWARD_STATUS];\n          switch (status) {\n            case AdStatus.AD_OPEN:\n              hilog.info(0x0000, 'testTag', '%{public}s', 'onAdOpen');\n              break;\n            case AdStatus.AD_CLICKED:\n              hilog.info(0x0000, 'testTag', '%{public}s', 'onAdClick');\n              break;\n            case AdStatus.AD_CLOSED:\n              hilog.info(0x0000, 'testTag', '%{public}s', 'onAdClose');\n              this.unRegisterPPSReceiver();\n              break;\n            case AdStatus.AD_REWARDED:\n              const rewardData: Record<string, string | number> = commonEventSubscriber?.parameters?.[KEY_REWARD_DATA];\n              const rewardType: string = rewardData?.rewardType as string;\n              const rewardAmount: number = rewardData?.rewardAmount as number;\n              hilog.info(0x0000, 'testTag', '%{public}s',\n                `onAdReward, rewardType: ${rewardType}, rewardAmount: ${rewardAmount}`);\n              break;\n            case AdStatus.AD_VIDEO_START:\n              hilog.info(0x0000, 'testTag', '%{public}s', 'onAdVideoStart');\n              break;\n            case AdStatus.AD_COMPLETED:\n              hilog.info(0x0000, 'testTag', '%{public}s', 'onAdCompleted');\n              break;\n            default:\n              break;\n          }\n        }\n      });\n    });\n  }\n\n  // 取消订阅\n  public unRegisterPPSReceiver(): void {\n    commonEventManager.unsubscribe(this.subscriber, (err: BusinessError) => {\n      if (err) {\n        hilog.error(0x0000, 'testTag', '%{public}s', `Unsubscribe error, code: ${err.code}, message: ${err.message}`);\n      } else {\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Succeeded in unsubscribing');\n        this.subscriber = null;\n      }\n    });\n  }\n}\n\nenum AdStatus {\n  AD_OPEN = 'onAdOpen',\n  AD_CLICKED = 'onAdClick',\n  AD_CLOSED = 'onAdClose',\n  AD_REWARDED = 'onAdReward',\n  AD_VIDEO_START = 'onVideoPlayBegin',\n  AD_COMPLETED = 'onVideoPlayEnd'\n} 展示广告。ads为步骤2请求到的广告信息，调用showAd方法来展示广告。示例代码如下所示：import { advertising } from '@kit.AdsKit';\nimport { common } from '@kit.AbilityKit';\n\n@Entry\n@Component\nstruct Index {\n  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;\n  // 步骤2中请求到的广告内容\n  private ads: Array<advertising.Advertisement> = [];\n  private displayOptions: advertising.AdDisplayOptions = {\n    // 激励广告视频播放是否静音\n    mute: true\n  };\n\n  build() {\n    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {\n      Row() {\n        Button('showAd').onClick(() => {\n          this.showAd();\n        }).width('45%')\n      }\n    }\n  }\n\n  private showAd() {\n    // 请在此处自行增加步骤3中的，注册激励广告状态监听器\n    // ...\n\n    // 此处ads[0]表示请求到的第一个广告，用户根据实际情况选择\n    advertising.showAd(this.ads[0], this.displayOptions, this.context);\n  }\n}  
校验激励广告服务端验证回调
服务端验证回调是指鲸鸿动能平台发送给媒体服务器的网址请求，其中带有特定的查询参数，用来通知媒体服务器某位用户因为与激励视频广告互动而应予以奖励，从而规避欺骗的行为。
[h2]奖励用户
在给用户发奖励时，要把握好用户体验和奖励验证之间的平衡。由于服务器端回调会存在延迟的情况，因此我们建议客户端立即奖励用户，同时在收到服务器端回调时对所有奖励进行验证。这种做法可确保奖励符合发放条件，同时提供良好的用户体验。对于某些应用而言，奖励是否达到发放条件非常重要，用户可适当接受延迟。这时，推荐做法是等待服务器端回调完成验证，再向用户发放奖励。
[h2]校验服务端验证回调
App上架至华为应用市场（AppGallery）时间超过12小时才可以收到回调。
设置激励广告的奖励配置。您在鲸鸿动能媒体服务平台上申请激励视频广告位时选择“媒体管理（点击媒体名）> 新增展示位 > 选择激励视频（点击下一步，进入编辑页面）”，设置奖励类型和奖励数量，并点击“高级设置”，设置服务器端验证的URL。如下图：  （可选）设置自定义数据customData和userId。ads为步骤2请求到的广告信息，调用showAd方法来展示广告。 您在App中展示激励广告之前设置自定义数据customData和userId。示例代码如下所示： import { advertising } from '@kit.AdsKit';\nimport { common } from '@kit.AbilityKit';\n\n@Entry\n@Component\nstruct Index {\n  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;\n  // 步骤2中请求到的广告内容\n  private ads: Array<advertising.Advertisement> = [];\n  private displayOptions: advertising.AdDisplayOptions = {\n    // 激励广告视频播放是否静音\n    mute: true,\n    // 设置自定义数据\n    customData: 'CUSTOM_DATA',\n    // 设置自定义数据\n    userId: '1234567'\n  };\n\n  build() {\n    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {\n      Row() {\n        Button('showAd').onClick(() => {\n          this.showAd();\n        }).width('45%')\n      }\n    }\n  }\n\n  private showAd() {\n    // 请在此处自行增加开发步骤3中的，注册激励广告状态监听器\n    // ...\n\n    // 此处ads[0]表示请求到的第一个广告，用户根据实际情况选择\n    advertising.showAd(this.ads[0], this.displayOptions, this.context);\n  }\n}  如果没有设置customData和userId，不影响发放奖励事件上报但是服务端验证的参数中没有这两个字段。如果设置customData和userId，必须在展示广告之前设置并且URLEncode之后，长度不超过1024个字符，否则影响服务端验证。  获取要验证的内容。用户观看完激励广告时，鲸鸿动能平台服务端会把需要验证的参数以及keyId和sign传给媒体提供的URL：https://www.example.com/feedback（即步骤1中配置的验证URL）。请求体样例： {\n    \"adId\" : \"testx9dtjwj8hp\",\n    \"data\" : \"CUSTOM_DATA\",\n    \"keyId\" : \"12345678\",\n    \"rewardAmount\" : \"10\",\n    \"rewardName\" : \"金币\",\n    \"sign\" : \"OA33u6mypnhE4hbmF32N/ibYi1uXt72nDDyYMwjDI6JXVVFKePZYo4F7Fuk2MaG......\",\n    \"uniqueId\" : \"3361626337333932313435313430373438383561376265636130393939313166\",\n    \"userId\" : \"1234567\"\n} 服务器端验证回调查询参数说明： 参数名称  类型  是否必选  描述    adId  String  是  激励视频广告位ID   data  String  否  自定义数据字符串   keyId  String  是  验证回调的密钥   rewardAmount  String  否  奖励数量   rewardName  String  否  奖励奖品   sign  String  是  回调的签名   uniqueId  String  是  获奖事件生成的十六进制的标识符   userId  String  否  用户ID     组装验证参数验证内容（除sign、keyId）格式顺序如下： adId={adId}&data={data}&rewardAmount={rewardAmount}&rewardName={rewardName}&uniqueId={uniqueId}&userId={userId} 其中‘{}’里面表示参数的值，且参数顺序不能变。如果参数为null或者空字符串，则URL中不拼接该参数。然后用SHA256计算散列值，得到paramContentData。示例代码如下所示： String adId = request.getParameter(\"adId\");\nString data = request.getParameter(\"data\");\n...\nString userId = request.getParameter(\"userId\");\nString param = \"adId=\" + adId + \"&data=\" + data + \"&rewardAmount=\" + rewardAmount + \"&rewardName=\" + rewardName + \"&uniqueId=\" + uniqueId + \"&userId=\" + userId;\nString sha256Value = Sha256Util.digest(param);\nbyte[] paramContentData = sha256Value.getBytes(Charset.forName(\"UTF-8\")); 获取公钥列表。a. 在鲸鸿动能媒体服务平台上查看对应的帐户信息时选择“账户”。  通过点击上图所示的“获取密钥”按钮弹出如下所示的弹框，获取“开发者ID”和“密钥”。  b. 您根据应用分发区域不同，需要使用对应站点的接口URL去获取公钥列表，不同站点对应的接口URL如下所示： 中国境内（不包含中国香港、中国澳门、中国台湾）：https://ppscrowd-drcn.op.hicloud.com/action-lib-track/publickeys 将body通过密钥进行HMAC-SHA256加密得到签名，替换到Authorization中，并设置“开发者ID”和Authorization到Header中。示例代码如下所示： String data = \"\";\nString url = \"https://ppscrowd-dre.op.dbankcloud.com/action-lib-track/publickeys\";\nString authorization = \"Digest validTime=\\\"{0}\\\", response=\\\"{1}\\\"\";\n// 开发者ID\nString userId = \"YOUR_PUBLISHER_ID\"; \n// 密钥\nString key = \"YOUR_KEY\"; \n\nHttpClient httpclient = HttpClients.createDefault();\nHttpGet request = new HttpGet();\ntry {\n    // 将body通过密钥进行HMAC-SHA256加密得到签名，替换到Authorization中\n    String validTime = String.valueOf(System.currentTimeMillis());\n    String body = validTime + \":/publickeys\";\n    byte[] keyBytes = Base64.decodeBase64(key);\n    byte[] bodyBytes = body.getBytes(Charsets.UTF_8);\n\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    SecretKey secretKey = new SecretKeySpec(keyBytes, \"HmacSHA256\");\n    mac.init(secretKey);\n    byte[] signatureBytes = mac.doFinal(bodyBytes);\n\n    String signature = (signatureBytes == null) ? null : Hex.encodeHexString(signatureBytes);\n    authorization = MessageFormat.format(authorization, validTime, signature);\n    // 设置开发者ID和Authorization到Header中\n    request.setURI(new URI(url));\n    request.setHeader(\"userId\", userId);\n    request.setHeader(\"Authorization\", authorization);\n    HttpResponse response = httpclient.execute(request);\n    data = EntityUtils.toString(response.getEntity());\n} catch (Exception e) {\n    System.out.println(e.getMessage());\n} 返回data消息体（publicKey已匿名化）： {    \n    \"keys\": [       \n        {          \n            \"keyId\":\"12345678\",          \n            \"publicKey\":\"LS0tLS1*******************************************************\"       \n        },      \n        {          \n            \"keyId\": \"22345678\",                               \n            \"publicKey\":\"LS0tLS1*******************************************************\"       \n        }     \n    ]\n} 返回消息结构体： 参数名称  类型  是否必选  描述    keys  List<key>  是  返回公钥列表     key结构体： 参数名称  类型  是否必选  描述    keyId  String  是  密钥ID   publicKey  String  是  公钥     执行验证。a. 根据keyId从公钥列表中找到对应的base64编码后的publicKey。 b. 将paramContentData、publicKey、sign和SHA256withRSA数字签名算法的入参，执行验证。 示例代码如下所示： public static boolean verify(byte[] data, String publicKey, String sign, String signatureAlgorithm) {\n    try {\n        byte[] keyBytes = base64Decode(publicKey);\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        PublicKey publicK = keyFactory.generatePublic(keySpec);\n        Signature signature = Signature.getInstance(signatureAlgorithm);\n        signature.initVerify(publicK);\n        signature.update(data);\n        return signature.verify(base64Decode(sign));\n    } catch (InvalidKeyException | SignatureException | UnsupportedEncodingException | InvalidKeySpecException | NoSuchAlgorithmException e) {\n        return false;\n    }\n}\n\nprivate static byte[] base64Decode(String encoded) throws UnsupportedEncodingException {\n    return Base64.decodeBase64(encoded.getBytes(\"UTF-8\"));\n} 

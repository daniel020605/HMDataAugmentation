推送应用内通话消息
场景介绍
应用内通话消息，支持应用实现网络音视频通话的能力。当终端处于锁屏或解锁两种不同状态时，Push Kit将分别进行以下处理：
 终端处于锁屏状态时，可在锁屏上点击接听或拒绝按钮。锁屏状态下只支持接听语音。 终端处于解锁状态时，网络音视频通话呼叫消息显性展示于横幅，支持用户接听视频或语音。 
接听视频时会拉起应用内的接听界面。接通后，可以正常挂断（主动挂断/被动挂断）应用内通话消息。
应用内通话消息样式可参考如下示例，真实样式请以实际效果为准：
锁屏
来电横幅
 应用内通话消息当前仅支持手机与平板机型。 应用内通话消息的问题场景请参见指导。 应用内通话消息的pushOptions.ttl建议设置为30~60秒。 
开通权益
推送应用内通话消息需要申请场景化消息权益，请参见申请推送应用内通话消息权益。
频控规则
调测阶段，每个项目每日全网最多可推送1000条测试消息。发送测试消息需设置testMessage为true。
正式发布阶段，单设备单应用下每日推送消息总条数受设备消息频控限制，所有场景化消息发送条数不超过3000条。
开发步骤
 参见指导获取Push Token。 在您的工程内创建一个UIAbility类型的组件，如PushMessageAbility.ets（在项目工程的src/main/ets/entryability目录下），负责处理应用内通话消息的主流程，并完成onCreate()、onWindowStageCreate()、onDestroy()方法的覆写，代码示例如下：import { UIAbility } from '@kit.AbilityKit';\nimport { pushService } from '@kit.PushKit';\nimport { window } from '@kit.ArkUI';\nimport { voipCall } from '@kit.CallKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { image } from '@kit.ImageKit';\nimport { resourceManager } from '@kit.LocalizationKit';\nimport { TimeoutUtil } from '../utils/TimeoutUtil';\nimport { VoipCallUtil } from '../utils/VoipCallUtil';\nimport { CalleeUtil } from '../utils/CalleeUtil';\n\n// 定义端侧从云侧下发的消息中解析场景类型的字段，例如：端侧定义scene字段，此时从云侧传递extraData时携带scene字段，可决定是音频呼叫或视频呼叫\ninterface VoipScene {\n  scene: string;\n}\n\ninterface Content {\n  data: string;\n  header: string;\n  callId: string;\n}\nexport default class PushMessageAbility extends UIAbility {\n  onCreate(): void {\n    try {\n      pushService.receiveMessage('VoIP', this, (data) => {\n        // process message，并建议对Callback进行try-catch\n        try {\n          hilog.info(0x0000, 'testTag', ` VOIP get message:${JSON.stringify(data)}`);\n          this.processVoIPMainMsg(data.data);\n        } catch (error) {\n          hilog.error(0x0000, 'testTag', 'Failed to process data: %{public}d %{public}s', error.code, error.message);\n        }\n      });\n      hilog.info(0x0000, 'testTag', 'Succeeded in registering VoIP.');\n    } catch (e) {\n      hilog.info(0x0000, 'testTag', `Failed to register VOIP, error: ${e.code}, ${e.message}.`);\n    }\n  }\n  private async processVoIPMainMsg(data: string): Promise<void> {\n    hilog.info(0x0000, 'testTag', 'processVoIPMainMsg');\n    let content: Content = JSON.parse(data);\n    let scene: VoipScene = JSON.parse(content.data);\n    let callId: string = content.callId;\n    hilog.info(0x0000, 'testTag', `callId: ${callId}.`);\n    hilog.info(0x0000, 'testTag', `scene: ${scene}.`);\n    if (callId) {\n      AppStorage.setOrCreate('close', false);\n      voipCall.on('voipCallUiEvent', async (event) => {\n        hilog.info(0x0000, 'testTag', `DemoPushMessageAbility voipCallUiEvent: ${JSON.stringify(event)}.`);\n        TimeoutUtil.stop();\n        switch (event.voipCallUiEvent) {\n          case voipCall.VoipCallUiEvent.VOIP_CALL_EVENT_VOICE_ANSWER:\n          case voipCall.VoipCallUiEvent.VOIP_CALL_EVENT_VIDEO_ANSWER:\n            VoipCallUtil.reportCallStateChange(voipCall.VoipCallState.VOIP_CALL_STATE_ACTIVE);\n            AppStorage.setOrCreate('answered', true);\n            break;\n          case voipCall.VoipCallUiEvent.VOIP_CALL_EVENT_REJECT:\n          case voipCall.VoipCallUiEvent.VOIP_CALL_EVENT_HANGUP:\n            CalleeUtil.close();\n            break;\n          default: {\n            break;\n          }\n        }\n      })\n      const resourceMgr : resourceManager.ResourceManager = this.context.resourceManager;\n      // example.png表示用户头像，取值为“/resources/rawfile”路径下的文件名\n      const fileData : Uint8Array = await resourceMgr.getRawFileContent('example.png');\n      const buffer = fileData.buffer;\n      const imageSource : image.ImageSource = image.createImageSource(buffer);\n      const pixelMap : image.PixelMap = await imageSource.createPixelMap();\n      if (pixelMap) {\n        pixelMap.getImageInfo((err, imageInfo) => {\n          if (imageInfo) {\n            hilog.info(0x0000, 'testTag', `DemoPushMessageAbility imageInfo: ${imageInfo.size.width} * ${imageInfo.size.height}.`);\n          }\n        });\n      }\n      // 定义应用内通话时传入的数据。注意，voipCallType.scene为您自定义的场景类型字段，从云侧推送消息时，请注意与端侧取值保持一致\n      let call: voipCall.VoipCallAttribute = {\n        callId: callId,\n        voipCallType: scene?.scene === 'video' ? voipCall.VoipCallType.VOIP_CALL_VIDEO : voipCall.VoipCallType.VOIP_CALL_VOICE,\n        userName: 'push',\n        userProfile: pixelMap,\n        abilityName: 'PushMessageAbility',\n        voipCallState: voipCall.VoipCallState.VOIP_CALL_STATE_RINGING\n      };\n      try {\n        let error = await voipCall.reportIncomingCall(call);\n        if (error) {\n          hilog.info(0x0000, 'testTag', ` PushMessageAbility reportIncomingCall result: ${error}.`);\n          let err: voipCall.ErrorReason = error as voipCall.ErrorReason;\n          if (err !== voipCall.ErrorReason.ERROR_NONE) {\n            hilog.info(0x0000, 'testTag', `PushMessageAbility reportIncomingCall failed: ${error}.`);\n            return;\n          }\n        }\n        VoipCallUtil.init(callId);\n      } catch (e) {\n        hilog.info(0x0000, 'testTag', ` PushMessageAbility reportIncomingCall exception: ${e}.`);\n      }\n    }\n    hilog.info(0x0000, 'testTag', `processVoIPMainMsg end.`);\n  }\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    hilog.info(0x0000, 'testTag', `PushMessageAbility onWindowStageCreate.`);\n    windowStage.loadContent('pages/CalleePage');\n  }\n  onDestroy(): void {\n    hilog.info(0x0000, 'testTag', 'PushMessageAbility onDestroy.');\n  }\n} CalleeUtil.ets（在项目工程的src/main/ets/utils目录下），处理应用内通话挂断，代码示例如下： import { router } from '@kit.ArkUI';\nimport { voipCall } from '@kit.CallKit';\nimport { VoipCallUtil } from './VoipCallUtil';\nimport { TimeoutUtil } from './TimeoutUtil';\n\nexport class CalleeUtil {\n  static close(needBack = false): void {\n    if (needBack) {\n      router.back();\n    }\n    TimeoutUtil.stop();\n    VoipCallUtil.reportCallStateChange(voipCall.VoipCallState.VOIP_CALL_STATE_DISCONNECTED);\n    voipCall.off('voipCallUiEvent');\n  }\n} TimeoutUtil.ets（在项目工程的src/main/ets/utils目录下），处理应用内通话连接超时，代码示例如下： import { CalleeUtil } from './CalleeUtil';\n\nexport class TimeoutUtil {\n  static timeout: number | undefined;\n\n  static start(): void {\n    // 如果30秒内没有接听或挂断，连接将会超时\n    TimeoutUtil.timeout = setTimeout(() => {\n      CalleeUtil.close();\n    }, 30_000);\n  }\n\n  static stop(): void {\n    if (TimeoutUtil.timeout !== undefined) {\n      clearTimeout(TimeoutUtil.timeout);\n      TimeoutUtil.timeout = undefined;\n    }\n  }\n} VoipCallUtil.ets（在项目工程的src/main/ets/utils目录下），处理应用内通话状态变更，代码示例如下： import { voipCall } from '@kit.CallKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\n\nexport class VoipCallUtil {\n  static callId: string | undefined;\n\n  static init(callId: string) {\n    VoipCallUtil.callId = callId;\n  }\n\n  static async reportCallStateChange(callState: voipCall.VoipCallState): Promise<void> {\n    if (VoipCallUtil.callId) {\n      await voipCall.reportCallStateChange(VoipCallUtil.callId, callState);\n      if (callState === voipCall.VoipCallState.VOIP_CALL_STATE_DISCONNECTED) {\n        hilog.info(0x0000, 'testTag', 'Call end, reset callId');\n        VoipCallUtil.callId = undefined;\n      }\n    } else {\n      hilog.info(0x0000, 'testTag', 'CallId is undefined');\n    }\n  }\n}     需要在项目工程的src/main/resources/rawfile目录下添加example.png，表示来电时的用户头像。    在receiveMessage()回调中接收应用内通话消息，应用提前和服务器建连，并调用voipCall.on()接口注册监听通话状态回调。用户点击接听或者拒绝接听之后，系统会通过应用注册的事件监听通话状态回调结果。 应用需要在10秒内调用voipCall.reportIncomingCall()接口上报通话来电状态，调用完成之后，系统会弹出应用内通话横幅通知。 应用内通话有三种回调状态，分别为：接听状态、拒绝状态和挂断状态。          在接听状态回调中，应用在建立连接成功之后，需要调用voipCall.reportCallStateChange()接口上报通话激活状态。 在拒绝接听状态回调中，应用断开和服务器的连接之后，需要调用voipCall.reportCallStateChange()接口上报通话拒绝状态。 在应用进行应用内通话的同时，若运营商来电，会弹出运营商来电接听界面，用户点击接听运营商来电之后，会回调应用内通话挂断状态，在回调方法中应用需要自行断开和服务器的连接，并调用voipCall.reportCallStateChange()接口上报通话断开状态。  有关应用内通话回调状态的更多信息，详情请参见Call Kit简介。   在项目工程的 src/main/ets/pages目录添加：视频接听页面CalleePage.ets，代码示例如下：import CallComponent from '../component/CallComponent';\nimport { router } from '@kit.ArkUI';\nimport { CalleeUtil } from '../utils/CalleeUtil';\n \n@Entry\n@Component\nstruct CalleePage {\n  @StorageLink('close') @Watch('close') end: boolean | undefined = undefined;\n  interval: number = 0;\n\n  aboutToAppear() {\n    this.end = false;\n  }\n \n  private close() {\n    CalleeUtil.close(true);\n    router.back(); // 此处仅为示例（跳转返回），请根据实际情况设定路由\n  }\n \n  aboutToDisappear() {\n    clearInterval(this.interval);\n  }\n \n  build() {\n    Column() {\n      CallComponent({})\n    }\n  }\n} CallComponent.ets（在项目工程的src/main/ets/component目录下），代码示例如下： @Component\nexport default struct CallComponent {\n  @StorageLink('close') end: boolean | undefined = undefined;\n \n  build() {\n    Flex({ direction: FlexDirection.Column, justifyContent: FlexAlign.SpaceBetween }) {\n      Row() {\n      }\n      .width('100%')\n      .justifyContent(FlexAlign.Center)\n \n      Row({ space: 30 }) {\n        Column() {\n          Button()\n            .width(80)\n            .height(80)\n            .backgroundColor(Color.Red)\n            .onClick(() => {\n              this.end = true;\n            })\n \n          Text('Hang Up').fontColor(Color.White).padding({ top: 5 })\n        }\n      }\n      .width('100%')\n      .justifyContent(FlexAlign.Center)\n    }\n    .padding('30 10')\n    .backgroundColor(Color.Black)\n  }\n} 在项目工程的 src/main/resources/base/profile/main_pages.json添加page目录，示例如下： {\n  \"src\": [\n    \"pages/Index\",\n    \"pages/CalleePage\"\n  ]\n}     示例代码提供的页面效果仅供开发参考，不代表最终效果。    在项目工程的 src/main/module.json5 文件的 abilities 模块中配置PushMessageAbility的actions信息。\"abilities\": [ \n  { \n    \"name\": \"PushMessageAbility\", \n    \"srcEntry\": \"./ets/entryability/PushMessageAbility.ets\", \n    \"launchType\": \"singleton\",\n    \"description\": \"PushMessageAbility test\", \n    \"startWindowIcon\": \"$media:startIcon\",\n    \"startWindowBackground\": \"$color:start_window_background\",\n    \"exported\": false, \n    \"skills\": [ \n      { \n        \"actions\": [\"action.ohos.push.listener\"]\n      }\n    ]\n  } \n]  actions：内容为action.ohos.push.listener，有且只能有一个ability定义该action，若同时添加uris参数，则uris内容需为空。   应用服务端调用REST API推送应用内通话消息，消息详情可参见场景化消息API接口功能介绍，请求示例如下：// Request URL  \nPOST https://push-api.cloud.huawei.com/v3/[projectId]/messages:send\n  \n// Request Header  \nContent-Type: application/json  \nAuthorization: Bearer eyJr*****OiIx---****.eyJh*****iJodHR--***.QRod*****4Gp---****  \npush-type: 10\n  \n{  \n  \"pushOptions\": {\n    \"ttl\": 30\n  },\n  \"payload\": {  \n    \"extraData\": \"{\\\"scene\\\": \\\"voice\\\"}\"\n  },  \n  \"target\": {  \n    \"token\": [\"IQAAAACy0tEjCgBijrEB3************8o0m5EdTXbdlhiIiX_vNGQ5Ic5rXWmw\"]  \n  }\n}  [projectId]：项目ID，登录AppGallery Connect网站，选择“我的项目”，在项目列表中选择对应的项目，左侧导航栏选择“项目设置”，在该页面获取。 Authorization：JWT格式字符串，可参见Authorization获取。 push-type：10表示应用内通话消息场景。 token：Push Token，可参见获取Push Token获取。 extraData：携带的额外数据，字符串类型。详情参见extraData。 ttl：消息缓存时间，建议设置为30~60秒，详见pushOptions.ttl。   发送应用内通话消息后将拉起应用的进程，在进程内完成您的通话状态上报，监听通话状态回调，被叫页面加载等操作。铃声、震动、音视频效果等需要开发者自行适配完成。     进行音视频通话时，若您的应用处于Overhead场景（设备发热严重或负载较重，Level=4），请降低码率和帧率，或关闭视频流降级为音频。相关说明请参见Basic Services Kit（基础服务）提供的接口getLevel()。    

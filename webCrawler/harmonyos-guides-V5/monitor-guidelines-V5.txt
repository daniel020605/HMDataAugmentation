事件监听开发指导（C/C++）
功能介绍
多模提供为应用提供了按键、输入事件（鼠标、触屏和轴事件）监听能力，当前仅支持录屏类应用。使用场景例如：用户在录屏应用开启录屏时，需要监听设备的按键、鼠标、触摸和轴事件。
接口说明
创建和删除事件监听相关接口如下表所示，接口详细介绍请参考Input文档。
开发步骤
[h2]链接动态库
调用创建和删除事件拦截前，需链接相关动态库。链接动态库的方法是，在CMakeList.txt文件中做下面例子所示的配置：
   target_link_libraries(entry PUBLIC libohinput.so)
[h2]申请所需权限
应用需要在module.json5中添加下面权限的配置，详细的配置方法参考声明声明权限文档。
\"requestPermissions\": [\n    {\n        \"name\": \"ohos.permission.INTERCEPT_INPUT_EVENT\"\n    }\n]
[h2]创建事件监听
按键事件
#include \"multimodalinput/oh_input_manager.h\"\n\nstruct KeyEvent {\n    int32_t action;\n    int32_t keyCode;\n    int64_t actionTime { -1 };\n};\n\n//定义按键事件回调函数\nvoid OnKeyEventCallback(const Input_KeyEvent* keyEvent)\n{\n    KeyEvent event;\n    //Input_KeyEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    event.action = OH_Input_GetKeyEventAction(keyEvent);\n    event.keyCode = OH_Input_GetKeyEventKeyCode(keyEvent);\n    event.actionTime = OH_Input_GetKeyEventActionTime(keyEvent);\n}\n\nvoid TestMonitor()\n{\n    //添加按键事件监听\n    Input_Result ret = OH_Input_AddKeyEventMonitor(OnKeyEventCallback);\n    //移除按键事件监听\n    ret = OH_Input_RemoveKeyEventMonitor(OnKeyEventCallback);\n}
鼠标事件
#include \"multimodalinput/oh_input_manager.h\"\n\nstruct MouseEvent {\n    int32_t action;\n    int32_t displayX;\n    int32_t displayY;\n    int32_t button { -1 };\n    int32_t axisType { -1 };\n    float axisValue { 0.0f };\n    int64_t actionTime { -1 };\n};\n\n//定义鼠标事件回调函数\nvoid OnMouseEventCallback(const Input_MouseEvent* mouseEvent)\n{\n    MouseEvent event;\n    //Input_MouseEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    event.action = OH_Input_GetMouseEventAction(mouseEvent);\n    event.displayX = OH_Input_GetMouseEventDisplayX(mouseEvent);\n    event.displayY = OH_Input_GetMouseEventDisplayY(mouseEvent);\n    event.button = OH_Input_GetMouseEventButton(mouseEvent);\n    event.axisType = OH_Input_GetMouseEventAxisType(mouseEvent);\n    event.axisValue = OH_Input_GetMouseEventAxisValue(mouseEvent);\n    event.actionTime = OH_Input_GetMouseEventActionTime(mouseEvent);\n}\n\nvoid TestMonitor()\n{\n    //添加鼠标事件监听\n    Input_Result ret = OH_Input_AddMouseEventMonitor(OnMouseEventCallback);\n    //移除鼠标事件监听\n    ret = OH_Input_RemoveMouseEventMonitor(OnMouseEventCallback);\n}
触摸事件
#include \"multimodalinput/oh_input_manager.h\"\n\nstruct TouchEvent {\n    int32_t action;\n    int32_t id;\n    int32_t displayX;\n    int32_t displayY;\n    int64_t actionTime { -1 };\n};\n\n//定义触摸事件回调函数\nvoid OnTouchEventCallback(const Input_TouchEvent* touchEvent)\n{\n    TouchEvent event;\n    //Input_TouchEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    event.action = OH_Input_GetTouchEventAction(touchEvent);\n    event.id = OH_Input_GetTouchEventFingerId(touchEvent);\n    event.displayX = OH_Input_GetTouchEventDisplayX(touchEvent);\n    event.displayY = OH_Input_GetTouchEventDisplayY(touchEvent);\n    event.actionTime = OH_Input_GetTouchEventActionTime(touchEvent);\n}\n\nvoid TestMonitor()\n{\n    //添加触摸事件监听\n    Input_Result ret = OH_Input_AddTouchEventMonitor(OnTouchEventCallback);\n    //移除触摸事件监听\n    ret = OH_Input_RemoveTouchEventMonitor(OnTouchEventCallback);\n}
轴事件
#include \"multimodalinput/oh_input_manager.h\"\n#include <map>\n\nstruct AxisEvent {\n    int32_t axisAction;\n    float displayX;\n    float displayY;\n    std::map<int32_t, double> axisValues;\n    int64_t actionTime { -1 };\n    int32_t sourceType;\n    int32_t axisEventType { -1 };\n};\n\n//定义所有类型轴事件回调函数\nvoid OnAllAxisEventCallback(const Input_AxisEvent* axisEvent)\n{\n    AxisEvent event;\n    \n    //Input_AxisEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    InputEvent_AxisAction action;\n    Input_Result ret = OH_Input_GetAxisEventAction(axisEvent, &action);\n    event.axisAction = action;\n    ret = OH_Input_GetAxisEventDisplayX(axisEvent, &event.displayX);\n    ret = OH_Input_GetAxisEventDisplayY(axisEvent, &event.displayY);\n    ret = OH_Input_GetAxisEventActionTime(axisEvent, &event.actionTime);\n    InputEvent_SourceType sourceType;\n    ret = OH_Input_GetAxisEventSourceType(axisEvent, &sourceType);\n    event.sourceType = sourceType;\n    InputEvent_AxisEventType axisEventType;\n    ret = OH_Input_GetAxisEventType(axisEvent, &axisEventType);\n    event.axisEventType = axisEventType;\n    if (event.axisEventType == AXIS_EVENT_TYPE_PINCH) {\n        double value = 0;\n        ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_PINCH, &value);\n        event.axisValues.insert(std::make_pair(AXIS_TYPE_PINCH, value));\n        ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_ROTATE, &value);\n        event.axisValues.insert(std::make_pair(AXIS_TYPE_ROTATE, value));\n    } else if (event.axisEventType == AXIS_EVENT_TYPE_SCROLL) {\n        double value = 0;\n        ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_SCROLL_VERTICAL, &value);\n        event.axisValues.insert(std::make_pair(AXIS_TYPE_SCROLL_VERTICAL, value));\n        ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_SCROLL_HORIZONTAL, &value);\n        event.axisValues.insert(std::make_pair(AXIS_TYPE_SCROLL_HORIZONTAL, value));\n    }\n}\n\n//定义捏合类型轴事件回调函数\nvoid OnPinchAxisEventCallback(const Input_AxisEvent* axisEvent)\n{\n    AxisEvent event;\n    \n    //Input_AxisEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    InputEvent_AxisAction action;\n    Input_Result ret = OH_Input_GetAxisEventAction(axisEvent, &action);\n    event.axisAction = action;\n    ret = OH_Input_GetAxisEventDisplayX(axisEvent, &event.displayX);\n    ret = OH_Input_GetAxisEventDisplayY(axisEvent, &event.displayY);\n    ret = OH_Input_GetAxisEventActionTime(axisEvent, &event.actionTime);\n    InputEvent_SourceType sourceType;\n    ret = OH_Input_GetAxisEventSourceType(axisEvent, &sourceType);\n    event.sourceType = sourceType;\n    InputEvent_AxisEventType axisEventType;\n    ret = OH_Input_GetAxisEventType(axisEvent, &axisEventType);\n    event.axisEventType = axisEventType;\n    double value = 0;\n    ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_PINCH, &value);\n    event.axisValues.insert(std::make_pair(AXIS_TYPE_PINCH, value));\n    ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_ROTATE, &value);\n    event.axisValues.insert(std::make_pair(AXIS_TYPE_ROTATE, value));\n}\n\n//定义滚轮类型轴事件回调函数\nvoid OnScrollAxisEventCallback(const Input_AxisEvent* axisEvent)\n{\n    AxisEvent event;\n    \n    //Input_AxisEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    InputEvent_AxisAction action;\n    Input_Result ret = OH_Input_GetAxisEventAction(axisEvent, &action);\n    event.axisAction = action;\n    ret = OH_Input_GetAxisEventDisplayX(axisEvent, &event.displayX);\n    ret = OH_Input_GetAxisEventDisplayY(axisEvent, &event.displayY);\n    ret = OH_Input_GetAxisEventActionTime(axisEvent, &event.actionTime);\n    InputEvent_SourceType sourceType;\n    ret = OH_Input_GetAxisEventSourceType(axisEvent, &sourceType);\n    event.sourceType = sourceType;\n    InputEvent_AxisEventType axisEventType;\n    ret = OH_Input_GetAxisEventType(axisEvent, &axisEventType);\n    event.axisEventType = axisEventType;\n    double value = 0;\n    ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_SCROLL_VERTICAL, &value);\n    event.axisValues.insert(std::make_pair(AXIS_TYPE_SCROLL_VERTICAL, value));\n    ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_SCROLL_HORIZONTAL, &value);\n    event.axisValues.insert(std::make_pair(AXIS_TYPE_SCROLL_HORIZONTAL, value));\n}\n\nvoid TestMonitor()\n{\n    //添加所有类型轴事件监听\n    Input_Result ret = OH_Input_AddAxisEventMonitorForAll(OnAllAxisEventCallback);\n    //移除所有类型轴事件监听\n    ret = OH_Input_RemoveAxisEventMonitorForAll(OnAllAxisEventCallback);\n\n    //添加捏合类型轴事件监听\n    ret = OH_Input_AddAxisEventMonitor(AXIS_EVENT_TYPE_PINCH, OnPinchAxisEventCallback);\n    //移除捏合类型轴事件监听\n    ret = OH_Input_RemoveAxisEventMonitor(AXIS_EVENT_TYPE_PINCH, OnPinchAxisEventCallback);\n\n    //添加滚轮类型轴事件监听\n    ret = OH_Input_AddAxisEventMonitor(AXIS_EVENT_TYPE_SCROLL, OnScrollAxisEventCallback);\n    //移除滚轮类型轴事件监听\n    ret = OH_Input_RemoveAxisEventMonitor(AXIS_EVENT_TYPE_SCROLL, OnScrollAxisEventCallback);\n}

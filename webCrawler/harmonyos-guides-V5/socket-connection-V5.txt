Socket 连接
简介
Socket 连接主要是通过 Socket 进行数据传输，支持 TCP/UDP/Multicast/TLS 协议。
应用退后台又切回前台后，需要对网络通信做失败重试，通信失败后匹配错误码并重新创建新的TCP/UDP连接对象。
基本概念
 Socket：套接字，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。 TCP：传输控制协议(Transmission Control Protocol)。是一种面向连接的、可靠的、基于字节流的传输层通信协议。 UDP：用户数据报协议(User Datagram Protocol)。是一个简单的面向消息的传输层，不需要连接。 Multicast：多播，基于UDP的一种通信模式，用于实现组内所有设备之间广播形式的通信。 LocalSocket：本地套接字，IPC(Inter-Process Communication)进程间通信的一种，实现设备内进程之间相互通信，无需网络。 TLS：安全传输层协议(Transport Layer Security)。用于在两个通信应用程序之间提供保密性和数据完整性。 
场景介绍
应用通过 Socket 进行数据传输，支持 TCP/UDP/Multicast/TLS 协议。主要场景有：
 应用通过 TCP/UDP Socket进行数据传输 应用通过 TCP Socket Server 进行数据传输 应用通过 Multicast Socket 进行数据传输 应用通过 Local Socket进行数据传输 应用通过 Local Socket Server 进行数据传输 应用通过 TLS Socket 进行加密数据传输 应用通过 TLS Socket Server 进行加密数据传输 
接口说明
完整的 API 说明以及实例代码请参考：Socket 连接。
Socket 连接主要由 socket 模块提供。具体接口说明如下表。
TLS Socket 连接主要由 tls_socket 模块提供。具体接口说明如下表。
应用 TCP/UDP 协议进行通信
UDP 与 TCP 流程大体类似，下面以 TCP 为例：
 import 需要的 socket 模块。 创建一个 TCPSocket 连接，返回一个 TCPSocket 对象。 （可选）订阅 TCPSocket 相关的订阅事件。 绑定 IP 地址和端口，端口可以指定或由系统随机分配。 连接到指定的 IP 地址和端口。 发送数据。 Socket 连接使用完毕后，主动关闭。 
import { socket } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nclass SocketInfo {\n  message: ArrayBuffer = new ArrayBuffer(1);\n  remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;\n}\n// 创建一个TCPSocket连接，返回一个TCPSocket对象。\nlet tcp: socket.TCPSocket = socket.constructTCPSocketInstance();\ntcp.on('message', (value: SocketInfo) => {\n  console.log(\"on message\");\n  let buffer = value.message;\n  let dataView = new DataView(buffer);\n  let str = \"\";\n  for (let i = 0; i < dataView.byteLength; ++i) {\n    str += String.fromCharCode(dataView.getUint8(i));\n  }\n  console.log(\"on connect received:\" + str);\n});\ntcp.on('connect', () => {\n  console.log(\"on connect\");\n});\ntcp.on('close', () => {\n  console.log(\"on close\");\n});\n\n// 绑定本地IP地址和端口。\nlet ipAddress : socket.NetAddress = {} as socket.NetAddress;\nipAddress.address = \"192.168.xxx.xxx\";\nipAddress.port = 1234;\ntcp.bind(ipAddress, (err: BusinessError) => {\n  if (err) {\n    console.log('bind fail');\n    return;\n  }\n  console.log('bind success');\n\n  // 连接到指定的IP地址和端口。\n  ipAddress.address = \"192.168.xxx.xxx\";\n  ipAddress.port = 5678;\n\n  let tcpConnect : socket.TCPConnectOptions = {} as socket.TCPConnectOptions;\n  tcpConnect.address = ipAddress;\n  tcpConnect.timeout = 6000;\n\n  tcp.connect(tcpConnect).then(() => {\n    console.log('connect success');\n    let tcpSendOptions: socket.TCPSendOptions = {\n      data: 'Hello, server!'\n    }\n    tcp.send(tcpSendOptions).then(() => {\n      console.log('send success');\n    }).catch((err: BusinessError) => {\n      console.log('send fail');\n    });\n  }).catch((err: BusinessError) => {\n    console.log('connect fail');\n  });\n});\n\n// 连接使用完毕后，主动关闭。取消相关事件的订阅。\nsetTimeout(() => {\n  tcp.close().then(() => {\n    console.log('close success');\n  }).catch((err: BusinessError) => {\n    console.log('close fail');\n  });\n  tcp.off('message');\n  tcp.off('connect');\n  tcp.off('close');\n}, 30 * 1000);
应用通过 TCP Socket Server 进行数据传输
服务端 TCP Socket 流程：
 import 需要的 socket 模块。 创建一个 TCPSocketServer 连接，返回一个 TCPSocketServer 对象。 绑定本地 IP 地址和端口，监听并接受与此套接字建立的客户端 TCPSocket 连接。 订阅 TCPSocketServer 的 connect 事件，用于监听客户端的连接状态。 客户端与服务端建立连接后，返回一个 TCPSocketConnection 对象，用于与客户端通信。 订阅 TCPSocketConnection 相关的事件，通过 TCPSocketConnection 向客户端发送数据。 主动关闭与客户端的连接。 取消 TCPSocketConnection 和 TCPSocketServer 相关事件的订阅。 
import { socket } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n// 创建一个TCPSocketServer连接，返回一个TCPSocketServer对象。\nlet tcpServer: socket.TCPSocketServer = socket.constructTCPSocketServerInstance();\n// 绑定本地IP地址和端口，进行监听\n\nlet ipAddress : socket.NetAddress = {} as socket.NetAddress;\nipAddress.address = \"192.168.xxx.xxx\";\nipAddress.port = 4651;\ntcpServer.listen(ipAddress).then(() => {\n  console.log('listen success');\n}).catch((err: BusinessError) => {\n  console.log('listen fail');\n});\n\nclass SocketInfo {\n  message: ArrayBuffer = new ArrayBuffer(1);\n  remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;\n}\n// 订阅TCPSocketServer的connect事件\ntcpServer.on(\"connect\", (client: socket.TCPSocketConnection) => {\n  // 订阅TCPSocketConnection相关的事件\n  client.on(\"close\", () => {\n    console.log(\"on close success\");\n  });\n  client.on(\"message\", (value: SocketInfo) => {\n    let buffer = value.message;\n    let dataView = new DataView(buffer);\n    let str = \"\";\n    for (let i = 0; i < dataView.byteLength; ++i) {\n      str += String.fromCharCode(dataView.getUint8(i));\n    }\n    console.log(\"received message--:\" + str);\n    console.log(\"received address--:\" + value.remoteInfo.address);\n    console.log(\"received family--:\" + value.remoteInfo.family);\n    console.log(\"received port--:\" + value.remoteInfo.port);\n    console.log(\"received size--:\" + value.remoteInfo.size);\n  });\n\n  // 向客户端发送数据\n  let tcpSendOptions : socket.TCPSendOptions = {} as socket.TCPSendOptions;\n  tcpSendOptions.data = 'Hello, client!';\n  client.send(tcpSendOptions).then(() => {\n    console.log('send success');\n  }).catch((err: Object) => {\n    console.error('send fail: ' + JSON.stringify(err));\n  });\n\n  // 关闭与客户端的连接\n  client.close().then(() => {\n    console.log('close success');\n  }).catch((err: BusinessError) => {\n    console.log('close fail');\n  });\n\n  // 取消TCPSocketConnection相关的事件订阅\n  setTimeout(() => {\n    client.off(\"message\");\n    client.off(\"close\");\n  }, 10 * 1000);\n});\n\n// 取消TCPSocketServer相关的事件订阅\nsetTimeout(() => {\n  tcpServer.off(\"connect\");\n}, 30 * 1000);
应用通过 Multicast Socket 进行数据传输
 import 需要的 socket 模块。 创建 multicastSocket 多播对象。 指定多播 IP 与端口，加入多播组。 开启消息 message 监听。 发送数据，数据以广播的形式传输，同一多播组中已经开启消息 message 监听的多播对象都会接收到数据。 关闭 message 消息的监听。 退出多播组。 
import { socket } from '@kit.NetworkKit';\n\n// 创建Multicast对象\nlet multicast: socket.MulticastSocket = socket.constructMulticastSocketInstance();\n\nlet addr : socket.NetAddress = {\n  address: '239.255.0.1',\n  port: 32123,\n  family: 1\n}\n\n// 加入多播组\nmulticast.addMembership(addr).then(() => {\n  console.log('addMembership success');\n}).catch((err: Object) => {\n  console.log('addMembership fail');\n});\n\n// 开启监听消息数据，将接收到的ArrayBuffer类型数据转换为String\nclass SocketInfo {\n  message: ArrayBuffer = new ArrayBuffer(1);\n  remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;\n}\nmulticast.on('message', (data: SocketInfo) => {\n  console.info('接收的数据: ' + JSON.stringify(data))\n  const uintArray = new Uint8Array(data.message)\n  let str = ''\n  for (let i = 0; i < uintArray.length; ++i) {\n    str += String.fromCharCode(uintArray[i])\n  }\n  console.info(str)\n})\n\n// 发送数据\nmulticast.send({ data:'Hello12345', address: addr }).then(() => {\n  console.log('send success');\n}).catch((err: Object) => {\n  console.log('send fail, ' + JSON.stringify(err));\n});\n\n// 关闭消息的监听\nmulticast.off('message')\n\n// 退出多播组\nmulticast.dropMembership(addr).then(() => {\n  console.log('drop membership success');\n}).catch((err: Object) => {\n  console.log('drop membership fail');\n});
应用通过 LocalSocket 进行数据传输
 import 需要的 socket 模块。 使用 constructLocalSocketInstance 接口，创建一个 LocalSocket 客户端对象。 注册 LocalSocket 的消息(message)事件，以及一些其它事件(可选)。 连接到指定的本地套接字文件路径。 发送数据。 Socket 连接使用完毕后，取消事件的注册，并关闭套接字。 
import { socket } from '@kit.NetworkKit';\n\n// 创建一个LocalSocket连接，返回一个LocalSocket对象。\nlet client: socket.LocalSocket = socket.constructLocalSocketInstance();\nclient.on('message', (value: socket.LocalSocketMessageInfo) => {\n  const uintArray = new Uint8Array(value.message)\n  let messageView = '';\n  for (let i = 0; i < uintArray.length; i++) {\n    messageView += String.fromCharCode(uintArray[i]);\n  }\n  console.log('total receive: ' + JSON.stringify(value));\n  console.log('message information: ' + messageView);\n});\nclient.on('connect', () => {\n  console.log(\"on connect\");\n});\nclient.on('close', () => {\n  console.log(\"on close\");\n});\n\n// 传入指定的本地套接字路径，连接服务端。\nlet sandboxPath: string = getContext(this).filesDir + '/testSocket'\nlet localAddress : socket.LocalAddress = {\n  address: sandboxPath\n}\nlet connectOpt: socket.LocalConnectOptions = {\n  address: localAddress,\n  timeout: 6000\n}\nlet sendOpt: socket.LocalSendOptions = {\n  data: 'Hello world!'\n}\nclient.connect(connectOpt).then(() => {\n  console.log('connect success')\n  client.send(sendOpt).then(() => {\n  console.log('send success')\n  }).catch((err: Object) => {\n    console.log('send failed: ' + JSON.stringify(err))\n  })\n}).catch((err: Object) => {\n  console.log('connect fail: ' + JSON.stringify(err));\n});\n\n// 当不需要再连接服务端，需要断开且取消事件的监听时\nclient.off('message');\nclient.off('connect');\nclient.off('close');\nclient.close().then(() => {\n  console.log('close client success')\n}).catch((err: Object) => {\n  console.log('close client err: ' + JSON.stringify(err))\n})
应用通过 Local Socket Server 进行数据传输
服务端 LocalSocket Server 流程：
 import 需要的 socket 模块。 使用 constructLocalSocketServerInstance 接口，创建一个 LocalSocketServer 服务端对象。 启动服务，绑定本地套接字路径，创建出本地套接字文件，监听客户端的连接请求。 注册 LocalSocket 的客户端连接(connect)事件，以及一些其它事件(可选)。 在客户端连接上来时，通过连接事件的回调函数，获取连接会话对象。 给会话对象 LocalSocketConnection 注册消息(message)事件，以及一些其它事件(可选)。 通过会话对象主动向客户端发送消息。 结束与客户端的通信，主动断开与客户端的连接。 取消 LocalSocketConnection 和 LocalSocketServer 相关事件的订阅。 
import { socket } from '@kit.NetworkKit';\n\n// 创建一个LocalSocketServer连接，返回一个LocalSocketServer对象。\nlet server: socket.LocalSocketServer = socket.constructLocalSocketServerInstance();\n// 创建并绑定本地套接字文件testSocket，进行监听\nlet sandboxPath: string = getContext(this).filesDir + '/testSocket'\nlet listenAddr: socket.LocalAddress = {\n  address: sandboxPath\n}\nserver.listen(listenAddr).then(() => {\n  console.log(\"listen success\");\n}).catch((err: Object) => {\n  console.log(\"listen fail: \" + JSON.stringify(err));\n});\n\n// 订阅LocalSocketServer的connect事件\nserver.on('connect', (connection: socket.LocalSocketConnection) => {\n  // 订阅LocalSocketConnection相关的事件\n  connection.on('error', (err: Object) => {\n    console.log(\"on error success\");\n  });\n  connection.on('message', (value: socket.LocalSocketMessageInfo) => {\n    const uintArray = new Uint8Array(value.message);\n    let messageView = '';\n    for (let i = 0; i < uintArray.length; i++) {\n      messageView += String.fromCharCode(uintArray[i]);\n    }\n    console.log('total: ' + JSON.stringify(value));\n    console.log('message information: ' + messageView);\n  });\n\n  connection.on('error', (err: Object) => {\n    console.log(\"err:\" + JSON.stringify(err));\n  })\n\n  // 向客户端发送数据\n  let sendOpt : socket.LocalSendOptions = {\n    data: 'Hello world!'\n  };\n  connection.send(sendOpt).then(() => {\n    console.log('send success');\n  }).catch((err: Object) => {\n    console.log('send failed: ' + JSON.stringify(err));\n  })\n\n  // 关闭与客户端的连接\n  connection.close().then(() => {\n    console.log('close success');\n  }).catch((err: Object) => {\n    console.log('close failed: ' + JSON.stringify(err));\n  });\n\n  // 取消LocalSocketConnection相关的事件订阅\n  connection.off('message');\n  connection.off('error');\n});\n\n// 取消LocalSocketServer相关的事件订阅\nserver.off('connect');\nserver.off('error');
应用通过 TLS Socket 进行加密数据传输
客户端 TLS Socket 流程：
 import 需要的 socket 模块。 绑定服务器 IP 和端口号。 双向认证上传客户端 CA 证书及数字证书；单向认证上传客户端 CA 证书。 创建一个 TLSSocket 连接，返回一个 TLSSocket 对象。 （可选）订阅 TLSSocket 相关的订阅事件。 发送数据。 TLSSocket 连接使用完毕后，主动关闭。 
import { socket } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nclass SocketInfo {\n  message: ArrayBuffer = new ArrayBuffer(1);\n  remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;\n}\n// 创建一个（双向认证）TLS Socket连接，返回一个TLS Socket对象。\nlet tlsTwoWay: socket.TLSSocket = socket.constructTLSSocketInstance();\n// 订阅TLS Socket相关的订阅事件\ntlsTwoWay.on('message', (value: SocketInfo) => {\n  console.log(\"on message\");\n  let buffer = value.message;\n  let dataView = new DataView(buffer);\n  let str = \"\";\n  for (let i = 0; i < dataView.byteLength; ++i) {\n    str += String.fromCharCode(dataView.getUint8(i));\n  }\n  console.log(\"on connect received:\" + str);\n});\ntlsTwoWay.on('connect', () => {\n  console.log(\"on connect\");\n});\ntlsTwoWay.on('close', () => {\n  console.log(\"on close\");\n});\n\n// 绑定本地IP地址和端口。\nlet ipAddress : socket.NetAddress = {} as socket.NetAddress;\nipAddress.address = \"192.168.xxx.xxx\";\nipAddress.port = 4512;\ntlsTwoWay.bind(ipAddress, (err: BusinessError) => {\n  if (err) {\n    console.log('bind fail');\n    return;\n  }\n  console.log('bind success');\n});\n\nipAddress.address = \"192.168.xxx.xxx\";\nipAddress.port = 1234;\n\nlet tlsSecureOption : socket.TLSSecureOptions = {} as socket.TLSSecureOptions;\ntlsSecureOption.key = \"xxxx\";\ntlsSecureOption.cert = \"xxxx\";\ntlsSecureOption.ca = [\"xxxx\"];\ntlsSecureOption.password = \"xxxx\";\ntlsSecureOption.protocols = [socket.Protocol.TLSv12];\ntlsSecureOption.useRemoteCipherPrefer = true;\ntlsSecureOption.signatureAlgorithms = \"rsa_pss_rsae_sha256:ECDSA+SHA256\";\ntlsSecureOption.cipherSuite = \"AES256-SHA256\";\n\nlet tlsTwoWayConnectOption : socket.TLSConnectOptions = {} as socket.TLSConnectOptions;\ntlsSecureOption.key = \"xxxx\";\ntlsTwoWayConnectOption.address = ipAddress;\ntlsTwoWayConnectOption.secureOptions = tlsSecureOption;\ntlsTwoWayConnectOption.ALPNProtocols = [\"spdy/1\", \"http/1.1\"];\n\n// 建立连接\ntlsTwoWay.connect(tlsTwoWayConnectOption).then(() => {\n  console.log(\"connect successfully\");\n}).catch((err: BusinessError) => {\n  console.log(\"connect failed \" + JSON.stringify(err));\n});\n\n// 连接使用完毕后，主动关闭。取消相关事件的订阅。\ntlsTwoWay.close((err: BusinessError) => {\n  if (err) {\n    console.log(\"close callback error = \" + err);\n  } else {\n    console.log(\"close success\");\n  }\n  tlsTwoWay.off('message');\n  tlsTwoWay.off('connect');\n  tlsTwoWay.off('close');\n});\n\n// 创建一个（单向认证）TLS Socket连接，返回一个TLS Socket对象。\nlet tlsOneWay: socket.TLSSocket = socket.constructTLSSocketInstance(); // One way authentication\n\n// 订阅TLS Socket相关的订阅事件\ntlsTwoWay.on('message', (value: SocketInfo) => {\n  console.log(\"on message\");\n  let buffer = value.message;\n  let dataView = new DataView(buffer);\n  let str = \"\";\n  for (let i = 0; i < dataView.byteLength; ++i) {\n    str += String.fromCharCode(dataView.getUint8(i));\n  }\n  console.log(\"on connect received:\" + str);\n});\ntlsTwoWay.on('connect', () => {\n  console.log(\"on connect\");\n});\ntlsTwoWay.on('close', () => {\n  console.log(\"on close\");\n});\n\n// 绑定本地IP地址和端口。\nipAddress.address = \"192.168.xxx.xxx\";\nipAddress.port = 5445;\ntlsOneWay.bind(ipAddress, (err:BusinessError) => {\n  if (err) {\n    console.log('bind fail');\n    return;\n  }\n  console.log('bind success');\n});\n\nipAddress.address = \"192.168.xxx.xxx\";\nipAddress.port = 8789;\nlet tlsOneWaySecureOption : socket.TLSSecureOptions = {} as socket.TLSSecureOptions;\ntlsOneWaySecureOption.ca = [\"xxxx\", \"xxxx\"];\ntlsOneWaySecureOption.cipherSuite = \"AES256-SHA256\";\n\nlet tlsOneWayConnectOptions: socket.TLSConnectOptions = {} as socket.TLSConnectOptions;\ntlsOneWayConnectOptions.address = ipAddress;\ntlsOneWayConnectOptions.secureOptions = tlsOneWaySecureOption;\n\n// 建立连接\ntlsOneWay.connect(tlsOneWayConnectOptions).then(() => {\n  console.log(\"connect successfully\");\n}).catch((err: BusinessError) => {\n  console.log(\"connect failed \" + JSON.stringify(err));\n});\n\n// 连接使用完毕后，主动关闭。取消相关事件的订阅。\ntlsTwoWay.close((err: BusinessError) => {\n  if (err) {\n    console.log(\"close callback error = \" + err);\n  } else {\n    console.log(\"close success\");\n  }\n  tlsTwoWay.off('message');\n  tlsTwoWay.off('connect');\n  tlsTwoWay.off('close');\n});
应用通过将 TCP Socket 升级为 TLS Socket 进行加密数据传输
客户端 TCP Socket 升级为 TLS Socket 流程：
 import 需要的 socket 模块。 参考应用 TCP/UDP 协议进行通信，创建一个 TCPSocket 连接。 确保 TCPSocket 已连接后，使用该 TCPSocket 对象创建 TLSSocket 连接，返回一个 TLSSocket 对象。 双向认证上传客户端 CA 证书及数字证书；单向认证上传客户端 CA 证书。 （可选）订阅 TLSSocket 相关的订阅事件。 发送数据。 TLSSocket 连接使用完毕后，主动关闭。 
import { socket } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nclass SocketInfo {\n  message: ArrayBuffer = new ArrayBuffer(1);\n  remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;\n}\n\n// 创建一个TCPSocket连接，返回一个TCPSocket对象。\nlet tcp: socket.TCPSocket = socket.constructTCPSocketInstance();\ntcp.on('message', (value: SocketInfo) => {\n  console.log(\"on message\");\n  let buffer = value.message;\n  let dataView = new DataView(buffer);\n  let str = \"\";\n  for (let i = 0; i < dataView.byteLength; ++i) {\n    str += String.fromCharCode(dataView.getUint8(i));\n  }\n  console.log(\"on connect received:\" + str);\n});\ntcp.on('connect', () => {\n  console.log(\"on connect\");\n});\n\n// 绑定本地IP地址和端口。\nlet ipAddress: socket.NetAddress = {} as socket.NetAddress;\nipAddress.address = \"192.168.xxx.xxx\";\nipAddress.port = 1234;\ntcp.bind(ipAddress, (err: BusinessError) => {\n  if (err) {\n    console.log('bind fail');\n    return;\n  }\n  console.log('bind success');\n\n  // 连接到指定的IP地址和端口。\n  ipAddress.address = \"192.168.xxx.xxx\";\n  ipAddress.port = 443;\n\n  let tcpConnect: socket.TCPConnectOptions = {} as socket.TCPConnectOptions;\n  tcpConnect.address = ipAddress;\n  tcpConnect.timeout = 6000;\n\n  tcp.connect(tcpConnect, (err: BusinessError) => {\n    if (err) {\n      console.log('connect fail');\n      return;\n    }\n    console.log('connect success');\n\n    // 确保TCPSocket已连接后，将其升级为TLSSocket连接。\n    let tlsTwoWay: socket.TLSSocket = socket.constructTLSSocketInstance(tcp);\n    // 订阅TLSSocket相关的订阅事件。\n    tlsTwoWay.on('message', (value: SocketInfo) => {\n      console.log(\"tls on message\");\n      let buffer = value.message;\n      let dataView = new DataView(buffer);\n      let str = \"\";\n      for (let i = 0; i < dataView.byteLength; ++i) {\n        str += String.fromCharCode(dataView.getUint8(i));\n      }\n      console.log(\"tls on connect received:\" + str);\n    });\n    tlsTwoWay.on('connect', () => {\n      console.log(\"tls on connect\");\n    });\n    tlsTwoWay.on('close', () => {\n      console.log(\"tls on close\");\n    });\n\n    // 配置TLSSocket目的地址、证书等信息。\n    ipAddress.address = \"192.168.xxx.xxx\";\n    ipAddress.port = 1234;\n\n    let tlsSecureOption: socket.TLSSecureOptions = {} as socket.TLSSecureOptions;\n    tlsSecureOption.key = \"xxxx\";\n    tlsSecureOption.cert = \"xxxx\";\n    tlsSecureOption.ca = [\"xxxx\"];\n    tlsSecureOption.password = \"xxxx\";\n    tlsSecureOption.protocols = [socket.Protocol.TLSv12];\n    tlsSecureOption.useRemoteCipherPrefer = true;\n    tlsSecureOption.signatureAlgorithms = \"rsa_pss_rsae_sha256:ECDSA+SHA256\";\n    tlsSecureOption.cipherSuite = \"AES256-SHA256\";\n\n    let tlsTwoWayConnectOption: socket.TLSConnectOptions = {} as socket.TLSConnectOptions;\n    tlsSecureOption.key = \"xxxx\";\n    tlsTwoWayConnectOption.address = ipAddress;\n    tlsTwoWayConnectOption.secureOptions = tlsSecureOption;\n    tlsTwoWayConnectOption.ALPNProtocols = [\"spdy/1\", \"http/1.1\"];\n\n    // 建立TLSSocket连接\n    tlsTwoWay.connect(tlsTwoWayConnectOption, () => {\n      console.log(\"tls connect success\");\n\n      // 连接使用完毕后，主动关闭。取消相关事件的订阅。\n      tlsTwoWay.close((err: BusinessError) => {\n        if (err) {\n          console.log(\"tls close callback error = \" + err);\n        } else {\n          console.log(\"tls close success\");\n        }\n        tlsTwoWay.off('message');\n        tlsTwoWay.off('connect');\n        tlsTwoWay.off('close');\n      });\n    });\n  });\n});
应用通过 TLS Socket Server 进行加密数据传输
服务端 TLS Socket Server 流程：
 import 需要的 socket 模块。 启动服务，绑定 IP 和端口号，监听客户端连接，创建并初始化 TLS 会话，加载证书密钥并验证。 订阅 TLSSocketServer 的连接事件。 收到客户端连接，通过回调得到 TLSSocketConnection 对象。 订阅 TLSSocketConnection 相关的事件。 发送数据。 TLSSocketConnection 连接使用完毕后，断开连接。 取消订阅 TLSSocketConnection 以及 TLSSocketServer 的相关事件。 
import { socket } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet tlsServer: socket.TLSSocketServer = socket.constructTLSSocketServerInstance();\n\nlet netAddress: socket.NetAddress = {\n  address: '192.168.xx.xxx',\n  port: 8080\n}\n\nlet tlsSecureOptions: socket.TLSSecureOptions = {\n  key: \"xxxx\",\n  cert: \"xxxx\",\n  ca: [\"xxxx\"],\n  password: \"xxxx\",\n  protocols: socket.Protocol.TLSv12,\n  useRemoteCipherPrefer: true,\n  signatureAlgorithms: \"rsa_pss_rsae_sha256:ECDSA+SHA256\",\n  cipherSuite: \"AES256-SHA256\"\n}\n\nlet tlsConnectOptions: socket.TLSConnectOptions = {\n  address: netAddress,\n  secureOptions: tlsSecureOptions,\n  ALPNProtocols: [\"spdy/1\", \"http/1.1\"]\n}\n\ntlsServer.listen(tlsConnectOptions).then(() => {\n  console.log(\"listen callback success\");\n}).catch((err: BusinessError) => {\n  console.log(\"failed\" + err);\n});\n\nclass SocketInfo {\n  message: ArrayBuffer = new ArrayBuffer(1);\n  remoteInfo: socket.SocketRemoteInfo = {} as socket.SocketRemoteInfo;\n}\nlet callback = (value: SocketInfo) => {\n  let messageView = '';\n  for (let i: number = 0; i < value.message.byteLength; i++) {\n    let uint8Array = new Uint8Array(value.message)\n    let messages = uint8Array[i]\n    let message = String.fromCharCode(messages);\n    messageView += message;\n  }\n  console.log('on message message: ' + JSON.stringify(messageView));\n  console.log('remoteInfo: ' + JSON.stringify(value.remoteInfo));\n}\ntlsServer.on('connect', (client: socket.TLSSocketConnection) => {\n  client.on('message', callback);\n\n  // 发送数据\n  client.send('Hello, client!').then(() => {\n    console.log('send success');\n  }).catch((err: BusinessError) => {\n    console.log('send fail');\n  });\n\n  // 断开连接\n  client.close().then(() => {\n    console.log('close success');\n  }).catch((err: BusinessError) => {\n    console.log('close fail');\n  });\n\n  // 可以指定传入on中的callback取消一个订阅，也可以不指定callback清空所有订阅。\n  client.off('message', callback);\n  client.off('message');\n});\n\n// 取消订阅tlsServer的相关事件\ntlsServer.off('connect');

通过关系型数据库实现数据持久化
场景介绍
关系型数据库基于SQLite组件，适用于存储包含复杂关系数据的场景，比如一个班级的学生信息，需要包括姓名、学号、各科成绩等，又或者公司的雇员信息，需要包括姓名、工号、职位等，由于数据之间有较强的对应关系，复杂程度比键值型数据更高，此时需要使用关系型数据库来持久化保存数据。
大数据量场景下查询数据可能会导致耗时长甚至应用卡死，如有相关操作可参考文档批量数据写数据库场景，且有建议如下：
 单次查询数据量不超过5000条。 在TaskPool中查询。 拼接SQL语句尽量简洁。 合理地分批次查询。 
基本概念
 谓词：数据库中用来代表数据实体的性质、特征或者数据实体之间关系的词项，主要用来定义数据库的操作条件。 结果集：指用户查询之后的结果集合，可以对数据进行访问。结果集提供了灵活的数据访问方式，可以更方便地拿到用户想要的数据。 
运作机制
关系型数据库对应用提供通用的操作接口，底层使用SQLite作为持久化存储引擎，支持SQLite具有的数据库特性，包括但不限于事务、索引、视图、触发器、外键、参数化查询和预编译SQL语句。
图1 关系型数据库运作机制
约束限制
 系统默认日志方式是WAL（Write Ahead Log）模式，系统默认落盘方式是FULL模式。 数据库中有4个读连接和1个写连接，线程获取到空闲读连接时，即可进行读取操作。当没有空闲读连接且有空闲写连接时，会将写连接当做读连接来使用。 为保证数据的准确性，数据库同一时间只能支持一个写操作。 当应用被卸载完成后，设备上的相关数据库文件及临时文件会被自动清除。 ArkTS侧支持的基本数据类型：number、string、二进制类型数据、boolean。 为保证插入并读取数据成功，建议一条数据不要超过2M。超出该大小，插入成功，读取失败。 
接口说明
以下是关系型数据库持久化功能的相关接口，大部分为异步接口。异步接口均有callback和Promise两种返回形式，下表均以callback形式为例，更多接口及使用方式请见关系型数据库。
开发步骤
因Stage模型、FA模型的差异，个别示例代码提供了在两种模型下的对应示例；示例代码未区分模型或没有对应注释说明时默认在两种模型下均适用。
关系库数据库操作或者存储过程中，有可能会因为各种原因发生非预期的数据库异常情况（抛出14800011），此时需要对数据库进行重建并恢复数据，以保障正常的应用开发，具体可见关系型数据库异常重建。
 使用关系型数据库实现数据持久化，需要获取一个RdbStore，其中包括建库、建表、升降级等操作。示例代码如下所示： Stage模型示例： import { relationalStore } from '@kit.ArkData'; // 导入模块\nimport { UIAbility } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { window } from '@kit.ArkUI';\n\n// 此处示例在Ability中实现，使用者也可以在其他合理场景中使用\nclass EntryAbility extends UIAbility {\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    const STORE_CONFIG :relationalStore.StoreConfig= {\n      name: 'RdbTest.db', // 数据库文件名\n      securityLevel: relationalStore.SecurityLevel.S3, // 数据库安全级别\n      encrypt: false, // 可选参数，指定数据库是否加密，默认不加密\n      customDir: 'customDir/subCustomDir', // 可选参数，数据库自定义路径。数据库将在如下的目录结构中被创建：context.databaseDir + '/rdb/' + customDir，其中context.databaseDir是应用沙箱对应的路径，'/rdb/'表示创建的是关系型数据库，customDir表示自定义的路径。当此参数不填时，默认在本应用沙箱目录下创建RdbStore实例。\n      isReadOnly: false // 可选参数，指定数据库是否以只读方式打开。该参数默认为false，表示数据库可读可写。该参数为true时，只允许从数据库读取数据，不允许对数据库进行写操作，否则会返回错误码801。\n    };\n\n    // 判断数据库版本，如果不匹配则需进行升降级操作\n    // 假设当前数据库版本为3，表结构：EMPLOYEE (NAME, AGE, SALARY, CODES, IDENTITY)\n    const SQL_CREATE_TABLE = 'CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INTEGER, SALARY REAL, CODES BLOB, IDENTITY UNLIMITED INT)'; // 建表Sql语句, IDENTITY为bigint类型，sql中指定类型为UNLIMITED INT\n\n    relationalStore.getRdbStore(this.context, STORE_CONFIG, (err, store) => {\n      if (err) {\n        console.error(`Failed to get RdbStore. Code:${err.code}, message:${err.message}`);\n        return;\n      }\n      console.info('Succeeded in getting RdbStore.');\n\n      // 当数据库创建时，数据库默认版本为0\n      if (store.version === 0) {\n        store.executeSql(SQL_CREATE_TABLE); // 创建数据表\n        // 设置数据库的版本，入参为大于0的整数\n        store.version = 3;\n      }\n\n      // 如果数据库版本不为0且和当前数据库版本不匹配，需要进行升降级操作\n      // 当数据库存在并假定版本为1时，例应用从某一版本升级到当前版本，数据库需要从1版本升级到2版本\n      if (store.version === 1) {\n        // version = 1：表结构：EMPLOYEE (NAME, SALARY, CODES, ADDRESS) => version = 2：表结构：EMPLOYEE (NAME, AGE, SALARY, CODES, ADDRESS)\n        (store as relationalStore.RdbStore).executeSql('ALTER TABLE EMPLOYEE ADD COLUMN AGE INTEGER');\n        store.version = 2;\n      }\n\n      // 当数据库存在并假定版本为2时，例应用从某一版本升级到当前版本，数据库需要从2版本升级到3版本\n      if (store.version === 2) {\n        // version = 2：表结构：EMPLOYEE (NAME, AGE, SALARY, CODES, ADDRESS) => version = 3：表结构：EMPLOYEE (NAME, AGE, SALARY, CODES)\n        (store as relationalStore.RdbStore).executeSql('ALTER TABLE EMPLOYEE DROP COLUMN ADDRESS TEXT');\n        store.version = 3;\n      }\n    });\n\n    // 请确保获取到RdbStore实例后，再进行数据库的增、删、改、查等操作\n  }\n} FA模型示例： import { relationalStore } from '@kit.ArkData'; // 导入模块\nimport { featureAbility } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet context = featureAbility.getContext();\n\nconst STORE_CONFIG :relationalStore.StoreConfig = {\n  name: 'RdbTest.db', // 数据库文件名\n  securityLevel: relationalStore.SecurityLevel.S3 // 数据库安全级别\n};\n\n// 假设当前数据库版本为3，表结构：EMPLOYEE (NAME, AGE, SALARY, CODES, IDENTITY)\nconst SQL_CREATE_TABLE = 'CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INTEGER, SALARY REAL, CODES BLOB, IDENTITY UNLIMITED INT)'; // 建表Sql语句，IDENTITY为bigint类型，sql中指定类型为UNLIMITED INT\n\nrelationalStore.getRdbStore(context, STORE_CONFIG, (err, store) => {\n  if (err) {\n    console.error(`Failed to get RdbStore. Code:${err.code}, message:${err.message}`);\n    return;\n  }\n  console.info('Succeeded in getting RdbStore.');\n\n  // 当数据库创建时，数据库默认版本为0\n  if (store.version === 0) {\n    store.executeSql(SQL_CREATE_TABLE); // 创建数据表\n    // 设置数据库的版本，入参为大于0的整数\n    store.version = 3;\n  }\n\n  // 如果数据库版本不为0且和当前数据库版本不匹配，需要进行升降级操作\n  // 当数据库存在并假定版本为1时，例应用从某一版本升级到当前版本，数据库需要从1版本升级到2版本\n  if (store.version === 1) {\n    // version = 1：表结构：EMPLOYEE (NAME, SALARY, CODES, ADDRESS) => version = 2：表结构：EMPLOYEE (NAME, AGE, SALARY, CODES, ADDRESS)\n    store.executeSql('ALTER TABLE EMPLOYEE ADD COLUMN AGE INTEGER');\n    store.version = 2;\n  }\n\n  // 当数据库存在并假定版本为2时，例应用从某一版本升级到当前版本，数据库需要从2版本升级到3版本\n  if (store.version === 2) {\n    // version = 2：表结构：EMPLOYEE (NAME, AGE, SALARY, CODES, ADDRESS) => version = 3：表结构：EMPLOYEE (NAME, AGE, SALARY, CODES)\n    store.executeSql('ALTER TABLE EMPLOYEE DROP COLUMN ADDRESS TEXT');\n    store.version = 3;\n  }\n});\n\n// 请确保获取到RdbStore实例后，再进行数据库的增、删、改、查等操作      应用创建的数据库与其上下文（Context）有关，即使使用同样的数据库名称，但不同的应用上下文，会产生多个数据库，例如每个UIAbility都有各自的上下文。 当应用首次获取数据库（调用getRdbStore）后，在应用沙箱内会产生对应的数据库文件。使用数据库的过程中，在与数据库文件相同的目录下可能会产生以-wal和-shm结尾的临时文件。此时若开发者希望移动数据库文件到其它地方使用查看，则需要同时移动这些临时文件，当应用被卸载完成后，其在设备上产生的数据库文件及临时文件也会被移除。 错误码的详细介绍请参见通用错误码和关系型数据库错误码。    获取到RdbStore后，调用insert()接口插入数据。示例代码如下所示： let store: relationalStore.RdbStore | undefined = undefined;\n\nlet value1 = 'Lisa';\nlet value2 = 18;\nlet value3 = 100.5;\nlet value4 = new Uint8Array([1, 2, 3, 4, 5]);\nlet value5 = BigInt('15822401018187971961171');\n// 以下三种方式可用\nconst valueBucket1: relationalStore.ValuesBucket = {\n  'NAME': value1,\n  'AGE': value2,\n  'SALARY': value3,\n  'CODES': value4,\n  'IDENTITY': value5,\n};\nconst valueBucket2: relationalStore.ValuesBucket = {\n  NAME: value1,\n  AGE: value2,\n  SALARY: value3,\n  CODES: value4,\n  IDENTITY: value5,\n};\nconst valueBucket3: relationalStore.ValuesBucket = {\n  \"NAME\": value1,\n  \"AGE\": value2,\n  \"SALARY\": value3,\n  \"CODES\": value4,\n  \"IDENTITY\": value5,\n};\n\nif (store !== undefined) {\n  (store as relationalStore.RdbStore).insert('EMPLOYEE', valueBucket1, (err: BusinessError, rowId: number) => {\n    if (err) {\n      console.error(`Failed to insert data. Code:${err.code}, message:${err.message}`);\n      return;\n    }\n    console.info(`Succeeded in inserting data. rowId:${rowId}`);\n  })\n}     关系型数据库没有显式的flush操作实现持久化，数据插入即保存在持久化文件。   根据谓词指定的实例对象，对数据进行修改或删除。 调用update()方法修改数据，调用delete()方法删除数据。示例代码如下所示： let value6 = 'Rose';\nlet value7 = 22;\nlet value8 = 200.5;\nlet value9 = new Uint8Array([1, 2, 3, 4, 5]);\nlet value10 = BigInt('15822401018187971967863');\n// 以下三种方式可用\nconst valueBucket4: relationalStore.ValuesBucket = {\n  'NAME': value6,\n  'AGE': value7,\n  'SALARY': value8,\n  'CODES': value9,\n  'IDENTITY': value10,\n};\nconst valueBucket5: relationalStore.ValuesBucket = {\n  NAME: value6,\n  AGE: value7,\n  SALARY: value8,\n  CODES: value9,\n  IDENTITY: value10,\n};\nconst valueBucket6: relationalStore.ValuesBucket = {\n  \"NAME\": value6,\n  \"AGE\": value7,\n  \"SALARY\": value8,\n  \"CODES\": value9,\n  \"IDENTITY\": value10,\n};\n\n// 修改数据\nlet predicates1 = new relationalStore.RdbPredicates('EMPLOYEE'); // 创建表'EMPLOYEE'的predicates\npredicates1.equalTo('NAME', 'Lisa'); // 匹配表'EMPLOYEE'中'NAME'为'Lisa'的字段\nif (store !== undefined) {\n  (store as relationalStore.RdbStore).update(valueBucket4, predicates1, (err: BusinessError, rows: number) => {\n    if (err) {\n      console.error(`Failed to update data. Code:${err.code}, message:${err.message}`);\n     return;\n   }\n   console.info(`Succeeded in updating data. row count: ${rows}`);\n  })\n}\n\n// 删除数据\npredicates1 = new relationalStore.RdbPredicates('EMPLOYEE');\npredicates1.equalTo('NAME', 'Lisa');\nif (store !== undefined) {\n  (store as relationalStore.RdbStore).delete(predicates1, (err: BusinessError, rows: number) => {\n    if (err) {\n      console.error(`Failed to delete data. Code:${err.code}, message:${err.message}`);\n      return;\n    }\n    console.info(`Delete rows: ${rows}`);\n  })\n} 根据谓词指定的查询条件查找数据。 调用query()方法查找数据，返回一个ResultSet结果集。示例代码如下所示： let predicates2 = new relationalStore.RdbPredicates('EMPLOYEE');\npredicates2.equalTo('NAME', 'Rose');\nif (store !== undefined) {\n  (store as relationalStore.RdbStore).query(predicates2, ['ID', 'NAME', 'AGE', 'SALARY', 'IDENTITY'], (err: BusinessError, resultSet) => {\n    if (err) {\n      console.error(`Failed to query data. Code:${err.code}, message:${err.message}`);\n      return;\n    }\n    console.info(`ResultSet column names: ${resultSet.columnNames}, column count: ${resultSet.columnCount}`);\n    // resultSet是一个数据集合的游标，默认指向第-1个记录，有效的数据从0开始。\n    while (resultSet.goToNextRow()) {\n      const id = resultSet.getLong(resultSet.getColumnIndex('ID'));\n      const name = resultSet.getString(resultSet.getColumnIndex('NAME'));\n      const age = resultSet.getLong(resultSet.getColumnIndex('AGE'));\n      const salary = resultSet.getDouble(resultSet.getColumnIndex('SALARY'));\n      const identity = resultSet.getValue(resultSet.getColumnIndex('IDENTITY'));\n      console.info(`id=${id}, name=${name}, age=${age}, salary=${salary}, identity=${identity}`);\n    }\n    // 释放数据集的内存\n    resultSet.close();\n  })\n}     当应用完成查询数据操作，不再使用结果集（ResultSet）时，请及时调用close方法关闭结果集，释放系统为其分配的内存。   在同路径下备份数据库。关系型数据库支持两种手动备份和自动备份（仅系统应用可用）两种方式，具体可见关系型数据库备份。 此处以手动备份为例： if (store !== undefined) {\n  // \"Backup.db\"为备份数据库文件名，默认在RdbStore同路径下备份。也可指定路径：customDir + \"backup.db\"\n  (store as relationalStore.RdbStore).backup(\"Backup.db\", (err: BusinessError) => {\n    if (err) {\n      console.error(`Failed to backup RdbStore. Code:${err.code}, message:${err.message}`);\n      return;\n    }\n    console.info(`Succeeded in backing up RdbStore.`);\n  })\n} 从备份数据库中恢复数据。关系型数据库支持两种方式：恢复手动备份数据和恢复自动备份数据（仅系统应用可用），具体可见关系型数据库数据恢复。 此处以调用restore接口恢复手动备份数据为例： if (store !== undefined) {\n  (store as relationalStore.RdbStore).restore(\"Backup.db\", (err: BusinessError) => {\n    if (err) {\n      console.error(`Failed to restore RdbStore. Code:${err.code}, message:${err.message}`);\n      return;\n    }\n    console.info(`Succeeded in restoring RdbStore.`);\n  })\n} 删除数据库。 调用deleteRdbStore()方法，删除数据库及数据库相关文件。示例代码如下： Stage模型示例： relationalStore.deleteRdbStore(this.context, 'RdbTest.db', (err: BusinessError) => {\n if (err) {\n    console.error(`Failed to delete RdbStore. Code:${err.code}, message:${err.message}`);\n    return;\n  }\n  console.info('Succeeded in deleting RdbStore.');\n}); FA模型示例： relationalStore.deleteRdbStore(context, 'RdbTest.db', (err: BusinessError) => {\n  if (err) {\n    console.error(`Failed to delete RdbStore. Code:${err.code}, message:${err.message}`);\n    return;\n  }\n  console.info('Succeeded in deleting RdbStore.');\n}); 

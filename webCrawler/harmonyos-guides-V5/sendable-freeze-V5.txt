Sendable对象冻结
Sendable对象支持冻结操作，冻结后的对象变成只读对象，不能增删改属性，因此在多个并发实例间访问均不需要加锁，可以通过调用Object.freeze接口冻结对象。
使用示例
提供ts文件封装Object.freeze方法。 // helper.ts\nexport function freezeObj(obj: any) {\n  Object.freeze(obj);\n} 通过调用freeze方法冻结对象，并将对象发送给子线程。 // Index.ets\nimport { freezeObj } from './helper';\nimport { worker } from '@kit.ArkTS';\n \n@Sendable\nexport class GlobalConfig {\n  // 一些配置属性与方法\n  init() {\n    // 初始化相关逻辑\n    freezeObj(this); // 初始化完成后冻结当前对象\n  }\n}\n \n@Entry\n@Component\nstruct Index {\n  build() {\n    Column() {\n      Text(\"Sendable freezeObj Test\")\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .onClick(() => {\n          let gConifg = new GlobalConfig();\n          gConifg.init();\n          const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ets', { name: \"Worker1\" });\n          workerInstance.postMessage(gConifg);\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n} 子线程不加锁直接操作对象。 // Worker.ets\nimport { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';\nimport { GlobalConfig } from '../pages/Index';\n\nconst workerPort: ThreadWorkerGlobalScope = worker.workerPort;\nworkerPort.onmessage = (e: MessageEvents) => {\n  let gConfig: GlobalConfig = e.data;\n  // 使用gConfig对象\n} 

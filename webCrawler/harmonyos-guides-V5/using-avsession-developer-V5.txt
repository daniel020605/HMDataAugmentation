媒体会话提供方
音视频应用在实现音视频功能的同时，需要作为媒体会话提供方接入媒体会话，在媒体会话控制方（例如播控中心）中展示媒体相关信息，及响应媒体会话控制方下发的播控命令。
基本概念
 媒体会话元数据（AVMetadata）： 用于描述媒体数据相关属性，包含标识当前媒体的ID（assetId），上一首媒体的ID（previousAssetId），下一首媒体的ID（nextAssetId），标题（title），专辑作者（author），专辑名称（album），词作者（writer），媒体时长（duration）等属性。 媒体播放状态（AVPlaybackState）：用于描述媒体播放状态的相关属性，包含当前媒体的播放状态（state）、播放位置（position）、播放倍速（speed）、缓冲时间（bufferedTime）、循环模式（loopMode）、是否收藏（isFavorite）、正在播放的媒体Id（activeItemId）、自定义媒体数据（extras）等属性。 
接口说明
媒体会话提供方使用的关键接口如下表所示。接口返回值有两种返回形式：callback和promise，下表中为callback形式接口，promise和callback只是返回值方式不一样，功能相同。
更多API说明请参见API文档。
创建媒体会话。
一个UIAbility只能存在一个媒体会话，重复创建会失败。
开发步骤
音视频应用作为媒体会话提供方接入媒体会话的基本步骤如下所示：
 通过AVSessionManager的方法创建并激活媒体会话。 import { avSession as AVSessionManager } from '@kit.AVSessionKit';\n\n// 开始创建并激活媒体会话\n// 创建session\nlet context: Context = getContext(this);\nasync function createSession() {\n  let type: AVSessionManager.AVSessionType = 'audio';\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n  await session.activate();\n  console.info(`session create done : sessionId : ${session.sessionId}`);\n} 跟随媒体信息的变化，及时设置媒体会话信息。需要设置的媒体会话信息主要包括：  媒体会话元数据AVMetadata。 媒体播放状态AVPlaybackState。  音视频应用设置的媒体会话信息，会被媒体会话控制方通过AVSessionController相关方法获取后进行显示或处理。 import { avSession as AVSessionManager } from '@kit.AVSessionKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet context: Context = getContext(this);\nasync function setSessionInfo() {\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', 'audio');\n  // 播放器逻辑··· 引发媒体信息与播放状态的变更\n  // 设置必要的媒体信息\n  let metadata: AVSessionManager.AVMetadata = {\n    assetId: '0', // 由应用指定，用于标识应用媒体库里的媒体\n    title: 'TITLE',\n    mediaImage: 'IMAGE',\n    artist: 'ARTIST'\n  };\n  session.setAVMetadata(metadata).then(() => {\n    console.info(`SetAVMetadata successfully`);\n  }).catch((err: BusinessError) => {\n    console.error(`Failed to set AVMetadata. Code: ${err.code}, message: ${err.message}`);\n  });\n  // 简单设置一个播放状态 - 暂停 未收藏\n  let playbackState: AVSessionManager.AVPlaybackState = {\n    state:AVSessionManager.PlaybackState.PLAYBACK_STATE_PAUSE,\n    isFavorite:false\n  };\n  session.setAVPlaybackState(playbackState, (err) => {\n    if (err) {\n      console.error(`Failed to set AVPlaybackState. Code: ${err.code}, message: ${err.message}`);\n    } else {\n      console.info(`SetAVPlaybackState successfully`);\n    }\n  });\n  // 设置一个播放列表\n  let queueItemDescription_1: AVSessionManager.AVMediaDescription = {\n    assetId: '001',\n    title: 'music_name',\n    subtitle: 'music_sub_name',\n    description: 'music_description',\n    mediaImage: \"PIXELMAP_OBJECT\",\n    extras: {'extras':'any'}\n  };\n  let queueItem_1: AVSessionManager.AVQueueItem = {\n    itemId: 1,\n    description: queueItemDescription_1\n  };\n  let queueItemDescription_2: AVSessionManager.AVMediaDescription = {\n    assetId: '002',\n    title: 'music_name',\n    subtitle: 'music_sub_name',\n    description: 'music_description',\n    mediaImage: \"PIXELMAP_OBJECT\",\n    extras: {'extras':'any'}\n  };\n  let queueItem_2: AVSessionManager.AVQueueItem = {\n    itemId: 2,\n    description: queueItemDescription_2\n  };\n  let queueItemsArray = [queueItem_1, queueItem_2];\n  session.setAVQueueItems(queueItemsArray).then(() => {\n    console.info(`SetAVQueueItems successfully`);\n  }).catch((err: BusinessError) => {\n    console.error(`Failed to set AVQueueItem, error code: ${err.code}, error message: ${err.message}`);\n  });\n  // 设置媒体播放列表名称\n  let queueTitle = 'QUEUE_TITLE';\n  session.setAVQueueTitle(queueTitle).then(() => {\n    console.info(`SetAVQueueTitle successfully`);\n  }).catch((err: BusinessError) => {\n    console.info(`Failed to set AVQueueTitle, error code: ${err.code}, error message: ${err.message}`);\n  });\n} 设置用于被媒体会话控制方拉起的UIAbility。当用户操作媒体会话控制方的界面时，例如点击播控中心的卡片，可以拉起此处配置的UIAbility。 设置UIAbility时通过WantAgent接口实现，更多关于WantAgent的信息请参考WantAgent。 import { avSession as AVSessionManager } from '@kit.AVSessionKit';\nimport { wantAgent } from '@kit.AbilityKit';\n\nlet context: Context = getContext(this);\nasync function getWantAgent() {\n  let type: AVSessionManager.AVSessionType = 'audio';\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n  let wantAgentInfo: wantAgent.WantAgentInfo = {\n    wants: [\n      {\n        bundleName: 'com.example.musicdemo',\n        abilityName: 'MainAbility'\n      }\n    ],\n    // OperationType.START_ABILITIES\n    operationType: 2,\n    requestCode: 0,\n    wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]\n  }\n  wantAgent.getWantAgent(wantAgentInfo).then((agent) => {\n    session.setLaunchAbility(agent);\n  })\n} 设置一个即时的自定义会话事件，以供媒体控制方接收到事件后进行相应的操作。     通过dispatchSessionEvent方法设置的数据不会保存在会话对象或AVSession服务中。   import { avSession as AVSessionManager } from '@kit.AVSessionKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet context: Context = getContext(this);\nasync function dispatchSessionEvent() {\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let type: AVSessionManager.AVSessionType = 'audio';\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n  let eventName = 'dynamic_lyric';\n  await session.dispatchSessionEvent(eventName, {lyric : 'This is my lyric'}).then(() => {\n    console.info(`Dispatch session event successfully`);\n  }).catch((err: BusinessError) => {\n    console.error(`Failed to dispatch session event. Code: ${err.code}, message: ${err.message}`);\n  })\n} 设置与当前会话相关的自定义媒体数据包，以供媒体控制方接收到事件后进行相应的操作。     通过setExtras方法设置的数据包会被存储在AVSession服务中，数据的生命周期与会话一致；会话对应的Controller可以使用getExtras来获取该数据。   import { avSession as AVSessionManager } from '@kit.AVSessionKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet context: Context = getContext(this);\nasync function setExtras() {\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let type: AVSessionManager.AVSessionType = 'audio';\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n  await session.setExtras({extra : 'This is my custom meida packet'}).then(() => {\n    console.info(`Set extras successfully`);\n  }).catch((err: BusinessError) => {\n    console.error(`Failed to set extras. Code: ${err.code}, message: ${err.message}`);\n  })\n} 注册播控命令事件监听，便于响应用户通过媒体会话控制方，例如播控中心，下发的播控命令。 在Session侧注册的监听分为固定播控命令和高级播控事件两种。 6.1 固定控制命令的监听     媒体会话提供方在注册相关固定播控命令事件监听时，监听的事件会在媒体会话控制方的getValidCommands()方法中体现，即媒体会话控制方会认为对应的方法有效，进而根据需要触发相应暂不使用时的事件。为了保证媒体会话控制方下发的播控命令可以被正常执行，媒体会话提供方请勿进行无逻辑的空实现监听。   Session侧的固定播控命令主要包括播放、暂停、上一首、下一首等基础操作命令，详细介绍请参见AVControlCommand import { avSession as AVSessionManager } from '@kit.AVSessionKit';\n\nlet context: Context = getContext(this);\nasync function setListenerForMesFromController() {\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let type: AVSessionManager.AVSessionType = 'audio';\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n  // 一般在监听器中会对播放器做相应逻辑处理\n  // 不要忘记处理完后需要通过set接口同步播放相关信息，参考上面的用例\n  session.on('play', () => {\n    console.info(`on play , do play task`);\n    // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('play')取消监听\n    // 处理完毕后，请使用SetAVPlayState上报播放状态\n  });\n  session.on('pause', () => {\n    console.info(`on pause , do pause task`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('pause')取消监听\n     // 处理完毕后，请使用SetAVPlayState上报播放状态\n  });\n  session.on('stop', () => {\n    console.info(`on stop , do stop task`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('stop')取消监听\n     // 处理完毕后，请使用SetAVPlayState上报播放状态\n  });\n  session.on('playNext', () => {\n    console.info(`on playNext , do playNext task`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('playNext')取消监听\n     // 处理完毕后，请使用SetAVPlayState上报播放状态，使用SetAVMetadata上报媒体信息\n  });\n  session.on('playPrevious', () => {\n    console.info(`on playPrevious , do playPrevious task`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('playPrevious')取消监听\n     // 处理完毕后，请使用SetAVPlayState上报播放状态，使用SetAVMetadata上报媒体信息\n  });\n  session.on('fastForward', () => {\n    console.info(`on fastForward , do fastForward task`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('fastForward')取消监听\n     // 处理完毕后，请使用SetAVPlayState上报播放状态和播放position\n  });\n  session.on('rewind', () => {\n    console.info(`on rewind , do rewind task`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('rewind')取消监听\n     // 处理完毕后，请使用SetAVPlayState上报播放状态和播放position\n  });\n  session.on('seek', (time) => {\n    console.info(`on seek , the seek time is ${time}`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('seek')取消监听\n     // 处理完毕后，请使用SetAVPlayState上报播放状态和播放position\n  });\n  session.on('setSpeed', (speed) => {\n    console.info(`on setSpeed , the speed is ${speed}`);\n    // do some tasks ···\n  });\n  session.on('setLoopMode', (mode) => {\n    console.info(`on setLoopMode , the loop mode is ${mode}`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('setLoopMode')取消监听\n     // 应用自定下一个模式，处理完毕后，请使用SetAVPlayState上报切换后的LoopMode\n  });\n  session.on('toggleFavorite', (assetId) => {\n    console.info(`on toggleFavorite , the target asset Id is ${assetId}`);\n     // 如暂不支持该指令，请勿注册；或在注册后但暂不使用时，通过session.off('toggleFavorite')取消监听\n     // 处理完毕后，请使用SetAVPlayState上报收藏结果isFavorite\n  });\n} 6.2 高级播控事件的监听 Session侧的可以注册的高级播控事件主要包括：  skipToQueueItem: 播放列表其中某项被选中的事件。 handleKeyEvent: 按键事件。 outputDeviceChange: 播放设备变化的事件。 commonCommand: 自定义控制命令变化的事件。  import { avSession as AVSessionManager } from '@kit.AVSessionKit';\n\nlet context: Context = getContext(this);\nasync function setListenerForMesFromController() {\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let type: AVSessionManager.AVSessionType = 'audio';\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n  // 一般在监听器中会对播放器做相应逻辑处理\n  // 不要忘记处理完后需要通过set接口同步播放相关信息，参考上面的用例\n  session.on('skipToQueueItem', (itemId) => {\n    console.info(`on skipToQueueItem , do skip task`);\n    // do some tasks ···\n  });\n  session.on('handleKeyEvent', (event) => {\n    console.info(`on handleKeyEvent , the event is ${JSON.stringify(event)}`);\n    // do some tasks ···\n  });\n  session.on('outputDeviceChange', (device) => {\n    console.info(`on outputDeviceChange , the device info is ${JSON.stringify(device)}`);\n    // do some tasks ···\n  });\n  session.on('commonCommand', (commandString, args) => {\n    console.info(`on commonCommand , command is ${commandString}, args are ${JSON.stringify(args)}`);\n    // do some tasks ···\n  });\n} 获取当前媒体会话自身的控制器，与媒体会话对应进行通信交互。 import { avSession as AVSessionManager } from '@kit.AVSessionKit';\n\nlet context: Context = getContext(this);\nasync function createControllerFromSession() {\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let type: AVSessionManager.AVSessionType = 'audio';\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n\n  // 通过已有session获取一个controller对象\n  let controller = await session.getController();\n\n  // controller可以与原session对象进行基本的通信交互，比如下发播放命令\n  let avCommand: AVSessionManager.AVControlCommand = {command:'play'};\n  controller.sendControlCommand(avCommand);\n\n  // 或者做状态变更监听\n  controller.on('playbackStateChange', 'all', (state) => {\n\n    // do some things\n  });\n\n  // controller可以做的操作还有很多，具体可以参考媒体会话控制方相关的说明\n} 音视频应用在退出，并且不需要继续播放时，及时取消监听以及销毁媒体会话释放资源。 取消播控命令监听的示例代码如下所示 ： import { avSession as AVSessionManager } from '@kit.AVSessionKit';\n\nlet context: Context = getContext(this);\nasync function unregisterSessionListener() {\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let type: AVSessionManager.AVSessionType = 'audio';\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n\n  // 取消指定session下的相关监听\n  session.off('play');\n  session.off('pause');\n  session.off('stop');\n  session.off('playNext');\n  session.off('playPrevious');\n  session.off('skipToQueueItem');\n  session.off('handleKeyEvent');\n  session.off('outputDeviceChange');\n  session.off('commonCommand');\n} 销毁媒体会话示例代码如下所示： import { avSession as AVSessionManager } from '@kit.AVSessionKit';\n\nlet context: Context = getContext(this);\nasync function destroySession() {\n  // 假设已经创建了一个session，如何创建session可以参考之前的案例\n  let type: AVSessionManager.AVSessionType = 'audio';\n  let session = await AVSessionManager.createAVSession(context, 'SESSION_NAME', type);\n  // 主动销毁已创建的session\n  session.destroy((err) => {\n    if (err) {\n      console.error(`Failed to destroy session. Code: ${err.code}, message: ${err.message}`);\n    } else {\n      console.info(`Destroy : SUCCESS `);\n    }\n  });\n} 

OffscreenCanvasRenderingContext2D对象
使用OffscreenCanvas在离屏Canvas画布组件上进行绘制，绘制对象可以是矩形、文本、图片等。 离屏，即GPU在当前缓冲区以外新开辟的一个缓冲区。 具体请参考OffscreenCanvasRenderingContext2D对象。
以下示例创建了一个OffscreenCanvas画布，再在画布上创建一个getContext2d对象，并设置filter属性改变图片样式。
<!-- xxx.hml -->\n<div class=\"container\">\n  <canvas ref=\"canvas1\"></canvas>\n  <select @change=\"change()\">\n    <option value=\"blur(5px)\">blur</option>\n    <option value=\"grayscale(50%)\">grayscale</option>\n    <option value=\"hue-rotate(45deg)\">hue-rotate</option>\n    <option value=\"invert(100%)\">invert</option>\n    <option value=\"drop-shadow(8px 8px 10px green)\">drop-shadow</option>\n    <option value=\"brightness(0.4)\">brightness</option>\n    <option value=\"opacity(0.25)\">opacity</option>\n    <option value=\"saturate(30%)\">saturate</option>\n    <option value=\"sepia(60%)\">sepia</option>\n    <option value=\"contrast(200%)\">contrast</option>\n  </select>\n</div>
/* xxx.css */\n.container{\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  background-color: #F1F3F5;\n}\ncanvas{\n  width: 600px;\n  height: 500px;\n  background-color: #fdfdfd;\n  border: 5px solid red;\n}\nselect{\n  margin-top: 50px;\n  width: 250px;\n  height: 100px;\n  background-color: white;\n}
// xxx.js\nimport promptAction from '@ohos.promptAction';\nexport default {\n  data:{\n    el: null,\n    ctx: null,\n    offscreen: null,\n    offCanvas: null,\n    img: null,\n  },\n  onShow(){\n    this.ctx = this.$refs.canvas1.getContext(\"2d\");\n    this.offscreen = new OffscreenCanvas(600, 500);\n    this.offCanvas = this.offscreen.getContext(\"2d\");\n    this.img = new Image();\n    this.img.src = 'common/images/2.png';\n    // 图片成功获取触发方法\n    let _this = this;\n    this.img.onload = function() {\n      _this.offCanvas.drawImage(_this.img, 100, 100, 400, 300);\n    };\n    this.img.onerror = function() {\n      promptAction.showToast({message:\"error\",duration:2000})\n    };\n    var bitmap = this.offscreen.transferToImageBitmap();    this.ctx.transferFromImageBitmap(bitmap);\n  },\n  change(e){\n    this.offCanvas.filter = e.newValue;this.offCanvas.drawImage(this.img, 100, 100, 400, 300);\n    var bitmap = this.offscreen.transferToImageBitmap();\n    this.ctx.transferFromImageBitmap(bitmap);\n  },\n}
判断位置
使用isPointInPath判断坐标点是否在路径的区域内，使用isPointInStroke判断坐标点是否在路径的边缘线上，并在页面上显示返回结果。
<!-- xxx.hml -->\n<div class=\"container\">\n  <div class=\"content\">\n    <text>坐标：{{X}}, {{Y}}</text>\n    <text>In path:{{textValue}}</text>\n    <text>In stroke:{{textValue1}}</text>\n  </div>\n  <canvas ref=\"canvas\"></canvas>\n  <button onclick=\"change\">Add(50)</button>\n</div>
/* xxx.css */\n.container{\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  background-color: #F1F3F5;\n}\ncanvas{\n  width: 600px;\n  height: 500px;\n  background-color: #fdfdfd;\n  border: 5px solid red;\n}\n.content{\n  flex-direction: column;\n  justify-content: center;\n  align-items: center; \n}\ntext{\n  font-size: 30px;\n  width: 300px;\n  height: 80px;\n  text-align: center;\n}\nbutton{\n  width: 180px;\n  height: 75px;\n  margin-top: 50px;\n}
// xxx.js\nexport default {\n  data: {\n    textValue: 0,\n    textValue1: 0,\n    X:0,\n    Y:250,\n  },\n  onShow(){\n    let canvas = this.$refs.canvas.getContext('2d');\n    let offscreen = new OffscreenCanvas(500,500);\n    let offscreenCanvasCtx = offscreen.getContext(\"2d\");\n    let offscreenCanvasCtx1 = offscreen.getContext(\"2d\");\n    offscreenCanvasCtx1.arc(this.X, this.Y, 2, 0, 6.28);\n    offscreenCanvasCtx.lineWidth=20;\n    offscreenCanvasCtx.rect(200,150, 200, 200);\n    offscreenCanvasCtx.stroke();\n    this.textValue1 = offscreenCanvasCtx.isPointInStroke(this.X, this.Y)?'true':'false';\n    this.textValue = offscreenCanvasCtx.isPointInPath(this.X, this.Y)?'true':'false';\n    let bitmap = offscreen.transferToImageBitmap();\n    canvas.transferFromImageBitmap(bitmap);\n  },\n  change(){\n    if(this.X < 500){\n      this.X = this.X+50;\n    }else{\n      this.X = 0;\n    }\n    let canvas = this.$refs.canvas.getContext('2d');\n    let offscreen = new OffscreenCanvas(500,500);\n    let offscreenCanvasCtx = offscreen.getContext(\"2d\");\n    let offscreenCanvasCtx1 = offscreen.getContext(\"2d\");\n    offscreenCanvasCtx1.arc(this.X, this.Y, 1, 0, 6.28)\n    offscreenCanvasCtx.lineWidth=20\n    offscreenCanvasCtx.rect(200,150, 200, 200);\n    offscreenCanvasCtx.stroke();\n    this.textValue1 = offscreenCanvasCtx.isPointInStroke(this.X, this.Y)?'true':'false';\n    this.textValue = offscreenCanvasCtx.isPointInPath(this.X, this.Y)?'true':'false';\n    let bitmap = offscreen.transferToImageBitmap();\n    canvas.transferFromImageBitmap(bitmap);\n  }\n}

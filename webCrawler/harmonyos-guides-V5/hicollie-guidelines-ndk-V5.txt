使用HiCollie检测业务线程卡死卡顿问题（C/C++）
HiCollie模块对外提供检测业务线程卡死、卡顿，以及上报卡死事件的能力。
接口说明
业务线程卡死故障日志是以appfreeze-开头，生成在”设备/data/log/faultlog/faultlogger/”路径下。该日志文件名格式为“appfreeze-应用包名-应用UID-秒级时间”。具体规格可参考：appfreeze-应用无响应日志分析。
业务线程卡顿故障日志规格，可参考：MAIN_THREAD_JANK-主线程超时事件规格。
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiCollie。
开发步骤
下文将展示如何在应用内增加一个按钮，并单击该按钮以调用HiCollie Ndk接口。
 新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下： entry:\n  src:\n    main:\n      cpp:\n        - types:\n            libentry:\n              - index.d.ts\n        - CMakeLists.txt\n        - napi_init.cpp\n      ets:\n        - entryability:\n            - EntryAbility.ts\n        - pages:\n            - Index.ets 编辑\"CMakeLists.txt\"文件，添加源文件及动态库： # 新增动态库依赖libhilog_ndk.z.so(日志输出)\ntarget_link_libraries(entry PUBLIC libace_napi.z.so libhilog_ndk.z.so libohhicollie.so) 编辑\"napi_init.cpp\"文件，导入依赖的文件，并定义LOG_TAG及测试方法：  #include \"napi/native_api.h\"\n #include \"hilog/log.h\"\n #include \"hicollie/hicollie.h\"\n #include <thread>\n #include <string>\n #include <unistd.h>\n #include <atomic>\n \n #undef LOG_TAG\n #define LOG_TAG \"testTag\"\n\n static OH_HiCollie_BeginFunc beginFunc_; //定义回调函数对象\n static OH_HiCollie_EndFunc endFunc_; //定义回调函数对象\n HiCollie_DetectionParam param {.sampleStackTriggerTime = 150,.reserved = 0}; //定义结构体\n int64_t lastWatchTime = 0; // 记录上次卡死检测时间\n const int64_t CHECK_INTERNAL_TIME = 3000; // 设置卡死检测间隔\n std::shared_ptr<std::atomic<bool>> isReport = std::make_shared<std::atomic<bool>>(false); // 设置上报卡死事件标志位\n int count = 0; // 记录第一次初始化\n bool needReport = false; // 根据实际场景，设置是否上报标志\n\n //定义回调函数\n void InitBeginFunc(const char* eventName)\n {\n     std::string str(eventName);\n     OH_LOG_INFO(LogType::LOG_APP, \"InitBeginFunc eventName: %{public}s\", str.c_str());\n }\n void InitEndFunc(const char* eventName)\n {\n     std::string str(eventName);\n     OH_LOG_INFO(LogType::LOG_APP, \"OH_HiCollie_EndFunc eventName: %{public}s\", str.c_str());\n }\n //定义子线程回调函数\n void TestJankDetection()\n {\n     beginFunc_ = InitBeginFunc; // 初始化回调函数\n     endFunc_ = InitEndFunc;\n     int initResult = OH_HiCollie_Init_JankDetection(&beginFunc_, &endFunc_, param); // 初始化线程卡顿监控函数\n     OH_LOG_INFO(LogType::LOG_APP, \"OH_HiCollie_Init_JankDetection: %{public}d\", initResult); // 成功结果：0\n     int count = 0;\n     while (count < 2) {\n         beginFunc_(\"TestBegin\"); // 设置处理开始回调函数，监控线程任务执行开始时长\n         usleep(350 * 1000); // 睡眠350ms，模拟任务线程处理事件卡顿场景\n         endFunc_(\"TestEnd\"); // 设置处理结束回调函数，监控线程任务执行结束时长\n         count++;\n     }\n }\n\n static napi_value TestHiCollieJankNdk(napi_env env, napi_callback_info info)\n {\n     std::thread threadObj(TestJankDetection); // 创建子线程\n     threadObj.join(); // 执行回调函数\n     return 0;\n }\n\n int64_t GetCurrentTime()\n {\n   return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::\n       system_clock::now().time_since_epoch()).count();\n }\n\n bool ReportEvent()\n {\n   if ((GetCurrentTime() - lastWatchTime) > CHECK_INTERNAL_TIME) {\n       return true;\n   }\n   return false;\n }\n\n void TestTask()\n {\n     if (needReport && ReportEvent()) {\n       bool temp = isReport->load();\n       int reportResult = OH_HiCollie_Report(&temp);\n       OH_LOG_INFO(LogType::LOG_APP, \"OH_HiCollie_Report: %{public}d\", reportResult); // 成功结果：0\n       OH_LOG_INFO(LogType::LOG_APP, \"OH_HiCollie_Report isReport: %{public}d\", temp);\n       needReport = false;\n     }\n     int64_t now = GetCurrentTime();\n     if ((now - lastWatchTime) >= (CHECK_INTERNAL_TIME / 2)) {\n         lastWatchTime = now;\n     }\n }\n\n //定义子线程回调函数\n void TestStuckDetection()\n {\n     int initResult = -1;\n     if(count == 0) {\n       initResult = OH_HiCollie_Init_StuckDetection(TestTask); // 初始化线程卡死监控函数\n       OH_LOG_INFO(LogType::LOG_APP, \"OH_HiCollie_Init_StuckDetection: %{public}d\", initResult); // 成功结果：0\n       count++;\n     }\n }\n static napi_value TestHiCollieStuckNdk(napi_env env, napi_callback_info info)\n {\n   std::thread threadObj(TestStuckDetection); // 创建子线程\n   threadObj.join(); // 执行回调函数\n   return 0;\n } 将TestHiCollieNdk注册为ArkTS接口： 编辑\"napi_init.cpp\"文件，将TestHiCollieNdk注册为ArkTS接口：  static napi_value Init(napi_env env, napi_value exports)\n {\n     napi_property_descriptor desc[] = {\n         { \"testHiCollieJankNdk\", nullptr, TestHiCollieJankNdk, nullptr, nullptr, nullptr, napi_default, nullptr },\n         { \"testHiCollieStuckNdk\", nullptr, TestHiCollieStuckNdk, nullptr, nullptr, nullptr, napi_default, nullptr }};\n     };\n     napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n     return exports;\n } 编辑\"index.d.ts\"文件，定义ArkTS接口： export const testHiCollieJankNdk: () => void;\nexport const testHiCollieStuckNdk: () => void; 编辑\"Index.ets\"文件： import testNapi from 'libentry.so'\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World'\n\n  build() {\n    Row() {\n      Column() {\n        Button(\"testHiCollieJankNdk\")\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(testNapi.testHiCollieJankNdk);//添加点击事件，触发testHiCollieJankNdk方法。\n        Button(\"testHiCollieStuckNdk\")\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(testNapi.testHiCollieStuckNdk);//添加点击事件，触发testHiCollieStuckNdk方法。\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n} 点击DevEco Studio界面中的运行按钮，运行应用工程。 在DevEco Studio的底部，切换到“Log”窗口，设置日志的过滤条件为“testTag”。 （1）等待10s，再点击\"testHiCollieJankNdk\"按钮（线程启动10s内，不进行卡顿检测）。 此时窗口将显示通过OH_HiCollie_Init_JankDetection接口获取的应用业务线程采样栈的超时信息。 生成栈文件目录地址：/data/app/el2/100/log/应用bundle name/watchdog/BUSSINESS_THREAD_JANK_XXX.txt。 （2）点击\"testHiCollieStuckNdk\"按钮。 此时窗口将显示通过OH_HiCollie_Init_StuckDetection接口，初始化卡死检测回调函数。可以根据实际业务场景，自行定义卡死检测函数。 

业务模块并发加载场景
在应用启动过程中，会有多个业务模块需要加载，例如地图类应用的定位、打车、导航等不同的模块，如果全部在UI主线程初始化，则会严重影响冷启动耗时。此时需要在不同子线程并行化加载这些模块功能，降低启动耗时。
通过使用ArkTS提供的TaskPool能力，可以将不同业务初始化任务移到子线程中，业务模块通过下沉C++实现成NativeBinding对象、或者在ArkTS层定义Sendable对象，就可以将初始化的模块返回UI主线程调用，实现如下。
各业务功能（SDK）模块定义（这里以Sendable对象为例）。 计算器业务模块定义如下： // sdk/Calculator.ets\nimport { collections } from '@kit.ArkTS'\n\n@Sendable\nexport class Calculator {\n  history?: collections.Array<collections.Array<string>>\n  totalCount: number = 0\n\n  static init(): Calculator {\n    let calc = new Calculator()\n    calc.totalCount = 0\n    calc.history = collections.Array.create(calc.totalCount, collections.Array.create(2, \"\"));\n    return calc\n  }\n\n  add(a: number, b: number) {\n    let result = a + b;\n    this.newCalc(`${a} + ${b}`, `${result}`);\n    return result\n  }\n\n  sub(a: number, b: number) {\n    let result = a - b;\n    this.newCalc(`${a} - ${b}`, `${result}`);\n    return result\n  }\n\n  mul(a: number, b: number) {\n    let result = a * b;\n    this.newCalc(`${a} * ${b}`, `${result}`);\n    return result\n  }\n\n  div(a: number, b: number) {\n    let result = a / b;\n    this.newCalc(`${a} / ${b}`, `${result}`);\n    return result\n  }\n\n  getHistory(): collections.Array<collections.Array<string>> {\n    return this.history!;\n  }\n\n  showHistory() {\n    for (let i = 0; i < this.totalCount; i++) {\n      console.info(`${i}: ${this.history![i][0]} = ${this.history![i][1]}`)\n    }\n  }\n\n  private newCalc(opt: string, ret: string) {\n    let newRecord = new collections.Array<string>(opt, ret)\n    this.totalCount = this.history!.unshift(newRecord)\n  }\n} 定时器业务模块定义如下： // sdk/TimerSdk.ets\n@Sendable\nexport class TimerSdk {\n  static init(): TimerSdk {\n    let timer = new TimerSdk()\n    return timer\n  }\n\n  async Countdown(time: number) {\n    return new Promise((resolve: (value: boolean) => void) => {\n      setTimeout(() => {\n        resolve(true)\n      }, time)\n    })\n  }\n} 在UI主线程触发各业务模块分发到子线程，加载完成后在UI主线程使用。 // Index.ets\nimport { Calculator } from '../sdk/Calculator'\nimport { TimerSdk } from '../sdk/TimerSdk'\nimport { taskpool } from '@kit.ArkTS';\n\n@Concurrent\nfunction initCalculator(): Calculator {\n  return Calculator.init()\n}\n\n@Concurrent\nfunction initTimerSdk(): TimerSdk {\n  return TimerSdk.init()\n}\n\n@Entry\n@Component\nstruct Index {\n  calc?: Calculator\n  timer?: TimerSdk\n\n  aboutToAppear(): void {\n    taskpool.execute(initCalculator).then((ret) => {\n      this.calc = ret as Calculator\n    })\n    taskpool.execute(initTimerSdk).then((ret) => {\n      this.timer = ret as TimerSdk\n    })\n  }\n\n  build() {\n    Row() {\n      Column() {\n        Text(\"calculate add\")\n          .id('add')\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .alignRules({\n            center: { anchor: '__container__', align: VerticalAlign.Center },\n            middle: { anchor: '__container__', align: HorizontalAlign.Center }\n          })\n          .onClick(async () => {\n            let result = this.calc?.add(1, 2)\n            console.info(`Result is ${result}`)\n          })\n        Text(\"show history\")\n          .id('show')\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .alignRules({\n            center: { anchor: '__container__', align: VerticalAlign.Center },\n            middle: { anchor: '__container__', align: HorizontalAlign.Center }\n          })\n          .onClick(async () => {\n            this.calc?.showHistory()\n          })\n        Text(\"countdown\")\n          .id('get')\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .alignRules({\n            center: { anchor: '__container__', align: VerticalAlign.Center },\n            middle: { anchor: '__container__', align: HorizontalAlign.Center }\n          })\n          .onClick(async () => {\n            console.info(`Timer start`)\n            await this.timer?.Countdown(1000);\n            console.info(`Timer end`)\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n} 

时域AI超分
XEngine Kit提供时域AI超分能力，利用相机的抖动获取不同位置的采样信息，融合时域实现超采样率和超分辨率功能，并利用神经网络达到抗锯齿效果，建议超分倍率为[1.25, 2.0]。
接口说明
以下接口为时域AI超分设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
接口名
描述
KAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties)
XEngine Vulkan扩展特性查询接口。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateTemporalUpscale (VkDevice device, XEG_TemporalUpscaleCreateInfo * pTemporalUpscaleInfo, XEG_TemporalUpscale * pTemporalUpscale)
创建XEG_TemporalUpscale对象。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdRenderTemporalUpscale (VkCommandBuffer commandBuffer, XEG_TemporalUpscale temporalUpscale, XEG_TemporalUpscaleDescription * pDescription)
执行时域AI超分渲染命令。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyTemporalUpscale (XEG_TemporalUpscale temporalUpscale)
销毁XEG_TemporalUpscale对象。
开发步骤
本章以Vulkan图像API集成为例，说明XEngine集成操作过程。
[h2]配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
 头文件引用#include <algorithm>\n#include <string>\n#include <vector>\n#include \"xengine/xeg_vulkan_temporal_upscale.h\"\n#include \"xengine/xeg_vulkan_extension.h\" 编写CMakeLists.txtCMakeLists.txt部分示例代码如下。 find_library(\n    # Sets the name of the path variable.\n    hilog-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    hilog_ndk.z\n)\nfind_library(\n    # Sets the name of the path variable.\n    libace-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    ace_ndk.z\n)\nfind_library(\n    # Sets the name of the path variable.\n    libnapi-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    ace_napi.z\n)\nfind_library(\n    # Sets the name of the path variable.\n    libuv-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    uv\n)\nadd_library(libassimp SHARED IMPORTED)\nset_target_properties(\n        libassimp\n        PROPERTIES\n        IMPORTED_LOCATION\n        ${CMAKE_CURRENT_SOURCE_DIR}/libs/arm64-v8a/libassimp.so\n)\nfind_library(\n# Sets the name of the path variable.\nxengine-lib\n# Specifies the name of the NDK library that\n# you want CMake to locate.\nxengine\n)\ntarget_link_libraries(nativerender PUBLIC\n    ${hilog-lib} ${libace-lib} ${libnapi-lib} ${libuv-lib} libnative_window.so libc++.a libktx librawfile.z.so libassimp ${xengine-lib}) 
[h2]集成XEngine时域AI超分（Vulkan）
使用Vulkan图形API搭建图像渲染管线，并集成时域AI超分在Native层实现，渲染结果通过XComponent组件显示到屏幕。
本节阐述Vulkan图形API的时域AI超分使用。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
 调用HMS_XEG_EnumerateDeviceExtensionProperties接口，获取XEngine支持的扩展信息，只有在支持XEG_TEMPORAL_UPSCALE_EXTENSION_NAME扩展时才可以使用时域AI超分的相关接口。// physicalDevice为Vulkan物理设备，用户需进行初始化\nVkPhysicalDevice physicalDevice;\n// 查询XEngine支持的Vulkan扩展列表\nstd::vector<std::string> supportedExtensions;\nuint32_t pPropertyCount;\nHMS_XEG_EnumerateDeviceExtensionProperties(physicalDevice, &pPropertyCount, nullptr);\nif (pPropertyCount > 0) {\n    std::vector<XEG_ExtensionProperties> pProperties(pPropertyCount);\n    if (HMS_XEG_EnumerateDeviceExtensionProperties(physicalDevice, &pPropertyCount,\n        &pProperties.front()) == VK_SUCCESS) {\n        for (auto ext : pProperties) {\n            supportedExtensions.push_back(ext.extensionName);\n        }\n    }\n}\n// 查询是否支持时域AI超分\nif (std::find(supportedExtensions.begin(), supportedExtensions.end(), XEG_TEMPORAL_UPSCALE_EXTENSION_NAME) ==\n    supportedExtensions.end()) {\n    exit(1); //return error;\n}  声明实例句柄。XEG_TemporalUpscale xegTemporalUpscale;  调用HMS_XEG_CreateTemporalUpscale接口，创建时域AI超分实例。// 渲染宽高和超分后宽高均为用户自定义参数，这里将以800*600的分辨率进行1.5倍超分到1200*900的分辨率为例\nuint32_t lowResWidth = 800;\nuint32_t lowResHeight = 600;\nuint32_t highResWidth = 1200;\nuint32_t highResHeight = 900;\nconst uint32_t jitterNum = 8;\n// Vulkan逻辑设备，用户需进行初始化\nVkDevice device;\n// XEG_TemporalUpscaleCreateInfo为创建XEG_TemporalUpscale对象所需信息\nXEG_TemporalUpscaleCreateInfo createInfo;\n// 指定输入图像的大小，即低分辨率图像的尺寸\ncreateInfo.inputSize = {lowResWidth, lowResHeight};\n// 指定输出图像的大小，即高分辨率图像的尺寸\ncreateInfo.outputSize = {highResWidth, highResHeight};\n// 指定输出图像的颜色格式\ncreateInfo.outputFormat = VK_FORMAT_R8G8B8A8_UNORM;\n// jitterNum为相机抖动的周期数\ncreateInfo.jitterNum = jitterNum;\n// 指定了深度值是否反转\ncreateInfo.isDepthReversed = true;\nVkResult res = HMS_XEG_CreateTemporalUpscale(device, &createInfo, &xegTemporalUpscale);\nif (res != VK_SUCCESS) {\n    exit(1); //return error;\n}  调用HMS_XEG_CmdRenderTemporalUpscale接口下发超分，每帧都需要调用。其中，参数jitterX和jitterY分别为相机在X方向和Y方向的抖动，是一个类似Halton的低差异序列。         本例使用Halton算法计算Jitter值：使用Halton算法生成一个[0, 1]的序列，再减去0.5使序列范围保持在[-0.5, 0.5]，最后除以输入图像的分辨率，得到UV坐标下的Jitter值。         根据Halton算法生成每帧需要的相机抖动（Jitter）。// Halton算法示例\nfloat getHaltonSequence(uint32_t index, uint32_t base) {\n    float result = 0.0;\n    float fraction = 1.0 / base;\n    while (index > 0) {\n        result += fraction * (index % base);\n        index /= base;\n        fraction /= base;\n    }\n    return result;\n} 调用时域AI超分渲染接口。// 当前帧数，需要每帧+1，用于确定当前帧使用的Jitter值，使Jitter值在JitterNum范围内轮转\nuint64_t frameNum = 0;\n// jitterX与jitterY分别为相机在X和Y方向上的抖动\nfloat jitterX = 0.0;\nfloat jitterY = 0.0;\n// 定义XEG_TemporalUpscaleDescription对象xegDescription\nXEG_TemporalUpscaleDescription xegDescription;\n// inputImageView为用户创建的超分输入图像的vkImageView\nVkImageView inputImageView = VK_NULL_HANDLE;\n// depthImageView为用户创建的深度图像vkImageView\nVkImageView motionVectorImageView= VK_NULL_HANDLE;\n// motionVectorImageView为用户创建的运动矢量图像vkImageView\nVkImageView depthImageView = VK_NULL_HANDLE;\n// dynamicMaskImageView为用户创建的物体动态遮罩图像vkImageView\nVkImageView dynamicMaskImageView = VK_NULL_HANDLE;\n// outputImageView为用户创建的超分输出图像vkImageView\nVkImageView outputImageView = VK_NULL_HANDLE;\n// commandBuffer为命令缓冲区，用户需进行初始化\nVkCommandBuffer commandBuffer = VK_NULL_HANDLE;\nxegDescription.inputImage = inputImageView;\nxegDescription.depthImage = depthImageView;\nxegDescription.motionVectorImage = motionVectorImageView;\nxegDescription.dynamicMaskImage = dynamicMaskImageView;\nxegDescription.outputImage = outputImageView;\n// 此处需要保证生成的低差异序列长度与jitterNum保持一致，且在[-0.5, 0.5]的范围内\njitterX = GetHaltonSequence((frameNum % jitterNum) + 1, 2) - 0.5;\njitterY = GetHaltonSequence((frameNum % jitterNum) + 1, 3) - 0.5;\n// lowResWidth与lowResHeight为步骤3中的输入图像的宽度和高度\njitterX = jitterX / lowResWidth;\njitterY = jitterY / lowResHeight;\nxegDescription.jitterX = -jitterX;\nxegDescription.jitterY = -jitterY;\n// resetHistory为选择是否重置历史帧数据，true表示重置，false则表示不重置，此处以true为例\nxegDescription.resetHistory = (frameNum == 0) ? true : false;\n// steadyLevel为画面偏向当前帧还是历史帧的平衡程度，取值范围为[0.0, 1.0]，此处以平衡程度为0.5为例\nxegDescription.steadyLevel = 0.5;\nHMS_XEG_CmdRenderTemporalUpscale(commandBuffer, xegTemporalUpscale, &xegDescription);    调用HMS_XEG_DestroyTemporalUpscale接口销毁实例。if (xegTemporalUpscale) {\n    HMS_XEG_DestroyTemporalUpscale(xegTemporalUpscale);\n}  

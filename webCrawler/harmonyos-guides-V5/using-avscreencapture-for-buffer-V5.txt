使用AVScreenCapture录屏取码流(C/C++)
屏幕录制主要为主屏幕录屏功能。
开发者可以调用录屏（AVScreenCapture）模块的C API接口，完成屏幕录制，采集设备内、麦克风等的音视频源数据。当开发直播、办公等应用时，可以调用录屏模块获取音视频原始码流，然后通过流的方式流转到其他模块处理，达成直播时共享桌面的场景。
录屏模块和窗口（Window）、图形（Graphic）等模块协同完成整个视频采集的流程。
当前在进行屏幕录制时默认使用主屏，图形默认根据主屏生产录屏帧数据到显示数据缓冲队列，录屏框架从显示数据缓冲队列获取数据进行相应处理。
使用AVScreenCapture录制屏幕涉及到AVScreenCapture实例的创建、音视频采集参数的配置、采集的开始与停止、资源的释放等。
开始屏幕录制时正在通话中或者屏幕录制过程中来电，录屏将自动停止。因通话中断的录屏会上报OH_SCREEN_CAPTURE_STATE_STOPPED_BY_CALL状态。
屏幕录制过程中发生系统用户切换事件时，录屏将自动停止。因系统用户切换中断的录屏会上报OH_SCREEN_CAPTURE_STATE_STOPPED_BY_USER_SWITCHES状态。
本开发指导将以完成一次屏幕数据录制的过程为例，向开发者讲解如何使用AVScreenCapture进行屏幕录制，详细的API声明请参考AVScreenCapture API参考。
如果配置了采集麦克风音频数据，需对应配置麦克风权限ohos.permission.MICROPHONE和申请长时任务，配置方式请参见向用户申请权限、申请长时任务。
开发步骤及注意事项
使用AVScreenCapture时要明确其状态的变化，在创建实例后，调用对应的方法可以进入指定的状态实现对应的行为。
在确定的状态下执行不合适的方法会导致AVScreenCapture发生错误，开发者需要在调用状态转换的方法前进行状态检查，避免程序运行异常。
在 CMake 脚本中链接动态库
target_link_libraries(entry PUBLIC libnative_avscreen_capture.so libnative_buffer.so libnative_media_core.so)
 添加头文件。 #include \"napi/native_api.h\"\n#include <multimedia/player_framework/native_avscreen_capture.h>\n#include <multimedia/player_framework/native_avscreen_capture_base.h>\n#include <multimedia/player_framework/native_avscreen_capture_errors.h>\n#include <native_buffer/native_buffer.h>\n#include <fcntl.h>\n#include \"string\"\n#include \"unistd.h\" 创建AVScreenCapture实例capture。 OH_AVScreenCapture* capture = OH_AVScreenCapture_Create(); 配置屏幕录制参数。 创建AVScreenCapture实例capture后，可以设置屏幕录制所需要的参数。 OH_AudioCaptureInfo miccapinfo = {\n    .audioSampleRate = 16000,\n    .audioChannels = 2,\n    .audioSource = OH_MIC\n};\n\nOH_VideoCaptureInfo videocapinfo = {\n    .videoFrameWidth = 768,\n    .videoFrameHeight = 1280,\n    .videoSource = OH_VIDEO_SOURCE_SURFACE_RGBA\n};\n\nOH_AudioInfo audioinfo = {\n    .micCapInfo = miccapinfo,\n};\n\nOH_VideoInfo videoinfo = {\n    .videoCapInfo = videocapinfo\n};\n\nOH_AVScreenCaptureConfig config = {\n    .captureMode = OH_CAPTURE_HOME_SCREEN,\n    .dataType = OH_ORIGINAL_STREAM,\n    .audioInfo = audioinfo,\n    .videoInfo = videoinfo\n};\n\nOH_AVScreenCapture_Init(capture, config); 设置麦克风开关。 bool isMic = true;\nOH_AVScreenCapture_SetMicrophoneEnabled(capture, isMic); 回调函数的设置，主要监听录屏过程中的错误事件的发生，音频流和视频流数据的产生事件。 OH_AVScreenCapture_SetErrorCallback(capture, OnError, userData);\nOH_AVScreenCapture_SetStateCallback(capture, OnStateChange, userData);\nOH_AVScreenCapture_SetDataCallback(capture, OnBufferAvailable, userData); 调用StartScreenCapture()方法开始进行屏幕录制。 OH_AVScreenCapture_StartScreenCapture(capture); 或调用StartScreenCaptureWithSurface方法以Surface模式进行屏幕录制。 OH_AVScreenCapture_StartScreenCaptureWithSurface(capture, window); 调用StopScreenCapture()方法停止录制。 OH_AVScreenCapture_StopScreenCapture(capture); 在回调OnBufferAvailable()中获取并处理音频视频原始码流数据。 OnBufferAvailable(OH_AVScreenCapture *capture, OH_AVBuffer *buffer,\n    OH_AVScreenCaptureBufferType bufferType, int64_t timestamp, void *userData) 调用Release()方法销毁实例，释放资源。 OH_AVScreenCapture_Release(capture); 
完整示例
下面展示了使用AVScreenCapture屏幕录制的完整示例代码。
创建OH_AVBuffer，可参考视频解码Buffer模式。
使用Surface模式录屏，可参考视频编码Surface模式。
目前阶段流程结束后返回的buffer为原始码流，针对原始码流可以进行编码并以mp4等文件格式保存以供播放。
编码格式当前阶段仅作预留，待后续版本实现。
#include \"napi/native_api.h\"\n#include <multimedia/player_framework/native_avscreen_capture.h>\n#include <multimedia/player_framework/native_avscreen_capture_base.h>\n#include <multimedia/player_framework/native_avscreen_capture_errors.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <native_buffer/native_buffer.h>\n#include <fcntl.h>\n#include \"string\"\n#include \"unistd.h\"\n\nvoid OnError(OH_AVScreenCapture *capture, int32_t errorCode, void *userData) {\n    (void)capture;\n    (void)errorCode;\n    (void)userData;\n}\n\nvoid OnStateChange(struct OH_AVScreenCapture *capture, OH_AVScreenCaptureStateCode stateCode, void *userData) {\n    (void)capture;\n    \n    if (stateCode == OH_SCREEN_CAPTURE_STATE_STARTED) {\n        // 处理状态变更\n    }\n    if (stateCode == OH_SCREEN_CAPTURE_STATE_STOPPED_BY_CALL ||\n        stateCode == OH_SCREEN_CAPTURE_STATE_STOPPED_BY_USER_SWITCHES) {\n        // 录屏中断状态处理\n    }\n    if (stateCode == OH_SCREEN_CAPTURE_STATE_INTERRUPTED_BY_OTHER) {\n        // 处理状态变更\n    }\n    (void)userData;\n}\n\nvoid OnBufferAvailable(OH_AVScreenCapture *capture, OH_AVBuffer *buffer,\n    OH_AVScreenCaptureBufferType bufferType, int64_t timestamp, void *userData) {\n    // 获取解码后信息 可以参考编解码接口\n    int bufferLen = OH_AVBuffer_GetCapacity(buffer);\n    OH_NativeBuffer *nativeBuffer = OH_AVBuffer_GetNativeBuffer(buffer);\n    OH_NativeBuffer_Config config;\n    OH_NativeBuffer_GetConfig(nativeBuffer, &config);\n    int32_t videoSize= config.height * config.width * 4;\n    uint8_t *buf = OH_AVBuffer_GetAddr(buffer);\n    if (bufferType == OH_SCREEN_CAPTURE_BUFFERTYPE_VIDEO) {\n        // 处理视频buffer\n    } else if (bufferType == OH_SCREEN_CAPTURE_BUFFERTYPE_AUDIO_INNER) {\n        // 处理内录buffer\n    } else if (bufferType == OH_SCREEN_CAPTURE_BUFFERTYPE_AUDIO_MIC) {\n        // 处理麦克风buffer\n    }\n}\n\nstruct OH_AVScreenCapture *capture;\nstatic napi_value Screencapture(napi_env env, napi_callback_info info) {\n    // 从js端获取窗口id number[]\n    std::vector<int> windowIdsExclude = {};\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    // 获取参数\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n    // 获取数组长度\n    uint32_t array_length;\n    napi_get_array_length(env, args[0], &array_length);\n    // 读初窗口id\n    for (int32_t i = 0; i < array_length; i++) {\n        napi_value temp;\n        napi_get_element(env, args[0], i, &temp);\n        uint32_t tempValue;\n        napi_get_value_uint32(env, temp, &tempValue);\n        windowIdsExclude.push_back(tempValue);\n     }\n    // 实例化ScreenCapture\n    capture = OH_AVScreenCapture_Create();\n    \n    // 设置回调 \n    OH_AVScreenCapture_SetErrorCallback(capture, OnError, nullptr);\n    OH_AVScreenCapture_SetStateCallback(capture, OnStateChange, nullptr);\n    OH_AVScreenCapture_SetDataCallback(capture, OnBufferAvailable, nullptr);\n\n    // 可选 配置录屏旋转，此接口在感知到手机屏幕旋转时调用，如果手机的屏幕实际上没有发生旋转，调用接口是无效的。\n    OH_AVScreenCapture_SetCanvasRotation(capture, true);\n    // 可选 [过滤音频]\n    OH_AVScreenCapture_ContentFilter *contentFilter= OH_AVScreenCapture_CreateContentFilter();\n    // 添加过滤通知音\n    OH_AVScreenCapture_ContentFilter_AddAudioContent(contentFilter, OH_SCREEN_CAPTURE_NOTIFICATION_AUDIO);\n    // 排除指定窗口id\n    OH_AVScreenCapture_ContentFilter_AddWindowContent(contentFilter, &windowIdsExclude[0],\n                                                      static_cast<int32_t>(windowIdsExclude.size()));\n\n    OH_AVScreenCapture_ExcludeContent(capture, contentFilter);\n\n    // 初始化录屏，传入配置信息OH_AVScreenRecorderConfig\n    OH_AudioCaptureInfo miccapinfo = {.audioSampleRate = 16000, .audioChannels = 2, .audioSource = OH_MIC};\n    OH_VideoCaptureInfo videocapinfo = {\n        .videoFrameWidth = 768, .videoFrameHeight = 1280, .videoSource = OH_VIDEO_SOURCE_SURFACE_RGBA};\n    OH_AudioInfo audioinfo = {\n        .micCapInfo = miccapinfo,\n    };\n    OH_VideoInfo videoinfo = {.videoCapInfo = videocapinfo};\n    OH_AVScreenCaptureConfig config = {.captureMode = OH_CAPTURE_HOME_SCREEN,\n                                       .dataType = OH_ORIGINAL_STREAM,\n                                       .audioInfo = audioinfo,\n                                       .videoInfo = videoinfo};\n    OH_AVScreenCapture_Init(capture, config);\n\n    // 可选 [Surface模式]\n    // 通过 MIME TYPE 创建编码器，系统会根据MIME创建最合适的编码器。\n    // OH_AVCodec *codec = OH_VideoEncoder_CreateByMime(OH_AVCODEC_MIMETYPE_VIDEO_AVC);    \n    // 从视频编码器获取输入Surface\n    // OH_AVErrCode OH_VideoEncoder_GetSurface(codec, window);\n    // 启动编码器\n    // int32_t retEnc = OH_VideoEncoder_Start(codec);\n    // 指定surface开始录屏\n    // int32_t retStart = OH_AVScreenCapture_StartScreenCaptureWithSurface(capture, window); \n\n    // 开始录屏\n    OH_AVScreenCapture_StartScreenCapture(capture);\n\n    // mic开关设置\n    OH_AVScreenCapture_SetMicrophoneEnabled(capture, true);\n\n    // 可选 豁免隐私窗口 需传递应用豁免子窗口和主窗口ID，传空数组取消豁免隐私窗口\n    // std::vector<int> windowIdsSkipPrivacy = {};\n    // OH_AVScreenCapture_SkipPrivacyMode(capture, &windowIdsSkipPrivacy[0],\n    //     static_cast<int32_t>(windowIdsSkipPrivacy.size()));\n\n    // 可选 调整录屏分辨率 需在启动后调用，分辨率有范围限制 可参考avcodec编解码能力\n    // OH_AVScreenCapture_ResizeCanvas(capture, 768, 1280);\n\n    sleep(10); // 录制10s\n    // 结束录屏\n    OH_AVScreenCapture_StopScreenCapture(capture);\n    // 释放ScreenCapture\n    OH_AVScreenCapture_Release(capture);\n    // 返回调用结果，示例仅返回随意值\n    napi_value sum;\n    napi_create_double(env, 5, &sum);\n\n    return sum;\n}

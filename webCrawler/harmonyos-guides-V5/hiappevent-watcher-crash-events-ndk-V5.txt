订阅崩溃事件（C/C++）
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考HiAppEvent。
使用C/C++接口订阅崩溃事件，包含JsError和NativeCrash两种崩溃类型。
订阅接口功能介绍：
开发步骤
以实现对用户点击按钮触发崩溃场景生成的崩溃事件订阅为例，说明开发步骤。
 新建Native C++工程，并将jsoncpp导入到新建工程内，目录结构如下： entry:\n  src:\n    main:\n      cpp:\n        - json:\n            - json.h\n            - json-forwards.h\n        - types:\n            libentry:\n              - index.d.ts\n        - CMakeLists.txt\n        - napi_init.cpp\n        - jsoncpp.cpp\n      ets:\n        - entryability:\n            - EntryAbility.ets\n        - pages:\n            - Index.ets 编辑\"CMakeLists.txt\"文件，添加源文件及动态库： # 新增jsoncpp.cpp(解析订阅事件中的json字符串)源文件\nadd_library(entry SHARED napi_init.cpp jsoncpp.cpp)\n# 新增动态库依赖libhiappevent_ndk.z.so和libhilog_ndk.z.so(日志输出)\ntarget_link_libraries(entry PUBLIC libace_napi.z.so libhilog_ndk.z.so libhiappevent_ndk.z.so) 编辑\"napi_init.cpp\"文件，导入依赖的文件，并定义LOG_TAG： #include \"napi/native_api.h\"\n#include \"json/json.h\"\n#include \"hilog/log.h\"\n#include \"hiappevent/hiappevent.h\"\n\n#undef LOG_TAG\n#define LOG_TAG \"testTag\" 订阅系统事件：  onReceive类型观察者： 编辑\"napi_init.cpp\"文件，定义onReceive类型观察者相关方法： //定义一变量，用来缓存创建的观察者的指针。\nstatic HiAppEvent_Watcher *systemEventWatcher; \n\nstatic void OnReceive(const char *domain, const struct HiAppEvent_AppEventGroup *appEventGroups, uint32_t groupLen) {\n    for (int i = 0; i < groupLen; ++i) {\n        for (int j = 0; j < appEventGroups[i].infoLen; ++j) {\n            OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.domain=%{public}s\", appEventGroups[i].appEventInfos[j].domain);\n            OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.name=%{public}s\", appEventGroups[i].appEventInfos[j].name);\n            OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.eventType=%{public}d\", appEventGroups[i].appEventInfos[j].type);\n            if (strcmp(appEventGroups[i].appEventInfos[j].domain, DOMAIN_OS) == 0 && \n                strcmp(appEventGroups[i].appEventInfos[j].name, EVENT_APP_CRASH) == 0) {\n                Json::Value params;\n                Json::Reader reader(Json::Features::strictMode());\n                Json::FastWriter writer;\n                if (reader.parse(appEventGroups[i].appEventInfos[j].params, params)) {\n                    auto time = params[\"time\"].asInt64();\n                    auto crashType = params[\"crash_type\"].asString();\n                    auto foreground = params[\"foreground\"].asBool();\n                    auto bundleVersion = params[\"bundle_version\"].asString();\n                    auto bundleName = params[\"bundle_name\"].asString();\n                    auto pid = params[\"pid\"].asInt();\n                    auto uid = params[\"uid\"].asInt();\n                    auto uuid = params[\"uuid\"].asString();\n                    auto exception = writer.write(params[\"exception\"]);\n                    auto hilogSize = params[\"hilog\"].size();\n                    auto externalLog = writer.write(params[\"external_log\"]);\n                    auto logOverLimit = params[\"log_over_limit\"].asBool();\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.time=%{public}lld\", time);\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.crash_type=%{public}s\", crashType.c_str());\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.foreground=%{public}d\", foreground);\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.bundle_version=%{public}s\", bundleVersion.c_str());\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.bundle_name=%{public}s\", bundleName.c_str());\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.pid=%{public}d\", pid);\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.uid=%{public}d\", uid);\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.uuid=%{public}s\", uuid.c_str());\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.exception=%{public}s\", exception.c_str());\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.hilog.size=%{public}d\", hilogSize);\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.external_log=%{public}s\", externalLog.c_str());\n                    OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.log_over_limit=%{public}d\", logOverLimit);\n                }\n            }\n        }\n    }\n}\n\nstatic napi_value RegisterWatcher(napi_env env, napi_callback_info info) {\n    // 开发者自定义观察者名称，系统根据不同的名称来识别不同的观察者。\n    systemEventWatcher = OH_HiAppEvent_CreateWatcher(\"onReceiverWatcher\");\n    // 设置订阅的事件为EVENT_APP_CRASH。\n    const char *names[] = {EVENT_APP_CRASH};\n    // 开发者订阅感兴趣的事件，此处订阅了系统事件。\n    OH_HiAppEvent_SetAppEventFilter(systemEventWatcher, DOMAIN_OS, 0, names, 1);\n    // 开发者设置已实现的回调函数，观察者接收到事件后回立即触发OnReceive回调。\n    OH_HiAppEvent_SetWatcherOnReceive(systemEventWatcher, OnReceive);\n    // 使观察者开始监听订阅的事件。\n    OH_HiAppEvent_AddWatcher(systemEventWatcher);\n    return {};\n} onTrigger类型观察者： 编辑\"napi_init.cpp\"文件，定义OnTrigger类型观察者相关方法： //定义一变量，用来缓存创建的观察者的指针。\nstatic HiAppEvent_Watcher *systemEventWatcher;\n\n// 开发者可以自行实现获取已监听到事件的回调函数，其中events指针指向内容仅在该函数内有效。\nstatic void OnTake(const char *const *events, uint32_t eventLen) {\n    Json::Reader reader(Json::Features::strictMode());\n    Json::FastWriter writer;\n    for (int i = 0; i < eventLen; ++i) {\n        Json::Value eventInfo;\n        if (reader.parse(events[i], eventInfo)) {\n            auto domain =  eventInfo[\"domain_\"].asString();\n            auto name = eventInfo[\"name_\"].asString();\n            auto type = eventInfo[\"type_\"].asInt();\n            OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.domain=%{public}s\", domain.c_str());\n            OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.name=%{public}s\", name.c_str());\n            OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.eventType=%{public}d\", type);\n            if (domain ==  DOMAIN_OS && name == EVENT_APP_CRASH) {\n                auto time = eventInfo[\"time\"].asInt64();\n                auto crashType = eventInfo[\"crash_type\"].asString();\n                auto foreground = eventInfo[\"foreground\"].asBool();\n                auto bundleVersion = eventInfo[\"bundle_version\"].asString();\n                auto bundleName = eventInfo[\"bundle_name\"].asString();\n                auto pid = eventInfo[\"pid\"].asInt();\n                auto uid = eventInfo[\"uid\"].asInt();\n                auto uuid = eventInfo[\"uuid\"].asString();\n                auto exception = writer.write(eventInfo[\"exception\"]);\n                auto hilogSize = eventInfo[\"hilog\"].size();\n                auto externalLog = writer.write(eventInfo[\"external_log\"]);\n                auto logOverLimit = eventInfo[\"log_over_limit\"].asBool();\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.time=%{public}lld\", time);\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.crash_type=%{public}s\", crashType.c_str());\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.foreground=%{public}d\", foreground);\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.bundle_version=%{public}s\", bundleVersion.c_str());\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.bundle_name=%{public}s\", bundleName.c_str());\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.pid=%{public}d\", pid);\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.uid=%{public}d\", uid);\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.uuid=%{public}s\", uuid.c_str());\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.exception=%{public}s\", exception.c_str());\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.hilog.size=%{public}d\", hilogSize);\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.external_log=%{public}s\", externalLog.c_str());\n                OH_LOG_INFO(LogType::LOG_APP, \"HiAppEvent eventInfo.params.log_over_limit=%{public}d\", logOverLimit);\n            }\n        }\n    }\n}\n\n// 开发者可以自行实现订阅回调函数，以便对获取到的事件打点数据进行自定义处理。\nstatic void OnTrigger(int row, int size) {\n    // 接收回调后，获取指定数量的已接收事件。\n    OH_HiAppEvent_TakeWatcherData(systemEventWatcher, row, OnTake);\n}\n\nstatic napi_value RegisterWatcher(napi_env env, napi_callback_info info) {\n    // 开发者自定义观察者名称，系统根据不同的名称来识别不同的观察者。\n    systemEventWatcher = OH_HiAppEvent_CreateWatcher(\"onTriggerWatcher\");\n    // 设置订阅的事件为EVENT_APP_CRASH。\n    const char *names[] = {EVENT_APP_CRASH};\n    // 开发者订阅感兴趣的事件，此处订阅了系统事件。\n    OH_HiAppEvent_SetAppEventFilter(systemEventWatcher, DOMAIN_OS, 0, names, 1);\n    // 开发者设置已实现的回调函数，需OH_HiAppEvent_SetTriggerCondition设置的条件满足方可触发。\n    OH_HiAppEvent_SetWatcherOnTrigger(systemEventWatcher, OnTrigger);\n    // 开发者可以设置订阅触发回调的条件，此处是设置新增事件打点数量为1个时，触发onTrigger回调。\n    OH_HiAppEvent_SetTriggerCondition(systemEventWatcher, 1, 0, 0);\n    // 使观察者开始监听订阅的事件。\n    OH_HiAppEvent_AddWatcher(systemEventWatcher);\n    return {};\n}  将RegisterWatcher注册为ArkTS接口： 编辑\"napi_init.cpp\"文件，将RegisterWatcher注册为ArkTS接口： static napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        { \"registerWatcher\", nullptr, RegisterWatcher, nullptr, nullptr, nullptr, napi_default, nullptr }\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n} 编辑\"index.d.ts\"文件，定义ArkTS接口： export const registerWatcher: () => void; 编辑\"EntryAbility.ets\"文件，在onCreate()函数中新增接口调用： // 导入依赖模块\nimport testNapi from 'libentry.so'\n\n// 在onCreate()函数中新增接口调用\n// 启动时，注册系统事件观察者\ntestNapi.registerWatcher(); 编辑\"Index.ets\"文件，新增按钮触发崩溃事件： Button(\"appCrash\").onClick(() => {\n  JSON.parse(\"\");\n}) 点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“appCrash”，触发一次崩溃事件。崩溃事件发生后，系统会根据崩溃类型（JsError或NativeCrash）采用不同的栈回溯方式生成崩溃日志，然后再进行回调。其中NativeCrash栈回溯耗时约2秒，实际耗时与业务线程数量、进程间通信耗时有关。JsError触发进程内栈回溯，NativeCrash触发进程外栈回溯，因此NativeCrash栈回溯会比JsError栈回溯更耗时。用户可以订阅崩溃事件，栈回溯完成后会异步上报，不会阻塞当前业务。 下次应用启动后，HiAppEvent将崩溃事件上报给应用已注册的监听，完成回调。并可以在Log窗口看到对系统事件数据的处理日志： HiAppEvent eventInfo.domain=OS\nHiAppEvent eventInfo.name=APP_CRASH\nHiAppEvent eventInfo.eventType=1\nHiAppEvent eventInfo.params.time=1502032265088\nHiAppEvent eventInfo.params.crash_type=JsError\nHiAppEvent eventInfo.params.foreground=1\nHiAppEvent eventInfo.params.bundle_version=1.0.0\nHiAppEvent eventInfo.params.bundle_name=com.example.myapplication\nHiAppEvent eventInfo.params.pid=19237\nHiAppEvent eventInfo.params.uid=20010043\nHiAppEvent eventInfo.params.uuid=cc0f062e1b28c1fd2c817fafab5e8ca3207925b4bdd87c43ed23c60029659e01\nHiAppEvent eventInfo.params.exception={\"message\":\"Unexpected Text in JSON\",\"name\":\"SyntaxError\",\"stack\":\"at anonymous (entry/src/main/ets/pages/Index.ets:16:11)\"}\nHiAppEvent eventInfo.params.hilog.size=110\nHiAppEvent eventInfo.params.external_log=[\"/data/storage/el2/log/hiappevent/APP_CRASH_1502032265211_19237.log\"]\nHiAppEvent eventInfo.params.log_over_limit=0 移除事件观察者： static napi_value RemoveWatcher(napi_env env, napi_callback_info info) {\n    // 使观察者停止监听事件\n    OH_HiAppEvent_RemoveWatcher(systemEventWatcher);\n    return {};\n} 销毁事件观察者： static napi_value DestroyWatcher(napi_env env, napi_callback_info info) {\n    // 销毁创建的观察者，并置systemEventWatcher为nullptr。\n    OH_HiAppEvent_DestroyWatcher(systemEventWatcher);\n    systemEventWatcher = nullptr;\n    return {};\n} 

用户身份认证访问控制开发指导
场景介绍及相关概念说明请参考用户身份认证访问控制简介。
对于对称加解密场景，仅AES/CBC、AES/GCM、SM4/CBC模式支持细粒度访问控制。
开发步骤
 生成密钥，指定指纹访问控制类型及相关属性。 生成或导入密钥时，在密钥属性集中需指定三个参数：用户认证类型HuksUserAuthType、授权访问类型HuksAuthAccessType、挑战值类型HuksChallengeType。 
import { huks } from '@kit.UniversalKeystoreKit';\n\n/*\n* 确定密钥别名和封装密钥属性参数集\n*/\nlet keyAlias = 'test_sm4_key_alias';\nlet properties: Array<huks.HuksParam> = [{\n  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n  value: huks.HuksKeyAlg.HUKS_ALG_SM4\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT\n}, {\n  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n  value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n  value: huks.HuksCipherMode.HUKS_MODE_CBC,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PADDING,\n  value: huks.HuksKeyPadding.HUKS_PADDING_NONE,\n},\n  // 指定密钥身份认证的类型：指纹\n  {\n    tag: huks.HuksTag.HUKS_TAG_USER_AUTH_TYPE,\n    value: huks.HuksUserAuthType.HUKS_USER_AUTH_TYPE_FINGERPRINT\n  },\n  // 指定密钥安全授权的类型（失效类型）：新录入生物特征（指纹）后无效\n  {\n    tag: huks.HuksTag.HUKS_TAG_KEY_AUTH_ACCESS_TYPE,\n    value: huks.HuksAuthAccessType.HUKS_AUTH_ACCESS_INVALID_NEW_BIO_ENROLL\n  },\n  // 指定挑战值的类型：默认类型\n  {\n    tag: huks.HuksTag.HUKS_TAG_CHALLENGE_TYPE,\n    value: huks.HuksChallengeType.HUKS_CHALLENGE_TYPE_NORMAL\n  }];\n\nlet huksOptions: huks.HuksOptions = {\n  properties: properties,\n  inData: new Uint8Array(new Array())\n}\n\n/*\n * 生成密钥\n */\nclass throwObject {\n  isThrow: boolean = false\n}\n\nfunction generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise generateKeyItem`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await generateKeyItem(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: generateKeyItem failed, ` + JSON.stringify(error));\n        }\n      });\n  } catch (error) {\n    console.error(`promise: generateKeyItem input arg invalid, ` + JSON.stringify(error));\n  }\n}\n\nasync function TestGenKeyForFingerprintAccessControl() {\n  await publicGenKeyFunc(keyAlias, huksOptions);\n}
 初始化密钥会话，发起指纹认证获取认证令牌。 
import { huks } from '@kit.UniversalKeystoreKit';\nimport { userAuth } from '@kit.UserAuthenticationKit';\n\n/*\n * 确定密钥别名和封装密钥属性参数集\n */\nlet IV = '1234567890123456';\nlet srcKeyAlias = 'test_sm4_key_alias';\nlet handle: number;\nlet challenge: Uint8Array;\nlet fingerAuthToken: Uint8Array;\nlet authType = userAuth.UserAuthType.FINGERPRINT;\nlet authTrustLevel = userAuth.AuthTrustLevel.ATL1;\n/* 集成生成密钥参数集 & 加密参数集 */\nlet properties: Array<huks.HuksParam> = [{\n  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n  value: huks.HuksKeyAlg.HUKS_ALG_SM4,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n  value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n  value: huks.HuksCipherMode.HUKS_MODE_CBC,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PADDING,\n  value: huks.HuksKeyPadding.HUKS_PADDING_NONE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_IV,\n  value: StringToUint8Array(IV),\n}];\n\nfunction StringToUint8Array(str: string) {\n  let arr: number[] = [];\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  return new Uint8Array(arr);\n}\n\nlet huksOptions: huks.HuksOptions = {\n  properties: properties,\n  inData: new Uint8Array(new Array())\n}\n\nclass throwObject {\n  isThrow: boolean = false\n}\n\nfunction initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksSessionHandle>((resolve, reject) => {\n    try {\n      huks.initSession(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n/* 初始化HUKS中的会话，获取挑战值 */\nasync function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doInit`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await initSession(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);\n        handle = data.handle;\n        challenge = data.challenge as Uint8Array;\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doInit failed, ` + JSON.stringify(error));\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doInit input arg invalid, ` + JSON.stringify(error));\n  }\n}\n/* 调用UserIAM拉起指纹认证，触发HUKS的访问控制流程 */\nfunction userIAMAuthFinger(huksChallenge: Uint8Array) {\n  // 获取认证对象\n  let authTypeList: userAuth.UserAuthType[] = [authType];\n  const authParam: userAuth.AuthParam = {\n    challenge: huksChallenge,\n    authType: authTypeList,\n    authTrustLevel: userAuth.AuthTrustLevel.ATL1\n  };\n  const widgetParam: userAuth.WidgetParam = {\n    title: '请输入密码',\n  };\n  let auth: userAuth.UserAuthInstance;\n  try {\n    auth = userAuth.getUserAuthInstance(authParam, widgetParam);\n    console.info(\"get auth instance success\");\n  } catch (error) {\n    console.error(\"get auth instance failed\" + JSON.stringify(error));\n    return;\n  }\n  // 订阅认证结果\n  try {\n    auth.on(\"result\", {\n      onResult(result) {\n        console.info(\"[HUKS] -> [IAM]  userAuthInstance callback result = \" + JSON.stringify(result));\n        fingerAuthToken = result.token;\n      }\n    });\n    console.log(\"subscribe authentication event success\");\n  } catch (error) {\n    console.error(\"subscribe authentication event failed, \" + JSON.stringify(error));\n  }\n  // 开始认证\n  try {\n    auth.start();\n    console.info(\"authV9 start auth success\");\n  } catch (error) {\n    console.error(\"authV9 start auth failed, error = \" + JSON.stringify(error));\n  }\n}\n\nasync function testInitAndAuthFinger() {\n  /* 初始化密钥会话获取挑战值 */\n  await publicInitFunc(srcKeyAlias, huksOptions);\n  /* 调用userIAM进行身份认证 */\n  userIAMAuthFinger(challenge);\n}
 传入认证令牌进行数据操作。 
/*\n* 以下以SM4 128密钥为例\n*/\nimport { huks } from '@kit.UniversalKeystoreKit';\n\n/*\n* 确定封装密钥属性参数集\n*/\nlet IV = '1234567890123456';\nlet cipherInData = 'Hks_SM4_Cipher_Test_101010101010101010110_string';\nlet handle: number;\nlet fingerAuthToken: Uint8Array;\nlet finishOutData: Uint8Array;\n\nclass throwObject {\n  isThrow: boolean = false;\n}\n\n/* 集成生成密钥参数集 & 加密参数集 */\nclass propertyEncryptType {\n  tag: huks.HuksTag = huks.HuksTag.HUKS_TAG_ALGORITHM;\n  value: huks.HuksKeyAlg | huks.HuksKeyPurpose | huks.HuksKeySize | huks.HuksKeyPadding | huks.HuksCipherMode\n    | Uint8Array = huks.HuksKeyAlg.HUKS_ALG_SM4;\n}\n\nlet propertiesEncrypt: propertyEncryptType[] = [\n  {\n    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n    value: huks.HuksKeyAlg.HUKS_ALG_SM4,\n  },\n  {\n    tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT,\n  },\n  {\n    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n    value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,\n  },\n  {\n    tag: huks.HuksTag.HUKS_TAG_PADDING,\n    value: huks.HuksKeyPadding.HUKS_PADDING_NONE,\n  },\n  {\n    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n    value: huks.HuksCipherMode.HUKS_MODE_CBC,\n  },\n  {\n    tag: huks.HuksTag.HUKS_TAG_IV,\n    value: StringToUint8Array(IV),\n  }\n]\nlet encryptOptions: huks.HuksOptions = {\n  properties: propertiesEncrypt,\n  inData: new Uint8Array(new Array())\n}\n\nfunction StringToUint8Array(str: string) {\n  let arr: number[] = [];\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  return new Uint8Array(arr);\n}\n\nfunction updateSession(handle: number, huksOptions: huks.HuksOptions, token: Uint8Array, throwObject: throwObject) {\n  return new Promise<huks.HuksReturnResult>((resolve, reject) => {\n    try {\n      huks.updateSession(handle, huksOptions, token, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicUpdateFunc(handle: number, token: Uint8Array, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doUpdate`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await updateSession(handle, huksOptions, token, throwObject)\n      .then((data) => {\n        console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doUpdate failed, ` + JSON.stringify(error));\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doUpdate input arg invalid, ` + JSON.stringify(error));\n  }\n}\n\nfunction finishSession(handle: number, huksOptions: huks.HuksOptions, token: Uint8Array, throwObject: throwObject) {\n  return new Promise<huks.HuksReturnResult>((resolve, reject) => {\n    try {\n      huks.finishSession(handle, huksOptions, token, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicFinishFunc(handle: number, token: Uint8Array, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doFinish`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await finishSession(handle, huksOptions, token, throwObject)\n      .then((data) => {\n        finishOutData = data.outData as Uint8Array;\n        console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doFinish failed, ` + JSON.stringify(error));\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doFinish input arg invalid, ` + JSON.stringify(error));\n  }\n}\n\nasync function testSm4Cipher() {\n  encryptOptions.inData = StringToUint8Array(cipherInData);\n  /* 传入认证令牌 */\n  await publicUpdateFunc(handle, fingerAuthToken, encryptOptions);\n  /* 传入认证令牌 */\n  await publicFinishFunc(handle, fingerAuthToken, encryptOptions);\n  if (finishOutData === StringToUint8Array(cipherInData)) {\n    console.info('test finish encrypt error ');\n  } else {\n    console.info('test finish encrypt success');\n  }\n}

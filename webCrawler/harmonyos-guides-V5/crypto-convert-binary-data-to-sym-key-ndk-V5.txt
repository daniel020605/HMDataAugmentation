指定二进制数据转换对称密钥(C/C++)
以3DES和HMAC为例，根据指定的对称密钥二进制数据，生成密钥（OH_CryptoSymKey），即将外部或存储的二进制数据转换为算法库的密钥对象，该对象可用于后续的加解密等操作。
在CMake脚本中链接相关动态库
   target_link_libraries(entry PUBLIC libohcrypto.so)
指定二进制数据转换3DES密钥
对应的算法规格请查看对称密钥生成和转换规格：3DES。
 获取3DES二进制密钥数据，封装成Crypto_DataBlob。 调用OH_CryptoSymKeyGenerator_Create，指定字符串参数'3DES192'，创建密钥算法为3DES、密钥长度为192位的对称密钥生成器（OH_CryptoSymKeyGenerator）。 调用OH_CryptoSymKeyGenerator_Convert，根据指定的对称密钥二进制数据，生成对称密钥对象（OH_CryptoSymKey）。 调用OH_CryptoSymKey_GetKeyData，获取密钥对象的二进制数据。 
以下以生成3DES密钥为例：
#include \"CryptoArchitectureKit/crypto_common.h\"\n#include \"CryptoArchitectureKit/crypto_sym_key.h\"\n\nstatic OH_Crypto_ErrCode doTestDataCovertSymKey() {\n    const char *algName = \"3DES192\";\n    OH_CryptoSymKeyGenerator *ctx = nullptr;\n    OH_CryptoSymKey *convertKeyCtx = nullptr;\n    Crypto_DataBlob out = {.data = nullptr, .len = 0};\n    OH_Crypto_ErrCode ret;\n    uint8_t arr[] = {0xba, 0x3d, 0xc2, 0x71, 0x21, 0x1e, 0x30, 0x56, 0xad, 0x47, 0xfc, 0x5a,\n                    0x46, 0x39, 0xee, 0x7c, 0xba, 0x3b, 0xc2, 0x71, 0xab, 0xa0, 0x30, 0x72};\n    Crypto_DataBlob convertBlob = {.data = arr, .len = sizeof(arr)};\n    ret = OH_CryptoSymKeyGenerator_Create(algName, &ctx);\n    if (ret != CRYPTO_SUCCESS) {\n        return ret;\n    }\n    ret = OH_CryptoSymKeyGenerator_Convert(ctx, &convertBlob, &convertKeyCtx);\n    if (ret != CRYPTO_SUCCESS) {\n        OH_CryptoSymKeyGenerator_Destroy(ctx);\n        return ret;\n    }\n    ret = OH_CryptoSymKey_GetKeyData(convertKeyCtx, &out);\n    OH_CryptoSymKeyGenerator_Destroy(ctx);\n    OH_CryptoSymKey_Destroy(convertKeyCtx);\n    if (ret != CRYPTO_SUCCESS) {\n        return ret;\n    }\n    OH_Crypto_FreeDataBlob(&out);\n    return ret;\n}
指定二进制数据转换HMAC密钥
对应的算法规格请查看对称密钥生成和转换规格：HMAC。
 获取HMAC二进制密钥，封装成Crypto_DataBlob。 调用OH_CryptoSymKeyGenerator_Create，指定字符串参数'HMAC'，创建密钥算法为HMAC、密钥长度为[1, 32768]位的对称密钥生成器（OH_CryptoSymKeyGenerator）。 调用OH_CryptoSymKeyGenerator_Convert，根据指定的对称密钥二进制数据，生成对称密钥对象（OH_CryptoSymKey）。 调用OH_CryptoSymKey_GetKeyData，获取密钥对象的二进制数据。 
以下以生成HMAC密钥为例：
#include \"CryptoArchitectureKit/crypto_common.h\"\n#include \"CryptoArchitectureKit/crypto_sym_key.h\"\n#include <string.h>\n\nstatic OH_Crypto_ErrCode testConvertHmacKey() {\n    const char *algName = \"HMAC\";\n    OH_CryptoSymKeyGenerator *ctx = nullptr;\n    OH_CryptoSymKey *convertKeyCtx = nullptr;\n    Crypto_DataBlob out = {.data = nullptr, .len = 0};\n    OH_Crypto_ErrCode ret;\n\n    char *arr = const_cast<char *>(\"12345678abcdefgh12345678abcdefgh12345678abcdefgh12345678abcdefgh\");\n    Crypto_DataBlob convertBlob = {.data = (uint8_t *)(arr), .len = strlen(arr)};\n    ret = OH_CryptoSymKeyGenerator_Create(algName, &ctx);\n    if (ret != CRYPTO_SUCCESS) {\n        return ret;\n    }\n    ret = OH_CryptoSymKeyGenerator_Convert(ctx, &convertBlob, &convertKeyCtx);\n    if (ret != CRYPTO_SUCCESS) {\n        OH_CryptoSymKeyGenerator_Destroy(ctx);\n        return ret;\n    }\n    ret = OH_CryptoSymKey_GetKeyData(convertKeyCtx, &out);\n    OH_CryptoSymKeyGenerator_Destroy(ctx);\n    OH_CryptoSymKey_Destroy(convertKeyCtx);\n    if (ret != CRYPTO_SUCCESS) {\n        return ret;\n    }\n    OH_Crypto_FreeDataBlob(&out);\n    return ret;\n}

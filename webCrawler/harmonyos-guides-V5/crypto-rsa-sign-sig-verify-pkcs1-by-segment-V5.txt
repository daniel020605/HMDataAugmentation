使用RSA密钥对分段签名验签（PKCS1模式）(ArkTS)
对应的算法规格请查看签名验签算法规格：RSA。
签名
 调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成密钥算法为RSA、密钥长度为1024位、素数个数为2的非对称密钥对象（KeyPair），包括公钥（PubKey）和私钥（PriKey）。 如何生成RSA非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。 调用cryptoFramework.createSign，指定字符串参数'RSA1024|PKCS1|SHA256'，创建非对称密钥类型为RSA1024、填充模式为PKCS1、摘要算法为SHA256的Sign实例，用于完成签名操作。 调用Sign.init，使用私钥（PriKey）初始化Sign实例。 将一次传入数据量设置为64字节，多次调用Sign.update，传入待签名的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。 调用Sign.sign，生成数据签名。 
验签
 调用cryptoFramework.createVerify，指定字符串参数'RSA1024|PKCS1|SHA256'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。 调用Verify.init，使用公钥（PubKey）初始化Verify实例。 调用Verify.update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。 调用Verify.verify，对数据进行验签。 
 异步方法示例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nasync function signMessageBySegment(priKey: cryptoFramework.PriKey, plainText: Uint8Array) {\n  let signAlg = \"RSA1024|PKCS1|SHA256\";\n  let signer = cryptoFramework.createSign(signAlg);\n  await signer.init(priKey);\n  let textSplitLen = 64; // 自定义的数据拆分长度，此处取64\n  for (let i = 0; i < plainText.length; i += textSplitLen) {\n    let updateMessage = plainText.subarray(i, i + textSplitLen);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    // 分段update\n    await signer.update(updateMessageBlob);\n  }\n  // 已通过分段传入所有明文，故此处sign传入null\n  let signData = await signer.sign(null);\n  return signData;\n}\nasync function verifyMessagBySegment(pubKey: cryptoFramework.PubKey, plainText: Uint8Array, signMessageBlob: cryptoFramework.DataBlob) {\n  let verifyAlg = \"RSA1024|PKCS1|SHA256\";\n  let verifier = cryptoFramework.createVerify(verifyAlg);\n  await verifier.init(pubKey);\n  let textSplitLen = 64; // 自定义的数据拆分长度，此处取64\n  for (let i = 0; i < plainText.length; i += textSplitLen) {\n    let updateMessage = plainText.subarray(i, i + textSplitLen);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    // 分段update\n    await verifier.update(updateMessageBlob);\n  }\n  // 已通过分段传入所有明文，故此处verify第一个参数传入null\n  let res = await verifier.verify(null, signMessageBlob);\n  console.info(\"verify result is \" + res);\n  return res;\n}\nasync function rsaSignatureBySegment() {\n  let message = \"This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\";\n  let keyGenAlg = \"RSA1024\";\n  let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);\n  let keyPair = await generator.generateKeyPair();\n  let messageData = new Uint8Array(buffer.from(message, 'utf-8').buffer);\n  let signData = await signMessageBySegment(keyPair.priKey, messageData);\n  let verifyResult = await verifyMessagBySegment(keyPair.pubKey, messageData, signData);\n  if (verifyResult == true) {\n    console.info('verify success');\n  } else {\n    console.error('verify failed');\n  }\n} 同步方法示例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nfunction signMessageBySegment(priKey: cryptoFramework.PriKey, plainText: Uint8Array) {\n  let signAlg = \"RSA1024|PKCS1|SHA256\";\n  let signer = cryptoFramework.createSign(signAlg);\n  signer.initSync(priKey);\n  let textSplitLen = 64; // 自定义的数据拆分长度，此处取64\n  for (let i = 0; i < plainText.length; i += textSplitLen) {\n    let updateMessage = plainText.subarray(i, i + textSplitLen);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    // 分段update\n    signer.updateSync(updateMessageBlob);\n  }\n  // 已通过分段传入所有明文，故此处sign传入null\n  let signData = signer.signSync(null);\n  return signData;\n}\nfunction verifyMessagBySegment(pubKey: cryptoFramework.PubKey, plainText: Uint8Array, signMessageBlob: cryptoFramework.DataBlob) {\n  let verifyAlg = \"RSA1024|PKCS1|SHA256\";\n  let verifier = cryptoFramework.createVerify(verifyAlg);\n  verifier.initSync(pubKey);\n  let textSplitLen = 64; // 自定义的数据拆分长度，此处取64\n  for (let i = 0; i < plainText.length; i += textSplitLen) {\n    let updateMessage = plainText.subarray(i, i + textSplitLen);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    // 分段update\n    verifier.updateSync(updateMessageBlob);\n  }\n  // 已通过分段传入所有明文，故此处verify第一个参数传入null\n  let res = verifier.verifySync(null, signMessageBlob);\n  console.info(\"verify result is \" + res);\n  return res;\n}\nfunction rsaSignatureBySegment() {\n  let message = \"This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\";\n  let keyGenAlg = \"RSA1024\";\n  let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);\n  let keyPair = generator.generateKeyPairSync();\n  let messageData = new Uint8Array(buffer.from(message, 'utf-8').buffer);\n  let signData = signMessageBySegment(keyPair.priKey, messageData);\n  let verifyResult = verifyMessagBySegment(keyPair.pubKey, messageData, signData);\n  if (verifyResult == true) {\n    console.info('verify success');\n  } else {\n    console.error('verify failed');\n  }\n} 

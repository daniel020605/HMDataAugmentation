签名/验签(C/C++)
以密钥算法为RSA2048、摘要算法为SHA384、填充模式为PSS的密钥为例，完成签名、验签。具体的场景介绍及支持的算法规格，请参考签名/验签支持的算法。
在CMake脚本中链接相关动态库
target_link_libraries(entry PUBLIC libhuks_ndk.z.so)
开发步骤
生成密钥
 指定密钥别名。 初始化密钥属性集。 调用OH_Huks_GenerateKeyItem生成密钥，具体请参考密钥生成。 
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
签名
 获取密钥别名。 指定待签名的明文数据。 调用OH_Huks_InitParamSet指定算法参数配置。 调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。 调用OH_Huks_FinishSession结束密钥会话，获取签名signature。 
验签
 获取密钥别名。 获取待验证的签名signature。 指定算法参数配置。 调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。 调用OH_Huks_UpdateSession更新密钥会话。 调用OH_Huks_FinishSession结束密钥会话，验证签名。 
删除密钥
当密钥废弃不用时，需要调用OH_Huks_DeleteKeyItem删除密钥，具体请参考密钥删除。
#include \"huks/native_huks_api.h\"\n#include \"huks/native_huks_param.h\"\n#include \"napi/native_api.h\"\n#include <string.h>\nOH_Huks_Result InitParamSet(\n    struct OH_Huks_ParamSet **paramSet,\n    const struct OH_Huks_Param *params,\n    uint32_t paramCount)\n{\n    OH_Huks_Result ret = OH_Huks_InitParamSet(paramSet);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    ret = OH_Huks_AddParams(*paramSet, params, paramCount);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        OH_Huks_FreeParamSet(paramSet);\n        return ret;\n    }\n    ret = OH_Huks_BuildParamSet(paramSet);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        OH_Huks_FreeParamSet(paramSet);\n        return ret;\n    }\n    return ret;\n}\nstatic struct OH_Huks_Param g_genSignVerifyParamsTest[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_RSA\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_SIGN | OH_HUKS_KEY_PURPOSE_VERIFY\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_RSA_KEY_SIZE_2048\n    }, {\n        .tag = OH_HUKS_TAG_PADDING,\n        .uint32Param = OH_HUKS_PADDING_PSS\n    }, {\n        .tag = OH_HUKS_TAG_DIGEST,\n        .uint32Param = OH_HUKS_DIGEST_SHA384\n    },\n};\nstatic struct OH_Huks_Param g_signParamsTest[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_RSA\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_SIGN\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_RSA_KEY_SIZE_2048\n    }, {\n        .tag = OH_HUKS_TAG_PADDING,\n        .uint32Param = OH_HUKS_PADDING_PSS\n    }, {\n        .tag = OH_HUKS_TAG_DIGEST,\n        .uint32Param = OH_HUKS_DIGEST_SHA384\n    }\n};\nstatic struct OH_Huks_Param g_verifyParamsTest[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_RSA\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_VERIFY\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_RSA_KEY_SIZE_2048\n    }, {\n        .tag = OH_HUKS_TAG_PADDING,\n        .uint32Param = OH_HUKS_PADDING_PSS\n    }, {\n        .tag = OH_HUKS_TAG_DIGEST,\n        .uint32Param = OH_HUKS_DIGEST_SHA384\n    }\n};\nstatic const uint32_t RSA_COMMON_SIZE = 1024;\nstatic const char *g_dataToSign = \"Hks_RSA_Sign_Verify_Test_0000000000000000000000000000000000000000000000000000000\"\n                                    \"00000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n                                    \"0000000000000000000000000000000000000000000000000000000000000000000000000_string\";\nstatic napi_value SignVerifyKey(napi_env env, napi_callback_info info) \n{\n    struct OH_Huks_Blob g_keyAlias = {\n        (uint32_t)strlen(\"test_signVerify\"),\n        (uint8_t *)\"test_signVerify\"\n    };\n    struct OH_Huks_Blob inData = {\n        (uint32_t)strlen(g_dataToSign),\n        (uint8_t *)g_dataToSign\n    };\n    struct OH_Huks_ParamSet *genParamSet = nullptr;\n    struct OH_Huks_ParamSet *signParamSet = nullptr;\n    struct OH_Huks_ParamSet *verifyParamSet = nullptr;\n    OH_Huks_Result ohResult;\n    do {\n        ohResult = InitParamSet(&genParamSet, g_genSignVerifyParamsTest, sizeof(g_genSignVerifyParamsTest) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = InitParamSet(&signParamSet, g_signParamsTest, sizeof(g_signParamsTest) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = InitParamSet(&verifyParamSet, g_verifyParamsTest, sizeof(g_verifyParamsTest) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 1. Generate Key */\n        ohResult = OH_Huks_GenerateKeyItem(&g_keyAlias, genParamSet, nullptr);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 2. Sign */\n        // Init\n        uint8_t handleS[sizeof(uint64_t)] = {0};\n        struct OH_Huks_Blob handleSign = { (uint32_t)sizeof(uint64_t), handleS };\n        ohResult = OH_Huks_InitSession(&g_keyAlias, signParamSet, &handleSign, nullptr);\n        // Update\n        uint8_t outDataS[RSA_COMMON_SIZE] = {0};\n        struct OH_Huks_Blob outDataSign = { RSA_COMMON_SIZE, outDataS };\n        ohResult = OH_Huks_UpdateSession(&handleSign, signParamSet,  &inData, &outDataSign);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        // Finish\n        struct OH_Huks_Blob finishInData = { 0, NULL };\n        ohResult = OH_Huks_FinishSession(&handleSign, signParamSet, &finishInData, &outDataSign);\n        \n        /* 3. Verify */\n        // Init\n        uint8_t handleV[sizeof(uint64_t)] = {0};\n        struct OH_Huks_Blob handleVerify = { (uint32_t)sizeof(uint64_t), handleV };\n        ohResult = OH_Huks_InitSession(&g_keyAlias, verifyParamSet, &handleVerify, nullptr);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        // Update loop\n        uint8_t temp[] = \"out\";\n        struct OH_Huks_Blob verifyOut = { (uint32_t)sizeof(temp), temp };\n        ohResult = OH_Huks_UpdateSession(&handleVerify, verifyParamSet, &inData, &verifyOut);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        // Finish\n        ohResult = OH_Huks_FinishSession(&handleVerify, verifyParamSet, &outDataSign, &verifyOut);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n    } while (0);\n    (void)OH_Huks_DeleteKeyItem(&g_keyAlias, genParamSet);\n    OH_Huks_FreeParamSet(&genParamSet);\n    OH_Huks_FreeParamSet(&signParamSet);\n    OH_Huks_FreeParamSet(&verifyParamSet);\n    \n    napi_value ret;\n    napi_create_int32(env, ohResult.errorCode, &ret);\n    return ret;\n}

获取并使用公共目录
通过 ArkTS 接口获取并访问公共目录
目录环境能力接口（ohos.file.environment）提供获取公共目录路径的能力，支持三方应用在公共文件用户目录下进行文件访问操作。
约束限制
 使用此方式，需确认设备具有以下系统能力：SystemCapability.FileManagement.File.Environment.FolderObtain，当前仅支持2in1设备。if (!canIUse('SystemCapability.FileManagement.File.Environment.FolderObtain')) {\n    console.error('this api is not supported on this device');\n    return;\n} 公共目录获取接口仅用于获取公共目录路径，不对公共目录访问权限进行校验。若需访问公共目录需申请对应的公共目录访问权限。三方应用需要访问公共目录时，需通过弹窗授权向用户申请授予 Download 目录权限、Documents 目录权限或 Desktop 目录权限，具体参考访问控制-向用户申请授权。 
   \"requestPermissions\" : [\n       \"ohos.permission.READ_WRITE_DOWNLOAD_DIRECTORY\",\n       \"ohos.permission.READ_WRITE_DOCUMENTS_DIRECTORY\",\n   ]
[h2]示例
 获取公共目录路径。  import { BusinessError } from '@kit.BasicServicesKit';\n import { Environment } from '@kit.CoreFileKit';\n\n function getUserDirExample() {\n     try {\n         const downloadPath = Environment.getUserDownloadDir();\n         console.info(`success to getUserDownloadDir: ${downloadPath}`);\n         const documentsPath = Environment.getUserDocumentDir();\n         console.info(`success to getUserDocumentDir: ${documentsPath}`);\n     } catch (error) {\n         const err: BusinessError = error as BusinessError;\n         console.error(`failed to get user dir, because: ${JSON.stringify(err)}`);\n     }\n } 以 Download 目录为例，访问 Download 目录下的文件。  import { BusinessError } from '@kit.BasicServicesKit';\n import { Environment } from '@kit.CoreFileKit';\n import { fileIo as fs } from '@kit.CoreFileKit';\n import { common } from '@kit.AbilityKit';\n\n function readUserDownloadDirExample() {\n     // 检查是否具有 READ_WRITE_DOWNLOAD_DIRECTORY 权限，无权限则需要向用户申请授予权限。\n     try {\n         // 获取 Download 目录\n         const downloadPath = Environment.getUserDownloadDir();\n         console.info(`success to getUserDownloadDir: ${downloadPath}`);\n         const context = getContext() as common.UIAbilityContext;\n         const dirPath = context.filesDir;\n         console.info(`success to get filesDir: ${dirPath}`);\n         // 查看 Download 目录下的文件并拷贝到沙箱目录中\n         let fileList: string[] = fs.listFileSync(downloadPath);\n         fileList.forEach((file, index) => {\n             console.info(`${downloadPath} ${index}: ${file}`);\n             fs.copyFileSync(`${downloadPath}/${file}`, `${dirPath}/${file}`);\n         });\n         // 查看沙箱目录下对应的文件\n         fileList = fs.listFileSync(dirPath);\n         fileList.forEach((file, index) => {\n             console.info(`${dirPath} ${index}: ${file}`);\n         });\n     } catch (error) {\n         const err: BusinessError = error as BusinessError;\n         console.error(`Error code: ${err.code}, message: ${err.message}`);\n     }\n } 以 Download 目录为例，保存文件到 Download 目录。  import { BusinessError } from '@kit.BasicServicesKit';\n import { Environment } from '@kit.CoreFileKit';\n import { fileIo as fs } from '@kit.CoreFileKit';\n\n function writeUserDownloadDirExample() {\n // 检查是否具有 READ_WRITE_DOWNLOAD_DIRECTORY 权限，无权限则需要向用户申请授予权限。\n     try {\n         // 获取 Download 目录\n         const downloadPath = Environment.getUserDownloadDir();\n         console.info(`success to getUserDownloadDir: ${downloadPath}`);\n         // 保存 temp.txt 到 Download 目录下\n         const file = fs.openSync(`${downloadPath}/temp.txt`, fs.OpenMode.CREATE | fs.OpenMode.READ_WRITE);\n         fs.writeSync(file.fd, 'write a message');\n         fs.closeSync(file);\n     } catch (error) {\n         const err: BusinessError = error as BusinessError;\n         console.error(`Error code: ${err.code}, message: ${err.message}`);\n     }\n } 
通过 C/C++ 接口获取并使用公共目录
除了通过 ArkTS 访问公共目录的方式，也可通过 C/C++ 接口进行目录访问，具体可以参考 Environment。
约束限制
 使用此接口，需确认设备具有以下系统能力：SystemCapability.FileManagement.File.Environment.FolderObtain。 三方应用需要访问公共目录时，需通过弹窗授权向用户申请授予 Download 目录权限、Documents 目录权限或 Desktop 目录权限，具体参考访问控制-向用户申请授权。 
[h2]接口说明
接口的详细说明，请参考API参考
[h2]开发步骤
在CMake脚本中链接动态库
CMakeLists.txt中添加以下lib。
target_link_libraries(sample PUBLIC libohenvironment.so libhilog_ndk.z.so)
添加头文件
#include <filemanagement/environment/oh_environment.h>\n#include <filemanagement/fileio/oh_fileio.h>\n#include <hilog/log.h>
 调用 OH_Environment_GetUserDownloadDir 接口获取用户 Download 目录沙箱路径，在接口中使用malloc申请的内存需要在使用完后释放因此需要free对应的内存。示例代码如下所示： void GetUserDownloadDirExample()\n{\n    char *downloadPath = nullptr;\n    FileManagement_ErrCode ret = OH_Environment_GetUserDownloadDir(&downloadPath);\n    if (ret == 0) {\n        OH_LOG_INFO(LOG_APP, \"Download Path=%{public}s\", downloadPath);\n        free(downloadPath);\n    } else {\n        OH_LOG_ERROR(LOG_APP, \"GetDownloadPath fail, error code is %{public}d\", ret);\n    }\n} 调用 OH_Environment_GetUserDownloadDir 接口获取用户 Download 目录沙箱路径，并查看 Download 目录下的文件。示例代码如下所示： void ScanUserDownloadDirPathExample()\n{\n    // 获取 download 路径\n    char *downloadPath = nullptr;\n    FileManagement_ErrCode ret = OH_Environment_GetUserDownloadDir(&downloadPath);\n    if (ret == 0) {\n        OH_LOG_INFO(LOG_APP, \"Download Path=%{public}s\", downloadPath);\n    } else {\n        OH_LOG_ERROR(LOG_APP, \"GetDownloadPath fail, error code is %{public}d\", ret);\n        return;\n    }\n    // 查看文件夹下的文件\n    struct dirent **namelist = {nullptr};\n    int num = scandir(downloadPath, &namelist, nullptr, nullptr);\n    if (num < 0) {\n        free(downloadPath);\n        OH_LOG_ERROR(LOG_APP, \"Failed to scan dir\");\n        return;\n    }\n    for (int i = 0; i < num; i++) {\n        OH_LOG_INFO(LOG_APP, \"%{public}s\", namelist[i]->d_name);\n    }\n    free(downloadPath);\n    free(namelist);\n} 调用 OH_Environment_GetUserDownloadDir 接口获取用户 Download 目录沙箱路径，并保存 temp.txt 到 Download 目录下。示例代码如下所示： void WriteUserDownloadDirPathExample()\n{\n    // 获取 download 路径\n    char *downloadPath = nullptr;\n    FileManagement_ErrCode ret = OH_Environment_GetUserDownloadDir(&downloadPath);\n    if (ret == 0) {\n        OH_LOG_INFO(LOG_APP, \"Download Path=%{public}s\", downloadPath);\n    } else {\n        OH_LOG_ERROR(LOG_APP, \"GetDownloadPath fail, error code is %{public}d\", ret);\n        return;\n    }\n    // 保存文件到 download 目录下\n    std::string filePath = std::string(downloadPath) + \"/temp.txt\";\n    free(downloadPath);\n\n    std::ofstream outfile;\n    outfile.open(filePath.c_str());\n    if (!outfile) {\n        OH_LOG_ERROR(LOG_APP, \"Failed to open file\");\n        return;\n    }\n    std::string msg = \"Write a message\";\n    outfile.write(msg.c_str(), sizeof(msg));\n    outfile.close();\n} 

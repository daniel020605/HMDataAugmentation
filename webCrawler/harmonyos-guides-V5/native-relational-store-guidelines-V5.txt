RelationalStore开发指导 (C/C++)
场景介绍
RelationalStore提供了一套完整的对本地数据库进行管理的机制，对外提供了一系列的增、删、改、查等接口，也可以直接运行用户输入的SQL语句来满足复杂的场景需要。
基本概念
 谓词：数据库中用来代表数据实体的性质、特征或者数据实体之间关系的词项，主要用来定义数据库的操作条件。 结果集：指用户查询之后的结果集合，可以对数据进行访问。结果集提供了灵活的数据访问方式，可以更方便地拿到用户想要的数据。 
约束限制
 系统默认日志方式是WAL（Write Ahead Log）模式，系统默认落盘方式是FULL模式。 数据库中连接池的最大数量是4个，用以管理用户的读操作。 为保证数据的准确性，数据库同一时间只能支持一个写操作。 当应用被卸载完成后，设备上的相关数据库文件及临时文件会被自动清除。 使用API11新增的端云同步等接口时，需要确保已实现云服务功能。 
接口说明
详细的接口说明请参考RDB。
开发步骤
添加动态链接库
CMakeLists.txt中添加以下lib。
libnative_rdb_ndk.z.so
头文件
#include <database/data/data_asset.h>\n#include <database/rdb/oh_cursor.h>\n#include <database/rdb/oh_predicates.h>\n#include <database/rdb/oh_value_object.h>\n#include <database/rdb/oh_values_bucket.h>\n#include <database/rdb/relational_store.h>\n#include <database/rdb/relational_store_error_code.h>
 获取OH_Rdb_Store实例，创建数据库文件。其中dataBaseDir变量为应用沙箱路径，Stage模式下建议使用数据库目录，参考Context的databaseDir属性。FA模式下，由于没有接口获取数据库沙箱路径，可使用应用程序的文件目录，可参考Context的getFilesDir接口。area为数据库文件存放的安全区域，详见contextConstant，开发时需要实现由AreaMode枚举值对Rdb_SecurityArea枚举值的转换。示例代码如下所示： // 创建OH_Rdb_Config对象\nOH_Rdb_Config config;\n// 该路径为应用沙箱路径\nconfig.dataBaseDir = \"xxx\";\n// 数据库文件名\nconfig.storeName = \"RdbTest.db\";\n// 应用包名\nconfig.bundleName = \"xxx\";\n// 应用模块名\nconfig.moduleName = \"xxx\";\n// 数据库文件安全等级\nconfig.securityLevel = OH_Rdb_SecurityLevel::S1;\n// 数据库是否加密\nconfig.isEncrypt = false;\n// config所占内存大小\nconfig.selfSize = sizeof(OH_Rdb_Config);\n// 数据库文件存放的安全区域\nconfig.area = RDB_SECURITY_AREA_EL1;\n\nint errCode = 0;\n// 获取OH_Rdb_Store实例\nOH_Rdb_Store *store_ = OH_Rdb_GetOrOpen(&config, &errCode); 获取到OH_Rdb_Store后，调用OH_Rdb_Execute接口创建表，并调用OH_Rdb_Insert接口插入数据。示例代码如下所示： char createTableSql[] = \"CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, \"\n                        \"AGE INTEGER, SALARY REAL, CODES BLOB)\";\n// 执行建表语句\nOH_Rdb_Execute(store_, createTableSql);\n\n// 创建键值对实例\nOH_VBucket *valueBucket = OH_Rdb_CreateValuesBucket();\nvalueBucket->putText(valueBucket, \"NAME\", \"Lisa\");\nvalueBucket->putInt64(valueBucket, \"AGE\", 18);\nvalueBucket->putReal(valueBucket, \"SALARY\", 100.5);\nuint8_t arr[] = {1, 2, 3, 4, 5};\nint len = sizeof(arr) / sizeof(arr[0]);\nvalueBucket->putBlob(valueBucket, \"CODES\", arr, len);\n// 插入数据\nint rowId = OH_Rdb_Insert(store_, \"EMPLOYEE\", valueBucket);\n// 销毁键值对实例\nvalueBucket->destroy(valueBucket);     关系型数据库没有显式的flush操作实现持久化，数据插入即保存在持久化文件。   根据谓词指定的实例对象，对数据进行修改或删除。 调用OH_Rdb_Update方法修改数据，调用OH_Rdb_Delete方法删除数据。示例代码如下所示： // 修改数据\nOH_VBucket *valueBucket = OH_Rdb_CreateValuesBucket();\nvalueBucket->putText(valueBucket, \"NAME\", \"Rose\");\nvalueBucket->putInt64(valueBucket, \"AGE\", 22);\nvalueBucket->putReal(valueBucket, \"SALARY\", 200.5);\nuint8_t arr[] = {1, 2, 3, 4, 5};\nint len = sizeof(arr) / sizeof(arr[0]);\nvalueBucket->putBlob(valueBucket, \"CODES\", arr, len);\n\nOH_Predicates *predicates = OH_Rdb_CreatePredicates(\"EMPLOYEE\");\nOH_VObject *valueObject = OH_Rdb_CreateValueObject();\nconst char *name = \"Lisa\";\nvalueObject->putText(valueObject, name);\npredicates->equalTo(predicates, \"NAME\", valueObject)->andOperate(predicates);\nuint32_t count = 1;\ndouble salary = 100.5;\nvalueObject->putDouble(valueObject, &salary, count);\npredicates->equalTo(predicates, \"SALARY\", valueObject);\n    \nint changeRows = OH_Rdb_Update(store_, valueBucket, predicates);\nvalueObject->destroy(valueObject);\nvalueBucket->destroy(valueBucket);\npredicates->destroy(predicates); // 删除数据\nOH_Predicates *predicates = OH_Rdb_CreatePredicates(\"EMPLOYEE\");\nOH_VObject *valueObject = OH_Rdb_CreateValueObject();\nconst char *name = \"Lisa\";\nvalueObject->putText(valueObject, name);\npredicates->equalTo(predicates, \"NAME\", valueObject);\nint deleteRows = OH_Rdb_Delete(store_, predicates);\nvalueObject->destroy(valueObject);\npredicates->destroy(predicates); 根据谓词指定的查询条件查找数据。 调用OH_Rdb_Query方法查找数据，返回一个OH_Cursor结果集。示例代码如下所示： OH_Predicates *predicates = OH_Rdb_CreatePredicates(\"EMPLOYEE\");\n\nconst char *columnNames[] = {\"NAME\", \"AGE\"};\nint len = sizeof(columnNames) / sizeof(columnNames[0]);\nOH_Cursor *cursor = OH_Rdb_Query(store_, predicates, columnNames, len);\n\nint columnCount = 0;\ncursor->getColumnCount(cursor, &columnCount);\n\n// OH_Cursor是一个数据集合的游标，默认指向第-1个记录，有效的数据从0开始\nint64_t age;\nwhile (cursor->goToNextRow(cursor) == OH_Rdb_ErrCode::RDB_OK) {\n    cursor->getInt64(cursor, 1, &age);\n}\n\n// 释放谓词实例\npredicates->destroy(predicates);\n// 释放结果集\ncursor->destroy(cursor); 向数据库表中插入资产类型数据。 // 列的属性为单个资产类型时，sql语句中应指定为asset，多个资产类型应指定为assets。\nchar createAssetTableSql[] = \"CREATE TABLE IF NOT EXISTS asset_table (id INTEGER PRIMARY KEY AUTOINCREMENT, data1 asset, data2 assets );\";\nerrCode = OH_Rdb_Execute(store_, createAssetTableSql);\nData_Asset *asset = OH_Data_Asset_CreateOne();\nOH_Data_Asset_SetName(asset, \"name0\");\nOH_Data_Asset_SetUri(asset, \"uri0\");\nOH_Data_Asset_SetPath(asset, \"path0\");\nOH_Data_Asset_SetCreateTime(asset, 1);\nOH_Data_Asset_SetModifyTime(asset, 1);\nOH_Data_Asset_SetSize(asset, 1);\nOH_Data_Asset_SetStatus(asset, Data_AssetStatus::ASSET_NORMAL);\nerrCode = OH_VBucket_PutAsset(valueBucket, \"data1\", asset);\n\nData_Asset **assets = OH_Data_Asset_CreateMultiple(2);\n\nOH_Data_Asset_SetName(assets[0], \"name0\");\nOH_Data_Asset_SetUri(assets[0], \"uri0\");\nOH_Data_Asset_SetPath(assets[0], \"path0\");\nOH_Data_Asset_SetCreateTime(assets[0], 1);\nOH_Data_Asset_SetModifyTime(assets[0], 1);\nOH_Data_Asset_SetSize(assets[0], 1);\nOH_Data_Asset_SetStatus(assets[0], Data_AssetStatus::ASSET_NORMAL);\n\nOH_Data_Asset_SetName(assets[1], \"name1\");\nOH_Data_Asset_SetUri(assets[1], \"uri1\");\nOH_Data_Asset_SetPath(assets[1], \"path1\");\nOH_Data_Asset_SetCreateTime(assets[1], 1);\nOH_Data_Asset_SetModifyTime(assets[1], 1);\nOH_Data_Asset_SetSize(assets[1], 1);\nOH_Data_Asset_SetStatus(assets[1], Data_AssetStatus::ASSET_NORMAL);\n\nerrCode = OH_VBucket_PutAssets(valueBucket, \"data2\", assets, assetsCount);\nint rowID = OH_Rdb_Insert(cursorTestRdbStore_, table, valueBucket);\n// 释放Data_Asset*和Data_Asset**\nOH_Data_Asset_DestroyMultiple(assets, 2);\nOH_Data_Asset_DestroyOne(asset); 从结果集中读取资产类型数据。 OH_Predicates *predicates = OH_Rdb_CreatePredicates(\"asset_table\");\n\nOH_Cursor *cursor = OH_Rdb_Query(cursorTestRdbStore_, predicates, NULL, 0);\ncursor->goToNextRow(cursor);\n\nuint32_t assetCount = 0;\n// assetCount作为出参获取该列资产类型数据的数量\nerrCode = cursor->getAssets(cursor, 2, nullptr, &assetCount);\nData_Asset **assets = OH_Data_Asset_CreateMultiple(assetCount);\nerrCode = cursor->getAssets(cursor, 2, assets, &assetCount);\nData_Asset *asset = assets[1];\n\nchar name[10] = \"\";\nsize_t nameLength = 10;\nerrCode = OH_Data_Asset_GetName(asset, name, &nameLength);\n\nchar uri[10] = \"\";\nsize_t uriLength = 10;\nerrCode = OH_Data_Asset_GetUri(asset, uri, &uriLength);\n\nchar path[10] = \"\";\nsize_t pathLength = 10;\nerrCode = OH_Data_Asset_GetPath(asset, path, &pathLength);\n\nint64_t createTime = 0;\nerrCode = OH_Data_Asset_GetCreateTime(asset, &createTime);\n\nint64_t modifyTime = 0;\nerrCode = OH_Data_Asset_GetModifyTime(asset, &modifyTime);\n\nsize_t size = 0;\nerrCode = OH_Data_Asset_GetSize(asset, &size);\n\nData_AssetStatus status = Data_AssetStatus::ASSET_NULL;\nerrCode = OH_Data_Asset_GetStatus(asset, &status);\n\npredicates->destroy(predicates);\nOH_Data_Asset_DestroyMultiple(assets, assetCount);\ncursor->destroy(cursor); 查询数据的最后修改时间。调用OH_Rdb_FindModifyTime查询指定表中指定列的数据的最后修改时间，该接口返回一个有两列数据的OH_Cursor对象，第一列为传入的主键/RowId，第二列为最后修改时间。示例代码如下所示： OH_VObject *values = OH_Rdb_CreateValueObject();\nint64_t keys[] = { 1 };\nvalues->putInt64(values, keys, 1);\nOH_Cursor *cursor;\ncursor = OH_Rdb_FindModifyTime(store_, \"EMPLOYEE\", \"ROWID\", values); 创建分布式表。调用OH_Rdb_Execute接口创建表之后，可以将已创建的表设置成分布式表，并配置相关的分布式选项。使用该接口需要实现云服务功能。示例代码如下所示： constexpr int TABLE_COUNT = 1;\nconst char *table[TABLE_COUNT];\ntable[0] = \"EMPLOYEE\";\nint errcode = OH_Rdb_SetDistributedTables(store_, table, TABLE_COUNT, Rdb_DistributedType::DISTRIBUTED_CLOUD, &config); 对分布式表手动执行端云同步。调用OH_Rdb_SetDistributedTables创建分布式表之后，可以对该表进行手动端云同步。使用该接口需要实现云服务功能。示例代码如下所示： // 定义回调函数\nvoid CloudSyncObserverCallback(void *context, Rdb_ProgressDetails *progressDetails)\n{\n// do something\n}\nconst Rdb_ProgressObserver observer = { .context = nullptr, .callback = CloudSyncObserverCallback };\nOH_Rdb_CloudSync(store_, Rdb_SyncMode::SYNC_MODE_TIME_FIRST, table, TABLE_COUNT, &observer); 将数据观察者注册到指定的存储对象(store)上，并订阅指定类型(type)的事件。在数据发生变化时，系统会调用相应的回调函数来处理进度观察。调用OH_Rdb_Subscribe接口订阅数据变化事件。使用该接口需要实现云服务功能。示例代码如下所示： // 定义回调函数\nvoid RdbSubscribeBriefCallback(void *context, const char *values[], uint32_t count)\n{\n// do something\n}\nRdb_BriefObserver briefObserver;\nconst Rdb_BriefObserver briefObserver = { .context = nullptr, .callback = RdbSubscribeBriefCallback };\n// 订阅数据变化\nOH_Rdb_Subscribe(store_, Rdb_SubscribeType::RDB_SUBSCRIBE_TYPE_CLOUD, &briefObserver); 调用OH_Rdb_Subscribe接口订阅本地数据库数据变更的事件。示例代码如下所示： // 定义回调函数\nvoid LocalDataChangeObserverCallback1(void *context, const Rdb_ChangeInfo **changeInfo, uint32_t count)\n{\n   for (uint32_t i = 0; i < count; i++) {\n      EXPECT_EQ(DISTRIBUTED_CHANGE_INFO_VERSION, changeInfo[i]->version);\n      // 表名为employee\n      changeInfo[i]->tableName;\n      changeInfo[i]->ChangeType;\n      // 添加行数为1\n      changeInfo[i]->inserted.count;\n      // 修改行数为0\n      changeInfo[i]->updated.count;\n      // 删除行数为0\n      changeInfo[i]->deleted.count;\n   }\n}\nRdb_DetailsObserver callback = LocalDataChangeObserverCallback1;\nRdb_DataObserver observer = { nullptr, { callback } };\n// 订阅本地数据库数据变更的事件\nOH_Rdb_Subscribe(store_, Rdb_SubscribeType::RDB_SUBSCRIBE_TYPE_LOCAL_DETAILS, &observer);\n\nOH_VBucket* valueBucket = OH_Rdb_CreateValuesBucket();\nvalueBucket->putText(valueBucket, \"NAME\", \"Lisa\");\nvalueBucket->putInt64(valueBucket, \"AGE\", 18);\nvalueBucket->putReal(valueBucket, \"SALARY\", 100.5);\nuint8_t arr[] = {1, 2, 3, 4, 5};\nint len = sizeof(arr) / sizeof(arr[0]);\nvalueBucket->putBlob(valueBucket, \"CODES\", arr, len);\n// 插入数据\nint rowId = OH_Rdb_Insert(store_, \"EMPLOYEE\", valueBucket);\n// 销毁键值对实例\nvalueBucket->destroy(valueBucket); 从指定的存储对象(store)中取消对指定类型(type)的事件的订阅。取消后，系统将不再调用相应的回调函数来处理进度观察。调用OH_Rdb_Unsubscribe接口取消订阅数据变化事件。使用该接口需要实现云服务功能。示例代码如下所示： // 定义回调函数\nvoid RdbSubscribeBriefCallback(void *context, const char *values[], uint32_t count)\n{\n// do something\n}\nRdb_BriefObserver briefObserver = RdbSubscribeBriefCallback;\nconst Rdb_DataObserver briefObs = { .context = nullptr, .callback.briefObserver = briefObserver };\n// 取消订阅数据变化事件\nOH_Rdb_Unsubscribe(store_, Rdb_SubscribeType::RDB_SUBSCRIBE_TYPE_CLOUD, &briefObs); 调用OH_Rdb_Unsubscribe接口取消订阅本地数据库数据变更的事件。示例代码如下所示： // 定义回调函数\nvoid LocalDataChangeObserverCallback1(void *context, const Rdb_ChangeInfo **changeInfo, uint32_t count)\n{\n// do something\n}\nRdb_DetailsObserver callback = LocalDataChangeObserverCallback1;\nRdb_DataObserver observer = { nullptr, { callback } };\n// 取消订阅本地数据库数据变更的事件\nOH_Rdb_Unsubscribe(store_, Rdb_SubscribeType::RDB_SUBSCRIBE_TYPE_LOCAL_DETAILS, &observer); 将进度观察者注册到指定的存储对象(store)上，以便订阅自动同步进度的事件。当存储对象进行自动同步时，系统会调用相应的回调函数处理进度观察。调用OH_Rdb_SubscribeAutoSyncProgress接口订阅自动同步进度事件。使用该接口需要实现云服务功能。示例代码如下所示： // 定义回调函数\nvoid RdbProgressObserverCallback(void *context, Rdb_ProgressDetails *progressDetails)\n{\n// do something\n}\nconst Rdb_ProgressObserver observer = { .context = nullptr, .callback = RdbProgressObserverCallback };\nOH_Rdb_SubscribeAutoSyncProgress(store_, &observer); 从指定的存储对象(store)中取消订阅自动同步进度的事件。取消后，系统将不再调用相应的回调函数来处理进度观察。调用OH_Rdb_UnsubscribeAutoSyncProgress接口取消订阅自动同步进度事件。使用该接口需要实现云服务功能。示例代码如下所示： // 定义回调函数\nvoid RdbProgressObserverCallback(void *context, Rdb_ProgressDetails *progressDetails)\n{\n// do something\n}\nconst Rdb_ProgressObserver observer = { .context = nullptr, .callback = RdbProgressObserverCallback };\nOH_Rdb_UnsubscribeAutoSyncProgress(store_, &observer); 删除数据库。调用OH_Rdb_DeleteStore方法，删除数据库及数据库相关文件。示例代码如下： // 释放数据库实例\nOH_Rdb_CloseStore(store_);\n// 删除数据库文件\nOH_Rdb_DeleteStore(&config); 

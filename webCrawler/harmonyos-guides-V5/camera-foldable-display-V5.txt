适配不同折叠状态的摄像头变更(ArkTS)
在开发相机应用时，需要先参考开发准备申请相关权限。
一台可折叠设备在不同折叠状态下，可使用不同的摄像头，应用可调用CameraManager.on('foldStatusChange')或display.on('foldStatusChange')监听设备的折叠状态变化，并调用CameraManager.getSupportedCameras获取当前状态下可用摄像头，完成相应适配，确保应用在折叠状态变更时的用户体验。
详细的API说明请参考Camera API参考。
创建XComponent
使用两个XComponent分别展示折叠态和展开态，防止切换折叠屏状态亮屏的时候上一个摄像头还未关闭，残留上一个摄像头的画面。
 @Entry\n @Component\n struct Index {\n   @State reloadXComponentFlag: boolean = false;\n   @StorageLink('foldStatus') @Watch('reloadXComponent') foldStatus: number = 0;\n   private mXComponentController: XComponentController = new XComponentController();\n   private mXComponentOptions: XComponentOptions = {\n     type: XComponentType.SURFACE,\n     controller: this.mXComponentController\n   }\n\n   reloadXComponent() {\n     this.reloadXComponentFlag = !this.reloadXComponentFlag;\n   }\n\n   async loadXComponent() {\n     //初始化XComponent\n   }\n\n   build() {\n     Stack() {\n       if (this.reloadXComponentFlag) {\n         XComponent(this.mXComponentOptions)\n           .onLoad(async () => {\n             await this.loadXComponent();\n           })\n           .width(px2vp(1080))\n           .height(px2vp(1920))\n       } else {\n         XComponent(this.mXComponentOptions)\n           .onLoad(async () => {\n             await this.loadXComponent();\n           })\n           .width(px2vp(1080))\n           .height(px2vp(1920))\n       }\n     }\n     .size({ width: '100%', height: '100%' })\n     .backgroundColor(Color.Black)\n   }\n }
获取设备折叠状态
此处提供两种方案供开发者选择。
 方案一：使用相机框架提供的CameraManager.on('foldStatusChange')监听设备折叠态变化。import { camera } from '@kit.CameraKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet cameraManager = camera.getCameraManager(getContext())\n\nfunction registerFoldStatusChanged(err: BusinessError, foldStatusInfo: camera.FoldStatusInfo) {\n  // foldStatus 变量用来控制显示XComponent组件\n  AppStorage.setOrCreate<number>('foldStatus', foldStatusInfo.foldStatus);\n}\n\ncameraManager.on('foldStatusChange', registerFoldStatusChanged);\n//cameraManager.off('foldStatusChange', registerFoldStatusChanged); 方案二：使用图形图像的display.on('foldStatusChange')监听设备折叠态变化。import { display } from '@kit.ArkUI';\nlet preFoldStatus: display.FoldStatus = display.getFoldStatus();\ndisplay.on('foldStatusChange', (foldStatus: display.FoldStatus) => {\n  // 从半折叠态（FOLD_STATUS_HALF_FOLDED）和展开态（FOLD_STATUS_EXPANDED），相机框架返回所支持的摄像头是一致的，所以从半折叠态到展开态不需要重新配流，从展开态到半折叠态也是一样的\n  if ((preFoldStatus === display.FoldStatus.FOLD_STATUS_HALF_FOLDED &&\n    foldStatus === display.FoldStatus.FOLD_STATUS_EXPANDED) ||\n    (preFoldStatus === display.FoldStatus.FOLD_STATUS_EXPANDED &&\n      foldStatus === display.FoldStatus.FOLD_STATUS_HALF_FOLDED)) {\n    preFoldStatus = foldStatus;\n    return;\n  }\n  preFoldStatus = foldStatus;\n  // foldStatus 变量用来控制显示XComponent组件\n  AppStorage.setOrCreate<number>('foldStatus', foldStatus);\n}) 
完整示例
import { camera } from '@kit.CameraKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { abilityAccessCtrl } from '@kit.AbilityKit';\nimport { display } from '@kit.ArkUI';\n\nlet context = getContext(this);\n\nconst TAG = 'FoldScreenCameraAdaptationDemo ';\n\n@Entry\n@Component\nstruct Index {\n  @State isShow: boolean = false;\n  @State reloadXComponentFlag: boolean = false;\n  @StorageLink('foldStatus') @Watch('reloadXComponent') foldStatus: number = 0;\n  private mXComponentController: XComponentController = new XComponentController();\n  private mXComponentOptions: XComponentOptions = {\n    type: XComponentType.SURFACE,\n    controller: this.mXComponentController\n  }\n  private mSurfaceId: string = '';\n  private mCameraPosition: camera.CameraPosition = camera.CameraPosition.CAMERA_POSITION_BACK;\n  private mCameraManager: camera.CameraManager = camera.getCameraManager(context);\n  // surface宽高根据需要自行选择\n  private surfaceRect: SurfaceRect = {\n    surfaceWidth: 1080,\n    surfaceHeight: 1920\n  };\n  private curCameraDevice: camera.CameraDevice | undefined = undefined;\n  private mCameraInput: camera.CameraInput | undefined = undefined;\n  private mPreviewOutput: camera.PreviewOutput | undefined = undefined;\n  private mPhotoSession: camera.PhotoSession | undefined = undefined;\n  // One of the recommended preview resolutions\n  private previewProfileObj: camera.Profile = {\n    format: 1003,\n    size: {\n      width: 1920,\n      height: 1080\n    }\n  };\n\n  private preFoldStatus: display.FoldStatus = display.getFoldStatus();\n  // 监听折叠屏状态，可以使用cameraManager.on(type: 'foldStatusChange', callback: AsyncCallback<FoldStatusInfo>): void;\n  // 也可以使用display.on(type: 'foldStatusChange', callback: Callback<FoldStatus>): void;\n  private foldStatusCallback =\n    (err: BusinessError, info: camera.FoldStatusInfo): void => this.registerFoldStatusChanged(err, info);\n  private displayFoldStatusCallback =\n    (foldStatus: display.FoldStatus): void => this.onDisplayFoldStatusChange(foldStatus);\n\n\n  registerFoldStatusChanged(err: BusinessError, foldStatusInfo: camera.FoldStatusInfo) {\n    console.info(TAG + 'foldStatusChanged foldStatus: ' + foldStatusInfo.foldStatus);\n    for (let i = 0; i < foldStatusInfo.supportedCameras.length; i++) {\n      console.info(TAG +\n        `foldStatusChanged camera[${i}]: ${foldStatusInfo.supportedCameras[i].cameraId},cameraPosition: ${foldStatusInfo.supportedCameras[i].cameraPosition}`);\n    }\n    AppStorage.setOrCreate<number>('foldStatus', foldStatusInfo.foldStatus);\n  }\n\n  onDisplayFoldStatusChange(foldStatus: display.FoldStatus): void {\n    console.error(TAG + `onDisplayFoldStatusChange foldStatus: ${foldStatus}`);\n    if ((this.preFoldStatus === display.FoldStatus.FOLD_STATUS_HALF_FOLDED &&\n      foldStatus === display.FoldStatus.FOLD_STATUS_EXPANDED) ||\n      (this.preFoldStatus === display.FoldStatus.FOLD_STATUS_EXPANDED &&\n        foldStatus === display.FoldStatus.FOLD_STATUS_HALF_FOLDED)) {\n      this.preFoldStatus = foldStatus;\n      return;\n    }\n    this.preFoldStatus = foldStatus;\n    // 获取当前打开的相机摄像头，如果是后置，折叠状态不影响当前摄像头的使用\n    if (!this.curCameraDevice) {\n      return;\n    }\n    // foldStatus 变量用来控制显示XComponent组件\n    AppStorage.setOrCreate<number>('foldStatus', foldStatus);\n  }\n\n  requestPermissionsFn(): void {\n    let atManager = abilityAccessCtrl.createAtManager();\n    atManager.requestPermissionsFromUser(context, [\n      'ohos.permission.CAMERA'\n    ]).then((): void => {\n      this.isShow = true;\n    }).catch((error: BusinessError): void => {\n      console.error(TAG + 'ohos.permission.CAMERA no permission.');\n    });\n  }\n\n  aboutToAppear(): void {\n    console.log(TAG + 'aboutToAppear is called');\n    this.requestPermissionsFn();\n    this.onFoldStatusChange();\n  }\n\n  async aboutToDisappear(): Promise<void> {\n    await this.releaseCamera();\n    // 解注册\n    this.offFoldStatusChange();\n  }\n\n  async onPageShow(): Promise<void> {\n    await this.initCamera(this.mSurfaceId, this.mCameraPosition);\n  }\n\n  async releaseCamera(): Promise<void> {\n    // 停止当前会话\n    try {\n      await this.mPhotoSession?.stop();\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to stop session, errorCode = ' + err.code);\n    }\n\n    // 释放相机输入流\n    try {\n      await this.mCameraInput?.close();\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to close device, errorCode = ' + err.code);\n    }\n\n    // 释放预览输出流\n    try {\n      await this.mPreviewOutput?.release();\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to release previewOutput, errorCode = ' + err.code);\n    }\n\n    this.mPreviewOutput = undefined;\n\n    // 释放会话\n    try {\n      await this.mPhotoSession?.release();\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to release photoSession, errorCode = ' + err.code);\n    }\n\n    // 会话置空\n    this.mPhotoSession = undefined;\n  }\n\n  onFoldStatusChange(): void {\n    this.mCameraManager.on('foldStatusChange', this.foldStatusCallback);\n    // display.on('foldStatusChange', this.displayFoldStatusCallback);\n  }\n\n  offFoldStatusChange(): void {\n    this.mCameraManager.off('foldStatusChange', this.foldStatusCallback);\n    // display.off('foldStatusChange', this.displayFoldStatusCallback);\n  }\n\n  reloadXComponent(): void {\n    this.reloadXComponentFlag = !this.reloadXComponentFlag;\n  }\n\n  async loadXComponent(): Promise<void> {\n    this.mSurfaceId = this.mXComponentController.getXComponentSurfaceId();\n    this.mXComponentController.setXComponentSurfaceRect(this.surfaceRect);\n    console.info(TAG + `mCameraPosition: ${this.mCameraPosition}`)\n    await this.initCamera(this.mSurfaceId, this.mCameraPosition);\n  }\n\n  getPreviewProfile(cameraOutputCapability: camera.CameraOutputCapability): camera.Profile | undefined {\n    let previewProfiles = cameraOutputCapability.previewProfiles;\n    if (previewProfiles.length < 1) {\n      return undefined;\n    }\n    let index = previewProfiles.findIndex((previewProfile: camera.Profile) => {\n      return previewProfile.size.width === this.previewProfileObj.size.width &&\n        previewProfile.size.height === this.previewProfileObj.size.height &&\n        previewProfile.format === this.previewProfileObj.format;\n    })\n    if (index === -1) {\n      return undefined;\n    }\n    return previewProfiles[index];\n  }\n\n  async initCamera(surfaceId: string, cameraPosition: camera.CameraPosition): Promise<void> {\n    await this.releaseCamera();\n    // 创建CameraManager对象\n    if (!this.mCameraManager) {\n      console.error(TAG + 'camera.getCameraManager error');\n      return;\n    }\n\n    // 获取相机列表\n    let cameraArray: Array<camera.CameraDevice> = this.mCameraManager.getSupportedCameras();\n    if (cameraArray.length <= 0) {\n      console.error(TAG + 'cameraManager.getSupportedCameras error');\n      return;\n    }\n\n    for (let index = 0; index < cameraArray.length; index++) {\n      console.info(TAG + 'cameraId : ' + cameraArray[index].cameraId); // 获取相机ID\n      console.info(TAG + 'cameraPosition : ' + cameraArray[index].cameraPosition); // 获取相机位置\n      console.info(TAG + 'cameraType : ' + cameraArray[index].cameraType); // 获取相机类型\n      console.info(TAG + 'connectionType : ' + cameraArray[index].connectionType); // 获取相机连接类型\n    }\n\n    let deviceIndex = cameraArray.findIndex((cameraDevice: camera.CameraDevice) => {\n      return cameraDevice.cameraPosition === cameraPosition;\n    })\n    if (deviceIndex === -1) {\n      deviceIndex = 0;\n      console.error(TAG + 'not found camera');\n    }\n    this.curCameraDevice = cameraArray[deviceIndex];\n\n    // 创建相机输入流\n    try {\n      this.mCameraInput = this.mCameraManager.createCameraInput(this.curCameraDevice);\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to createCameraInput errorCode = ' + err.code);\n    }\n    if (this.mCameraInput === undefined) {\n      return;\n    }\n\n    // 打开相机\n    try {\n      await this.mCameraInput.open();\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to open device, errorCode = ' + err.code);\n    }\n\n    // 获取支持的模式类型\n    let sceneModes: Array<camera.SceneMode> = this.mCameraManager.getSupportedSceneModes(this.curCameraDevice);\n    let isSupportPhotoMode: boolean = sceneModes.indexOf(camera.SceneMode.NORMAL_PHOTO) >= 0;\n    if (!isSupportPhotoMode) {\n      console.error(TAG + 'photo mode not support');\n      return;\n    }\n\n    // 获取相机设备支持的输出流能力\n    let cameraOutputCapability: camera.CameraOutputCapability =\n      this.mCameraManager.getSupportedOutputCapability(this.curCameraDevice, camera.SceneMode.NORMAL_PHOTO);\n    if (!cameraOutputCapability) {\n      console.error(TAG + 'cameraManager.getSupportedOutputCapability error');\n      return;\n    }\n    console.info(TAG + 'outputCapability: ' + JSON.stringify(cameraOutputCapability));\n    let previewProfile = this.getPreviewProfile(cameraOutputCapability);\n    if (previewProfile === undefined) {\n      console.error(TAG + 'The resolution of the current preview stream is not supported.');\n      return;\n    }\n    this.previewProfileObj = previewProfile;\n\n    // 创建预览输出流,其中参数 surfaceId 参考上文 XComponent 组件，预览流为XComponent组件提供的surface\n    try {\n      this.mPreviewOutput = this.mCameraManager.createPreviewOutput(this.previewProfileObj, surfaceId);\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + `Failed to create the PreviewOutput instance. error code: ${err.code}`);\n    }\n    if (this.mPreviewOutput === undefined) {\n      return;\n    }\n\n    //创建会话\n    try {\n      this.mPhotoSession = this.mCameraManager.createSession(camera.SceneMode.NORMAL_PHOTO) as camera.PhotoSession;\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to create the session instance. errorCode = ' + err.code);\n    }\n    if (this.mPhotoSession === undefined) {\n      return;\n    }\n\n    // 开始配置会话\n    try {\n      this.mPhotoSession.beginConfig();\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to beginConfig. errorCode = ' + err.code);\n    }\n\n    // 向会话中添加相机输入流\n    try {\n      this.mPhotoSession.addInput(this.mCameraInput);\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to addInput. errorCode = ' + err.code);\n    }\n\n    // 向会话中添加预览输出流\n    try {\n      this.mPhotoSession.addOutput(this.mPreviewOutput);\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to addOutput(previewOutput). errorCode = ' + err.code);\n    }\n\n    // 提交会话配置\n    try {\n      await this.mPhotoSession.commitConfig();\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to commit session configuration, errorCode = ' + err.code);\n    }\n\n    // 启动会话\n    try {\n      await this.mPhotoSession.start()\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(TAG + 'Failed to start session. errorCode = ' + err.code);\n    }\n  }\n\n  build() {\n    if (this.isShow) {\n      Stack() {\n        if (this.reloadXComponentFlag) {\n          XComponent(this.mXComponentOptions)\n            .onLoad(async () => {\n              await this.loadXComponent();\n            })\n            .width(px2vp(1080))\n            .height(px2vp(1920))\n        } else {\n          XComponent(this.mXComponentOptions)\n            .onLoad(async () => {\n              await this.loadXComponent();\n            })\n            .width(px2vp(1080))\n            .height(px2vp(1920))\n        }\n        Text('切换摄像头')\n          .size({ width: 80, height: 48 })\n          .position({ x: 1, y: 1 })\n          .backgroundColor(Color.White)\n          .textAlign(TextAlign.Center)\n          .borderRadius(24)\n          .onClick(async () => {\n            this.mCameraPosition = this.mCameraPosition === camera.CameraPosition.CAMERA_POSITION_BACK ?\n              camera.CameraPosition.CAMERA_POSITION_FRONT : camera.CameraPosition.CAMERA_POSITION_BACK;\n            this.reloadXComponentFlag = !this.reloadXComponentFlag;\n          })\n      }\n      .size({ width: '100%', height: '100%' })\n      .backgroundColor(Color.Black)\n    }\n  }\n}

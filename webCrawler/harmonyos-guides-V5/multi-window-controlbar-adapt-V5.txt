顶部窗口控制条避让适配智慧多窗
顶部窗口控制条是应用窗口处于智慧多窗模式下，应用顶部的操作横条  。
顶部窗口控制条示意图如下所示：
顶部横条的避让可通过以下两种方式适配：
使用窗口的避让能力：通过setWindowLayoutFullScreen设置窗口布局是否为沉浸式布局。沉浸式布局是指应用布局不避让状态栏、导航栏以及智慧多窗顶部横条，这可能发生组件与顶部横条的重叠，导致文字遮挡、点击事件冲突等情况。非沉浸式布局是指布局避让状态栏、导航栏以及智慧多窗顶部横条，组件不会与其重叠。因此可设置isLayoutFullScreen值为false使窗口的布局为非沉浸式布局。  示例： // Index.ets\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { window } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = '非沉浸式布局';\n  private windowClass: window.Window | undefined = undefined;\n\n  aboutToAppear(): void {\n    try {\n      window.getLastWindow(getContext(this), (err: BusinessError, data) => {\n        const errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));\n          return;\n        }\n        this.windowClass = data;\n        console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));\n      });\n    } catch (exception) {\n      console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));\n    }\n  }\n\n  private setWindowLayoutFullScreen(isLayoutFullScreen: boolean) {\n    if (!this.windowClass) {\n      return;\n    }\n    try {\n      this.windowClass.setWindowLayoutFullScreen(isLayoutFullScreen, (err: BusinessError) => {\n        const errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));\n          return;\n        }\n        console.info('Succeeded in setting the window layout to full-screen mode.');\n      });\n    } catch (exception) {\n      console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(exception));\n    }\n  }\n\n  build() {\n    Stack({ alignContent: Alignment.TopStart }) {\n      Column() {\n        Text(this.message)\n          .fontSize(25)\n          .fontWeight(FontWeight.Bold)\n          .margin({\n            top: '2%',\n            bottom: '40%'\n          })\n\n        Button() {\n          Text('设置窗口为沉浸式布局')\n            .fontSize(18)\n            .fontWeight(FontWeight.Normal)\n        }\n        .type(ButtonType.Normal)\n        .borderRadius(15)\n        .margin({ top: 20 })\n        .stateStyles({\n          normal: {\n            .backgroundColor('#ff6b89d4')\n          },\n          pressed: {\n            .backgroundColor('#ffc81f2a')\n          }\n        })\n        .width('60%')\n        .height('6%')\n        .onClick(() => {\n          this.setWindowLayoutFullScreen(true);\n          this.message = '沉浸式布局';\n        })\n\n        Button() {\n          Text('设置窗口为非沉浸式布局')\n            .fontSize(18)\n            .fontWeight(FontWeight.Normal)\n        }\n        .type(ButtonType.Normal)\n        .borderRadius(15)\n        .margin({ top: 20 })\n        .stateStyles({\n          normal: {\n            .backgroundColor('#ff6b89d4')\n          },\n          pressed: {\n            .backgroundColor('#ffc81f2a')\n          }\n        })\n        .width('60%')\n        .height('6%')\n        .onClick(() => {\n          this.setWindowLayoutFullScreen(false);\n          this.message = '非沉浸式布局';\n        })\n      }\n      .width('100%')\n    }\n    .backgroundColor('#fceaeaea')\n    .height('100%')\n  }\n} 应用主动避让：应用不使用窗口避让能力（即设置窗口为沉浸式布局），还通过getWindowAvoidArea接口可获取屏幕顶部需要规避的矩阵区域topRect，获取到该值后应用可对应做布局避让。同时可通过on('avoidAreaChange')监听系统规避区域变化以进行布局的动态调整。// Index.ets\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { window } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct Index {\n  @State topSafeHeight: number = 0;\n\n  aboutToAppear(): void {\n    try {\n      let windowClass: window.Window | undefined = undefined;\n      window.getLastWindow(getContext(this), (err: BusinessError, data) => {\n        const errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));\n          return;\n        }\n        windowClass = data;\n        windowClass.setWindowLayoutFullScreen(true);\n        this.topSafeHeight = px2vp(windowClass.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM).topRect.height);\n        windowClass.on('avoidAreaChange', (data) => {\n          if (data.type == window.AvoidAreaType.TYPE_SYSTEM) {\n            this.topSafeHeight = px2vp(data.area.topRect.height)\n          }\n        })\n        console.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));\n      });\n    } catch (exception) {\n      console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));\n    }\n  }\n\n  build() {\n    Stack({ alignContent: Alignment.TopStart }) {\n      // 顶部避让区域\n      Row() {\n      }\n      .height(this.topSafeHeight)\n      .width(\"100%\")\n\n      // 根据topSafeHeight动态调整应用布局\n      // ...\n    }\n    .height('100%')\n  }\n} 

使用RSA密钥对（PKCS1模式）签名验签(ArkTS)
对应的算法规格请查看签名验签算法规格：RSA。
签名
 调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成密钥算法为RSA、密钥长度为1024位、素数个数为2的非对称密钥对象（KeyPair），包括公钥（PubKey）和私钥（PriKey）。 如何生成RSA非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。 调用cryptoFramework.createSign，指定字符串参数'RSA1024|PKCS1|SHA256'，创建非对称密钥类型为RSA1024、填充模式为PKCS1、摘要算法为SHA256的Sign实例，用于完成签名操作。 调用Sign.init，使用私钥（PriKey）初始化Sign实例。 调用Sign.update，传入待签名的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。  当待签名的数据较短时，可以在init完成后直接调用sign。 当数据量较大时，可以多次调用update，即分段签名验签。  调用Sign.sign，生成数据签名。 
验签
 调用cryptoFramework.createVerify，指定字符串参数'RSA1024|PKCS1|SHA256'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。 调用Verify.init，使用公钥（PubKey）初始化Verify实例。 调用Verify.update，传入待验证的数据。 当前单次update长度没有限制，开发者可以根据数据量判断如何调用update。  当待签名的数据较短时，可以在init完成后直接调用verify。 当数据量较大时，可以多次调用update，即分段签名验签。  调用Verify.verify，对数据进行验签。 
 异步方法示例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n// 完整的明文被拆分为input1和input2\nlet input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(\"This is Sign test plan1\", 'utf-8').buffer) };\nlet input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(\"This is Sign test plan2\", 'utf-8').buffer) };\nasync function signMessagePromise(priKey: cryptoFramework.PriKey) {\n  let signAlg = \"RSA1024|PKCS1|SHA256\";\n  let signer = cryptoFramework.createSign(signAlg);\n  await signer.init(priKey);\n  await signer.update(input1); // 如果明文较短，可以直接调用sign接口一次性传入\n  let signData = await signer.sign(input2);\n  return signData;\n}\nasync function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {\n  let verifyAlg = \"RSA1024|PKCS1|SHA256\";\n  let verifier = cryptoFramework.createVerify(verifyAlg);\n  await verifier.init(pubKey);\n  await verifier.update(input1); // 如果明文较短，可以直接调用verify接口一次性传入\n  let res = await verifier.verify(input2, signMessageBlob);\n  console.info(\"verify result is \" + res);\n  return res;\n}\nasync function main() {\n  let keyGenAlg = \"RSA1024\";\n  let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);\n  let keyPair = await generator.generateKeyPair();\n  let signData = await signMessagePromise(keyPair.priKey);\n  let verifyResult = await verifyMessagePromise(signData, keyPair.pubKey);\n  if (verifyResult == true) {\n    console.info('verify success');\n  } else {\n    console.error('verify failed');\n  }\n} 同步方法示例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n// 完整的明文被拆分为input1和input2\nlet input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(\"This is Sign test plan1\", 'utf-8').buffer) };\nlet input2: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(\"This is Sign test plan2\", 'utf-8').buffer) };\nfunction signMessagePromise(priKey: cryptoFramework.PriKey) {\n  let signAlg = \"RSA1024|PKCS1|SHA256\";\n  let signer = cryptoFramework.createSign(signAlg);\n  signer.initSync(priKey);\n  signer.updateSync(input1); // 如果明文较短，可以直接调用sign接口一次性传入\n  let signData = signer.signSync(input2);\n  return signData;\n}\nfunction verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {\n  let verifyAlg = \"RSA1024|PKCS1|SHA256\";\n  let verifier = cryptoFramework.createVerify(verifyAlg);\n  verifier.initSync(pubKey);\n  verifier.updateSync(input1); // 如果明文较短，可以直接调用verify接口一次性传入\n  let res = verifier.verifySync(input2, signMessageBlob);\n  console.info(\"verify result is \" + res);\n  return res;\n}\nfunction main() {\n  let keyGenAlg = \"RSA1024\";\n  let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);\n  let keyPair = generator.generateKeyPairSync();\n  let signData = signMessagePromise(keyPair.priKey);\n  let verifyResult = verifyMessagePromise(signData, keyPair.pubKey);\n  if (verifyResult == true) {\n    console.info('verify success');\n  } else {\n    console.error('verify failed');\n  }\n} 

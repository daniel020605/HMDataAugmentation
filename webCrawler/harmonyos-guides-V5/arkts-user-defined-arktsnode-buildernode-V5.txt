自定义声明式节点 (BuilderNode)
概述
自定义声明式节点 (BuilderNode)提供能够挂载系统组件的能力，支持采用无状态的UI方式，通过全局自定义构建函数@Builder定制组件树。组件树的根FrameNode节点可通过getFrameNode获取，该节点既可直接由NodeController返回并挂载于NodeContainer节点下，亦可在FrameNode树与RenderNode树中嵌入声明式组件，实现混合显示。同时，BuilderNode具备纹理导出功能，导出的纹理可在XComponent中实现同层渲染。
由BuilderNode构建的ArkTS原生控件树，支持与自定义节点（如FrameNode、RenderNode）关联使用，确保了系统组件与自定义节点的混合显示效果。对于需与自定义节点对接的第三方框架，BuilderNode提供了嵌入系统组件的方法。
此外，BuilderNode还提供了组件预创建的能力，能够自定义系统组件的创建开始的时间，在后续业务中实现动态挂载与显示。此功能尤其适用于初始化耗时较长的声明式组件，如Web、XComponent等，通过预创建，可以有效减少初始化时间，优化组件加载效率。
基本概念
 系统组件：组件是UI的必要元素，形成了在界面中的样子，由ArkUI直接提供的称为系统组件。 实体节点：由后端创建的Native节点。 
BuilderNode仅可作为叶子节点进行使用。如有更新需要，建议通过BuilderNode中的Update方式触发更新，不建议通过BuilderNode中获取的RenderNode对节点进行修改操作。
 BuilderNode只支持一个由wrapBuilder包装的全局自定义构建函数@Builder。 一个新建的BuildNode在build之后才能通过getFrameNode获取到一个指向根节点的FrameNode对象，否则返回null。 如果传入的Builder的根节点为语法节点（if/else/foreach/...），需要额外生成一个FrameNode，在节点树中的显示为“BuilderProxyNode”。 如果BuilderNode通过getFrameNode将节点挂载在另一个FrameNode上，或者将其作为子节点挂载在NodeContainer节点上。则节点中使用父组件的布局约束进行布局。 如果BuilderNode的FrameNode通过getRenderNode形式将自己的节点挂载在RenderNode节点上，由于其FrameNode未上树，其大小默认为0，需要通过构造函数中的selfIdeaSize显式指定布局约束大小，才能正常显示。 BuilderNode的预加载并不会减少组件的创建时间。Web组件创建的时候需要在内核中加载资源，预创建不能减少Web组件的创建的时间，但是可以让内核进行预加载，减少正式使用时候内核的加载耗时。 
创建BuilderNode对象
BuilderNode对象为一个模板类，需要在创建的时候指定类型。该类型需要与后续build方法中传入的WrappedBuilder的类型保持一致，否则会存在编译告警导致编译失败。
创建原生组件树
通过BuilderNode的build可以实现原生组件树的创建。依照传入的WrappedBuilder对象创建组件树，并持有组件树的根节点。
无状态的UI方法全局@Builder最多拥有一个根节点。
build方法中对应的@Builder支持一个参数作为入参。
build中对于@Builder嵌套@Builder进行使用的场景，需要保证嵌套的参数与build的中提供的入参一致。
对于@Builder嵌套@Builder进行使用的场景，如果入参类型不一致，则要求增加BuilderOptions字段作为build的入参。
需要操作BuilderNode中的对象时，需要保证其引用不被回收。当BuilderNode对象被虚拟机回收之后，它的FrameNode、RenderNode对象也会与后端节点解引用。即从BuilderNode中获取的FrameNode对象不对应任何一个节点。
创建离线节点以及原生组件树，结合FrameNode进行使用。
BuilderNode的根节点直接作为NodeController的makeNode返回值。
import { BuilderNode, FrameNode, NodeController, UIContext } from '@kit.ArkUI';\n\nclass Params {\n  text: string = \"\";\n\n  constructor(text: string) {\n    this.text = text;\n  }\n}\n\n@Builder\nfunction buildText(params: Params) {\n  Column() {\n    Text(params.text)\n      .fontSize(50)\n      .fontWeight(FontWeight.Bold)\n      .margin({ bottom: 36 })\n  }\n}\n\nclass TextNodeController extends NodeController {\n  private textNode: BuilderNode<[Params]> | null = null;\n  private message: string = \"DEFAULT\";\n\n  constructor(message: string) {\n    super();\n    this.message = message;\n  }\n\n  makeNode(context: UIContext): FrameNode | null {\n    this.textNode = new BuilderNode(context);\n    this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message))\n    return this.textNode.getFrameNode();\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = \"hello\";\n\n  build() {\n    Row() {\n      Column() {\n        NodeContainer(new TextNodeController(this.message))\n          .width('100%')\n          .height(100)\n          .backgroundColor('#FFF0F0F0')\n      }\n      .width('100%')\n      .height('100%')\n    }\n    .height('100%')\n  }\n}
将BuilderNode与RenderNode进行结合使用。
BuilderNode的RenderNode挂载其它RenderNode下时，需要明确定义selfIdeaSize的大小作为BuilderNode的布局约束。不推荐通过该方式挂载节点。
import { NodeController, BuilderNode, FrameNode, UIContext, RenderNode } from \"@kit.ArkUI\";\n\nclass Params {\n  text: string = \"\";\n\n  constructor(text: string) {\n    this.text = text;\n  }\n}\n\n@Builder\nfunction buildText(params: Params) {\n  Column() {\n    Text(params.text)\n      .fontSize(50)\n      .fontWeight(FontWeight.Bold)\n      .margin({ bottom: 36 })\n  }\n}\n\nclass TextNodeController extends NodeController {\n  private rootNode: FrameNode | null = null;\n  private textNode: BuilderNode<[Params]> | null = null;\n  private message: string = \"DEFAULT\";\n\n  constructor(message: string) {\n    super();\n    this.message = message;\n  }\n\n  makeNode(context: UIContext): FrameNode | null {\n    this.rootNode = new FrameNode(context);\n    let renderNode = new RenderNode();\n    renderNode.clipToFrame = false;\n    this.textNode = new BuilderNode(context, { selfIdealSize: { width: 150, height: 150 } });\n    this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message));\n    const textRenderNode = this.textNode?.getFrameNode()?.getRenderNode();\n\n    const rootRenderNode = this.rootNode.getRenderNode();\n    if (rootRenderNode !== null) {\n      rootRenderNode.appendChild(renderNode);\n      renderNode.appendChild(textRenderNode);\n    }\n\n    return this.rootNode;\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = \"hello\";\n\n  build() {\n    Row() {\n      Column() {\n        NodeContainer(new TextNodeController(this.message))\n          .width('100%')\n          .height(100)\n          .backgroundColor('#FFF0F0F0')\n      }\n      .width('100%')\n      .height('100%')\n    }\n    .height('100%')\n  }\n}
更新原生组件树
通过BuilderNode对象的build创建原生组件树。依照传入的WrappedBuilder对象创建组件树，并持有组件树的根节点。
自定义组件的更新遵循状态管理的更新机制。WrappedBuilder中直接使用的自定义组件其父组件为BuilderNode对象。因此，更新子组件即WrappedBuilder中定义的自定义组件，需要遵循状态管理的定义将相关的状态变量定义为@Prop或者@ObjectLink。装饰器的选择请参照状态管理的装饰器规格结合应用开发需求进行选择。
使用update更新BuilderNode中的节点。
使用updateConfiguration触发BuilderNode中节点的全量更新。
更新BuilderNode中的节点。
import { NodeController, BuilderNode, FrameNode, UIContext } from \"@kit.ArkUI\";\n\nclass Params {\n  text: string = \"\";\n  constructor(text: string) {\n    this.text = text;\n  }\n}\n\n// 自定义组件\n@Component\nstruct TextBuilder {\n  // 作为自定义组件中需要更新的属性，数据类型为基础属性，定义为@Prop\n  @Prop message: string = \"TextBuilder\";\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .margin({ bottom: 36 })\n          .backgroundColor(Color.Gray)\n      }\n    }\n  }\n}\n\n@Builder\nfunction buildText(params: Params) {\n  Column() {\n    Text(params.text)\n      .fontSize(50)\n      .fontWeight(FontWeight.Bold)\n      .margin({ bottom: 36 })\n    TextBuilder({ message: params.text }) // 自定义组件\n  }\n}\n\nclass TextNodeController extends NodeController {\n  private textNode: BuilderNode<[Params]> | null = null;\n  private message: string = \"\";\n\n  constructor(message: string) {\n    super()\n    this.message = message\n  }\n\n  makeNode(context: UIContext): FrameNode | null {\n    this.textNode = new BuilderNode(context);\n    this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message))\n    return this.textNode.getFrameNode();\n  }\n\n  update(message: string) {\n    if (this.textNode !== null) {\n      // 调用update进行更新。\n      this.textNode.update(new Params(message));\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = \"hello\";\n  private textNodeController: TextNodeController = new TextNodeController(this.message);\n  private count = 0;\n\n  build() {\n    Row() {\n      Column() {\n        NodeContainer(this.textNodeController)\n          .width('100%')\n          .height(200)\n          .backgroundColor('#FFF0F0F0')\n        Button('Update')\n          .onClick(() => {\n            this.count += 1;\n            const message = \"Update \" + this.count.toString();\n            this.textNodeController.update(message);\n          })\n      }\n      .width('100%')\n      .height('100%')\n    }\n    .height('100%')\n  }\n}
解除实体节点引用关系
由于BuilderNode对应的是后端的实体节点，正常的内存释放依赖前端对象的回收。如果期望直接释放后端的节点对象，则可以通过调用dispose与实体节点解除引用关系，此时持有的前端BuilderNode对象不再影响实体节点的生命周期。
当BuilderNode对象调用dispose之后，不仅BuilderNode对象与后端实体节点解除引用关系，BuilderNode中的FrameNode与RenderNode也会同步和实体节点解除引用关系。
注入触摸事件
BuilderNode中提供了postTouchEvent，可以通过该接口向BuilderNode中绑定的组件注入触摸事件，实现事件的模拟转发。
通过postTouchEvent向BuilderNode对应的节点树中注入触摸事件。
向BuilderNode中的Column组件转发另一个Column的接收事件，即点击下方的Column组件，上方的Colum组件也会收到同样的触摸事件。当Button中的事件被成功识别的时候，返回值为true。
import { NodeController, BuilderNode, FrameNode, UIContext } from '@kit.ArkUI';\n\nclass Params {\n  text: string = \"this is a text\";\n}\n\n@Builder\nfunction ButtonBuilder(params: Params) {\n  Column() {\n    Button(`button ` + params.text)\n      .borderWidth(2)\n      .backgroundColor(Color.Orange)\n      .width(\"100%\")\n      .height(\"100%\")\n      .gesture(\n        TapGesture()\n          .onAction((event: GestureEvent) => {\n            console.log(\"TapGesture\");\n          })\n      )\n  }\n  .width(500)\n  .height(300)\n  .backgroundColor(Color.Gray)\n}\n\nclass MyNodeController extends NodeController {\n  private rootNode: BuilderNode<[Params]> | null = null;\n  private wrapBuilder: WrappedBuilder<[Params]> = wrapBuilder(ButtonBuilder);\n\n  makeNode(uiContext: UIContext): FrameNode | null {\n    this.rootNode = new BuilderNode(uiContext);\n    this.rootNode.build(this.wrapBuilder, { text: \"this is a string\" })\n    return this.rootNode.getFrameNode();\n  }\n\n  postTouchEvent(touchEvent: TouchEvent): void {\n    if (this.rootNode == null) {\n      return;\n    }\n    let result = this.rootNode.postTouchEvent(touchEvent);\n    console.log(\"result \" + result);\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private nodeController: MyNodeController = new MyNodeController();\n\n  build() {\n    Column() {\n      NodeContainer(this.nodeController)\n        .height(300)\n        .width(500)\n      Column()\n        .width(500)\n        .height(300)\n        .backgroundColor(Color.Pink)\n        .onTouch((event) => {\n          if (event != undefined) {\n            this.nodeController.postTouchEvent(event);\n          }\n        })\n    }\n  }\n}
节点复用能力
将reuse事件和recycle事件传递至BuilderNode中的自定义组件，以实现BuilderNode节点的复用。
import { FrameNode,NodeController,BuilderNode,UIContext } from \"@kit.ArkUI\";\n\nclass MyDataSource {\n  private dataArray: string[] = [];\n  private listener: DataChangeListener | null = null\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number) {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string) {\n    this.dataArray.push(data);\n  }\n\n  public reloadListener(): void {\n    this.listener?.onDataReloaded();\n  }\n\n  public registerDataChangeListener(listener: DataChangeListener): void {\n    this.listener = listener;\n  }\n\n  public unregisterDataChangeListener(): void {\n    this.listener = null;\n  }\n}\n\nclass Params {\n  item: string = '';\n\n  constructor(item: string) {\n    this.item = item;\n  }\n}\n\n@Builder\nfunction buildNode(param: Params = new Params(\"hello\")) {\n  ReusableChildComponent2({ item: param.item });\n}\n\nclass MyNodeController extends NodeController {\n  public builderNode: BuilderNode<[Params]> | null = null;\n  public item: string = \"\";\n\n  makeNode(uiContext: UIContext): FrameNode | null {\n    if (this.builderNode == null) {\n      this.builderNode = new BuilderNode(uiContext, { selfIdealSize: { width: 300, height: 200 } });\n      this.builderNode.build(wrapBuilder<[Params]>(buildNode), new Params(this.item));\n    }\n    return this.builderNode.getFrameNode();\n  }\n}\n\n@Reusable\n@Component\nstruct ReusableChildComponent {\n  @State item: string = '';\n  private controller: MyNodeController = new MyNodeController();\n\n  aboutToAppear() {\n    this.controller.item = this.item;\n  }\n\n  aboutToRecycle(): void {\n    console.log(\"ReusableChildComponent aboutToRecycle \" + this.item);\n    this.controller?.builderNode?.recycle();\n  }\n\n  aboutToReuse(params: object): void {\n    console.log(\"ReusableChildComponent aboutToReuse \" + JSON.stringify(params));\n    this.controller?.builderNode?.reuse(params);\n  }\n\n  build() {\n    NodeContainer(this.controller);\n  }\n}\n\n@Component\nstruct ReusableChildComponent2 {\n  @Prop item: string = \"false\";\n\n  aboutToReuse(params: Record<string, object>) {\n    console.log(\"ReusableChildComponent2 Reusable 2 \" + JSON.stringify(params));\n  }\n\n  aboutToRecycle(): void {\n    console.log(\"ReusableChildComponent2 aboutToRecycle 2 \" + this.item);\n  }\n\n  build() {\n    Row() {\n      Text(this.item)\n        .fontSize(20)\n        .backgroundColor(Color.Yellow)\n        .margin({ left: 10 })\n    }.margin({ left: 10, right: 10 })\n  }\n}\n\n\n@Entry\n@Component\nstruct Index {\n  @State data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0;i < 100; i++) {\n      this.data.pushData(i.toString());\n    }\n  }\n\n  build() {\n    Column() {\n      List({ space: 3 }) {\n        LazyForEach(this.data, (item: string) => {\n          ListItem() {\n            ReusableChildComponent({ item: item })\n          }\n        }, (item: string) => item)\n      }\n      .width('100%')\n      .height('100%')\n    }\n  }\n}
通过系统环境变化更新节点
使用updateConfiguration来监听系统环境变化事件，以触发节点的全量更新。
updateConfiguration接口用于通知对象进行更新，更新所使用的系统环境取决于应用当前系统环境的变化。
import { NodeController, BuilderNode, FrameNode, UIContext } from \"@kit.ArkUI\";\nimport { AbilityConstant, Configuration, EnvironmentCallback } from '@kit.AbilityKit';\n\nclass Params {\n  text: string = \"\"\n\n  constructor(text: string) {\n    this.text = text;\n  }\n}\n\n// 自定义组件\n@Component\nstruct TextBuilder {\n  // 作为自定义组件中需要更新的属性，数据类型为基础属性，定义为@Prop\n  @Prop message: string = \"TextBuilder\";\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .margin({ bottom: 36 })\n          .fontColor($r(`app.color.text_color`))\n          .backgroundColor($r(`app.color.start_window_background`))\n      }\n    }\n  }\n}\n\n@Builder\nfunction buildText(params: Params) {\n  Column() {\n    Text(params.text)\n      .fontSize(50)\n      .fontWeight(FontWeight.Bold)\n      .margin({ bottom: 36 })\n      .fontColor($r(`app.color.text_color`))\n    TextBuilder({ message: params.text }) // 自定义组件\n  }.backgroundColor($r(`app.color.start_window_background`))\n}\n\nclass TextNodeController extends NodeController {\n  private textNode: BuilderNode<[Params]> | null = null;\n  private message: string = \"\";\n\n  constructor(message: string) {\n    super()\n    this.message = message;\n  }\n\n  makeNode(context: UIContext): FrameNode | null {\n    return this.textNode?.getFrameNode() ? this.textNode?.getFrameNode() : null;\n  }\n\n  createNode(context: UIContext) {\n    this.textNode = new BuilderNode(context);\n    this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message));\n    builderNodeMap.push(this.textNode);\n  }\n\n  deleteNode() {\n    let node = builderNodeMap.pop();\n    node?.dispose();\n  }\n\n  update(message: string) {\n    if (this.textNode !== null) {\n      // 调用update进行更新。\n      this.textNode.update(new Params(message));\n    }\n  }\n}\n\n// 记录创建的自定义节点对象\nconst builderNodeMap: Array<BuilderNode<[Params]>> = new Array();\n\nfunction updateColorMode() {\n  builderNodeMap.forEach((value, index) => {\n    // 通知BuilderNode环境变量改变\n    value.updateConfiguration();\n  })\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = \"hello\"\n  private textNodeController: TextNodeController = new TextNodeController(this.message);\n  private count = 0;\n\n  aboutToAppear(): void {\n    let environmentCallback: EnvironmentCallback = {\n      onMemoryLevel: (level: AbilityConstant.MemoryLevel): void => {\n        console.log('onMemoryLevel');\n      },\n      onConfigurationUpdated: (config: Configuration): void => {\n        console.log('onConfigurationUpdated ' + JSON.stringify(config));\n        updateColorMode();\n      }\n    }\n    // 注册监听回调\n    this.getUIContext().getHostContext()?.getApplicationContext().on('environment', environmentCallback);\n    //创建自定义节点并添加至map\n    this.textNodeController.createNode(this.getUIContext());\n  }\n\n  aboutToDisappear(): void {\n    //移除map中的引用，并将自定义节点释放\n    this.textNodeController.deleteNode();\n  }\n\n  build() {\n    Row() {\n      Column() {\n        NodeContainer(this.textNodeController)\n          .width('100%')\n          .height(200)\n          .backgroundColor('#FFF0F0F0')\n        Button('Update')\n          .onClick(() => {\n            this.count += 1;\n            const message = \"Update \" + this.count.toString();\n            this.textNodeController.update(message);\n          })\n      }\n      .width('100%')\n      .height('100%')\n    }\n    .height('100%')\n  }\n}
跨页面复用注意事项
在使用路由接口router.replaceUrl、router.back、router.clear、router.replaceNamedRoute操作页面时，若某个被缓存的BuilderNode位于即将销毁的页面内，那么在新页面中复用该BuilderNode时，可能会存在数据无法更新或新创建节点无法显示的问题。以router.replaceNamedRoute为例，在以下示例代码中，当点击“router replace”按钮后，页面将切换至PageTwo，同时标志位isShowText会被设定为false。
// ets/pages/Index.ets\nimport { NodeController, BuilderNode, FrameNode, UIContext } from \"@kit.ArkUI\";\nimport \"ets/pages/PageTwo\"\n\n@Builder\nfunction buildText() {\n  // @Builder中使用语法节点生成BuilderProxyNode\n  if (true) {\n    MyComponent()\n  }\n}\n\n@Component\nstruct MyComponent {\n  @StorageLink(\"isShowText\") isShowText: boolean = true;\n\n  build() {\n    if (this.isShowText) {\n      Column() {\n        Text(\"BuilderNode Reuse\")\n          .fontSize(36)\n          .fontWeight(FontWeight.Bold)\n          .padding(16)\n      }\n    }\n  }\n}\n\nclass TextNodeController extends NodeController {\n  private rootNode: FrameNode | null = null;\n  private textNode: BuilderNode<[]> | null = null;\n\n  makeNode(context: UIContext): FrameNode | null {\n    this.rootNode = new FrameNode(context);\n\n    if (AppStorage.has(\"textNode\")) {\n      // 复用AppStorage中的BuilderNode\n      this.textNode = AppStorage.get<BuilderNode<[]>>(\"textNode\") as BuilderNode<[]>;\n      const parent = this.textNode.getFrameNode()?.getParent();\n      if (parent) {\n        parent.removeChild(this.textNode.getFrameNode());\n      }\n    } else {\n      this.textNode = new BuilderNode(context);\n      this.textNode.build(wrapBuilder<[]>(buildText));\n      // 将创建的BuilderNode存入AppStorage\n      AppStorage.setOrCreate<BuilderNode<[]>>(\"textNode\", this.textNode);\n    }\n    this.rootNode.appendChild(this.textNode.getFrameNode());\n\n    return this.rootNode;\n  }\n}\n\n@Entry({ routeName: \"myIndex\" })\n@Component\nstruct Index {\n  aboutToAppear(): void {\n    AppStorage.setOrCreate<boolean>(\"isShowText\", true);\n  }\n\n  build() {\n    Row() {\n      Column() {\n        NodeContainer(new TextNodeController())\n          .width('100%')\n          .backgroundColor('#FFF0F0F0')\n        Button('Router pageTwo')\n          .onClick(() => {\n            // 改变AppStorage中的状态变量触发Text节点的重新创建\n            AppStorage.setOrCreate<boolean>(\"isShowText\", false);\n\n            this.getUIContext().getRouter().replaceNamedRoute({ name: \"pageTwo\" });\n          })\n          .margin({ top: 16 })\n      }\n      .width('100%')\n      .height('100%')\n      .padding(16)\n    }\n    .height('100%')\n  }\n}
PageTwo的实现如下：
// ets/pages/PageTwo.ets\n// 该页面中存在一个按钮，可跳转回主页面，回到主页面后，原有的文字消失\nimport \"ets/pages/Index\"\n\n@Entry({ routeName: \"pageTwo\" })\n@Component\nstruct PageTwo {\n  build() {\n    Column() {\n      Button('Router replace to index')\n        .onClick(() => {\n          this.getUIContext().getRouter().replaceNamedRoute({ name: \"myIndex\" });\n        })\n    }\n    .height('100%')\n    .width('100%')\n    .alignItems(HorizontalAlign.Center)\n    .padding(16)\n  }\n}
在API version 16之前，解决该问题的方法是在页面销毁时，将页面上的BuilderNode从缓存中移除。以上述例子为例，可以在页面跳转前，通过点击事件将BuilderNode从AppStorage中移除，以此达到预期效果。
API version 16及之后版本，BuilderNode在新页面被复用时，会自动刷新自身内容，无需在页面销毁时将BuilderNode从缓存中移除。
// ets/pages/Index.ets\nimport { NodeController, BuilderNode, FrameNode, UIContext } from \"@kit.ArkUI\";\nimport \"ets/pages/PageTwo\"\n\n@Builder\nfunction buildText() {\n  // @Builder中使用语法节点生成BuilderProxyNode\n  if (true) {\n    MyComponent()\n  }\n}\n\n@Component\nstruct MyComponent {\n  @StorageLink(\"isShowText\") isShowText: boolean = true;\n\n  build() {\n    if (this.isShowText) {\n      Column() {\n        Text(\"BuilderNode Reuse\")\n          .fontSize(36)\n          .fontWeight(FontWeight.Bold)\n          .padding(16)\n      }\n    }\n  }\n}\n\nclass TextNodeController extends NodeController {\n  private rootNode: FrameNode | null = null;\n  private textNode: BuilderNode<[]> | null = null;\n\n  makeNode(context: UIContext): FrameNode | null {\n    this.rootNode = new FrameNode(context);\n\n    if (AppStorage.has(\"textNode\")) {\n      // 复用AppStorage中的BuilderNode\n      this.textNode = AppStorage.get<BuilderNode<[]>>(\"textNode\") as BuilderNode<[]>;\n      const parent = this.textNode.getFrameNode()?.getParent();\n      if (parent) {\n        parent.removeChild(this.textNode.getFrameNode());\n      }\n    } else {\n      this.textNode = new BuilderNode(context);\n      this.textNode.build(wrapBuilder<[]>(buildText));\n      // 将创建的BuilderNode存入AppStorage\n      AppStorage.setOrCreate<BuilderNode<[]>>(\"textNode\", this.textNode);\n    }\n    this.rootNode.appendChild(this.textNode.getFrameNode());\n\n    return this.rootNode;\n  }\n}\n\n@Entry({ routeName: \"myIndex\" })\n@Component\nstruct Index {\n  aboutToAppear(): void {\n    AppStorage.setOrCreate<boolean>(\"isShowText\", true);\n  }\n\n  build() {\n    Row() {\n      Column() {\n        NodeContainer(new TextNodeController())\n          .width('100%')\n          .backgroundColor('#FFF0F0F0')\n        Button('Router pageTwo')\n          .onClick(() => {\n            // 改变AppStorage中的状态变量触发Text节点的重新创建\n            AppStorage.setOrCreate<boolean>(\"isShowText\", false);\n            // 将BuilderNode从AppStorage中移除\n            AppStorage.delete(\"textNode\");\n\n            this.getUIContext().getRouter().replaceNamedRoute({ name: \"pageTwo\" });\n          })\n          .margin({ top: 16 })\n      }\n      .width('100%')\n      .height('100%')\n      .padding(16)\n    }\n    .height('100%')\n  }\n}

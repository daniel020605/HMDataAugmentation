IPC与RPC通信开发指导
场景介绍
IPC/RPC的主要工作是让运行在不同进程的Proxy和Stub互相通信，包括Proxy和Stub运行在不同设备的情况。
开发步骤
[h2]ArkTS侧开发步骤
 此文档中的示例代码描述的是系统应用跨进程通信。 当前不支持三方应用实现ServiceExtensionAbility，三方应用的UIAbility组件可以通过Context连接系统提供的ServiceExtensionAbility。 当前使用场景： 仅限客户端是三方应用，服务端是系统应用。 
 添加依赖  // FA模型需要从@kit.AbilityKit导入featureAbility\n // import { featureAbility } from '@kit.AbilityKit';\n import { rpc } from '@kit.IPCKit'; 绑定Ability 首先，构造变量want，指定要绑定的Ability所在应用的包名、组件名，如果是跨设备的场景，还需要绑定目标设备NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）；然后，构造变量connect，指定绑定成功、绑定失败、断开连接时的回调函数；最后，FA模型使用featureAbility提供的接口绑定Ability，Stage模型通过context获取服务后用提供的接口绑定Ability。  // FA模型需要从@kit.AbilityKit导入featureAbility\n // import { featureAbility } from \"@kit.AbilityKit\";\n import { Want, common } from '@kit.AbilityKit';\n import { rpc } from '@kit.IPCKit';\n import { hilog } from '@kit.PerformanceAnalysisKit';\n import { distributedDeviceManager } from '@kit.DistributedServiceKit';\n import { BusinessError } from '@kit.BasicServicesKit';\n\n let dmInstance: distributedDeviceManager.DeviceManager | undefined;\n let proxy: rpc.IRemoteObject | undefined;\n let connectId: number;\n\n // 单个设备绑定Ability\n let want: Want = {\n   // 包名和组件名写实际的值\n   bundleName: \"ohos.rpc.test.server\",\n   abilityName: \"ohos.rpc.test.server.ServiceAbility\",\n };\n let connect: common.ConnectOptions = {\n   onConnect: (elementName, remoteProxy) => {\n     hilog.info(0x0000, 'testTag', 'RpcClient: js onConnect called');\n     proxy = remoteProxy;\n   },\n   onDisconnect: (elementName) => {\n     hilog.info(0x0000, 'testTag', 'RpcClient: onDisconnect');\n   },\n   onFailed: () => {\n     hilog.info(0x0000, 'testTag', 'RpcClient: onFailed');\n   }\n };\n // FA模型使用此方法连接服务\n // connectId = featureAbility.connectAbility(want, connect);\n\n let context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext; // UIAbilityContext\n // 建立连接后返回的Id需要保存下来，在解绑服务时需要作为参数传入\n connectId = context.connectServiceExtensionAbility(want,connect);\n\n // 跨设备绑定\n try{\n   dmInstance = distributedDeviceManager.createDeviceManager(\"ohos.rpc.test\");\n } catch(error) {\n   let err: BusinessError = error as BusinessError;\n   hilog.error(0x0000, 'testTag', 'createDeviceManager errCode:' + err.code + ', errMessage:' + err.message);\n }\n\n // 使用distributedDeviceManager获取目标设备NetworkId\n if (dmInstance != undefined) {\n   let deviceList = dmInstance.getAvailableDeviceListSync();\n   let networkId = deviceList[0].networkId;\n   let want: Want = {\n     bundleName: \"ohos.rpc.test.server\",\n     abilityName: \"ohos.rpc.test.service.ServiceAbility\",\n     deviceId: networkId,\n     flags: 256\n   };\n   // 建立连接后返回的Id需要保存下来，在断开连接时需要作为参数传入\n   // FA模型使用此方法连接服务\n   // connectId = featureAbility.connectAbility(want, connect);\n\n   // 第一个参数是本应用的包名，第二个参数是接收distributedDeviceManager的回调函数\n   connectId = context.connectServiceExtensionAbility(want,connect);\n } 服务端处理客户端请求 服务端被绑定的Ability在onConnect方法里返回继承自rpc.RemoteObject的对象，该对象需要实现onRemoteMessageRequest方法，处理客户端的请求。  import { rpc } from '@kit.IPCKit';\n import { Want } from '@kit.AbilityKit';\n class Stub extends rpc.RemoteObject {\n   constructor(descriptor: string) {\n     super(descriptor);\n   }\n   onRemoteMessageRequest(code: number, data: rpc.MessageSequence, reply: rpc.MessageSequence, option: rpc.MessageOption): boolean | Promise<boolean> {\n     // 根据code处理客户端的请求\n     return true;\n   }\n\n   onConnect(want: Want) {\n     const robj: rpc.RemoteObject = new Stub(\"rpcTestAbility\");\n     return robj;\n   }\n } 客户端处理服务端响应 客户端在onConnect回调里接收到代理对象，调用sendMessageRequest方法发起请求，在期约（用于表示一个异步操作的最终完成或失败及其结果值）或者回调函数里接收结果。  import { rpc } from '@kit.IPCKit';\n import { hilog } from '@kit.PerformanceAnalysisKit';\n\n // 使用期约\n let option = new rpc.MessageOption();\n let data = rpc.MessageSequence.create();\n let reply = rpc.MessageSequence.create();\n // 往data里写入参数\n let proxy: rpc.IRemoteObject | undefined;\n if (proxy != undefined) {\n   proxy.sendMessageRequest(1, data, reply, option)\n     .then((result: rpc.RequestResult) => {\n       if (result.errCode != 0) {\n         hilog.error(0x0000, 'testTag', 'sendMessageRequest failed, errCode: ' + result.errCode);\n         return;\n       }\n       // 从result.reply里读取结果\n     })\n     .catch((e: Error) => {\n       hilog.error(0x0000, 'testTag', 'sendMessageRequest got exception: ' + e);\n     })\n     .finally(() => {\n       data.reclaim();\n       reply.reclaim();\n     })\n }\n\n // 使用回调函数\n function sendRequestCallback(err: Error, result: rpc.RequestResult) {\n   try {\n     if (result.errCode != 0) {\n       hilog.error(0x0000, 'testTag', 'sendMessageRequest failed, errCode: ' + result.errCode);\n       return;\n     }\n     // 从result.reply里读取结果\n   } finally {\n       result.data.reclaim();\n       result.reply.reclaim();\n   }\n }\n let options = new rpc.MessageOption();\n let datas = rpc.MessageSequence.create();\n let replys = rpc.MessageSequence.create();\n // 往data里写入参数\n if (proxy != undefined) {\n   proxy.sendMessageRequest(1, datas, replys, options, sendRequestCallback);\n } 断开连接 IPC通信结束后，FA模型使用featureAbility的接口断开连接，Stage模型在获取context后用提供的接口断开连接。  // FA模型需要从@kit.AbilityKit导入featureAbility\n // import { featureAbility } from \"@kit.AbilityKit\";\n import { Want, common } from '@kit.AbilityKit';\n import { rpc } from '@kit.IPCKit';\n import { hilog } from '@kit.PerformanceAnalysisKit';\n\n function disconnectCallback() {\n   hilog.info(0x0000, 'testTag', 'disconnect ability done');\n }\n // FA模型使用此方法断开连接\n // featureAbility.disconnectAbility(connectId, disconnectCallback);\n\n let proxy: rpc.IRemoteObject | undefined;\n let connectId: number;\n\n // 单个设备绑定Ability\n let want: Want = {\n   // 包名和组件名写实际的值\n   bundleName: \"ohos.rpc.test.server\",\n   abilityName: \"ohos.rpc.test.server.ServiceAbility\",\n };\n let connect: common.ConnectOptions = {\n   onConnect: (elementName, remote) => {\n     proxy = remote;\n   },\n   onDisconnect: (elementName) => {\n   },\n   onFailed: () => {\n     proxy;\n   }\n };\n // FA模型使用此方法连接服务\n // connectId = featureAbility.connectAbility(want, connect);\n\n connectId = this.context.connectServiceExtensionAbility(want,connect);\n\n this.context.disconnectServiceExtensionAbility(connectId); 

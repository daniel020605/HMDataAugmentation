使用Image完成图片解码
图片解码指将所支持格式的存档图片解码成统一的PixelMap，以便在应用或系统中进行图片显示或图片处理。当前支持的存档图片格式包括JPEG、PNG、GIF、WebP、BMP、SVG、ICO、DNG、HEIF(不同硬件设备支持情况不同)。
开发步骤
图片解码相关API的详细介绍请参见：图片解码接口文档。
[h2]添加依赖
在进行应用开发之前，开发者需要打开native工程的src/main/cpp/CMakeLists.txt，在target_link_libraries依赖中添加libace_napi.z.so、libpixelmap_ndk.z.so、libimage_source_ndk.z.so、librawfile.z.so以及日志依赖libhilog_ndk.z.so。
target_link_libraries(entry PUBLIC libace_napi.z.so libhilog_ndk.z.so libpixelmap_ndk.z.so libimage_source_ndk.z.so librawfile.z.so)
[h2]添加接口映射
打开src/main/cpp/hello.cpp文件，在Init函数中添加getSyncPixelMap函数接口映射，作用是以同步的方式生成PixelMap，具体代码如下：
EXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        { \"getSyncPixelMap\", nullptr, getSyncPixelMap, nullptr, nullptr, nullptr, napi_default, nullptr },\n    };\n\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END
[h2]JS侧调用
 打开src\\main\\cpp\\types\\libentry\\index.d.ts（其中libentry根据工程名生成），导入如下引用文件: import { image } from '@kit.ImageKit';\nimport { resourceManager } from '@kit.LocalizationKit';\n\n// 同步调用，入参为资源管理器和图片资源名称，返回PixelMap\nexport const getSyncPixelMap: (resMgr: resourceManager.ResourceManager, src: string) => image.PixelMap; 准备图片资源文件，本示例文件名为example.jpg，导入到src\\main\\resources\\rawfile\\ 路径下。 打开src\\main\\ets\\pages\\index.ets，导入\"libentry.so（根据工程名生成）\"，调用Native接口，传入JS的资源对象。示例如下: import testNapi from 'libentry.so'\nimport { image } from '@kit.ImageKit';\n\n@Entry\n@Component\nstruct Index {\n  @State pixelMap : PixelMap | undefined = undefined;\n  aboutToAppear() {\n     // 调用自定义的getSyncPixelMap接口，获取pixelMap\n     this.pixelMap = testNapi.getSyncPixelMap(getContext(this).resourceManager, \"example.jpg\")\n  }\n\n  build() {\n     Row() {\n        Column() {\n        Image(this.pixelMap)\n           .width(100)\n           .height(100)\n        }\n        .width('100%')\n     }\n     .height('100%')\n  }\n} 
[h2]Native接口调用
具体接口说明请参考API文档。
在hello.cpp文件中获取JS的资源对象，并转为Native的资源对象，即可调用Native接口，调用方式示例代码如下：
添加引用文件
   // 引入图片框架、raw文件、raw文件管理和日志打印头文件\n   #include <cstdlib>\n   #include <cstring>\n   #include <multimedia/image_framework/image_source_mdk.h>\n   #include <multimedia/image_framework/image_pixel_map_mdk.h>\n   #include <rawfile/raw_file.h>\n   #include <rawfile/raw_file_manager.h>\n   #include <hilog/log.h>\n   \n   static napi_value getSyncPixelMap(napi_env env, napi_callback_info info)\n   {\n      size_t argc = 2;\n      napi_value args[2] = {nullptr};\n\n      napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);\n      \n      napi_valuetype srcType;\n      napi_typeof(env, args[0], &srcType);\n\n      // 入参args[0]是资源管理器，用来初始化native层的资源管理器\n      NativeResourceManager *mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, args[0]);\n      \n      size_t strSize;\n      char srcBuf[2048];\n      // 入参args[1]是文件名称\n      napi_get_value_string_utf8(env, args[1], srcBuf, sizeof(srcBuf), &strSize);\n\n      // 用资源管理器打开Raw文件\n      RawFile * rawFile = OH_ResourceManager_OpenRawFile(mNativeResMgr, srcBuf);\n      if (rawFile != NULL) {\n         // 获取文件大小，并读取数据\n         long len = OH_ResourceManager_GetRawFileSize(rawFile);\n         uint8_t * data = static_cast<uint8_t *>(malloc(len));\n         int res = OH_ResourceManager_ReadRawFile(rawFile, data, len);\n\n         OhosImageSource imageSource_c;\n         imageSource_c.buffer = data;\n         imageSource_c.bufferSize = len;\n\n         OhosImageSourceOps ops{};\n         napi_value imageSource;\n         napi_value pixelMap;\n\n         // 用读取到的Raw数据创建ImageSource\n         int32_t ret = OH_ImageSource_Create(env, &imageSource_c, &ops, &imageSource);\n\n         // 初始化native层的ImageSource\n         ImageSourceNative * imageSourceNative_c = OH_ImageSource_InitNative(env, imageSource);\n         OhosImageDecodingOps decodingOps{};\n         // 创建pixelMap\n         OH_ImageSource_CreatePixelMap(imageSourceNative_c, &decodingOps, &pixelMap);\n\n         // 下列方法,为gif等动图格式提供。\n         // napi_value pixelMapList;\n         // OH_ImageSource_CreatePixelMapList(imageSourceNative_c, &decodingOps, &pixelMapList);\n         // OhosImageSourceDelayTimeList list{};\n         // OH_ImageSource_GetDelayTime(imageSourceNative_c, &list);\n         // uint32_t count;\n         // OH_ImageSource_GetFrameCount(imageSourceNative_c, &count);\n\n         OhosImageSourceInfo info{};\n         // 读取图片宽高\n         OH_ImageSource_GetImageInfo(imageSourceNative_c, 0, &info);\n         OH_LOG_Print(LOG_APP, LOG_INFO, 0xFF00, \"[decode]\", \"imageInfo width:%{public}d , height:%{public}d\", info.size.width, info.size.height);\n         \n         // 读取图片源的ImageWidth配置参数并打印日志\n         OhosImageSourceProperty target;\n         char exifKey_c[] = \"ImageWidth\";\n         target.size = strlen(exifKey_c);\n         target.value = exifKey_c;\n\n         OhosImageSourceProperty response{};\n         response.size = 20;\n         response.value = static_cast<char *>(malloc(20));\n         OH_ImageSource_GetImageProperty(imageSourceNative_c, &target, &response);\n         OH_LOG_Print(LOG_APP, LOG_INFO, 0xFF00, \"[decode]\", \"ImageProperty width after modify:%{public}s\", response.value);\n\n         // 处理完毕，释放native层资源\n         OH_ImageSource_Release(imageSourceNative_c);\n         OH_ResourceManager_CloseRawFile(rawFile);\n         return pixelMap;\n      }\n      OH_ResourceManager_ReleaseNativeResourceManager(mNativeResMgr);\n      return nullptr;\n   }
图片框架支持增量式解码，使用方法如下：
   // 引入图片框架、raw文件、raw文件管理和日志打印头文件\n   #include <cstdlib>\n   #include <cstring>\n   #include <multimedia/image_framework/image_source_mdk.h>\n   #include <multimedia/image_framework/image_pixel_map_mdk.h>\n   #include <rawfile/raw_file.h>\n   #include <rawfile/raw_file_manager.h>\n   #include <hilog/log.h>\n   \n   static napi_value getSyncPixelMap(napi_env env, napi_callback_info info)\n   {\n      size_t argc = 2;\n      napi_value args[2] = {nullptr};\n\n      napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);\n      \n      napi_valuetype srcType;\n      napi_typeof(env, args[0], &srcType);\n\n      // 入参args[0]是资源管理器，用来初始化native层的资源管理器\n      NativeResourceManager * mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, args[0]);\n      \n      size_t strSize;\n      char srcBuf[2048];\n      // 入参args[1]是文件名称\n      napi_get_value_string_utf8(env, args[1], srcBuf, sizeof(srcBuf), &strSize);\n\n      // 用资源管理器打开Raw文件\n      RawFile * rawFile = OH_ResourceManager_OpenRawFile(mNativeResMgr, srcBuf);\n      if (rawFile != NULL) {\n         // 获取文件大小，若大于2048字节，则增量式解码，否则直接全部解码\n         long len = OH_ResourceManager_GetRawFileSize(rawFile);\n         if (len > 2048) {\n            uint8_t * data = static_cast<uint8_t *>(malloc(len));\n            // 读取文件全部数据\n            int res = OH_ResourceManager_ReadRawFile(rawFile, data, len);\n            \n            uint8_t * holderdata = static_cast<uint8_t *>(malloc(len));\n\n            OhosImageSource imageSource_c;\n            // imageSource_c的buffer分配了空间，但是数据是空的\n            imageSource_c.buffer = holderdata;\n            imageSource_c.bufferSize = len;\n            OhosImageSourceOps ops{};\n            napi_value imageSource;\n            // 初始化增量ImageSource\n            OH_ImageSource_CreateIncremental(env, &imageSource_c, &ops, &imageSource);\n\n            // 初始化native层的ImageSource\n            ImageSourceNative * imageSourceNative_c = OH_ImageSource_InitNative(env, imageSource);\n\n            // 以下模拟分片加载场景，分两次加载分片。第一次加载2048字节，第二次加载剩余的数据。\n            OhosImageSourceUpdateData firstData{};\n            firstData.buffer = data; // 图片数据\n            firstData.bufferSize = len; // 图片数据总大小\n            firstData.isCompleted = false;\n            firstData.offset = 0; // 第一次重头开始加载\n            firstData.updateLength = 2048; // 第一次加载了2048字节\n            OH_ImageSource_UpdateData(imageSourceNative_c, &firstData);\n\n            OhosImageSourceUpdateData secondData{};\n            secondData.buffer = data;\n            secondData.bufferSize = len;\n            secondData.isCompleted = true; // 最后一次加载，要标记加载完成\n            secondData.offset = 2048; // 已经加载过2048字节了，第二次偏移已经加载的量\n            secondData.updateLength = len - 2048; // 第二次加载剩余的数据\n            OH_ImageSource_UpdateData(imageSourceNative_c, &secondData);\n\n            napi_value pixelMap;\n            OhosImageDecodingOps decodingOps{};\n            decodingOps.index = 0;\n            // 创建pixelMap\n            OH_ImageSource_CreatePixelMap(imageSourceNative_c, &decodingOps, &pixelMap);\n\n            // 处理完毕，释放native层资源\n            OH_ImageSource_Release(imageSourceNative_c);\n            OH_ResourceManager_CloseRawFile(rawFile);\n            return pixelMap;\n         } \n         // 读取Raw文件全部数据\n         uint8_t * data = static_cast<uint8_t *>(malloc(len));\n         int res = OH_ResourceManager_ReadRawFile(rawFile, data, len);\n\n         OhosImageSource imageSource_c;\n         imageSource_c.buffer = data;\n         imageSource_c.bufferSize = len;\n\n         OhosImageSourceOps ops{};\n         napi_value imageSource;\n         napi_value pixelMap;\n\n         // 用读取到的Raw数据创建ImageSource\n         int32_t ret = OH_ImageSource_Create(env, &imageSource_c, &ops, &imageSource);\n\n         // 初始化native层的ImageSource\n         ImageSourceNative * imageSourceNative_c = OH_ImageSource_InitNative(env, imageSource);\n         OhosImageDecodingOps decodingOps{};\n\n         // 创建pixelMap\n         OH_ImageSource_CreatePixelMap(imageSourceNative_c, &decodingOps, &pixelMap);\n\n         // 处理完毕，释放native层资源\n         OH_ImageSource_Release(imageSourceNative_c);\n         OH_ResourceManager_CloseRawFile(rawFile);\n         return pixelMap;\n      }\n      OH_ResourceManager_ReleaseNativeResourceManager(mNativeResMgr);\n      return nullptr;\n   }

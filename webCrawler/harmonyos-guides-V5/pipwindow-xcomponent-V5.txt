使用XComponent实现画中画功能开发
本文以视频播放为例，介绍通过XComponent实现画中画功能的基本开发步骤。
约束与限制
仅支持以XComponent作为媒体流播放组件的界面进入画中画模式，XComponent的type必须为'surface'或者XComponentType.SURFACE。UIAbility使用Navigation管理页面时，需要设置Navigation控件的id属性，并将该id传递给画中画控制器，确保还原时可以正常恢复原页面。如果应用主窗口不在前台，不建议在画中画回调方法中执行UI操作，例如页面push/pop等，这些操作不会立即执行，可能产生预期之外的结果。
开发步骤
创建画中画控制器，注册生命周期事件以及控制事件回调。通过create(config: PiPConfiguration)接口创建画中画控制器实例。通过画中画控制器实例的setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画。通过画中画控制器实例的on('stateChange')接口注册生命周期事件回调。通过画中画控制器实例的on('controlPanelActionEvent')接口注册控制事件回调。 启动画中画。创建画中画控制器实例后，通过startPiP接口启动画中画。 更新媒体源尺寸信息。画中画媒体源更新后（如切换视频），通过画中画控制器实例的updateContentSize接口更新媒体源尺寸信息，以调整画中画窗口比例。 关闭画中画。当不再需要显示画中画时，可根据业务需要，通过画中画控制器实例的stopPiP接口关闭画中画。 
// Index.ets\n// 该页面用于展示Navigation在画中画场景的使用。如果UIAbility是单页面，则无需使用Navigation\nimport { Page1 } from './Page1'\n\n@Entry\n@Component\nstruct Index {\n  @Provide('pageInfos') pageInfos: NavPathStack = new NavPathStack();\n  private navId: string = 'navId';\n  @Builder\n  PageMap(name: string) {\n    if (name === 'pageOne') {\n      Page1({navId: this.navId});\n    }\n  }\n  build() {\n    Navigation(this.pageInfos) {\n      Column() {\n        Button('pushPath', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfos.pushPath({ name: 'pageOne' }) // 将name指定的NavDestination页面信息入栈\n          })\n          .stateStyles({\n            pressed: {\n              .backgroundColor(Color.Red);\n            },\n            normal: {\n              .backgroundColor(Color.Blue);\n            }\n          })\n      }\n    }.title('NavIndex').navDestination(this.PageMap)\n    .id(this.navId) // 设置Navigation组件的id属性\n  }\n}
// Page1.ets\n// 该页面用于展示画中画功能的基本使用\nimport { AVPlayerDemo } from './AVPlayerDemo'; // 请自行实现视频播放的相关开发\nimport { BuilderNode, FrameNode, NodeController, Size, UIContext, PiPWindow } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nconst TAG = 'Page1';\n\nclass Params {\n  text: string = '';\n  constructor(text: string) {\n    this.text = text;\n  }\n}\n\n// 开发者可以通过@Builder装饰器实现布局构建\n@Builder\nfunction buildText(params: Params) {\n  Column() {\n    Text(params.text)\n      .fontSize(20)\n      .fontColor(Color.Red)\n  }\n  .width('100%') // 宽度方向充满画中画窗口\n  .height('100%') // 高度方向充满画中画窗口\n}\n\n// 开发者可通过继承NodeController实现自定义UI控制器\nclass TextNodeController extends NodeController {\n  private message: string;\n  private textNode: BuilderNode<[Params]> | null = null;\n  constructor(message: string) {\n    super();\n    this.message = message;\n  }\n\n  // 通过BuilderNode加载自定义布局\n  makeNode(context: UIContext): FrameNode | null {\n    this.textNode = new BuilderNode(context);\n    this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.message));\n    return this.textNode.getFrameNode();\n  }\n\n  // 开发者可自定义该方法实现布局更新\n  update(message: string) {\n    console.log(`update message: ${message}`);\n    if (this.textNode !== null) {\n      this.textNode.update(new Params(message));\n    }\n  }\n}\n\n@Component\nexport struct Page1 {\n  @Consume('pageInfos') pageInfos: NavPathStack;\n  private surfaceId: string = ''; // surfaceId，用于关联XComponent与视频播放器\n  private mXComponentController: XComponentController = new XComponentController();\n  private player?: AVPlayerDemo = undefined;\n  private pipController?: PiPWindow.PiPController = undefined;\n  private nodeController: TextNodeController = new TextNodeController('this is custom UI');\n  navId: string = '';\n  build() {\n    NavDestination() {\n      Column() {\n        // XComponent控件，用于播放视频流\n        XComponent({ id: 'pipDemo', type: 'surface', controller: this.mXComponentController })\n          .onLoad(() => {\n            this.surfaceId = this.mXComponentController.getXComponentSurfaceId();\n            // 需要设置AVPlayer的surfaceId为XComponentController的surfaceId\n            this.player = new AVPlayerDemo(this.surfaceId);\n            this.player.avPlayerFdSrcDemo();\n          })\n          .onDestroy(() => {\n            console.info(`[${TAG}] XComponent onDestroy`);\n          })\n          .size({ width: '100%', height: '800px' })\n        Row({ space: 20 }) {\n          Button('start') // 启动画中画\n            .onClick(() => {\n              this.startPip();\n            })\n            .stateStyles({\n              pressed: {\n                .backgroundColor(Color.Red);\n              },\n              normal: {\n                .backgroundColor(Color.Blue);\n              }\n            })\n          Button('stop') // 停止画中画\n            .onClick(() => {\n              this.stopPip();\n            })\n            .stateStyles({\n              pressed: {\n                .backgroundColor(Color.Red);\n              },\n              normal: {\n                .backgroundColor(Color.Blue);\n              }\n            })\n          Button('updateSize') // 更新视频尺寸\n            .onClick(() => {\n              // 此处设置的宽高应为媒体内容宽高，需要通过媒体相关接口或回调获取\n              // 例如使用AVPlayer播放视频时，可通过videoSizeChange回调获取媒体源更新后的尺寸\n              this.updateContentSize(900, 1600);\n            })\n            .stateStyles({\n              pressed: {\n                .backgroundColor(Color.Red);\n              },\n              normal: {\n                .backgroundColor(Color.Blue);\n              }\n            })\n        }\n        .size({ width: '100%', height: 60 })\n        .justifyContent(FlexAlign.SpaceAround)\n      }\n      .justifyContent(FlexAlign.Center)\n      .height('100%')\n      .width('100%')\n    }\n  }\n\n  startPip() {\n    if (!PiPWindow.isPiPEnabled()) {\n      console.error(`picture in picture disabled for current OS`);\n      return;\n    }\n    let config: PiPWindow.PiPConfiguration = {\n      context: getContext(this),\n      componentController: this.mXComponentController,\n      // 当前page导航id\n      // 1、UIAbility使用Navigation管理页面，需要设置Navigation控件的id属性，并将该id设置给画中画控制器，确保还原场景下能够从画中画窗口恢复到原页面\n      // 2、UIAbility使用Router管理页面时（画中画场景不推荐该导航方式），无需设置navigationId。注意：该场景下启动画中画后，不要进行页面切换，否则还原场景可能出现异常\n      // 3、UIAbility只有单页面时，无需设置navigationId，还原场景下也能够从画中画窗口恢复到原页面\n      navigationId: this.navId,\n      templateType: PiPWindow.PiPTemplateType.VIDEO_PLAY, // 对于视频通话、视频会议等场景，需要设置相应的模板类型\n      contentWidth: 1920, // 可选，创建画中画控制器时系统可通过XComponent组件大小设置画中画窗口比例\n      contentHeight: 1080, // 可选，创建画中画控制器时系统可通过XComponent组件大小设置画中画窗口比例\n      controlGroups:[PiPWindow.VideoPlayControlGroup.VIDEO_PREVIOUS_NEXT], // 可选，对于视频通话、视频会议和视频直播场景，可通过该属性选择对应模板类型下需显示的的控件组\n      customUIController: this.nodeController, // 可选，如果需要在画中画显示内容上方展示自定义UI，可设置该参数。\n    };\n    // 步骤1：创建画中画控制器，通过create接口创建画中画控制器实例\n    let promise : Promise<PiPWindow.PiPController> = PiPWindow.create(config);\n    promise.then((controller : PiPWindow.PiPController) => {\n      this.pipController = controller;\n      // 步骤1：初始化画中画控制器\n      this.initPipController();\n      // 步骤2：通过startPiP接口启动画中画\n      this.pipController.startPiP().then(() => {\n        console.info(`Succeeded in starting pip.`);\n      }).catch((err: BusinessError) => {\n        console.error(`Failed to start pip. Cause:${err.code}, message:${err.message}`);\n      });\n    }).catch((err: BusinessError) => {\n      console.error(`Failed to create pip controller. Cause:${err.code}, message:${err.message}`);\n    });\n  }\n\n  initPipController() {\n    if (!this.pipController) {\n      return;\n    }\n    // 步骤1：通过setAutoStartEnabled接口设置是否需要在应用返回桌面时自动启动画中画，注册stateChange和controlPanelActionEvent回调\n    this.pipController.setAutoStartEnabled(false /*or true if necessary*/); // 默认为false\n    this.pipController.on('stateChange', (state: PiPWindow.PiPState, reason: string) => {\n      this.onStateChange(state, reason);\n    });\n    this.pipController.on('controlPanelActionEvent', (event: PiPWindow.PiPActionEventType, status?: number) => {\n      this.onActionEvent(event, status);\n    });\n  }\n\n  onStateChange(state: PiPWindow.PiPState, reason: string) {\n    let curState: string = '';\n    switch(state) {\n      case PiPWindow.PiPState.ABOUT_TO_START:\n        curState = \"ABOUT_TO_START\";\n        break;\n      case PiPWindow.PiPState.STARTED:\n        curState = \"STARTED\";\n        break;\n      case PiPWindow.PiPState.ABOUT_TO_STOP:\n        curState = \"ABOUT_TO_STOP\";\n        break;\n      case PiPWindow.PiPState.STOPPED:\n        curState = \"STOPPED\";\n        break;\n      case PiPWindow.PiPState.ABOUT_TO_RESTORE:\n        curState = \"ABOUT_TO_RESTORE\";\n        break;\n      case PiPWindow.PiPState.ERROR:\n        curState = \"ERROR\";\n        break;\n      default:\n        break;\n    }\n    console.info(`[${TAG}] onStateChange: ${curState}, reason: ${reason}`);\n  }\n\n  onActionEvent(event: PiPWindow.PiPActionEventType, status?: number) {\n    switch (event) {\n      case 'playbackStateChanged':\n      // 开始或停止视频\n        if (status === 0) {\n          // 停止视频\n        } else if (status === 1) {\n          // 播放视频\n        }\n        break;\n      case 'nextVideo':\n      // 播放上一个视频\n        break;\n      case 'previousVideo':\n      // 播放下一个视频\n        break;\n      default:\n        break;\n    }\n  }\n\n  // 步骤3：视频内容变化时，向画中画控制器更新视频尺寸信息，用于调整画中画窗口比例\n  updateContentSize(width: number, height: number) {\n    if (this.pipController) {\n      this.pipController.updateContentSize(width, height);\n    }\n  }\n\n  // 步骤4：当不再需要显示画中画时，通过stopPiP接口关闭画中画\n  stopPip() {\n    if (this.pipController) {\n      let promise : Promise<void> = this.pipController.stopPiP();\n      promise.then(() => {\n        console.info(`Succeeded in stopping pip.`);\n        this.pipController?.off('stateChange'); // 如果已注册stateChange回调，停止画中画时取消注册该回调\n        this.pipController?.off('controlPanelActionEvent'); // 如果已注册controlPanelActionEvent回调，停止画中画时取消注册该回调\n      }).catch((err: BusinessError) => {\n        console.error(`Failed to stop pip. Cause:${err.code}, message:${err.message}`);\n      });\n    }\n  }\n}
以上示例代码对应的示意图如下所示：
示例代码
画中画效果

JSVM-API支持的数据类型和接口
JSVM-API的数据类型
[h2]JSVM_Status
是一个枚举数据类型，表示JSVM-API接口返回的状态信息。
每当调用一个JSVM-API函数，都会返回该值，表示操作成功与否的相关信息。
typedef enum {\n    JSVM_OK,\n    JSVM_INVALID_ARG,\n    JSVM_OBJECT_EXPECTED,\n    JSVM_STRING_EXPECTED,\n    JSVM_NAME_EXPECTED,\n    JSVM_FUNCTION_EXPECTED,\n    JSVM_NUMBER_EXPECTED,\n    JSVM_BOOL_EXPECTED,\n    JSVM_ARRAY_EXPECTED,\n    JSVM_GENERIC_FAILURE,\n    JSVM_PENDING_EXCEPTION,\n    JSVM_CENCELLED,\n    JSVM_ESCAPE_CALLED_TWICE,\n    JSVM_HANDLE_SCOPE_MISMATCH,\n    JSVM_CALLBACK_SCOPE_MISMATCH,\n    JSVM_QUEUE_FULL,\n    JSVM_CLOSING,\n    JSVM_BIGINT_EXPECTED,\n    JSVM_DATA_EXPECTED,\n    JSVM_CALLBACK_SCOPE_MISMATCH,\n    JSVM_DETACHABLE_ARRAYBUFFER_EXPECTED,\n    JSVM_WOULD_DEADLOCK,  /* unused */\n    JSVM_NO_EXTERNAL_BUFFERS_ALLOWED,\n    JSVM_CANNOT_RUN_JS\n} JSVM_Status;
[h2]JSVM_ExtendedErrorInfo
一个结构体，在调用函数不成功时存储了较为详细的错误信息。
typedef struct {\n    const char* errorMessage;\n    void* engineReserved;\n    uint32_t engineErrorCode;\n    JSVM_Status errorCode;\n} JSVM_ExtendedErrorInfo;
[h2]JSVM_Value
在C++代码中，表示一个JavaScript值。
[h2]JSVM_Env
用于表示JSVM-API执行时的上下文，Native侧函数入参，并传递给函数中的JSVM-API接口。 退出Native侧插件时，JSVM_Env将失效，该事件通过回调传递给OH_JSVM_SetInstanceData。 禁止缓存JSVM_Env，禁止在不同Worker中传递JSVM_Env。 在不同线程间共享JSVM_Env时，要保证在线程切换时在前一个线程中关闭env scope并在新的线程中打开新的env scope，以保证threadlocal变量的线程隔离。 
[h2]JSVM_ValueType
JSVM_Value的类型。包含了ECMAScript语言规范中定义的类型，其中JSVM_EXTERNAL表示外部数据类型。
typedef enum {\n    JSVM_UNDEFINED,\n    JSVM_NULL,\n    JSVM_BOOLEAN,\n    JSVM_NUMBER,\n    JSVM_STRING,\n    JSVM_SYMBOL,\n    JSVM_OBJECT,\n    JSVM_FUNCTION,\n    JSVM_EXTERNAL,\n    JSVM_BIGINT,\n} JSVM_ValueType;
[h2]JSVM_TypedarrayType
TypedArray的基本二进制标量数据类型。
typedef enum {\n    JSVM_INT8_ARRAY,\n    JSVM_UINT8_ARRAY,\n    JSVM_UINT8_CLAMPED_ARRAY,\n    JSVM_INT16_ARRAY,\n    JAVM_UINT16_ARRAY,\n    JSVM_INT32_ARRAY,\n    JSVM_UINT32_ARRAY,\n    JSVM_FLOAT32_ARRAY,\n    JSVM_FLOAT64_ARRAY,\n    JSVM_BIGINT64_ARRAY,\n    JSVM_BIGUINT64_ARRAY,\n} JSVM_TypedarrayType;
[h2]JSVM_RegExpFlags
正则表达式标志位。
typedef enum {\n    JSVM_REGEXP_NONE = 0,\n    JSVM_REGEXP_GLOBAL = 1 << 0,\n    JSVM_REGEXP_IGNORE_CASE = 1 << 1,\n    JSVM_REGEXP_MULTILINE = 1 << 2,\n    JSVM_REGEXP_STICKY = 1 << 3,\n    JSVM_REGEXP_UNICODE = 1 << 4,\n    JSVM_REGEXP_DOT_ALL = 1 << 5,\n    JSVM_REGEXP_LINEAR = 1 << 6,\n    JSVM_REGEXP_HAS_INDICES = 1 << 7,\n    JSVM_REGEXP_UNICODE_SETS = 1 << 8,\n} JSVM_RegExpFlags;
[h2]编译选项相关类型
JSVM_CompileOptions
配合编译接口 OH_JSVM_CompileScriptWithOptions 使用，是其参数中 options 数组的元素类型。
其中：
id 代表这个编译选项的类型。content 代表编译选项的内容。
id 的值和 content 的类型需要对应使用，详细对应关系参考下面对各个选项类型的介绍。
typedef struct {\n    /** compile option id. */\n    JSVM_CompileOptionId id;\n    /** option content. */\n    union {\n      /** ptr type. */\n      void *ptr;\n      /** int type. */\n      int num;\n      /** bool type. */\n      _Bool boolean;\n    } content;\n} JSVM_CompileOptions;
JSVM_CompileOptionId
JSVM_CompileOptions 中的 id 对应类型， 每个值都有其对应的 content 类型, 其中 JSVM_COMPILE_ENABLE_SOURCE_MAP 对应的类型为 bool，当同时传入的 JSVM_ScriptOrigin 中 sourceMapUrl 不为空时生效。
typedef enum {\n    /** compile mode. */\n    JSVM_COMPILE_MODE,\n    /** code cache content. */\n    JSVM_COMPILE_CODE_CACHE,\n    /** script origin. */\n    JSVM_COMPILE_SCRIPT_ORIGIN,\n    /** compile profile content. */\n    JSVM_COMPILE_COMPILE_PROFILE,\n    /** switch for source map support. */\n    JSVM_COMPILE_ENABLE_SOURCE_MAP,\n} JSVM_CompileOptionId;
JSVM_CompileMode
当 id 为 JSVM_COMPILE_MODE，content 的类型，每个值代表一种编译模式：
JSVM_COMPILE_MODE_DEFAULT : 默认的编译选项。JSVM_COMPILE_MODE_CONSUME_CODE_CACHE : 消耗 codecache 进行编译。JSVM_COMPILE_MODE_EAGER_COMPILE : 进行全量编译，不再进行 lazy compile。JSVM_COMPILE_MODE_PRODUCE_COMPILE_PROFILE/JSVM_COMPILE_MODE_CONSUME_COMPILE_PROFILE : 当前暂无效果，请等待后续更新。
typedef enum {\n    /** default mode. */\n    JSVM_COMPILE_MODE_DEFAULT,\n    /** consume code cache. */\n    JSVM_COMPILE_MODE_CONSUME_CODE_CACHE,\n    /** apply eager compile. */\n    JSVM_COMPILE_MODE_EAGER_COMPILE,\n    /** preset for compile profile. */\n    JSVM_COMPILE_MODE_PRODUCE_COMPILE_PROFILE,\n    /** consume compile profile. */\n    JSVM_COMPILE_MODE_CONSUME_COMPILE_PROFILE,\n} JSVM_CompileMode;
JSVM_CodeCache
当 id 为 JSVM_COMPILE_CODE_CACHE 时，content 的类型：
cache : 指向 code cache 的指针。length : code cache 的大小。
typedef struct {\n    /** cache pointer. */\n    uint8_t *cache;\n    /** length. */\n    size_t length;\n} JSVM_CodeCache;
JSVM_ScriptOrigin
当 id 为 JSVM_COMPILE_SCRIPT_ORIGIN 时，content 的类型，存放待编译脚本的源码信息：
sourceMapUrl : sourceMap 的路径，当前仅支持运行设备上的本地路径, 可以为空。resourceName : 待编译的 js script 的名字。
typedef struct {\n    /** Sourcemap url. */\n    const char* sourceMapUrl;\n    /** Resource name. */\n    const char* resourceName;\n    /** Resource line offset. */\n    size_t resourceLineOffset;\n    /** Resource column offset. */\n    size_t resourceColumnOffset;\n} JSVM_ScriptOrigin;
[h2]JSVM
[h2]内存管理类型
JSVM-API包含以下内存管理类型：
JSVM_HandleScope
JSVM_HandleScope数据类型是用来管理JavaScript对象的生命周期的。它允许JavaScript对象在一定范围内保持活动状态，以便在JavaScript代码中使用。在创建JSVM_HandleScope时，所有在该范围内创建的JavaScript对象都会保持活动状态，直到结束。这样可以避免在JavaScript代码中使用已经被释放的对象，从而提高代码的可靠性和性能。
JSVM_EscapableHandleScope
由OH_JSVM_OpenEscapableHandleScope接口创建，由OH_JSVM_CloseEscapableHandleScope接口关闭。 表示一种特殊类型的句柄范围，用于将在JSVM_EscapableHandleScope范围内创建的值返回给父scope。 用于OH_JSVM_EscapeHandle接口，将JSVM_EscapableHandleScope提升到JavaScript对象，以便在外部作用域使用。 
JSVM_Ref
指向JSVM_Value，允许用户管理JavaScript值的生命周期。
JSVM_TypeTag
该结构体定义了一个包含两个无符号64位整数的类型标签，用于标识一个JSVM-API值的类型信息。
typedef struct {\n    uint64_t lower;\n    uint64_t upper;\n} JSVM_TypeTag;
存储了两个无符号64位整数的128位值，用它来标记JavaScript对象，确保它们属于某种类型。 比OH_JSVM_Instanceof更强的类型检查，如果对象的原型被操纵，OH_JSVM_Instanceof可能会报告误报。 JSVM_TypeTag 在与 OH_JSVM_Wrap 结合使用时最有用，因为它确保从包装对象检索的指针可以安全地转换为与先前应用于JavaScript对象的类型标记相对应的Native类型。 
[h2]回调类型
JSVM-API包含以下回调类型：
JSVM_CallbackStruct
用户提供的 Native callback 的回调函数指针和数据，JSVM_CallbackStruct 将通过 JSVM-API 暴露给 JavaScript。例如，可以使用 OH_JSVM_CreateFunction 接口创建绑定到 Native callback 的 JS 函数，其中 Native callback 就是通过 JSVM_CallbackStruct 结构定义。除非在对象生命周期管理中有特殊要求，一般不在此 callback 中创建 handle 或者 callback scope。
typedef struct {\n  JSVM_Value(*callback)(JSVM_Env env, JSVM_CallbackInfo info);\n  void* data;\n} JSVM_CallbackStruct;
JSVM_Callback
JSVM_CallbackStruct 指针类型的类型别名。
定义如下:
typedef JSVM_CallbackStruct* JSVM_Callback;
JSVM_CallbackInfo
用户定义的 Native callback，第一个参数类型是 JSVM_Env，第二个参数类型是 JSVM_CallbackInfo。JSVM_CallbackInfo 表示从 JS 侧调用到 Native 侧时携带的调用信息，如参数列表。在实现 Native callback 时，一般使用 OH_JSVM_GetCbInfo 接口从 JSVM_CallbackInfo 中提取调用信息。
JSVM_Finalize
函数指针，用于传入OH_JSVM_SetInstanceData、OH_JSVM_CreateExternal、OH_JSVM_Wrap等接口。JSVM_Finalize在对象被回收时会被调用，可用于在JavaScript对象被垃圾回收时释放Native对象。
写法如下：
typedef void (*JSVM_Finalize)(JSVM_Env env, void* finalizeData, void* finalizeHint);
JSVM_PropertyHandlerConfigurationStruct
当执行对象的getter、setter、deleter和enumerator作时，对应的的回调将会触发。
typedef struct {\n    JSVM_Value(JSVM_CDECL* genericNamedPropertyGetterCallback)(JSVM_Env env,\n                                                               JSVM_Value name,\n                                                               JSVM_Value thisArg,\n                                                               JSVM_Value namedPropertyData);\n    JSVM_Value(JSVM_CDECL* genericNamedPropertySetterCallback)(JSVM_Env env,\n                                                               JSVM_Value name,\n                                                               JSVM_Value property,\n                                                               JSVM_Value thisArg,\n                                                               JSVM_Value namedPropertyData);\n    JSVM_Value(JSVM_CDECL* genericNamedPropertyDeleterCallback)(JSVM_Env env,\n                                                                JSVM_Value name,\n                                                                JSVM_Value thisArg,\n                                                                JSVM_Value namedPropertyData);\n    JSVM_Value(JSVM_CDECL* genericNamedPropertyEnumeratorCallback)(JSVM_Env env,\n                                                                   JSVM_Value thisArg,\n                                                                   JSVM_Value namedPropertyData);\n    JSVM_Value(JSVM_CDECL* genericIndexedPropertyGetterCallback)(JSVM_Env env,\n                                                                JSVM_Value index,\n                                                                JSVM_Value thisArg,\n                                                                JSVM_Value indexedPropertyData);\n    JSVM_Value(JSVM_CDECL* genericIndexedPropertySetterCallback)(JSVM_Env env,\n                                                                 JSVM_Value index,\n                                                                 JSVM_Value property,\n                                                                 JSVM_Value thisArg,\n                                                                 JSVM_Value indexedPropertyData);\n    JSVM_Value(JSVM_CDECL* genericIndexedPropertyDeleterCallback)(JSVM_Env env,\n                                                                  JSVM_Value index,\n                                                                  JSVM_Value thisArg,\n                                                                  JSVM_Value indexedPropertyData);\n    JSVM_Value(JSVM_CDECL* genericIndexedPropertyEnumeratorCallback)(JSVM_Env env,\n                                                                     JSVM_Value thisArg,\n                                                                     JSVM_Value indexedPropertyData);\n    JSVM_Value namedPropertyData;\n    JSVM_Value indexedPropertyData;\n} JSVM_PropertyHandlerConfigurationStruct;
JSVM_PropertyHandlerCfg
包含属性监听回调的结构的指针类型。
基本用法如下:
typedef JSVM_PropertyHandlerConfigurationStruct* JSVM_PropertyHandlerCfg;
支持的JSVM-API接口
标准JS引擎的能力通过JSVM-API提供。JSVM-API支持动态链接到不同版本的JS引擎库，从而为开发者屏蔽掉不同引擎接口的差异。JSVM-API提供引擎生命周期管理、JS context管理、JS代码执行、JS/C++互操作、执行环境快照、codecache等能力，具体可见下文。
[h2]使用 JSVM-API 接口创建引擎实例及 JS 执行上下文环境
场景介绍
执行JS代码需要先创建JavaScript VM，创建JS执行的上下文环境。
接口说明
JSVM_InitOptions 的使用描述
通过传入 JSVM_InitOptions 可以初始化具备不同能力的 VM 平台。
场景示例：
常规模式下初始化 VM 平台
static void NormalInit(bool &vmInit) {\n    if (!vmInit) {\n        // JSVM only need init once\n        JSVM_InitOptions initOptions;\n        memset(&initOptions, 0, sizeof(initOptions));\n        OH_JSVM_Init(&initOptions);\n        vmInit = true;\n    }\n}
场景示例：
初始化低内存占用的 VM 平台
static void LowMemoryInit(bool &vmInit) {\n    if (!vmInit) {\n        // JSVM only need init once\n        JSVM_InitOptions initOptions;\n        initOptions.argc = 4;\n        const char* argv[4];\n        argv[1] = \"--incremental-marking-hard-trigger=40\";\n        argv[2] = \"--min-semi-space-size=4\";\n        argv[3] = \"--max-semi-space-size=1\";\n        initOptions.argv = const_cast<char**>(argv);\n        OH_JSVM_Init(&initOptions);\n        vmInit = true;\n    }\n}
场景示例：
初始化低GC触发频次的 VM 平台
static void LowGCFrequencyInit(bool &vmInit) {\n    if (!vmInit) {\n        // JSVM only need init once\n        JSVM_InitOptions initOptions;\n        initOptions.argc = 4;\n        const char* argv[4];\n        argv[1] = \"--incremental-marking-hard-trigger=80\";\n        argv[2] = \"--min-semi-space-size=16\";\n        argv[3] = \"--max-semi-space-size=16\";\n        initOptions.argv = const_cast<char**>(argv);\n        OH_JSVM_Init(&initOptions);\n        vmInit = true;\n    }\n}
执行结果：
使用以上三个接口可以分别初始化具备不同能力的 VM 平台。初始化之后，可以创建 VM 实例，并执行 JavaScript 脚本。其中，
调用 LowGCFrequencyInit 接口进行 VM 平台初始化执行 JavaScript 脚本，相比调用 NormalInit 接口所触发的 GC 频次更低。调用 LowMemoryInit 接口进行 VM 平台初始化执行 JavaScript 脚本，相比调用 NormalInit 接口所占用内存更少。
创建 VM 实例
场景示例:
创建及销毁JavaScript引擎实例，包含创建及销毁JS执行上下文环境
bool VM_INIT = false;\n\nstatic JSVM_Value ConsoleInfo(JSVM_Env env, JSVM_CallbackInfo info) {\n    size_t argc = 1;\n    JSVM_Value args[1];\n    char log[256] = \"\";\n    size_t logLength;\n    OH_JSVM_GetCbInfo(env, info, &argc, args, NULL, NULL);\n\n    OH_JSVM_GetValueStringUtf8(env, args[0], log, 255, &logLength);\n    log[255] = 0;\n    OH_LOG_INFO(LOG_APP, \"JSVM API TEST: %{public}s\", log);\n    return nullptr;\n}\n\nstatic JSVM_Value Add(JSVM_Env env, JSVM_CallbackInfo info) {\n    size_t argc = 2;\n    JSVM_Value args[2];\n    OH_JSVM_GetCbInfo(env, info, &argc, args, NULL, NULL);\n    double num1, num2;\n    env, OH_JSVM_GetValueDouble(env, args[0], &num1);\n    OH_JSVM_GetValueDouble(env, args[1], &num2);\n    JSVM_Value sum = nullptr;\n    OH_JSVM_CreateDouble(env, num1 + num2, &sum);\n    return sum;\n}\n\nstatic napi_value MyJSVMDemo([[maybe_unused]] napi_env _env, [[maybe_unused]] napi_callback_info _info) {\n    std::thread t([]() {\n        // 可以根据不同的业务需求初始化具备不同能力的 VM 平台：\n        // 1. 初始化默认的 VM 平台：调用'NormalInit'接口。\n        // 2. 初始化低内存占用的 VM 平台：调用'LowMemoryInit'接口。\n        // 3. 初始化低 GC 触发频次的 VM 平台：调用'LowGCFrequencyInit'接口。\n        NormalInit(VM_INIT);\n        // create vm, and open vm scope\n        JSVM_VM vm;\n        JSVM_CreateVMOptions options;\n        memset(&options, 0, sizeof(options));\n        OH_JSVM_CreateVM(&options, &vm);\n\n        JSVM_VMScope vmScope;\n        OH_JSVM_OpenVMScope(vm, &vmScope);\n\n        JSVM_CallbackStruct param[] = {\n            {.data = nullptr, .callback = ConsoleInfo},\n            {.data = nullptr, .callback = Add},\n        };\n        JSVM_PropertyDescriptor descriptor[] = {\n            {\"consoleinfo\", NULL, &param[0], NULL, NULL, NULL, JSVM_DEFAULT},\n            {\"add\", NULL, &param[1], NULL, NULL, NULL, JSVM_DEFAULT},\n        };\n        // create env, register native method, and open env scope\n        JSVM_Env env;\n        OH_JSVM_CreateEnv(vm, sizeof(descriptor) / sizeof(descriptor[0]), descriptor, &env);\n\n        JSVM_EnvScope envScope;\n        OH_JSVM_OpenEnvScope(env, &envScope);\n\n        // open handle scope\n        JSVM_HandleScope handleScope;\n        OH_JSVM_OpenHandleScope(env, &handleScope);\n\n        std::string sourceCodeStr = \"\\\n{\\\nlet value = add(4.96, 5.28);\\\nconsoleinfo('Result is:' + value);\\\n}\\\n\";\n        // compile js script\n        JSVM_Value sourceCodeValue;\n        OH_JSVM_CreateStringUtf8(env, sourceCodeStr.c_str(), sourceCodeStr.size(), &sourceCodeValue);\n        JSVM_Script script;\n        OH_JSVM_CompileScript(env, sourceCodeValue, nullptr, 0, true, nullptr, &script);\n        JSVM_Value result;\n        // run js script\n        OH_JSVM_RunScript(env, script, &result);\n        JSVM_ValueType type;\n        OH_JSVM_Typeof(env, result, &type);\n        OH_LOG_INFO(LOG_APP, \"JSVM API TEST type: %{public}d\", type);\n\n        // exit vm and clean memory\n        OH_JSVM_CloseHandleScope(env, handleScope);\n\n        OH_JSVM_CloseEnvScope(env, envScope);\n        OH_JSVM_DestroyEnv(env);\n\n        OH_JSVM_CloseVMScope(vm, vmScope);\n        OH_JSVM_DestroyVM(vm);\n    });\n\n    t.detach();\n\n    return nullptr;\n}
[h2]使用 JSVM-API 接口编译及执行 JS 代码
场景介绍
编译及执行JS代码。
接口说明
场景示例：
编译及执行JS代码(创建vm，注册function，执行js，销毁vm)。
#include <cstring>\n#include <fstream>\n#include <string>\n#include <vector>\n\n// 依赖libjsvm.so\n#include \"ark_runtime/jsvm.h\"\n\nusing namespace std;\n\nstatic JSVM_Value Hello(JSVM_Env env, JSVM_CallbackInfo info) {\n    JSVM_Value output;\n    void* data = nullptr;\n    OH_JSVM_GetCbInfo(env, info, nullptr, nullptr, nullptr, &data);\n    OH_JSVM_CreateStringUtf8(env, (char*)data, strlen((char*)data), &output);\n    return output;\n}\n\nstatic JSVM_CallbackStruct hello_cb = { Hello, (void*)\"Hello\" };\n\nstatic string srcGlobal = R\"JS(\nconst concat = (...args) => args.reduce((a, b) => a + b);\n)JS\";\n\nstatic void RunScriptWithOption(JSVM_Env env, string& src,\n                                uint8_t** dataPtr = nullptr,\n                                size_t* lengthPtr = nullptr) {\n    JSVM_HandleScope handleScope;\n    OH_JSVM_OpenHandleScope(env, &handleScope);\n\n    JSVM_Value jsSrc;\n    OH_JSVM_CreateStringUtf8(env, src.c_str(), src.size(), &jsSrc);\n\n    uint8_t* data = dataPtr ? *dataPtr : nullptr;\n    auto compilMode = data ? JSVM_COMPILE_MODE_CONSUME_CODE_CACHE :  JSVM_COMPILE_MODE_DEFAULT;\n    size_t length = lengthPtr ? *lengthPtr : 0;\n    JSVM_Script script;\n    // 编译js代码\n    JSVM_ScriptOrigin origin {\n        // 以包名 helloworld 为例, 假如存在对应的 sourcemap, source map 的的路径可以是 /data/app/el2/100/base/com.example.helloworld/files/index.js.map\n        .sourceMapUrl = \"/data/app/el2/100/base/com.example.helloworld/files/index.js.map\",\n        // 源文件名字\n        .resourceName = \"index.js\",\n        // scirpt 在源文件中的起始行列号\n        .resourceLineOffset = 0,\n        .resourceColumnOffset = 0,\n    };\n    JSVM_CompileOptions option[3];\n    option[0] = {\n        .id = JSVM_COMPILE_MODE,\n        .content = { .num = compilMode }\n    };\n    JSVM_CodeCache codeCache = {\n        .cache = data,\n        .length = length\n    };\n    option[1] = {\n        .id = JSVM_COMPILE_CODE_CACHE,\n        .content = { .ptr = &codeCache }\n    };\n    // JSVM_COMPILE_ENABLE_SOURCE_MAP 选项默认值为 false，若为 true 那么对应的 sourceMapUrl 必须不为空\n    option[2] = {\n        .id = JSVM_COMPILE_ENABLE_SOURCE_MAP,\n        .content = { .boolean = true }\n    };\n    OH_JSVM_CompileScriptWithOptions(env, jsSrc, 3, option, &script);\n\n    JSVM_Value result;\n    // 执行js代码\n    OH_JSVM_RunScript(env, script, &result);\n\n    char resultStr[128];\n    size_t size;\n    OH_JSVM_GetValueStringUtf8(env, result, resultStr, 128, &size);\n    printf(\"%s\\n\", resultStr);\n    if (dataPtr && lengthPtr && *dataPtr == nullptr) {\n        // 将js源码编译出的脚本保存到cache，可以避免重复编译，带来性能提升\n        OH_JSVM_CreateCodeCache(env, script, (const uint8_t**)dataPtr, lengthPtr);\n        printf(\"Code cache created with length = %ld\\n\", *lengthPtr);\n    }\n\n    OH_JSVM_CloseHandleScope(env, handleScope);\n}\n\nstatic void RunScript(JSVM_Env env, string& src,\n                       bool withOrigin = false,\n                       uint8_t** dataPtr = nullptr,\n                       size_t* lengthPtr = nullptr) {\n    JSVM_HandleScope handleScope;\n    OH_JSVM_OpenHandleScope(env, &handleScope);\n\n    JSVM_Value jsSrc;\n    OH_JSVM_CreateStringUtf8(env, src.c_str(), src.size(), &jsSrc);\n\n    uint8_t* data = dataPtr ? *dataPtr : nullptr;\n    size_t length = lengthPtr ? *lengthPtr : 0;\n    bool cacheRejected = true;\n    JSVM_Script script;\n    // 编译js代码\n    if (withOrigin) {\n        JSVM_ScriptOrigin origin {\n            // 以包名 helloworld 为例, 假如存在对应的 sourcemap, source map 的的路径可以是 /data/app/el2/100/base/com.example.helloworld/files/index.js.map\n            .sourceMapUrl = \"/data/app/el2/100/base/com.example.helloworld/files/index.js.map\",\n            // 源文件名字\n            .resourceName = \"index.js\",\n            // scirpt 在源文件中的起始行列号\n            .resourceLineOffset = 0,\n            .resourceColumnOffset = 0,\n        };\n        OH_JSVM_CompileScriptWithOrigin(env, jsSrc, data, length, true, &cacheRejected, &origin, &script);\n    } else {\n        OH_JSVM_CompileScript(env, jsSrc, data, length, true, &cacheRejected, &script);\n    }\n    printf(\"Code cache is %s\\n\", cacheRejected ? \"rejected\" : \"used\");\n\n    JSVM_Value result;\n    // 执行js代码\n    OH_JSVM_RunScript(env, script, &result);\n\n    char resultStr[128];\n    size_t size;\n    OH_JSVM_GetValueStringUtf8(env, result, resultStr, 128, &size);\n    printf(\"%s\\n\", resultStr);\n    if (dataPtr && lengthPtr && *dataPtr == nullptr) {\n        // 将js源码编译出的脚本保存到cache，可以避免重复编译，带来性能提升\n        OH_JSVM_CreateCodeCache(env, script, (const uint8_t**)dataPtr, lengthPtr);\n        printf(\"Code cache created with length = %ld\\n\", *lengthPtr);\n    }\n\n    OH_JSVM_CloseHandleScope(env, handleScope);\n}\n\nstatic void CreateSnapshot() {\n    JSVM_VM vm;\n    JSVM_CreateVMOptions options;\n    memset(&options, 0, sizeof(options));\n    options.isForSnapshotting = true;\n    OH_JSVM_CreateVM(&options, &vm);\n    JSVM_VMScope vmScope;\n    OH_JSVM_OpenVMScope(vm, &vmScope);\n\n    JSVM_Env env;\n    // 将native函数注册成js可调用的方法，hello_cb中记录该native方法的指针和参数等信息\n    JSVM_PropertyDescriptor descriptors[] = {\n        { \"hello\", NULL, &hello_cb, NULL, NULL, NULL, JSVM_DEFAULT }\n    };\n    OH_JSVM_CreateEnv(vm, 1, descriptors, &env);\n\n    JSVM_EnvScope envScope;\n    OH_JSVM_OpenEnvScope(env, &envScope);\n    // 执行js源码src，src中可以包含任何js语法。也可以调用已注册的native方法。\n    string src = srcGlobal + \"concat(hello(), ', ', 'World from CreateSnapshot!');\";\n    RunScript(env, src, true);\n\n    // 创建snapshot，将当前的env保存到字符串，可以在某个时机通过该字符串还原出env，避免重复定义该env中的属性，带来性能提升。\n    const char* blobData = nullptr;\n    size_t blobSize = 0;\n    JSVM_Env envs[1] = { env };\n    OH_JSVM_CreateSnapshot(vm, 1, envs, &blobData, &blobSize);\n    printf(\"Snapshot blob size = %ld\\n\", blobSize);\n\n    // 如果将snapshot保存到文件中，需要考虑应用中的文件读写权限\n    ofstream file(\"/data/storage/el2/base/files/blob.bin\", ios::out | ios::binary | ios::trunc);\n    file.write(blobData, blobSize);\n    file.close();\n\n    OH_JSVM_CloseEnvScope(env, envScope);\n    OH_JSVM_DestroyEnv(env);\n    OH_JSVM_CloseVMScope(vm, vmScope);\n    OH_JSVM_DestroyVM(vm);\n}\n\nvoid RunWithoutSnapshot(uint8_t** dataPtr, size_t* lengthPtr) {\n    // 创建虚拟机实例\n    JSVM_VM vm;\n    OH_JSVM_CreateVM(nullptr, &vm);\n    JSVM_VMScope vmScope;\n    OH_JSVM_OpenVMScope(vm, &vmScope);\n\n    JSVM_Env env;\n    // 将native函数注册成js可调用的方法，hello_cb中记录该native方法的指针和参数等信息\n    JSVM_PropertyDescriptor descriptors[] = {\n        { \"hello\", NULL, &hello_cb, NULL, NULL, NULL, JSVM_DEFAULT }\n    };\n    OH_JSVM_CreateEnv(vm, 1, descriptors, &env);\n    JSVM_EnvScope envScope;\n    OH_JSVM_OpenEnvScope(env, &envScope);\n    // 执行js源码src，src中可以包含任何js语法。也可以调用已注册的native方法。\n    auto src = srcGlobal + \"concat(hello(), ', ', 'World', ' from RunWithoutSnapshot!')\";\n    // 其中使用新增接口，可以覆盖原有 Compile 系列接口的功能且具有拓展性\n    RunScriptWithOption(env, src, dataPtr, lengthPtr);\n\n    OH_JSVM_CloseEnvScope(env, envScope);\n    OH_JSVM_DestroyEnv(env);\n    OH_JSVM_CloseVMScope(vm, vmScope);\n    OH_JSVM_DestroyVM(vm);\n}\n\nvoid RunWithSnapshot(uint8_t **dataPtr, size_t *lengthPtr) {\n    // The lifetime of blobData must not be shorter than that of the vm.\n    // 如果从文件中读取snapshot，需要考虑应用中的文件读写权限\n    vector<char> blobData;\n    ifstream file(\"/data/storage/el2/base/files/blob.bin\", ios::in | ios::binary | ios::ate);\n    size_t blobSize = file.tellg();\n    blobData.resize(blobSize);\n    file.seekg(0, ios::beg);\n    file.read(blobData.data(), blobSize);\n    file.close();\n\n    // 创建虚拟机实例\n    JSVM_VM vm;\n    JSVM_CreateVMOptions options;\n    memset(&options, 0, sizeof(options));\n    options.snapshotBlobData = blobData.data();\n    options.snapshotBlobSize = blobSize;\n    OH_JSVM_CreateVM(&options, &vm);\n    JSVM_VMScope vmScope;\n    OH_JSVM_OpenVMScope(vm, &vmScope);\n\n    // 从快照中创建env\n    JSVM_Env env;\n    OH_JSVM_CreateEnvFromSnapshot(vm, 0, &env);\n    JSVM_EnvScope envScope;\n    OH_JSVM_OpenEnvScope(env, &envScope);\n\n    // 执行js脚本，因为快照记录的env中定义了hello()，所以无需重新定义。dataPtr中如果保存了编译后的js脚本，就能直接执行js脚本，避免从源码重复编译。\n    string src = \"concat(hello(), ', ', 'World', ' from RunWithSnapshot!')\";\n    RunScript(env, src, true, dataPtr, lengthPtr);\n\n    OH_JSVM_CloseEnvScope(env, envScope);\n    OH_JSVM_DestroyEnv(env);\n    OH_JSVM_CloseVMScope(vm, vmScope);\n    OH_JSVM_DestroyVM(vm);\n}\n\nvoid PrintVmInfo() {\n    JSVM_VMInfo vmInfo;\n    OH_JSVM_GetVMInfo(&vmInfo);\n    printf(\"apiVersion: %d\\n\", vmInfo.apiVersion);\n    printf(\"engine: %s\\n\", vmInfo.engine);\n    printf(\"version: %s\\n\", vmInfo.version);\n    printf(\"cachedDataVersionTag: 0x%x\\n\", vmInfo.cachedDataVersionTag);\n}\n\nstatic intptr_t externals[] = {\n    (intptr_t)&hello_cb,\n    0,\n};\n\nint main(int argc, char *argv[]) {\n    if (argc <= 1) {\n        printf(\"Usage: %s gen-snapshot|use-snapshot|no-snapshot\\n\", argv[0]);\n        return 0;\n    }\n\n    JSVM_InitOptions initOptions;\n    memset(&initOptions, 0, sizeof(initOptions));\n    initOptions.externalReferences = externals;\n    // 初始化引擎，一个进程中只能初始化一次\n    OH_JSVM_Init(&initOptions);\n    PrintVmInfo();\n\n    if (argv[1] == string(\"gen-snapshot\")) {\n        CreateSnapshot();\n        return 0;\n    }\n\n    // snapshot可以记录下某个时间的js执行环境，可以跨进程通过snapshot快速还原出js执行上下文环境，前提是保证snapshot数据的生命周期。\n    const auto useSnapshot = argv[1] == string(\"use-snapshot\");\n    const auto run = useSnapshot ? RunWithSnapshot : RunWithoutSnapshot;\n    uint8_t* data = nullptr;\n    size_t length = 0;\n    run(&data, &length);\n    run(&data, &length);\n    delete[] data;\n\n    return 0;\n}
[h2]使用 JSVM-API WebAssembly 接口编译 wasm module
场景介绍
JSVM-API WebAssembly 接口提供了 wasm 字节码编译、wasm 函数优化、wasm cache 序列化和反序列化的能力。
接口说明
场景示例
详见使用 JSVM-API WebAssembly 接口。
[h2]异常处理
场景介绍
获取、抛出、清理JS异常
接口说明
场景示例：
以TypeError为例。创建，判断，并抛出JS TypeError。
JSVM_Value code = nullptr;\nJSVM_Value message = nullptr;\nOH_JSVM_CreateStringUtf8(env, \"500\", JSVM_AUTO_LENGTH, &code);\nOH_JSVM_CreateStringUtf8(env, \"type error 500\", JSVM_AUTO_LENGTH, &message);\nJSVM_Value error = nullptr;\nOH_JSVM_CreateTypeError(env, code, message, &error);\nbool isError = false;\nOH_JSVM_IsError(env, error, &isError);\nOH_JSVM_ThrowTypeError(env, nullptr, \"type error1\");
使用OH_JSVM_GetAndClearLastException后将异常信息以字符串形式打印
if (status != JSVM_OK) // 当执行失败出现异常时\n{\n    bool isPending = false;\n    if (JSVM_OK == OH_JSVM_IsExceptionPending((env), &isPending) && isPending)\n    {\n        JSVM_Value error;\n        if (JSVM_OK == OH_JSVM_GetAndClearLastException((env), &error))\n        {\n            // 获取异常堆栈\n            JSVM_Value stack;\n            OH_JSVM_GetNamedProperty((env), error, \"stack\", &stack);\n\n            JSVM_Value message;\n            OH_JSVM_GetNamedProperty((env), error, \"message\", &message);\n\n            char stackstr[256];\n            OH_JSVM_GetValueStringUtf8(env, stack, stackstr, 256, nullptr);\n            OH_LOG_INFO(LOG_APP, \"JSVM error stack: %{public}s\", stackstr);\n\n            char messagestr[256];\n            OH_JSVM_GetValueStringUtf8(env, message, messagestr, 256, nullptr);\n            OH_LOG_INFO(LOG_APP, \"JSVM error message: %{public}s\", messagestr);\n        }\n    }\n}
[h2]对象生命周期管理
在调用JSVM-API接口时，底层VM堆中的对象可能会作为JSVM_Values返回句柄。这些句柄必须在Native方法退出或主动释放掉前，使其关联的对象处于“活动”状态，防止被引擎回收掉。
当对象句柄被返回时，它们与一个“scope”相关联。默认作用域的生命周期与本机方法调用的生命周期相关联，这些句柄及关联的对象将在Native方法的生命周期内保持活动状态。
然而，在许多情况下，句柄必须保持有效的时间范围并不与Native方法的生命周期相同。下面将介绍可用于更改句柄的生命周期的JSVM-API方法。
对象生命周期管理接口说明
场景示例：
通过handlescope保护在scope范围内创建的对象在该范围内不被回收。
JSVM_HandleScope scope;\nOH_JSVM_OpenHandleScope(env, &scope);\nJSVM_Value obj = nullptr;\nOH_JSVM_CreateObject(env, &obj);\nOH_JSVM_CloseHandleScope(env, scope);
通过escapable handlescope保护在scope范围内创建的对象在父作用域范围内不被回收
JSVM_EscapableHandleScope scope;\nJSVM_CALL(env, OH_JSVM_OpenEscapableHandleScope(env, &scope));\nJSVM_Value output = NULL;\nJSVM_Value escapee = NULL;\nJSVM_CALL(env, OH_JSVM_CreateObject(env, &output));\nJSVM_CALL(env, OH_JSVM_EscapeHandle(env, scope, output, &escapee));\nJSVM_CALL(env, OH_JSVM_CloseEscapableHandleScope(env, scope));\nreturn escapee;
通过CreateReference创建对象引用和释放
JSVM_Value obj = nullptr;\nOH_JSVM_CreateObject(env, &obj);\n// 创建引用\nJSVM_Ref reference;\nOH_JSVM_CreateReference(env, obj, 1, &reference);\n\n// 使用引用\nJSVM_Value result;\nOH_JSVM_GetReferenceValue(env, reference, &result);\n\n// 释放引用\nOH_JSVM_DeleteReference(env, reference);
通过 RetainScript 持久化保存 JSVM_Script 并使用
JSVM_HandleScope scope;\nOH_JSVM_OpenHandleScope(env, &scope);\nJSVM_Script script;\nJSVM_Value jsSrc;\nstd::string src(R\"JS(\nlet a = 37;\na = a * 9;\n)JS\");\nOH_JSVM_CreateStringUtf8(env, src.c_str(), src.size(), &jsSrc);\nOH_JSVM_CompileScriptWithOptions(env, jsSrc, 0, nullptr, &script);\nOH_JSVM_RetainScript(env, script);\nOH_JSVM_CloseHandleScope(env, scope);\n\n// 使用JSVM_Script\nOH_JSVM_OpenHandleScope(env, &scope);\nJSVM_Value result;\nOH_JSVM_RunScript(env, script, &result);\n\n// 释放JSVM_Script，并置空\nOH_JSVM_ReleaseScript(env, script);\nscript = nullptr;\nOH_JSVM_CloseHandleScope(env, scope);
[h2]创建JS对象类型和基本类型
场景介绍
创建JS对象类型和基本类型
接口说明
场景示例:
创建指定长度的数组。
size_t arrayLength = 2;\nJSVM_Value arr;\n\nOH_JSVM_CreateArrayWithLength(env, arrayLength, &arr);\nfor (uint32_t i = 0; i < arrayLength; i++)\n{\n    JSVM_Value element;\n    OH_JSVM_CreateUint32(env, i * 2, &element);\n    OH_JSVM_SetElement(env, arr, i, element);\n}
创建typedarray，以Int32Array为例：
JSVM_Value arrayBuffer = nullptr;\nvoid *arrayBufferPtr = nullptr;\nsize_t arrayBufferSize = 16;\nsize_t typedArrayLength = 4;\nOH_JSVM_CreateArraybuffer(env, arrayBufferSize, &arrayBufferPtr, &arrayBuffer);\n\nvoid *tmpArrayBufferPtr = nullptr;\nsize_t arrayBufferLength = 0;\nOH_JSVM_GetArraybufferInfo(env, arrayBuffer, &tmpArrayBufferPtr, &arrayBufferLength);\n\nJSVM_Value result;\nOH_JSVM_CreateTypedarray(env, JSVM_TypedarrayType::JSVM_INT32_ARRAY, typedArrayLength, arrayBuffer, 0, &result);\nreturn result;
创建number和string:
const char *testStringStr = \"test\";\nJSVM_Value testString = nullptr;\nOH_JSVM_CreateStringUtf8(env, testStringStr, strlen(testStringStr), &testString);\n\nJSVM_Value testNumber1 = nullptr;\nJSVM_Value testNumber2 = nullptr;\nOH_JSVM_CreateDouble(env, 10.1, &testNumber1);\nOH_JSVM_CreateInt32(env, 10, &testNumber2);
创建Map:
JSVM_Value value = nullptr;\nOH_JSVM_CreateMap(env, &value);
创建RegExp:
JSVM_Value value = nullptr;\nconst char testStr[] = \"ab+c\";\nOH_JSVM_CreateStringUtf8(env, testStr, strlen(testStr), &value);\nJSVM_Value result = nullptr;\nOH_JSVM_CreateRegExp(env, value, JSVM_RegExpFlags::JSVM_REGEXP_GLOBAL, &result);
创建Set:
JSVM_Value value;\nOH_JSVM_CreateSet(env, &value);
[h2]从JS类型获取C类型&获取JS类型信息
场景介绍
从JS类型获取C类型&获取JS类型信息。
接口说明
场景示例：
创建64位的BigInt，并获取64位int值。
int64_t testValue = INT64_MAX;\nJSVM_Value result = nullptr;\nOH_JSVM_CreateBigintInt64(env, testValue, &result);\nint64_t resultValue = 0;\nbool flag = false;\nOH_JSVM_GetValueBigintInt64(env, result, &resultValue, &flag);
创建一个Int32Array，并获取其长度，byteoffset等信息。
JSVM_Value arrayBuffer = nullptr;\nvoid *arrayBufferPtr = nullptr;\nsize_t arrayBufferSize = 16;\nsize_t typedArrayLength = 4;\nOH_JSVM_CreateArraybuffer(env, arrayBufferSize, &arrayBufferPtr, &arrayBuffer);\n\nbool isArrayBuffer = false;\nOH_JSVM_IsArraybuffer(env, arrayBuffer, &isArrayBuffer);\n\nJSVM_Value result;\nOH_JSVM_CreateTypedarray(env, JSVM_TypedarrayType::JSVM_INT32_ARRAY, typedArrayLength, arrayBuffer, 0, &result);\n\nbool isTypedArray = false;\nOH_JSVM_IsTypedarray(env, result, &isTypedArray);\n\n\nJSVM_TypedarrayType type;\nsize_t length = 0;\nvoid *data = nullptr;\nJSVM_Value retArrayBuffer;\nsize_t byteOffset = -1;\nOH_JSVM_GetTypedarrayInfo(env, result, &type, &length, &data, &retArrayBuffer, &byteOffset);\n\n\nbool retIsArrayBuffer = false;\nOH_JSVM_IsArraybuffer(env, retArrayBuffer, &retIsArrayBuffer);\nvoid *tmpArrayBufferPtr = nullptr;\nsize_t arrayBufferLength = 0;\nOH_JSVM_GetArraybufferInfo(env, retArrayBuffer, &tmpArrayBufferPtr, &arrayBufferLength);
创建utf8类型的String，并获取C字符串。
const char *testStringStr = \"testString\";\nJSVM_Value testString = nullptr;\nOH_JSVM_CreateStringUtf8(env, testStringStr, strlen(testStringStr), &testString);\n\nchar buffer[128];\nsize_t bufferSize = 128;\nsize_t copied;\n\nOH_JSVM_GetValueStringUtf8(env, testString, buffer, bufferSize, &copied);
[h2]JS值操作和抽象操作
场景介绍
JS值操作和抽象操作。
接口说明
场景示例:
判断JS值是否为数组类型
JSVM_Value array = nullptr;\nOH_JSVM_CreateArray(env, &array);\nbool isArray = false;\nOH_JSVM_IsArray(env, array, &isArray);
将int32类型转换为string类型
int32_t num = 123;\nJSVM_Value intValue;\nOH_JSVM_CreateInt32(env, num, &intValue);\nJSVM_Value stringValue;\nOH_JSVM_CoerceToString(env, intValue, &stringValue);\n\nchar buffer[128];\nsize_t bufferSize = 128;\nsize_t copied = 0;\n\nOH_JSVM_GetValueStringUtf8(env, stringValue, buffer, bufferSize, &copied);\n// buffer:\"123\";
将boolean类型转换为bigint类型
JSVM_Value boolValue;\nOH_JSVM_GetBoolean(env, false, &boolValue);\nJSVM_Value bigIntValue;\nOH_JSVM_CoerceToBigInt(env, boolValue, &bigIntValue);
判断两个JS值类型是否严格相同：先比较操作数类型，操作数类型不同就是不相等，操作数类型相同时，比较值是否相等，相等才返回true。
JSVM_Value value = nullptr;\nJSVM_Value value1 = nullptr;\nOH_JSVM_CreateArray(env, &value);\n\nOH_JSVM_CreateInt32(env, 10, &value1);\nbool isArray = true;\nOH_JSVM_StrictEquals(env, value, value, &isArray);
判断两个JS值类型是否宽松相同：判断两个操作数的类型是否相同，若不相同，且可以转换为相同的数据类型，转换为相同的数据类型后，值做严格相等比较，其他的都返回false。
JSVM_HandleScope handleScope;\nOH_JSVM_OpenHandleScope(env, &handleScope);\nconst char testStr[] = \"1\";\nJSVM_Value lhs = nullptr;\nOH_JSVM_CreateStringUtf8(env, testStr, strlen(testStr), &lhs);\nJSVM_Value rhs;\nOH_JSVM_CreateInt32(env, 1, &rhs);\nbool isEquals = false;\nOH_JSVM_Equals(env, lhs, rhs, &isEquals); // 这里isEquals的值是true\nOH_JSVM_CloseHandleScope(env, handleScope);
判断JS值是否为构造函数
JSVM_Value SayHello(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    return nullptr;\n}\nJSVM_Value value = nullptr;\nJSVM_CallbackStruct param;\nparam.data = nullptr;\nparam.callback = SayHello;\nOH_JSVM_CreateFunction(env, \"func\", JSVM_AUTO_LENGTH, &param, &value);\nbool isConstructor = false;\nOH_JSVM_IsConstructor(env, value, &isConstructor); // 这里isConstructor的值是true
判断JS值是否为map类型
JSVM_Value value = nullptr;\nOH_JSVM_CreateMap(env, &value);\nbool isMap = false;\nOH_JSVM_IsMap(env, value, &isMap); // 这里isMap的值是true
判断JS值是否为Set类型
JSVM_Value value;\nOH_JSVM_CreateSet(env, &value);\nbool isSet = false;\nOH_JSVM_IsSet(env, value, &isSet); // 这里isSet的值是true
判断JS值是否为RegExp类型
JSVM_Value value = nullptr;\nconst char testStr[] = \"ab+c\";\nOH_JSVM_CreateStringUtf8(env, testStr, strlen(testStr), &value);\nJSVM_Value result = nullptr;\nOH_JSVM_CreateRegExp(env, value, JSVM_RegExpFlags::JSVM_REGEXP_GLOBAL, &result);\nbool isRegExp = false;\nOH_JSVM_IsRegExp(env, result, &isRegExp);
[h2]JS属性操作
场景介绍
JS对象属性的增删获取和判断
接口说明
场景示例:
JS对象属性的增删获取和判断
// 创建一个空对象\nJSVM_Value myObject = nullptr;\nOH_JSVM_CreateObject(env, &myObject);\n\n// 设置属性\nconst char *testNameStr = \"John Doe\";\nJSVM_Value propValue = nullptr;\nJSVM_Value key;\nOH_JSVM_CreateStringUtf8(env, \"name\", JSVM_AUTO_LENGTH, &key);\nOH_JSVM_CreateStringUtf8(env, testNameStr, strlen(testNameStr), &propValue);\nOH_JSVM_SetProperty(env, myObject, key, propValue);\n\n// 获取属性\nJSVM_Value propResult = nullptr;\nOH_JSVM_GetProperty(env, myObject, key, &propResult);\n\n// 检查属性是否存在\nbool hasProperty = false;\nOH_JSVM_HasNamedProperty(env, myObject, \"name\", &hasProperty);\n    // 属性存在，做相应处理...\n    if (hasProperty)\n    {\n        // 获取对象的所有属性名\n        JSVM_Value propNames = nullptr;\n        OH_JSVM_GetPropertyNames(env, myObject, &propNames);\n\n        bool isArray = false;\n        OH_JSVM_IsArray(env, propNames, &isArray);\n\n        uint32_t arrayLength = 0;\n        OH_JSVM_GetArrayLength(env, propNames, &arrayLength);\n        // 遍历属性元素\n        for (uint32_t i = 0; i < arrayLength; i++)\n        {\n            bool hasElement = false;\n            OH_JSVM_HasElement(env, propNames, i, &hasElement);\n\n            JSVM_Value propName = nullptr;\n            OH_JSVM_GetElement(env, propNames, i, &propName);\n\n            bool hasProp = false;\n            OH_JSVM_HasProperty(env, myObject, propName, &hasProp);\n\n            JSVM_Value propValue = nullptr;\n            OH_JSVM_GetProperty(env, myObject, propName, &propValue);\n        }\n    }\n\n// 删除属性\nOH_JSVM_DeleteProperty(env, myObject, key, &hasProperty);\n\n// 设置对象原型\nJSVM_Value value;\nOH_JSVM_CreateSet(env, &value);\nOH_JSVM_ObjectSetPrototypeOf(env, myObject, value);\n\n// 获取对象原型\nJSVM_Value proto;\nOH_JSVM_ObjectGetPrototypeOf(env, myObject, &proto);
[h2]JS函数操作
场景介绍
JS函数操作。
接口说明
场景示例:
创建JavaScript函数操作
JSVM_Value SayHello(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    printf(\"Hello\\n\");\n    JSVM_Value ret;\n    OH_JSVM_CreateInt32(env, 2, &ret);\n    return ret;\n}\n\nstatic JSVM_Value JsvmCreateFunction(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    JSVM_CallbackStruct param;\n    param.data = nullptr;\n    param.callback = SayHello;\n\n    JSVM_Value funcValue = nullptr;\n    JSVM_Status status = OH_JSVM_CreateFunction(env, \"func\", JSVM_AUTO_LENGTH, &param, &funcValue);\n    return funcValue;\n}
在C/C++侧获取并调用JS方法
static JSVM_Value CallFunction(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value args[1];\n    JSVM_CALL(env, OH_JSVM_GetCbInfo(env, info, &argc, args, NULL, NULL));\n\n    JSVM_ASSERT(env, argc >= 1, \"Wrong number of arguments\");\n\n    JSVM_ValueType valuetype;\n    JSVM_CALL(env, OH_JSVM_Typeof(env, args[0], &valuetype));\n    JSVM_ASSERT(env, valuetype == JSVM_ValueType::JSVM_FUNCTION, \"Wrong type of argment. Expects a string.\");\n\n    JSVM_Value global;\n    JSVM_CALL(env, OH_JSVM_GetGlobal(env, &global));\n\n    JSVM_Value ret;\n    JSVM_CALL(env, OH_JSVM_CallFunction(env, global, args[0], 0, nullptr, &ret));\n    return ret;\n}
创建Function:
JSVM_Value script;\nOH_JSVM_CreateStringUtf8(env, \"return a + b;\", JSVM_AUTO_LENGTH, &script);\nJSVM_Value param1;\nJSVM_Value param2;\nOH_JSVM_CreateStringUtf8(env, \"a\", JSVM_AUTO_LENGTH, &param1);\nOH_JSVM_CreateStringUtf8(env, \"b\", JSVM_AUTO_LENGTH, &param2);\nJSVM_Value argus[] = {param1, param2};\nJSVM_Value func;\nOH_JSVM_CreateFunctionWithScript(env, \"add\", JSVM_AUTO_LENGTH, 2, argus, script, &func);
[h2]对象绑定操作
场景介绍
对象绑定操作。
接口说明
场景示例：
对象绑定操作。
static JSVM_Value AssertEqual(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 2;\n    JSVM_Value args[2];\n    JSVM_CALL(env, OH_JSVM_GetCbInfo(env, info, &argc, args, NULL, NULL));\n\n    bool isStrictEquals = false;\n    OH_JSVM_StrictEquals(env, args[0], args[1], &isStrictEquals);\n    return nullptr;\n}\n\nstatic napi_value TestWrap(napi_env env1, napi_callback_info info)\n{\n    OH_LOG_ERROR(LOG_APP, \"testWrap start\");\n    JSVM_InitOptions init_options;\n    memset(&init_options, 0, sizeof(init_options));\n    init_options.externalReferences = externals;\n    if (aa == 0) {\n        OH_JSVM_Init(&init_options);\n        aa++;\n    }\n    JSVM_VM vm;\n    JSVM_CreateVMOptions options;\n    memset(&options, 0, sizeof(options));\n    OH_JSVM_CreateVM(&options, &vm);\n    JSVM_VMScope vm_scope;\n    OH_JSVM_OpenVMScope(vm, &vm_scope);\n    JSVM_Env env;\n    JSVM_CallbackStruct param[1];\n    param[0].data = nullptr;\n    param[0].callback = AssertEqual;\n    JSVM_PropertyDescriptor descriptor[] = {\n        {\"assertEqual\", NULL, &param[0], NULL, NULL, NULL, JSVM_DEFAULT},\n    };\n    OH_JSVM_CreateEnv(vm, sizeof(descriptor) / sizeof(descriptor[0]), descriptor, &env);\n    JSVM_EnvScope envScope;\n    OH_JSVM_OpenEnvScope(env, &envScope);\n    JSVM_HandleScope handlescope;\n    OH_JSVM_OpenHandleScope(env, &handlescope);\n    JSVM_Value testClass = nullptr;\n    JSVM_CallbackStruct param1;\n    param1.data = nullptr;\n    param1.callback = [](JSVM_Env env, JSVM_CallbackInfo info) -> JSVM_Value {\n        JSVM_Value thisVar = nullptr;\n        OH_JSVM_GetCbInfo(env, info, nullptr, nullptr, &thisVar, nullptr);\n\n        return thisVar;\n    };\n    OH_JSVM_DefineClass(env, \"TestClass\", JSVM_AUTO_LENGTH, &param1, 0, nullptr, &testClass);\n\n    JSVM_Value instanceValue = nullptr;\n    OH_JSVM_NewInstance(env, testClass, 0, nullptr, &instanceValue);\n\n    const char *testStr = \"test\";\n    OH_JSVM_Wrap(\n        env, instanceValue, (void *)testStr, [](JSVM_Env env, void *data, void *hint) {}, nullptr, nullptr);\n    const char *tmpTestStr = nullptr;\n    OH_JSVM_Unwrap(env, instanceValue, (void **)&tmpTestStr);\n    const char *tmpTestStr1 = nullptr;\n    OH_JSVM_RemoveWrap(env, instanceValue, (void **)&tmpTestStr1);\n    OH_JSVM_Unwrap(env, instanceValue, (void **)&tmpTestStr1);\n    OH_JSVM_CloseHandleScope(env, handlescope);\n    OH_JSVM_CloseEnvScope(env, envScope);\n    OH_JSVM_DestroyEnv(env);\n    OH_JSVM_CloseVMScope(vm, vm_scope);\n    OH_JSVM_DestroyVM(vm);\n    OH_LOG_ERROR(LOG_APP, \"testWrap pass\");\n    return nullptr;\n}
场景示例：
对象绑定及监听拦截属性操作。
static int aa = 0;\nstatic JSVM_Value hello(JSVM_Env env, JSVM_CallbackInfo info) {\n    JSVM_Value output;\n    void *data = nullptr;\n    OH_JSVM_GetCbInfo(env, info, nullptr, nullptr, nullptr, &data);\n    OH_JSVM_CreateStringUtf8(env, (char *)data, strlen((char *)data), &output);\n    return output;\n}\n\nstatic JSVM_CallbackStruct hello_cb = {hello, (void *)\"Hello\"};\nstatic intptr_t externals[] = {\n    (intptr_t)&hello_cb,\n    0,\n};\n\nstatic void test1() { OH_LOG_INFO(LOG_APP, \"test1 called\"); }\n\nstruct Test {\n    void *ptr1;\n    void *ptr2;\n};\n\nstatic JSVM_Value assertEqual(JSVM_Env env, JSVM_CallbackInfo info) {\n    size_t argc = 2;\n    JSVM_Value args[2];\n    JSVM_CALL(env, OH_JSVM_GetCbInfo(env, info, &argc, args, NULL, NULL));\n\n    bool isStrictEquals = false;\n    OH_JSVM_StrictEquals(env, args[0], args[1], &isStrictEquals);\n    return nullptr;\n}\n\nstatic JSVM_Value GetPropertyCbInfo(JSVM_Env env, JSVM_Value name, JSVM_Value thisArg, JSVM_Value data) {\n    // 该回调是由对象上的获取请求触发的\n    char strValue[100];\n    size_t size;\n    OH_JSVM_GetValueStringUtf8(env, name, strValue, 300, &size);\n    JSVM_Value newResult = nullptr;\n    char newStr[] = \"new return value hahaha from name listening\";\n    OH_JSVM_CreateStringUtf8(env, newStr, strlen(newStr), &newResult);\n    int signBit = 0;\n    size_t wordCount = 2;\n    uint64_t wordsOut[2] = {0ULL, 0ULL};\n    JSVM_Status status = OH_JSVM_GetValueBigintWords(env, data, &signBit, &wordCount, wordsOut);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"GetPropertyCbInfo wordCount is %{public}zu\", wordCount);\n        auto test = reinterpret_cast<Test *>(wordsOut);\n        typedef void (*callTest1)();\n        callTest1 callTe = reinterpret_cast<callTest1>(test->ptr1);\n        callTe();\n    }\n    return nullptr;\n}\n\nstatic JSVM_Value SetPropertyCbInfo(JSVM_Env env, JSVM_Value name, JSVM_Value property, JSVM_Value thisArg, JSVM_Value data) {\n    // 该回调是由对象上的设置请求触发的\n    char strValue[100];\n    size_t size;\n    OH_JSVM_GetValueStringUtf8(env, name, strValue, 300, &size);\n    JSVM_Value newResult = nullptr;\n    char newStr[] = \"new return value hahaha from name listening\";\n    OH_JSVM_CreateStringUtf8(env, newStr, strlen(newStr), &newResult);\n    int signBit = 0;\n    size_t wordCount = 2;\n    uint64_t wordsOut[2] = {0ULL, 0ULL};\n    JSVM_Status status = OH_JSVM_GetValueBigintWords(env, data, &signBit, &wordCount, wordsOut);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"SetPropertyCbInfo wordCount is %{public}zu\", wordCount);\n        auto test = reinterpret_cast<Test *>(wordsOut);\n        typedef void (*callTest1)();\n        callTest1 callTe = reinterpret_cast<callTest1>(test->ptr1);\n        callTe();\n    }\n    return nullptr;\n}\n\nstatic JSVM_Value DeleterPropertyCbInfo(JSVM_Env env, JSVM_Value name, JSVM_Value thisArg, JSVM_Value data) {\n    // 该回调是由对象上的删除请求触发的\n    char strValue[100];\n    size_t size;\n    OH_JSVM_GetValueStringUtf8(env, name, strValue, 300, &size);\n    JSVM_Value newResult = nullptr;\n    bool returnValue = false;\n    OH_JSVM_GetBoolean(env, returnValue, &newResult);\n    int signBit = 0;\n    size_t wordCount = 2;\n    uint64_t wordsOut[2] = {0ULL, 0ULL};\n    JSVM_Status status = OH_JSVM_GetValueBigintWords(env, data, &signBit, &wordCount, wordsOut);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"DeleterPropertyCbInfo wordCount is %{public}zu\", wordCount);\n        auto test = reinterpret_cast<Test *>(wordsOut);\n        typedef void (*callTest1)();\n        callTest1 callTe = reinterpret_cast<callTest1>(test->ptr1);\n        callTe();\n    }\n    return nullptr;\n}\n\nstatic JSVM_Value EnumeratorPropertyCbInfo(JSVM_Env env, JSVM_Value thisArg, JSVM_Value data) {\n    // 该回调是由获取对象上的所有属性请求触发的\n    JSVM_Value testArray = nullptr;\n    OH_JSVM_CreateArrayWithLength(env, 2, &testArray);\n    JSVM_Value name1 = nullptr;\n    char newStr1[] = \"hahaha\";\n    OH_JSVM_CreateStringUtf8(env, newStr1, strlen(newStr1), &name1);\n    JSVM_Value name2 = nullptr;\n    char newStr2[] = \"heheheh\";\n    OH_JSVM_CreateStringUtf8(env, newStr2, strlen(newStr2), &name2);\n\n    OH_JSVM_SetElement(env, testArray, 0, name1);\n    OH_JSVM_SetElement(env, testArray, 1, name2);\n    int signBit = 0;\n    size_t wordCount = 2;\n    uint64_t wordsOut[2] = {0ULL, 0ULL};\n    JSVM_Status status = OH_JSVM_GetValueBigintWords(env, data, &signBit, &wordCount, wordsOut);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"EnumeratorPropertyCbInfo wordCount is %{public}zu\", wordCount);\n        auto test = reinterpret_cast<Test *>(wordsOut);\n        typedef void (*callTest1)();\n        callTest1 callTe = reinterpret_cast<callTest1>(test->ptr1);\n        callTe();\n    }\n    return nullptr;\n}\n\nstatic JSVM_Value IndexedPropertyGet(JSVM_Env env, JSVM_Value index, JSVM_Value thisArg, JSVM_Value data) {\n    // 该回调是由获取实例对象的索引属性触发的\n    uint32_t value;\n    OH_JSVM_GetValueUint32(env, index, &value);\n\n    JSVM_Value newResult = nullptr;\n    char newStr[] = \"new return value hahaha from index listening\";\n    OH_JSVM_CreateStringUtf8(env, newStr, strlen(newStr), &newResult);\n    int signBit = 0;\n    size_t wordCount = 2;\n    uint64_t wordsOut[2] = {0ULL, 0ULL};\n    JSVM_Status status = OH_JSVM_GetValueBigintWords(env, data, &signBit, &wordCount, wordsOut);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"IndexedPropertyGet wordCount is %{public}zu\", wordCount);\n        auto test = reinterpret_cast<Test *>(wordsOut);\n        typedef void (*callTest1)();\n        callTest1 callTe = reinterpret_cast<callTest1>(test->ptr1);\n        callTe();\n    }\n    return nullptr;\n}\n\nstatic JSVM_Value IndexedPropertySet(JSVM_Env env, JSVM_Value index, JSVM_Value property, JSVM_Value thisArg, JSVM_Value data) {\n    // 该回调是由设置实例对象的索引属性触发的\n    uint32_t value;\n    OH_JSVM_GetValueUint32(env, index, &value);\n    char str[100];\n    size_t size;\n    OH_JSVM_GetValueStringUtf8(env, property, str, 100, &size);\n    JSVM_Value newResult = nullptr;\n    char newStr[] = \"new return value hahaha from name listening\";\n    OH_JSVM_CreateStringUtf8(env, newStr, strlen(newStr), &newResult);\n    int signBit = 0;\n    size_t wordCount = 2;\n    uint64_t wordsOut[2] = {0ULL, 0ULL};\n    JSVM_Status status = OH_JSVM_GetValueBigintWords(env, data, &signBit, &wordCount, wordsOut);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"IndexedPropertySet wordCount is %{public}zu\", wordCount);\n        auto test = reinterpret_cast<Test *>(wordsOut);\n        typedef void (*callTest1)();\n        callTest1 callTe = reinterpret_cast<callTest1>(test->ptr1);\n        callTe();\n    }\n    return nullptr;\n}\n\nstatic JSVM_Value IndexedPropertyDeleter(JSVM_Env env, JSVM_Value index, JSVM_Value thisArg, JSVM_Value data) {\n    // 该回调是由删除实例对象的索引属性触发的\n    uint32_t value;\n    OH_JSVM_GetValueUint32(env, index, &value);\n    JSVM_Value newResult = nullptr;\n    bool returnValue = false;\n    OH_JSVM_GetBoolean(env, returnValue, &newResult);\n    int signBit = 0;\n    size_t wordCount = 2;\n    uint64_t wordsOut[2] = {0ULL, 0ULL};\n    JSVM_Status status = OH_JSVM_GetValueBigintWords(env, data, &signBit, &wordCount, wordsOut);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"IndexedPropertyDeleter wordCount is %{public}zu\", wordCount);\n        auto test = reinterpret_cast<Test *>(wordsOut);\n        typedef void (*callTest1)();\n        callTest1 callTe = reinterpret_cast<callTest1>(test->ptr1);\n        callTe();\n    }\n    return nullptr;\n}\n\nstatic JSVM_Value IndexedPropertyEnumerator(JSVM_Env env, JSVM_Value thisArg, JSVM_Value data) {\n    // 该回调是由获取对象上的所有索引属性请求触发的\n    JSVM_Value testArray = nullptr;\n    OH_JSVM_CreateArrayWithLength(env, 2, &testArray);\n    JSVM_Value index1 = nullptr;\n    OH_JSVM_CreateUint32(env, 1, &index1);\n    JSVM_Value index2 = nullptr;\n    OH_JSVM_CreateUint32(env, 2, &index2);\n    OH_JSVM_SetElement(env, testArray, 0, index1);\n    OH_JSVM_SetElement(env, testArray, 1, index2);\n    int signBit = 0;\n    size_t wordCount = 2;\n    uint64_t wordsOut[2] = {0ULL, 0ULL};\n    JSVM_Status status = OH_JSVM_GetValueBigintWords(env, data, &signBit, &wordCount, wordsOut);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"IndexedPropertyDeleter wordCount is %{public}zu\", wordCount);\n        auto test = reinterpret_cast<Test *>(wordsOut);\n        typedef void (*callTest1)();\n        callTest1 callTe = reinterpret_cast<callTest1>(test->ptr1);\n        callTe();\n    }\n    return nullptr;\n}\n\nstatic napi_value TestDefineClassWithProperty(napi_env env1, napi_callback_info info) {\n    OH_LOG_ERROR(LOG_APP, \"TestDefineClassWithProperty start\");\n    JSVM_InitOptions init_options;\n    memset(&init_options, 0, sizeof(init_options));\n    init_options.externalReferences = externals;\n    if (aa == 0) {\n        OH_JSVM_Init(&init_options);\n        aa++;\n    }\n    JSVM_VM vm;\n    JSVM_CreateVMOptions options;\n    memset(&options, 0, sizeof(options));\n    OH_JSVM_CreateVM(&options, &vm);\n    JSVM_VMScope vm_scope;\n    OH_JSVM_OpenVMScope(vm, &vm_scope);\n    JSVM_Env env;\n    JSVM_CallbackStruct param[1];\n    param[0].data = nullptr;\n    param[0].callback = assertEqual;\n    JSVM_PropertyDescriptor descriptor[] = {\n        {\"assertEqual\", NULL, &param[0], NULL, NULL, NULL, JSVM_DEFAULT},\n    };\n    OH_JSVM_CreateEnv(vm, sizeof(descriptor) / sizeof(descriptor[0]), descriptor, &env);\n    JSVM_EnvScope envScope;\n    OH_JSVM_OpenEnvScope(env, &envScope);\n    JSVM_HandleScope handlescope;\n    OH_JSVM_OpenHandleScope(env, &handlescope);\n\n\n    JSVM_CallbackStruct param1;\n    param1.callback = [](JSVM_Env env, JSVM_CallbackInfo info) -> JSVM_Value {\n        JSVM_Value thisVar = nullptr;\n        OH_JSVM_GetCbInfo(env, info, nullptr, nullptr, &thisVar, nullptr);\n        return thisVar;\n    };\n    param1.data = nullptr;\n\n    JSVM_Value res = nullptr;\n    Test *test = new Test();\n    test->ptr1 = (void *)test1;\n    test->ptr2 = (void *)test1;\n    OH_LOG_INFO(LOG_APP, \"OH_JSVM_CreateBigintWords 111 word count %{public}d\",\n                sizeof(*test) / sizeof(uint64_t));\n    JSVM_Status status = OH_JSVM_CreateBigintWords(env, 1, 2, reinterpret_cast<const uint64_t *>(test), &res);\n\n    // 初始化propertyCfg\n    JSVM_PropertyHandlerConfigurationStruct propertyCfg;\n    propertyCfg.genericNamedPropertyGetterCallback = GetPropertyCbInfo;\n    propertyCfg.genericNamedPropertySetterCallback = SetPropertyCbInfo;\n    propertyCfg.genericNamedPropertyDeleterCallback = DeleterPropertyCbInfo;\n    propertyCfg.genericNamedPropertyEnumeratorCallback = EnumeratorPropertyCbInfo;\n    propertyCfg.genericIndexedPropertyGetterCallback = IndexedPropertyGet;\n    propertyCfg.genericIndexedPropertySetterCallback = IndexedPropertySet;\n    propertyCfg.genericIndexedPropertyDeleterCallback = IndexedPropertyDeleter;\n    propertyCfg.genericIndexedPropertyEnumeratorCallback = IndexedPropertyEnumerator;\n    propertyCfg.namedPropertyData = res;\n    propertyCfg.indexedPropertyData = res;\n\n    JSVM_CallbackStruct callbackStruct;\n    callbackStruct.callback = [](JSVM_Env env, JSVM_CallbackInfo info) -> JSVM_Value {\n        OH_LOG_INFO(LOG_APP, \"call as a function called\");\n        JSVM_Value thisVar = nullptr;\n        void *innerData;\n        size_t argc = 1;\n        JSVM_Value args[1];\n        OH_JSVM_GetCbInfo(env, info, &argc, args, &thisVar, &innerData);\n        OH_LOG_INFO(LOG_APP, \"function call as function result is %{public}s\", reinterpret_cast<char *>(innerData));\n        uint32_t ret = 0;\n        OH_JSVM_GetValueUint32(env, args[0], &ret);\n        const char testStr[] = \"hello world 111111\";\n        JSVM_Value setvalueName = nullptr;\n        JSVM_CALL(env, OH_JSVM_CreateStringUtf8(env, testStr, strlen(testStr), &setvalueName));\n        return setvalueName;\n    };\n    char data[100] = \"1111 hello world\";\n    callbackStruct.data = data;\n    JSVM_Value testWrapClass = nullptr;\n\n    // 将属性的访问监听注册在propertyCfg中\n    OH_JSVM_DefineClassWithPropertyHandler(env, \"TestWrapClass\", NAPI_AUTO_LENGTH, &param1, 0, nullptr, &propertyCfg,\n                                           &callbackStruct, &testWrapClass);\n    JSVM_Value instanceValue = nullptr;\n    OH_JSVM_NewInstance(env, testWrapClass, 0, nullptr, &instanceValue);\n    const char testStr[] = \"hello world\";\n    JSVM_Value setvalueName = nullptr;\n    OH_JSVM_CreateStringUtf8(env, testStr, strlen(testStr), &setvalueName);\n\n    // 1. 名称属性回调\n    // 设置属性\n    OH_JSVM_SetNamedProperty(env, instanceValue, \"str11\", setvalueName);\n    OH_JSVM_SetNamedProperty(env, instanceValue, \"str123\", setvalueName);\n\n    // 获取属性\n    JSVM_Value valueName = nullptr;\n    OH_JSVM_GetNamedProperty(env, instanceValue, \"str11\", &valueName);\n    char str[100];\n    size_t size;\n    OH_JSVM_GetValueStringUtf8(env, valueName, str, 100, &size);\n\n    // 获取所有属性的名称\n    JSVM_Value allPropertyNames = nullptr;\n    OH_JSVM_GetAllPropertyNames(env, instanceValue, JSVM_KEY_OWN_ONLY,\n                                static_cast<JSVM_KeyFilter>(JSVM_KEY_ENUMERABLE | JSVM_KEY_SKIP_SYMBOLS),\n                                JSVM_KEY_NUMBERS_TO_STRINGS, &allPropertyNames);\n    uint32_t nameSize = 0;\n    OH_JSVM_GetArrayLength(env, allPropertyNames, &nameSize);\n    JSVM_Value propertyName = nullptr;\n    for (uint32_t i = 0; i < nameSize; ++i) {\n        OH_JSVM_GetElement(env, allPropertyNames, i, &propertyName);\n        char str[100];\n        size_t size;\n        OH_JSVM_GetValueStringUtf8(env, propertyName, str, 100, &size);\n    }\n\n    // 删除属性\n    bool result = false;\n    propertyName = nullptr;\n    char propertyChar[] = \"str11\";\n    OH_JSVM_CreateStringUtf8(env, propertyChar, strlen(propertyChar), &propertyName);\n    OH_JSVM_DeleteProperty(env, instanceValue, propertyName, &result);\n\n    // 2. 索引属性回调\n    // 设置属性\n    JSVM_Value jsIndex = nullptr;\n    uint32_t index = 0;\n    OH_JSVM_CreateUint32(env, index, &jsIndex);\n    OH_JSVM_SetProperty(env, instanceValue, jsIndex, setvalueName);\n    JSVM_Value jsIndex1 = nullptr;\n    index = 1;\n    OH_JSVM_CreateUint32(env, index, &jsIndex1);\n    OH_JSVM_SetProperty(env, instanceValue, jsIndex1, setvalueName);\n\n    // 获取属性\n    JSVM_Value valueName1 = nullptr;\n    OH_JSVM_GetProperty(env, instanceValue, jsIndex, &valueName1);\n    char str1[100];\n    size_t size1;\n    OH_JSVM_GetValueStringUtf8(env, valueName1, str1, 100, &size1);\n\n    // 获取所有属性的名称\n    JSVM_Value allPropertyNames1 = nullptr;\n    OH_JSVM_GetAllPropertyNames(env, instanceValue, JSVM_KEY_OWN_ONLY,\n                                static_cast<JSVM_KeyFilter>(JSVM_KEY_ENUMERABLE | JSVM_KEY_SKIP_SYMBOLS),\n                                JSVM_KEY_NUMBERS_TO_STRINGS, &allPropertyNames1);\n    uint32_t nameSize1 = 0;\n    OH_JSVM_GetArrayLength(env, allPropertyNames1, &nameSize);\n    JSVM_Value propertyName1 = nullptr;\n    for (uint32_t i = 0; i < nameSize1; ++i) {\n        OH_JSVM_GetElement(env, allPropertyNames1, i, &propertyName1);\n        char str[100];\n        size_t size;\n        OH_JSVM_GetValueStringUtf8(env, propertyName1, str, 100, &size);\n    }\n\n    // 删除属性\n    bool result1 = false;\n    OH_JSVM_DeleteProperty(env, instanceValue, jsIndex, &result1);\n\n    // 3. 作为函数的回调\n    JSVM_Value gloablObj = nullptr;\n    OH_JSVM_GetGlobal(env, &gloablObj);\n    OH_JSVM_SetNamedProperty(env, gloablObj, \"myTestInstance\", instanceValue);\n    OH_LOG_INFO(LOG_APP, \"set property on global object\");\n    std::string innerSourcecodestr = R\"(\n    {\n        let res = myTestInstance(12);\n    })\";\n    JSVM_Value innerSourcecodevalue;\n    OH_JSVM_CreateStringUtf8(env, innerSourcecodestr.c_str(), innerSourcecodestr.size(), &innerSourcecodevalue);\n    JSVM_Script innerscript;\n    OH_JSVM_CompileScript(env, innerSourcecodevalue, nullptr, 0, true, nullptr, &innerscript);\n    JSVM_Value innerResult;\n    OH_JSVM_RunScript(env, innerscript, &innerResult);\n\n    OH_JSVM_CloseHandleScope(env, handlescope);\n    OH_JSVM_CloseEnvScope(env, envScope);\n    OH_JSVM_DestroyEnv(env);\n    OH_JSVM_CloseVMScope(vm, vm_scope);\n    OH_JSVM_DestroyVM(vm);\n    OH_LOG_ERROR(LOG_APP, \"TestDefineClassWithProperty pass\");\n    return nullptr;\n}
[h2]版本管理
场景介绍
获取当前版本信息。
接口说明
场景示例：
获取当前版本信息。
JSVM_VMInfo result;\nOH_JSVM_GetVMInfo(&result);\nuint32_t versionId = 0;\nOH_JSVM_GetVersion(env, &versionId);
[h2]内存管理
场景介绍
内存管理
接口说明
BackingStore 的使用属于高危操作，需要使用者自身保证内存的正确使用，请参考下方的正确示例，谨慎使用。
场景示例：
内存管理。
// 分别在调用OH_JSVM_AdjustExternalMemory前后来查看底层虚拟机视角下外部分配的内存大小\nint64_t result;\nOH_JSVM_AdjustExternalMemory(env, 0, &result); // 假设外部分配内存的变化不变\nOH_LOG_INFO(LOG_APP, \"Before AdjustExternalMemory: %{public}lld\\n\", result); // 得到调整前的数值\n// 调整外部分配的内存大小通知给底层虚拟机（此示例假设内存使用量增加）\nint64_t memoryIncrease = 1024 * 1024; // 增加 1 MB\nOH_JSVM_AdjustExternalMemory(env, memoryIncrease, &result);\nOH_LOG_INFO(LOG_APP, \"After AdjustExternalMemory: %{public}lld\\n\", result); // 得到调整后的数值
// 打开一个Handle scope，在scope范围内申请大量内存来测试函数功能；\n// 分别在“完成申请后”、“关闭scope后”和“调用OH_JSVM_MemoryPressureNotification后”三个节点查看内存状态\nJSVM_HandleScope tmpscope;\nOH_JSVM_OpenHandleScope(env, &tmpscope);\nfor (int i = 0; i < 1000000; ++i) {\n    JSVM_Value obj;\n    OH_JSVM_CreateObject(env, &obj);\n}\nJSVM_HeapStatistics mem;\nOH_JSVM_GetHeapStatistics(vm, &mem); // 获取虚拟机堆的统计数据\nOH_LOG_INFO(LOG_APP, \"%{public}zu\\n\", mem.usedHeapSize); // 申请完成后，内存处于最大状态\nOH_JSVM_CloseHandleScope(env, tmpscope); // 关闭Handle scope\n\nOH_JSVM_GetHeapStatistics(vm, &mem);\nOH_LOG_INFO(LOG_APP, \"%{public}zu\\n\", mem.usedHeapSize); // 关闭scope后，GC并没有立即回收\n\n// 通知虚拟机系统内存压力层级，并有选择地触发垃圾回收\nOH_JSVM_MemoryPressureNotification(env, JSVM_MEMORY_PRESSURE_LEVEL_CRITICAL); // 假设内存压力处于临界状态\n\nOH_JSVM_GetHeapStatistics(vm, &mem);\nOH_LOG_INFO(LOG_APP, \"%{public}zu\\n\", mem.usedHeapSize); // 触发垃圾回收后
BackingStore 正确使用示例
void *backingStore;\nJSVM_Value arrayBuffer;\n\n// 申请一块大小为 100 字节的 BackingStore 内存\nOH_JSVM_AllocateArrayBufferBackingStoreData(100, JSVM_ZERO_INITIALIZED, &backingStore);\n\n// 在之前申请的 BackingStore 上创建一个 ArrayBuffer，位置为距离 BackingStore 起始地址加 30 字节处，大小为 20 字节\nOH_JSVM_CreateArrayBufferFromBackingStoreData(env, backingStore, 100, 30, 20, &arrayBuffer);\n\n// 在 JS 中使用创建的 ArrayBuffer\nJSVM_Value js_global;\nJSVM_Value name;\nOH_JSVM_GetGlobal(jsvm_env, &js_global);\nOH_JSVM_CreateStringUtf8(jsvm_env, \"buffer\", JSVM_AUTO_LENGTH, &name);\nOH_JSVM_SetProperty(env, js_global, name, arrayBuffer);\n\nJSVM_Script script;\nJSVM_Value scriptString;\nJSVM_Value result;\nconst char *src = R\"JS(\nfunction writeBuffer(data) {\n  let view = new Uint8Array(data);\n  // Write some values to the ArrayBuffer\n  for (let i = 0; i < view.length; i++) {\n    view[i] = i % 256;\n  }\n}\nwriteBuffer(buffer)\n)JS\";\nOH_JSVM_CreateStringUtf8(env, src, JSVM_AUTO_LENGTH, &scriptString);\nOH_JSVM_CompileScriptWithOptions(env, scriptString, 0, nullptr, &script);\nOH_JSVM_RunScript(env, script, &result);\n\n// 检查 ArrayBuffer 的内容\nuint8_t *array = static_cast<uint8_t*>(backingStore);\nfor (auto i = 0; i < 100; ++i) {\n  if (array[i] != i % 25 % 256) {\n    return false;\n  }\n}\n\n// 释放 array buffer. 注意对于这种方式创建的 ArrayBuffer, 在释放对应的 BackingStore 之前,\n// 务必使用 OH_JSVM_DetachArraybuffer 将所有使用当前的 BackingStore 创建的 ArrayBuffer 释放\n// 否则可能产生不可预测的内存问题，请谨慎使用\nOH_JSVM_DetachArraybuffer(env, arrayBuffer);\n\n// 释放申请的 backing store 内存\nOH_JSVM_FreeArrayBufferBackingStoreData(backingStore);
[h2]Promise操作
场景介绍
Promise相关操作。
接口说明
场景示例：
Promise相关操作。
JSVM_Deferred deferred;\nJSVM_Value promise;\nOH_JSVM_CreatePromise(env, &deferred, &promise);\n\n// 模拟异步操作\nint result = 42;\nbool success = true;\nif (success)\n{\n    // 解析Promise，并传递结果\n    JSVM_Value value;\n    OH_JSVM_CreateInt32(env, result, &value);\n    OH_JSVM_ResolveDeferred(env, deferred, value);\n} else {\n    // 拒绝Promise，并传递错误信息\n    JSVM_Value code = nullptr;\n    JSVM_Value message = nullptr;\n    OH_JSVM_CreateStringUtf8(env, \"600\", JSVM_AUTO_LENGTH, &code);\n    OH_JSVM_CreateStringUtf8(env, \"Async operation failed\", JSVM_AUTO_LENGTH, &message);\n    JSVM_Value error = nullptr;\n    OH_JSVM_CreateError(env, code, message, &error);\n    OH_JSVM_RejectDeferred(env, deferred, error);\n}
[h2]JSON操作
场景介绍
JSON操作。
接口说明
场景示例：
解析JSON操作。
std::string sourcecodestr = \"{\\\"name\\\": \\\"John\\\", \\\"age\\\": 30, \\\"city\\\": \\\"New York\\\"}\" ;\nJSVM_Value jsonString;\nOH_JSVM_CreateStringUtf8(env, sourcecodestr.c_str(), sourcecodestr.size(), &jsonString)\nJSVM_Value result;\nOH_JSVM_JsonParse(env, jsonString, &result);
[h2]创建和使用虚拟机的启动快照
场景介绍
创建和使用虚拟机的启动快照
接口说明
场景示例：
创建和使用虚拟机的启动快照。
[h2]检查传入的值是否可调用
场景介绍
检查传入的值是否可调用
接口说明
场景示例：
检查传入的值是否可调用
static JSVM_Value NapiIsCallable(JSVM_Env env, JSVM_CallbackInfo info) {\n    JSVM_Value value, rst;\n    size_t argc = 1;\n    bool isCallable = false;\n    JSVM_CALL(env, OH_JSVM_GetCbInfo(env, info, &argc, &value, NULL, NULL));\n    JSVM_CALL(env, OH_JSVM_IsCallable(env, value, &isCallable));\n    OH_JSVM_GetBoolean(env, isCallable, &rst);\n    return rst;\n}\n\nstatic napi_value MyJSVMDemo([[maybe_unused]] napi_env _env, [[maybe_unused]] napi_callback_info _info) {\n    std::thread t([]() {\n        // create vm, and open vm scope\n        JSVM_VM vm;\n        JSVM_CreateVMOptions options;\n        memset(&options, 0, sizeof(options));\n        OH_JSVM_CreateVM(&options, &vm);\n        JSVM_VMScope vmScope;\n        OH_JSVM_OpenVMScope(vm, &vmScope);\n        JSVM_CallbackStruct param[] = {\n            {.data = nullptr, .callback = NapiIsCallable},\n        };\n        JSVM_PropertyDescriptor descriptor[] = {\n            {\"napiIsCallable\", NULL, &param[0], NULL, NULL, NULL, JSVM_DEFAULT},\n        };\n        // create env, register native method, and open env scope\n        JSVM_Env env;\n        OH_JSVM_CreateEnv(vm, sizeof(descriptor) / sizeof(descriptor[0]), descriptor, &env);\n        JSVM_EnvScope envScope;\n        OH_JSVM_OpenEnvScope(env, &envScope);\n        // open handle scope\n        JSVM_HandleScope handleScope;\n        OH_JSVM_OpenHandleScope(env, &handleScope);\n        std::string sourceCodeStr = R\"JS(\n        function addNumbers(num1, num2)\n        {\n            var rst= num1 + num2;\n            return rst;\n        }\n        let rst = napiIsCallable(addNumbers);\n        )JS\";\n        // compile js script\n        JSVM_Value sourceCodeValue;\n        OH_JSVM_CreateStringUtf8(env, sourceCodeStr.c_str(), sourceCodeStr.size(), &sourceCodeValue);\n        JSVM_Script script;\n        OH_JSVM_CompileScript(env, sourceCodeValue, nullptr, 0, true, nullptr, &script);\n        JSVM_Value result;\n        // run js script\n        OH_JSVM_RunScript(env, script, &result);\n        JSVM_ValueType type;\n        OH_JSVM_Typeof(env, result, &type);\n        OH_LOG_INFO(LOG_APP, \"JSVM API TEST type: %{public}d\", type);\n        // exit vm and clean memory\n        OH_JSVM_CloseHandleScope(env, handleScope);\n        OH_JSVM_CloseEnvScope(env, envScope);\n        OH_JSVM_DestroyEnv(env);\n        OH_JSVM_CloseVMScope(vm, vmScope);\n        OH_JSVM_DestroyVM(vm);\n    });\n    t.detach();\n    return nullptr;\n}
[h2]Lock操作
场景介绍
Lock操作
接口说明
场景示例：
加锁解锁操作
class LockWrapper {\n public:\n  LockWrapper(JSVM_Env env) : env(env) {\n    OH_JSVM_IsLocked(env, &isLocked);\n    if (!isLocked) {\n      OH_JSVM_AcquireLock(env);\n      OH_JSVM_GetVM(env, &vm);\n      OH_JSVM_OpenVMScope(vm, &vmScope);\n      OH_JSVM_OpenEnvScope(env, &envScope);\n    }\n  }\n\n  ~LockWrapper() {\n    if (!isLocked) {\n      OH_JSVM_CloseEnvScope(env, envScope);\n      OH_JSVM_CloseVMScope(vm, vmScope);\n      OH_JSVM_ReleaseLock(env);\n    }\n  }\n\n  LockWrapper(const LockWrapper&) = delete;\n  LockWrapper& operator=(const LockWrapper&) = delete;\n  LockWrapper(LockWrapper&&) = delete;\n  void* operator new(size_t) = delete;\n  void* operator new[](size_t) = delete;\n\n private:\n  JSVM_Env env;\n  JSVM_EnvScope envScope;\n  JSVM_VMScope vmScope;\n  JSVM_VM vm;\n  bool isLocked;\n};\n\nstatic napi_value Add([[maybe_unused]] napi_env _env, [[maybe_unused]] napi_callback_info _info) {\n    static JSVM_VM vm;\n    static JSVM_Env env;\n    if (aa == 0) {\n        OH_JSVM_Init(nullptr);\n        aa++;\n        // create vm\n        JSVM_CreateVMOptions options;\n        memset(&options, 0, sizeof(options));\n        OH_JSVM_CreateVM(&options, &vm);\n        // create env\n        OH_JSVM_CreateEnv(vm, 0, nullptr, &env);\n    }\n\n    std::thread t1([]() {\n        LockWrapper lock(env);\n        JSVM_HandleScope handleScope;\n        OH_JSVM_OpenHandleScope(env, &handleScope);\n        JSVM_Value value;\n        JSVM_Status rst = OH_JSVM_CreateInt32(env, 32, &value); // 32: numerical value\n        if (rst == JSVM_OK) {\n            OH_LOG_INFO(LOG_APP, \"JSVM:t1 OH_JSVM_CreateInt32 suc\");\n        } else {\n            OH_LOG_ERROR(LOG_APP, \"JSVM:t1 OH_JSVM_CreateInt32 fail\");\n        }\n        int32_t num1;\n        OH_JSVM_GetValueInt32(env, value, &num1);\n        OH_LOG_INFO(LOG_APP, \"JSVM:t1 num1 = %{public}d\", num1);\n        OH_JSVM_CloseHandleScope(env, handleScope);\n    });\n    std::thread t2([]() {\n        LockWrapper lock(env);\n        JSVM_HandleScope handleScope;\n        OH_JSVM_OpenHandleScope(env, &handleScope);\n        JSVM_Value value;\n        JSVM_Status rst = OH_JSVM_CreateInt32(env, 32, &value); // 32: numerical value\n        if (rst == JSVM_OK) {\n            OH_LOG_INFO(LOG_APP, \"JSVM:t2 OH_JSVM_CreateInt32 suc\");\n        } else {\n            OH_LOG_ERROR(LOG_APP, \"JSVM:t2 OH_JSVM_CreateInt32 fail\");\n        }\n        int32_t num1;\n        OH_JSVM_GetValueInt32(env, value, &num1);\n        OH_LOG_INFO(LOG_APP, \"JSVM:t2 num1 = %{public}d\", num1);\n        OH_JSVM_CloseHandleScope(env, handleScope);\n    });\n    t1.detach();\n    t2.detach();\n    return nullptr;\n}
[h2]设置与获取和当前运行的JSVM环境相关联的数据
场景介绍
检索通过OH_JSVM_SetInstanceData()与当前运行的JSVM环境相关联的数据
接口说明
场景示例：
设置并获取与当前运行的JSVM环境相关联的数据。
JSVM_VM vm;\nJSVM_CreateVMOptions options;\nJSVM_VMScope vm_scope;\nJSVM_Env env;\nJSVM_EnvScope envScope;\nJSVM_HandleScope handlescope;\n\nstatic int aa = 0; \nstruct InstanceData {\n    int32_t value;\n};\n\n// 初始化虚拟机，创建JSVM运行环境\nvoid init_JSVM_environment(){         \n    JSVM_InitOptions init_options;\n    memset(&init_options, 0, sizeof(init_options));\n    if (aa == 0) {\n        OH_JSVM_Init(&init_options);\n        aa++;\n    }\n    memset(&options, 0, sizeof(options));\n    OH_JSVM_CreateVM(&options, &vm);\n    OH_JSVM_OpenVMScope(vm, &vm_scope);\n    OH_JSVM_CreateEnv(vm, 0, nullptr, &env);\n    OH_JSVM_OpenEnvScope(env, &envScope);\n    OH_JSVM_OpenHandleScope(env, &handlescope);\n}\n\n// 退出虚拟机，释放对应的环境\nnapi_value close_JSVM_environment(napi_env env1, napi_callback_info info) \n{\n    OH_JSVM_CloseHandleScope(env, handlescope);\n    OH_JSVM_CloseEnvScope(env, envScope);\n    OH_JSVM_DestroyEnv(env);\n    OH_JSVM_CloseVMScope(vm, vm_scope);\n    OH_JSVM_DestroyVM(vm);\n    napi_value result;\n    char* s = \"ok\";\n    napi_create_string_latin1(env1, s, strlen(s), &result);\n    return result;\n}\n\n//清除和释放与实例相关联的内存资源\nvoid InstanceFinalizeCallback(JSVM_Env env, void *finalizeData, void *finalizeHint)\n{\n    if (finalizeData) {\n        InstanceData *data = reinterpret_cast<InstanceData *>(finalizeData);\n        free(data);\n        *(InstanceData **)finalizeData = nullptr;\n    }\n}\n\nstatic napi_value GetInstanceData(napi_env env1, napi_callback_info info)\n{\n    InstanceData *instanceData = reinterpret_cast<InstanceData *>(malloc(sizeof(InstanceData)));\n    if (instanceData == nullptr) {\n        printf(\"Memory allocation failed!\\n\");\n        return nullptr;\n    }\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    //用于获取回调函数参数\n    napi_get_cb_info(env1, info, &argc, args , nullptr, nullptr);\n    napi_valuetype valuetype0;\n    napi_typeof(env1, args[0], &valuetype0);\n    int32_t tmp = 0;\n    napi_get_value_int32(env1, args[0], &tmp);\n    instanceData->value = tmp;\n    //将获得的参数与当前运行的JSVM环境关联起来\n    OH_JSVM_SetInstanceData(env, instanceData, InstanceFinalizeCallback, nullptr);\n    InstanceData *resData = nullptr;\n    //获取与当前运行的JSVM环境相关联的数据\n    OH_JSVM_GetInstanceData(env, (void **)&resData);\n    napi_value result;\n    napi_create_uint32(env1, resData->value, &result);\n    return result;\n}
[h2]任务队列
场景介绍
在虚拟机内部启动任务队列的运行，检查是否有微任务在队列中等待，这个任务队列可以由外部事件循环执行
接口说明
场景示例：
启动任务队列，执行任务。

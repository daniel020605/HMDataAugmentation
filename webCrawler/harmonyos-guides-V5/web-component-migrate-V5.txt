Web组件在不同的窗口间迁移
Web组件能够实现在不同窗口的组件树上进行挂载或移除操作，这一能力使得开发者可以将同一个Web组件在不同窗口间迁移。例如，将浏览器的Tab页拖出成独立窗口，或拖入浏览器的另一个窗口。
Web组件在不同窗口间迁移，是基于自定义节点能力实现的。实现的基本原理是：通过BuilderNode，开发者可创建Web组件的离线节点，并结合自定义占位节点控制Web节点的挂载与移除。当从一个窗口上移除Web节点，并挂载到另一个窗口中，即完成Web组件在窗口间的迁移。
在以下示例中，主窗Ability启动时，通过命令式的方式创建了一个Web组件。开发者可以利用common.ets中提供的方法和类，实现Web组件的挂载和移除。Index.ets则提供了一种挂载和移除Web组件的实现方法。通过这种方式，开发者能够实现Web组件在不同窗口中页面的挂载与移除，即实现了Web组件在不同窗口间的迁移。下图是展示了这一迁移过程的示意图。
不要将一个Web组件同时挂载在两个父节点下，这会导致非预期行为。
// 主窗Ability\n// EntryAbility.ets\nimport { createNWeb, defaultUrl } from '../pages/common'\n\n// ...\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');\n\n    windowStage.loadContent('pages/Index', (err) => {\n      if (err.code) {\n        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      // 创建Web动态组件（需传入UIContext），loadContent之后的任意时机均可创建，应用仅创建一个Web组件\n      createNWeb(defaultUrl, windowStage.getMainWindowSync().getUIContext());\n      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');\n    });\n  }\n\n// ...
// 提供动态挂载Web组件能力\n// pages/common.ets\nimport { UIContext, NodeController, BuilderNode, FrameNode } from '@kit.ArkUI';\nimport { webview } from '@kit.ArkWeb';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\n\nexport const defaultUrl : string = 'https://www.example.com';\n\n// Data为入参封装类\nclass Data{\n  url: string = '';\n  webController: webview.WebviewController | null = null;\n\n  constructor(url: string, webController: webview.WebviewController) {\n    this.url = url;\n    this.webController = webController;\n  }\n}\n\n// @Builder中为动态组件的具体组件内容\n@Builder\nfunction WebBuilder(data:Data) {\n  Web({ src: data.url, controller: data.webController })\n    .width(\"100%\")\n    .height(\"100%\")\n    .borderStyle(BorderStyle.Dashed)\n    .borderWidth(2)\n}\n\nlet wrap = wrapBuilder<[Data]>(WebBuilder);\n\n// 用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用\nexport class MyNodeController extends NodeController {\n  private builderNode: BuilderNode<[Data]> | null | undefined = null;\n  private webController : webview.WebviewController | null | undefined = null;\n  private rootNode : FrameNode | null = null;\n\n  constructor(builderNode : BuilderNode<[Data]> | undefined, webController : webview.WebviewController | undefined) {\n    super();\n    this.builderNode = builderNode;\n    this.webController = webController;\n  }\n\n  // 必须要重写的方法，用于构建节点数、返回节点挂载在对应NodeContainer中\n  // 在对应NodeContainer创建的时候调用或者通过rebuild方法调用刷新\n  makeNode(uiContext: UIContext): FrameNode | null {\n    // 该节点会被挂载在NodeContainer的父节点下\n    return this.rootNode;\n  }\n\n  // 挂载Webview\n  attachWeb() : void {\n    if (this.builderNode) {\n      let frameNode : FrameNode | null = this.builderNode.getFrameNode();\n      if (frameNode?.getParent() != null) {\n        // 挂载自定义节点前判断该节点是否已经被挂载\n        hilog.error(0x0000, 'testTag', '%{public}s', 'The frameNode is already attached');\n        return;\n      }\n      this.rootNode = this.builderNode.getFrameNode();\n    }\n  }\n\n  // 卸载Webview\n  detachWeb() : void {\n    this.rootNode = null;\n  }\n\n  getWebController() : webview.WebviewController | null | undefined {\n    return this.webController;\n  }\n}\n\n// 创建Map保存所需要的BuilderNode\nlet builderNodeMap : Map<string, BuilderNode<[Data]> | undefined> = new Map();\n// 创建Map保存所需要的webview.WebviewController\nlet webControllerMap : Map<string, webview.WebviewController | undefined> = new Map();\n\n// 初始化需要UIContext对象，UIContext对象可通过窗口或自定义组件的getUIContext方法获取\nexport const createNWeb = (url: string, uiContext: UIContext) => {\n  // 创建WebviewController\n  let webController = new webview.WebviewController() ;\n  // 创建BuilderNode\n  let builderNode : BuilderNode<[Data]> = new BuilderNode(uiContext);\n  // 创建动态Web组件\n  builderNode.build(wrap, new Data(url, webController));\n\n  // 保存BuilderNode\n  builderNodeMap.set(url, builderNode);\n  // 保存WebviewController\n  webControllerMap.set(url, webController);\n}\n\n// 自定义获取BuilderNode的接口\nexport const getBuilderNode = (url : string) : BuilderNode<[Data]> | undefined => {\n  return builderNodeMap.get(url);\n}\n// 自定义获取WebviewController的接口\nexport const getWebviewController = (url : string) : webview.WebviewController | undefined => {\n  return webControllerMap.get(url);\n}
// 使用NodeController的Page页\n// pages/Index.ets\nimport { getBuilderNode, MyNodeController, defaultUrl, getWebviewController } from \"./common\"\n\n@Entry\n@Component\nstruct Index {\n  private nodeController : MyNodeController =\n    new MyNodeController(getBuilderNode(defaultUrl), getWebviewController(defaultUrl));\n\n  build() {\n    Row() {\n      Column() {\n        Button(\"Attach Webview\")\n          .onClick(() => {\n            // 注意不要将同一个节点同时挂载在不同的页面上！\n            this.nodeController.attachWeb();\n            this.nodeController.rebuild();\n          })\n        Button(\"Detach Webview\")\n          .onClick(() => {\n            this.nodeController.detachWeb();\n            this.nodeController.rebuild();\n          })\n        // NodeContainer用于与NodeController节点绑定，rebuild会触发makeNode\n        // Page页通过NodeContainer接口绑定NodeController，实现动态组件页面显示\n        NodeContainer(this.nodeController)\n          .height(\"80%\")\n          .width(\"80%\")\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}

自定义占位节点
ArkUI提供了系统组件NodeContainer和ContentSlot作为自定义节点的占位节点。主要用于自定义节点以及自定义节点树的显示。
NodeContainer作为容器节点存在，具备通用属性，是UI节点。ContentSlot只是一个语法节点，无通用属性，不参与布局和渲染。支持混合模式开发，当容器是ArkTS组件，子组件在Native侧创建时，推荐使用ContentSlot占位组件。具体使用参考ContentSlot的接口文档说明。
NodeContainer是用来占位的系统组件，主要用于自定义节点以及自定义节点树的显示，支持组件的通用属性，对通用属性的处理请参考默认左上角对齐的Stack组件。
NodeController提供了一系列生命周期回调，通过makeNode回调返回一个 FrameNode 节点树的根节点。将FrameNode节点树挂载到对应的NodeContainer下。同时提供了aboutToAppear、aboutToDisappear、aboutToResize、onTouchEvent、rebuild五个回调方法用于监听对应的NodeContainer的状态。
每个生命周期的回调的具体含义参考NodeController的接口文档说明。
 NodeContainer下仅支持挂载自定义的FrameNode节点以及BuilderNode创建的组件树的根节点。 从API Version 12开始支持的接口，可以通过FrameNode的查询接口返回原生组件的代理节点，代理节点可以作为makeNode的返回值进行返回，但代理节点无法成功挂载在组件树上，最终的显示结果为代理节点挂载失败。 需要保证一个节点只能作为一个父节点的子节点去使用，否则可能存在显示异常或者功能异常，尤其是页面路由场景或者动效场景。例如，如果通过NodeController将同一个节点挂载在多个NodeContainer上，仅一个占位容器下会显示节点，且多个NodeContainer的可见性、透明度等影响子组件状态的属性更新均会影响被挂载的子节点。 
基本概念
 自定义节点：使用ArkUI提供的接口，以命令式创建的节点。包括自定义组件节点（FrameNode）、自定义渲染节点（RenderNode）、自定义声明式节点（BuilderNode）、ComponentContent等。 自定义节点树：根节点为自定义节点的节点树。 声明式节点树：根节点为声明式节点的节点树。 节点树：一种常见的数据结构，用于表示节点的层级关系。 占位节点：用于在声明式节点树上为自定义节点树预留位置的节点，主要包括NodeContainer和ContentSlot。鉴于页面的主树采用声明式节点树，因此，唯有借助占位节点，才能将命令式构建的自定义节点成功挂载至声明式节点树上。 
使用NodeContainer挂载自定义节点
通过NodeController在NodeContainer下挂载自定义节点。
// common.ets\nimport { BuilderNode, UIContext } from '@kit.ArkUI'\n\nclass Params {\n  text: string = \"this is a text\"\n}\n\nlet buttonNode: BuilderNode<[Params]> | null = null;\n\n@Builder\nfunction buttonBuilder(params: Params) {\n  Column() {\n    Button(params.text)\n      .fontSize(12)\n      .borderRadius(8)\n      .borderWidth(2)\n      .backgroundColor(Color.Orange)\n  }\n}\n\nexport function createNode(uiContext: UIContext) {\n  buttonNode = new BuilderNode<[Params]>(uiContext);\n  buttonNode.build(wrapBuilder(buttonBuilder), { text: \"This is a Button\" });\n  return buttonNode;\n}\n\nexport function getOrCreateNode(uiContext: UIContext): BuilderNode<[Params]> | null {\n  if (buttonNode?.getFrameNode() && buttonNode?.getFrameNode()?.getUniqueId() != -1) {\n    return buttonNode;\n  } else {\n    return createNode(uiContext);\n  }\n}
// Index.ets\nimport { FrameNode, NodeController, Size, UIContext } from '@kit.ArkUI'\nimport { getOrCreateNode } from \"./common\"\n\nconst TEST_TAG: string = \"NodeContainer\";\n\nclass MyNodeController extends NodeController {\n  private isShow: boolean = false;\n\n  constructor(isShow: boolean) {\n    super();\n    this.isShow = isShow;\n  }\n\n  makeNode(uiContext: UIContext): FrameNode | null {\n    if (!this.isShow) {\n      return null;\n    }\n    let frameNode = getOrCreateNode(uiContext)?.getFrameNode();\n    return frameNode ? frameNode : null;\n  }\n\n  aboutToResize(size: Size) {\n    console.log(TEST_TAG + \" aboutToResize width : \" + size.width + \" height : \" + size.height)\n  }\n\n  aboutToAppear() {\n    console.log(TEST_TAG + \" aboutToAppear\")\n  }\n\n  aboutToDisappear() {\n    console.log(TEST_TAG + \" aboutToDisappear\");\n  }\n\n  onTouchEvent(event: TouchEvent) {\n    console.log(TEST_TAG + \" onTouchEvent\");\n  }\n\n  toShow() {\n    this.isShow = true;\n    this.rebuild();\n  }\n\n  toHide() {\n    this.isShow = false;\n    this.rebuild();\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  private myNodeController1: MyNodeController = new MyNodeController(true);\n  private myNodeController2: MyNodeController = new MyNodeController(false);\n\n  build() {\n    Column() {\n      NodeContainer(this.myNodeController1)\n        .width(\"100%\")\n        .height(\"40%\")\n        .backgroundColor(Color.Brown)\n      NodeContainer(this.myNodeController2)\n        .width(\"100%\")\n        .height(\"40%\")\n        .backgroundColor(Color.Gray)\n      Button(\"Change the place of button\")\n        .onClick(() => {\n          // 先在原始占位节点中下树\n          // 后在新的占位节点中上树\n          // 保证自定义节点仅作为一个节点的子节点存在\n          this.myNodeController1.toHide();\n          this.myNodeController2.toShow();\n        })\n    }\n    .padding({ left: 35, right: 35, top: 35 })\n    .width(\"100%\")\n    .height(\"100%\")\n  }\n}
NodeContainer和ContentSlot添加子节点布局差异
NodeContainer是一个容器节点，布局参考默认左上角对齐的Stack组件，不会按照父容器的布局规则进行布局。ContentSlot只是一个语法节点，不参与布局，添加的子节点会按照父容器的布局规则进行布局。
import { FrameNode, NodeContent, NodeController, typeNode, UIContext } from '@kit.ArkUI';\n\nclass NodeContentCtrl {\n  content: NodeContent\n  textNode: Array<typeNode.Text> = new Array();\n  uiContext: UIContext\n  width: number\n\n  constructor(uiContext: UIContext) {\n    this.content = new NodeContent()\n    this.uiContext = uiContext\n    this.width = Infinity\n  }\n\n  AddNode() {\n    let node = typeNode.createNode(this.uiContext, \"Text\")\n    node.initialize(\"ContentText:\" + this.textNode.length).fontSize(20)\n    this.textNode.push(node)\n    this.content.addFrameNode(node)\n  }\n\n  RemoveNode() {\n    let node = this.textNode.pop()\n    this.content.removeFrameNode(node)\n  }\n\n  RemoveFront() {\n    let node = this.textNode.shift()\n    this.content.removeFrameNode(node)\n  }\n\n  GetContent(): NodeContent {\n    return this.content\n  }\n}\n\nclass MyNodeController extends NodeController {\n  public rootNode: FrameNode | null = null;\n  textNode: Array<typeNode.Text> = new Array();\n\n  makeNode(uiContext: UIContext): FrameNode {\n    this.rootNode = new FrameNode(uiContext);\n    return this.rootNode;\n  }\n\n  AddNode(frameNode: FrameNode | null, uiContext: UIContext) {\n    let node = typeNode.createNode(uiContext, \"Text\")\n    node.initialize(\"ControllerText:\" + this.textNode.length).fontSize(20)\n    this.textNode.push(node)\n    frameNode?.appendChild(node)\n  }\n\n  RemoveNode(frameNode: FrameNode | null) {\n    let node = this.textNode.pop()\n    frameNode?.removeChild(node)\n  }\n\n  RemoveFront(frameNode: FrameNode | null) {\n    let node = this.textNode.shift()\n    frameNode?.removeChild(node)\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n  controller = new NodeContentCtrl(this.getUIContext());\n  myNodeController = new MyNodeController();\n\n  build() {\n    Row() {\n      Column() {\n        ContentSlot(this.controller.GetContent())\n        Button(\"AddToSlot\")\n          .onClick(() => {\n            this.controller.AddNode()\n          })\n          .margin(10)\n        Button(\"RemoveBack\")\n          .onClick(() => {\n            this.controller.RemoveNode()\n          })\n          .margin(10)\n        Button(\"RemoveFront\")\n          .onClick(() => {\n            this.controller.RemoveFront()\n          })\n          .margin(10)\n      }\n      .width('50%')\n\n      Column() {\n        NodeContainer(this.myNodeController)\n        Button(\"AddToNodeContainer\")\n          .onClick(() => {\n            this.myNodeController.AddNode(this.myNodeController.rootNode, this.getUIContext())\n          })\n          .margin(10)\n        Button(\"RemoveBack\")\n          .onClick(() => {\n            this.myNodeController.RemoveNode(this.myNodeController.rootNode)\n          })\n          .margin(10)\n        Button(\"RemoveFront\")\n          .onClick(() => {\n            this.myNodeController.RemoveFront(this.myNodeController.rootNode)\n          })\n          .margin(10)\n      }\n      .width('50%')\n    }\n    .height('100%')\n  }\n}

ArkUI瀑布流渲染场景
此处提供使用任务池TaskPool提升WaterFlow瀑布流渲染性能的开发指导。UI线程查询数据库数据，并将数据渲染到瀑布流组件，数据过大时会导致UI线程长时间等待，影响用户体验。因此，我们可以将数据查询操作放到子线程中，并通过TaskPool的接口返回数据给UI线程。
本示例将说明下面的场景：
 模拟子线程读取数据库数据并返回给UI线程。 UI线程感知到数据更新，将子线程返回的数据渲染到瀑布流组件。 
 定义一个接口，用于子线程查询数据库并返回数据给UI线程。 // Mock.ets\nimport { taskpool } from '@kit.ArkTS';\nimport { fillImg } from './Index';\n\n@Concurrent\nfunction query() {\n  console.info(\"TaskPoolTest-this is query\");\n  let result = new Array<string>(33);\n  for (let i = 0; i < 33; i++) {\n    result[i] = 'Image' + i;\n  }\n  taskpool.Task.sendData(result);\n}\n\n\nexport function getImgFromDB() {\n  //此处模拟查询数据库，并返回数据\n  let task = new taskpool.Task(query);\n  task.onReceiveData(fillImg);\n  taskpool.execute(task);\n} 封装一个瀑布流数据源，用于瀑布流组件加载数据。 // WaterFlowDataSource.ets\n\n// 实现IDataSource接口的对象，用于瀑布流组件加载数据\nexport class WaterFlowDataSource implements IDataSource {\n  private dataArray: number[] = [];\n  private listeners: DataChangeListener[] = [];\n\n  constructor() {\n    for (let i = 0; i < 100; i++) {\n      this.dataArray.push(i);\n    }\n  }\n\n  // 获取索引对应的数据\n  public getData(index: number): number {\n    return this.dataArray[index];\n  }\n\n  // 通知控制器数据重新加载\n  notifyDataReload(): void {\n    this.listeners.forEach(listener => {\n      listener.onDataReloaded();\n    })\n  }\n\n  // 通知控制器数据增加\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index);\n    })\n  }\n\n  // 通知控制器数据变化\n  notifyDataChange(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataChange(index);\n    })\n  }\n\n  // 通知控制器数据删除\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataDelete(index);\n    })\n  }\n\n  // 通知控制器数据位置变化\n  notifyDataMove(from: number, to: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataMove(from, to);\n    })\n  }\n\n  //通知控制器数据批量修改\n  notifyDatasetChange(operations: DataOperation[]): void {\n    this.listeners.forEach(listener => {\n      listener.onDatasetChange(operations);\n    })\n  }\n\n  // 获取数据总数\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  // 注册改变数据的控制器\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener);\n    }\n  }\n\n  // 注销改变数据的控制器\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1);\n    }\n  }\n\n  // 增加数据\n  public add1stItem(): void {\n    this.dataArray.splice(0, 0, this.dataArray.length);\n    this.notifyDataAdd(0);\n  }\n\n  // 在数据尾部增加一个元素\n  public addLastItem(): void {\n    this.dataArray.splice(this.dataArray.length, 0, this.dataArray.length);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n\n  // 在指定索引位置增加一个元素\n  public addItem(index: number): void {\n    this.dataArray.splice(index, 0, this.dataArray.length);\n    this.notifyDataAdd(index);\n  }\n\n  // 删除第一个元素\n  public delete1stItem(): void {\n    this.dataArray.splice(0, 1);\n    this.notifyDataDelete(0);\n  }\n\n  // 删除第二个元素\n  public delete2ndItem(): void {\n    this.dataArray.splice(1, 1);\n    this.notifyDataDelete(1);\n  }\n\n  // 删除最后一个元素\n  public deleteLastItem(): void {\n    this.dataArray.splice(-1, 1);\n    this.notifyDataDelete(this.dataArray.length);\n  }\n\n  // 在指定索引位置删除一个元素\n  public deleteItem(index: number): void {\n    this.dataArray.splice(index, 1);\n    this.notifyDataDelete(index);\n  }\n\n  // 重新加载数据\n  public reload(): void {\n    this.dataArray.splice(1, 1);\n    this.dataArray.splice(3, 2);\n    this.notifyDataReload();\n  }\n} 在应用冷启动阶段，调用getImgFromDB()接口，将数据查询操作放到子线程中。在img接收到子线程返回的数据后，将数据渲染到瀑布流组件。 // Index.ets\nimport { WaterFlowDataSource } from './WaterFlowDataSource';\nimport { getImgFromDB } from './Mock';\n\n// 模拟图片数组\nlet img = new Array<string>(33);\nexport function fillImg(imgArr : Array<string>) {\n  img = imgArr;\n}\n\n@Entry\n@Component\nstruct WaterFlowDemo {\n  @State minSize: number = 80;\n  @State maxSize: number = 180;\n  @State fontSize: number = 24;\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F];\n  scroller: Scroller = new Scroller();\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource();\n  private itemWidthArray: number[] = [];\n  private itemHeightArray: number[] = [];\n  // 计算FlowItem宽/高\n  getSize() {\n    let ret = Math.floor(Math.random() * this.maxSize);\n    return (ret > this.minSize ? ret : this.minSize);\n  }\n\n  // 设置FlowItem的宽/高数组\n  setItemSizeArray() {\n    for (let i = 0; i < 100; i++) {\n      this.itemWidthArray.push(this.getSize());\n      this.itemHeightArray.push(this.getSize());\n    }\n  }\n\n  aboutToAppear() {\n    this.setItemSizeArray();\n  }\n\n  @Builder\n  itemFoot() {\n    Column() {\n      Text(`Footer`)\n        .fontSize(10)\n        .backgroundColor(Color.Red)\n        .width(50)\n        .height(50)\n        .align(Alignment.Center)\n        .margin({ top: 2 });\n    }\n  }\n\n  build() {\n    Column({ space: 2 }) {\n      Text(\"ArkUI WaterFlow Demo\")\n        .onAppear(()=>{\n          getImgFromDB();\n        })\n      WaterFlow() {\n        LazyForEach(this.dataSource, (item: number) => {\n          FlowItem() {\n            Column() {\n              Text(\"N\" + item)\n                .fontSize(12)\n                .height('16')\n                .onClick(()=>{\n\n                });\n              // 为了模拟图片加载，使用Text组件显示，正常加载jpg文件时，可以直接使用Image组件，参考 Image(this.img[item % 33]).objectFit(ImageFit.Contain).width('100%').layoutWeight(1)\n              if (img[item % 33] == null) {\n                Text(\"图片加载中...\")\n                  .width('100%')\n                  .layoutWeight(1);\n              }\n              Text(img[item % 33])\n                .width('100%')\n                .layoutWeight(1);\n            }\n          }\n          .onAppear(() => {\n            // 即将触底时提前增加数据\n            if (item + 20 == this.dataSource.totalCount()) {\n              for (let i = 0; i < 100; i++) {\n                this.dataSource.addLastItem();\n              }\n            }\n          })\n          .width('100%')\n          .height(this.itemHeightArray[item % 100])\n          .backgroundColor(this.colors[item % 5])\n        }, (item: string) => item)\n      }\n      .columnsTemplate(\"1fr 1fr\")\n      .columnsGap(10)\n      .rowsGap(5)\n      .backgroundColor(0xFAEEE0)\n      .width('100%')\n      .height('100%')\n      .onReachStart(() => {\n        console.info('TaskPoolTest-waterFlow reach start');\n      })\n      .onScrollStart(() => {\n        console.info('TaskPoolTest-waterFlow scroll start');\n      })\n      .onScrollStop(() => {\n        console.info('TaskPoolTest-waterFlow scroll stop');\n      })\n      .onScrollFrameBegin((offset: number, state: ScrollState) => {\n        console.info('TaskPoolTest-waterFlow scrollFrameBegin offset: ' + offset + ' state: ' + state.toString());\n        return { offsetRemain: offset };\n      })\n    }\n  }\n} 

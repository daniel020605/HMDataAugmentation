@Monitor装饰器：状态变量修改监听
为了增强状态管理框架对状态变量变化的监听能力，开发者可以使用@Monitor装饰器对状态变量进行监听。
@Monitor提供了对V2状态变量的监听。在阅读本文档前，建议提前阅读：@ComponentV2，@ObservedV2和@Trace，@Local。
@Monitor装饰器从API version 12开始支持。
概述
@Monitor装饰器用于监听状态变量修改，使得状态变量具有深度监听的能力：
@Monitor装饰器支持在@ComponentV2装饰的自定义组件中使用，未被状态变量装饰器@Local、@Param、@Provider、@Consumer、@Computed装饰的变量无法被@Monitor监听到变化。 @Monitor装饰器支持在类中与@ObservedV2、@Trace配合使用，不允许在未被@ObservedV2装饰的类中使用@Monitor装饰器。未被@Trace装饰的属性无法被@Monitor监听到变化。 当观测的属性变化时，@Monitor装饰器定义的回调方法将被调用。判断属性是否变化使用的是严格相等（===），当严格相等为false的情况下，就会触发@Monitor的回调。当在一次事件中多次改变同一个属性时，将会使用初始值和最终值进行比较以判断是否变化。 单个@Monitor装饰器能够同时监听多个属性的变化，当这些属性在一次事件中共同变化时，只会触发一次@Monitor的回调方法。 @Monitor装饰器具有深度监听的能力，能够监听嵌套类、多维数组、对象数组中指定项的变化。对于嵌套类、对象数组中成员属性变化的监听要求该类被@ObservedV2装饰且该属性被@Trace装饰。 在继承类场景中，可以在父子组件中对同一个属性分别定义@Monitor进行监听，当属性变化时，父子组件中定义的@Monitor回调均会被调用。 和@Watch装饰器类似，开发者需要自己定义回调函数，区别在于@Watch装饰器将函数名作为参数，而@Monitor直接装饰回调函数。@Monitor与@Watch的对比可以查看@Monitor与@Watch的对比。 
状态管理V1版本@Watch装饰器的局限性
现有状态管理V1版本无法实现对对象、数组中某一单个属性或数组项变化的监听，且无法获取变化之前的值。
@Observed\nclass Info {\n  name: string = \"Tom\";\n  age: number = 25;\n}\n@Entry\n@Component\nstruct Index {\n  @State @Watch('onInfoChange') info: Info = new Info();\n  @State @Watch('onNumArrChange') numArr: number[] = [1,2,3,4,5];\n\n  onInfoChange() {\n    console.log(`info after change name: ${this.info.name}, age: ${this.info.age} `);\n  }\n  onNumArrChange() {\n    console.log(`numArr after change ${JSON.stringify(this.numArr)}`);\n  }\n  build() {\n    Row() {\n      Column() {\n        Button(\"change info name\")\n          .onClick(() => {\n            this.info.name = \"Jack\";\n          })\n        Button(\"change info age\")\n          .onClick(() => {\n            this.info.age = 30;\n          })\n        Button(\"change numArr[2]\")\n          .onClick(() => {\n            this.numArr[2] = 5;\n          })\n        Button(\"change numArr[3]\")\n          .onClick(() => {\n            this.numArr[3] = 6;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
上述代码中，点击\"change info name\"更改info中的name属性或点击\"change info age\"更改age时，均会触发info注册的@Watch回调。点击\"change numArr[2]\"更改numArr中的第3个元素或点击\"change numArr[3]\"更改第4个元素时，均会触发numArr注册的@Watch回调。在这两个回调中，由于无法获取数据更改前的值，在业务逻辑更加复杂的场景下，无法准确知道是哪一个属性或元素发生了改变从而触发了@Watch事件，这不便于开发者对变量的更改进行准确监听。因此推出@Monitor装饰器实现对对象、数组中某一单个属性或数组项变化的监听，并且能够获取到变化之前的值。
装饰器说明
接口说明
[h2]IMonitor类型
IMonitor类型的变量用作@Monitor装饰方法的参数。
[h2]IMonitorValue<T>类型
IMonitorValue<T>类型保存了属性变化的信息，包括属性名、变化前值、当前值。
监听变化
[h2]在@ComponentV2装饰的自定义组件中使用@Monitor
使用@Monitor监听的状态变量发生变化时，会触发@Monitor的回调方法。
@Monitor监听的变量需要被@Local、@Param、@Provider、@Consumer、@Computed装饰，未被状态变量装饰器装饰的变量在变化时无法被监听。@Monitor可以同时监听多个状态变量，这些变量名之间用\",\"隔开。 @Entry\n@ComponentV2\nstruct Index {\n  @Local message: string = \"Hello World\";\n  @Local name: string = \"Tom\";\n  @Local age: number = 24;\n  @Monitor(\"message\", \"name\")\n  onStrChange(monitor: IMonitor) {\n    monitor.dirty.forEach((path: string) => {\n      console.log(`${path} changed from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`)\n    })\n  }\n  build() {\n    Column() {\n      Button(\"change string\")\n        .onClick(() => {\n          this.message += \"!\";\n          this.name = \"Jack\";\n      })\n    }\n  }\n} @Monitor监听的状态变量为类对象时，仅能监听对象整体的变化。监听类属性的变化需要类属性被@Trace装饰。 class Info {\n  name: string;\n  age: number;\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local info: Info = new Info(\"Tom\", 25);\n  @Monitor(\"info\")\n  infoChange(monitor: IMonitor) {\n    console.log(`info change`);\n  }\n  @Monitor(\"info.name\")\n  infoPropertyChange(monitor: IMonitor) {\n    console.log(`info name change`);\n  }\n  build() {\n    Column() {\n      Text(`name: ${this.info.name}, age: ${this.info.age}`)\n      Button(\"change info\")\n        .onClick(() => {\n          this.info = new Info(\"Lucy\", 18); // 能够监听到\n        })\n      Button(\"change info.name\")\n        .onClick(() => {\n          this.info.name = \"Jack\"; // 监听不到\n        })\n    }\n  }\n} 
[h2]在@ObservedV2装饰的类中使用@Monitor
使用@Monitor监听的属性发生变化时，会触发@Monitor的回调方法。
@Monitor监听的对象属性需要被@Trace装饰，未被@Trace装饰的属性的变化无法被监听。@Monitor可以同时监听多个属性，这些属性之间用\",\"隔开。
@ObservedV2\nclass Info {\n  @Trace name: string = \"Tom\";\n  @Trace region: string = \"North\";\n  @Trace job: string = \"Teacher\";\n  age: number = 25;\n  // name被@Trace装饰，能够监听变化\n  @Monitor(\"name\")\n  onNameChange(monitor: IMonitor) {\n    console.log(`name change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n  // age未被@Trace装饰，不能监听变化\n  @Monitor(\"age\")\n  onAgeChange(monitor: IMonitor) {\n    console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n  // region与job均被@Trace装饰，能够监听变化\n  @Monitor(\"region\", \"job\")\n  onChange(monitor: IMonitor) {\n    monitor.dirty.forEach((path: string) => {\n      console.log(`${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);\n    })\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n  build() {\n    Column() {\n      Button(\"change name\")\n        .onClick(() => {\n          this.info.name = \"Jack\"; // 能够触发onNameChange方法\n        })\n      Button(\"change age\")\n        .onClick(() => {\n          this.info.age = 26; // 不能够触发onAgeChange方法\n        })\n      Button(\"change region\")\n        .onClick(() => {\n          this.info.region = \"South\"; // 能够触发onChange方法\n        })\n      Button(\"change job\")\n        .onClick(() => {\n          this.info.job = \"Driver\"; // 能够触发onChange方法\n        })\n    }\n  }\n}
@Monitor可以监听深层属性的变化，该深层属性需要被@Trace装饰。
@ObservedV2\nclass Inner {\n  @Trace num: number = 0;\n}\n@ObservedV2\nclass Outer {\n  inner: Inner = new Inner();\n  @Monitor(\"inner.num\")\n  onChange(monitor: IMonitor) {\n    console.log(`inner.num change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  outer: Outer = new Outer();\n  build() {\n    Column() {\n      Button(\"change name\")\n        .onClick(() => {\n          this.outer.inner.num = 100; // 能够触发onChange方法\n        })\n    }\n  }\n}
在继承类场景下，可以在继承链中对同一个属性进行多次监听。
@ObservedV2\nclass Base {\n  @Trace name: string;\n  // 基类监听name属性\n  @Monitor(\"name\")\n  onBaseNameChange(monitor: IMonitor) {\n    console.log(`Base Class name change`);\n  }\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n@ObservedV2\nclass Derived extends Base {\n  // 继承类监听name属性\n  @Monitor(\"name\")\n  onDerivedNameChange(monitor: IMonitor) {\n    console.log(`Derived Class name change`);\n  }\n  constructor(name: string) {\n    super(name);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  derived: Derived = new Derived(\"AAA\");\n  build() {\n    Column() {\n      Button(\"change name\")\n        .onClick(() => {\n          this.derived.name = \"BBB\"; // 能够先后触发onBaseNameChange、onDerivedNameChange方法\n        })\n    }\n  }\n}
[h2]通用监听能力
@Monitor还有一些通用的监听能力。
@Monitor支持对数组中的项进行监听，包括多维数组，对象数组。@Monitor无法监听内置类型（Array、Map、Date、Set）的API调用引起的变化。当@Monitor监听数组整体时，只能观测到数组整体的赋值。可以通过监听数组的长度变化来判断数组是否有插入、删除等变化。当前仅支持使用\".\"的方式表达深层属性、数组项的监听。
@ObservedV2\nclass Info {\n  @Trace name: string;\n  @Trace age: number;\n  \n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n@ObservedV2\nclass ArrMonitor {\n  @Trace dimensionTwo: number[][] = [[1,1,1],[2,2,2],[3,3,3]];\n  @Trace dimensionThree: number[][][] = [[[1],[2],[3]],[[4],[5],[6]],[[7],[8],[9]]];\n  @Trace infoArr: Info[] = [new Info(\"Jack\", 24), new Info(\"Lucy\", 18)];\n  // dimensionTwo为二维简单类型数组，且被@Trace装饰，能够观测里面的元素变化\n  @Monitor(\"dimensionTwo.0.0\", \"dimensionTwo.1.1\")\n  onDimensionTwoChange(monitor: IMonitor) {\n    monitor.dirty.forEach((path: string) => {\n      console.log(`dimensionTwo path: ${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);\n    })\n  }\n  // dimensionThree为三维简单类型数组，且被@Trace装饰，能够观测里面的元素变化\n  @Monitor(\"dimensionThree.0.0.0\", \"dimensionThree.1.1.0\")\n  onDimensionThreeChange(monitor: IMonitor) {\n    monitor.dirty.forEach((path: string) => {\n      console.log(`dimensionThree path: ${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);\n    })\n  }\n  // Info类中属性name、age均被@Trace装饰，能够监听到变化\n  @Monitor(\"infoArr.0.name\", \"infoArr.1.age\")\n  onInfoArrPropertyChange(monitor: IMonitor) {\n    monitor.dirty.forEach((path: string) => {\n      console.log(`infoArr path:${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);\n    })\n  }\n  // infoArr被@Trace装饰，能够监听到infoArr整体赋值的变化\n  @Monitor(\"infoArr\")\n  onInfoArrChange(monitor: IMonitor) {\n    console.log(`infoArr whole change`);\n  }\n  // 能够监听到infoArr的长度变化\n  @Monitor(\"infoArr.length\")\n  onInfoArrLengthChange(monitor: IMonitor) {\n    console.log(`infoArr length change`);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  arrMonitor: ArrMonitor = new ArrMonitor();\n  build() {\n    Column() {\n      Button(\"Change dimensionTwo\")\n        .onClick(() => {\n          // 能够触发onDimensionTwoChange方法  \n          this.arrMonitor.dimensionTwo[0][0]++; \n          this.arrMonitor.dimensionTwo[1][1]++; \n        })\n      Button(\"Change dimensionThree\")\n        .onClick(() => {\n          // 能够触发onDimensionThreeChange方法\n          this.arrMonitor.dimensionThree[0][0][0]++;\n          this.arrMonitor.dimensionThree[1][1][0]++; \n        })\n      Button(\"Change info property\")\n        .onClick(() => {\n          // 能够触发onInfoArrPropertyChange方法\n          this.arrMonitor.infoArr[0].name = \"Tom\"; \n          this.arrMonitor.infoArr[1].age = 19; \n        })\n      Button(\"Change whole infoArr\")\n        .onClick(() => {\n          // 能够触发onInfoArrChange、onInfoArrPropertyChange、onInfoArrLengthChange方法\n          this.arrMonitor.infoArr = [new Info(\"Cindy\", 8)]; \n        })\n      Button(\"Push new info to infoArr\")\n        .onClick(() => {\n          // 能够触发onInfoArrPropertyChange、onInfoArrLengthChange方法\n          this.arrMonitor.infoArr.push(new Info(\"David\", 50)); \n        })\n    }\n  }\n}
对象整体改变，但监听的属性不变时，不触发@Monitor回调。
下面的示例按照Step1-Step2-Step3的顺序点击，表现为代码注释中的行为。
如果只点击Step2或Step3，改变name、age的值，此时会触发onNameChange和onAgeChange方法。
@ObservedV2\nclass Info {\n  @Trace person: Person;\n  @Monitor(\"person.name\")\n  onNameChange(monitor: IMonitor) {\n    console.log(`name change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n  @Monitor(\"person.age\")\n  onAgeChange(monitor: IMonitor) {\n    console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n  constructor(name: string, age: number) {\n    this.person = new Person(name, age);\n  }\n}\n@ObservedV2\nclass Person {\n  @Trace name: string;\n  @Trace age: number;\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info(\"Tom\", 25);\n  build() {\n    Column() {\n      Button(\"Step1、Only change name\")\n        .onClick(() => {\n          this.info.person = new Person(\"Jack\", 25);  // 能够触发onNameChange方法，不触发onAgeChange方法\n        })\n      Button(\"Step2、Only change age\")\n        .onClick(() => {\n          this.info.person = new Person(\"Jack\", 18);  // 能够触发onAgeChange方法，不触发onNameChange方法\n        })\n      Button(\"Step3、Change name and age\")\n        .onClick(() => {\n          this.info.person = new Person(\"Lucy\", 19);  // 能够触发onNameChange、onAgeChange方法\n        })\n    }\n  }\n}
在一次事件中多次改变被@Monitor监听的属性，以最后一次修改为准。
@ObservedV2\nclass Frequence {\n  @Trace count: number = 0;\n  @Monitor(\"count\")\n  onCountChange(monitor: IMonitor) {\n    console.log(`count change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  frequence: Frequence = new Frequence();\n  build() {\n    Column() {\n      Button(\"change count to 1000\")\n        .onClick(() => {\n          for (let i = 1; i <= 1000; i++) {\n            this.frequence.count = i;\n          }\n        })\n      Button(\"change count to 0 then to 1000\")\n        .onClick(() => {\n          for (let i = 999; i >= 0; i--) {\n            this.frequence.count = i;\n          }\n          this.frequence.count = 1000; // 最终不触发onCountChange方法\n        })\n    }\n  }\n}
在点击按钮\"change count to 1000\"后，会触发一次onCountChange方法，并输出日志\"count change from 0 to 1000\"。在点击按钮\"change count to 0 then to 1000\"后，由于事件前后属性count的值并没有改变，都为1000，所以不触发onCountChange方法。
限制条件
使用@Monitor需要注意如下限制条件：
不建议在一个类中对同一个属性进行多次@Monitor的监听。当一个类中存在对一个属性的多次监听时，只有最后一个定义的监听方法会生效。
@ObservedV2\nclass Info {\n  @Trace name: string = \"Tom\";\n  @Monitor(\"name\")\n  onNameChange(monitor: IMonitor) {\n    console.log(`onNameChange`);\n  }\n  @Monitor(\"name\")\n  onNameChangeDuplicate(monitor: IMonitor) {\n    console.log(`onNameChangeDuplicate`);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n  build() {\n    Column() {\n      Button(\"change name\")\n        .onClick(() => {\n          this.info.name = \"Jack\"; // 仅会触发onNameChangeDuplicate方法\n        })\n    }\n  }\n}
@Monitor的参数需要为监听属性名的字符串，仅可以使用字符串字面量、const常量、enum枚举值作为参数。如果使用变量作为参数，仅会监听@Monitor初始化时，变量值所对应的属性。当更改变量时，@Monitor无法实时改变监听的属性，即@Monitor监听的目标属性从初始化时便已经确定，无法动态更改。不建议开发者使用变量作为@Monitor的参数进行初始化。
const t2: string = \"t2\"; // const常量\nenum ENUM {\n  T3 = \"t3\" // enum枚举值\n};\nlet t4: string = \"t4\"; // 变量\n@ObservedV2\nclass Info {\n  @Trace t1: number = 0;\n  @Trace t2: number = 0;\n  @Trace t3: number = 0;\n  @Trace t4: number = 0;\n  @Trace t5: number = 0;\n  @Monitor(\"t1\") // 字符串字面量\n  onT1Change(monitor: IMonitor) {\n    console.log(`t1 change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n  @Monitor(t2)\n  onT2Change(monitor: IMonitor) {\n    console.log(`t2 change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n  @Monitor(ENUM.T3)\n  onT3Change(monitor: IMonitor) {\n    console.log(`t3 change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n  @Monitor(t4)\n  onT4Change(monitor: IMonitor) {\n    console.log(`t4 change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n  build() {\n    Column() {\n      Button(\"Change t1\")\n        .onClick(() => {\n          this.info.t1++; // 能够触发onT1Change方法\n        })\n      Button(\"Change t2\")\n        .onClick(() => {\n          this.info.t2++; // 能够触发onT2Change方法\n        })\n      Button(\"Change t3\")\n        .onClick(() => {\n          this.info.t3++; // 能够触发onT3Change方法\n        })\n      Button(\"Change t4\")\n        .onClick(() => {\n          this.info.t4++; // 能够触发onT4Change方法\n        })\n      Button(\"Change var t4 to t5\")\n        .onClick(() => {\n          t4 = \"t5\"; // 更改变量值为\"t5\"\n        })\n      Button(\"Change t5\")\n        .onClick(() => {\n          this.info.t5++; // onT4Change仍监听t4，不会触发\n        })\n      Button(\"Change t4 again\")\n        .onClick(() => {\n          this.info.t4++; // 能够触发onT4Change方法\n        })\n    }\n  }\n}
建议开发者避免在@Monitor中再次更改被监听的属性，这会导致无限循环。
@ObservedV2\nclass Info {\n  @Trace count: number = 0;\n  @Monitor(\"count\")\n  onCountChange(monitor: IMonitor) {\n    this.count++; // 应避免这种写法，会导致无限循环\n  }\n}
@Monitor与@Watch对比
@Monitor与@Watch的用法、功能对比如下：
使用场景
[h2]监听深层属性变化
@Monitor可以监听深层属性的变化，并能够根据更改前后的值做分类处理。
下面的示例中监听了属性value的变化，并根据变化的幅度改变Text组件显示的样式。
@ObservedV2\nclass Info {\n  @Trace value: number = 50;\n}\n@ObservedV2\nclass UIStyle {\n  info: Info = new Info();\n  @Trace color: Color = Color.Black;\n  @Trace fontSize: number = 45;\n  @Monitor(\"info.value\")\n  onValueChange(monitor: IMonitor) {\n    let lastValue: number = monitor.value()?.before as number;\n    let curValue: number = monitor.value()?.now as number;\n    if (lastValue != 0) {\n      let diffPercent: number = (curValue - lastValue) / lastValue;\n      if (diffPercent > 0.1) {\n        this.color = Color.Red;\n        this.fontSize = 50;\n      } else if (diffPercent < -0.1) {\n        this.color = Color.Green;\n        this.fontSize = 40;\n      } else {\n        this.color = Color.Black;\n        this.fontSize = 45;\n      }\n    }\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  textStyle: UIStyle = new UIStyle();\n  build() {\n    Column() {\n      Text(`Important Value: ${this.textStyle.info.value}`)\n        .fontColor(this.textStyle.color)\n        .fontSize(this.textStyle.fontSize)\n      Button(\"change!\")\n        .onClick(() => {\n          this.textStyle.info.value = Math.floor(Math.random() * 100) + 1;\n        })\n    }\n  }\n}
常见问题
[h2]自定义组件中@Monitor对变量监听的生效及失效时间
当@Monitor定义在@ComponentV2装饰的自定义组件中时，@Monitor会在状态变量初始化完成之后生效，并在组件销毁时失效。
@ObservedV2\nclass Info {\n  @Trace message: string = \"not initialized\";\n\n  constructor() {\n    console.log(\"in constructor message change to initialized\");\n    this.message = \"initialized\";\n  }\n}\n@ComponentV2\nstruct Child {\n  @Param info: Info = new Info();\n  @Monitor(\"info.message\")\n  onMessageChange(monitor: IMonitor) {\n    console.log(`Child message change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n  aboutToAppear(): void {\n    this.info.message = \"Child aboutToAppear\";\n  }\n  aboutToDisappear(): void {\n    console.log(\"Child aboutToDisappear\");\n    this.info.message = \"Child aboutToDisappear\";\n  }\n  build() {\n    Column() {\n      Text(\"Child\")\n      Button(\"change message in Child\")\n        .onClick(() => {\n          this.info.message = \"Child click to change Message\";\n        })\n    }\n    .borderColor(Color.Red)\n    .borderWidth(2)\n\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local info: Info = new Info();\n  @Local flag: boolean = false;\n  @Monitor(\"info.message\")\n  onMessageChange(monitor: IMonitor) {\n    console.log(`Index message change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n\n  build() {\n    Column() {\n      Button(\"show/hide Child\")\n        .onClick(() => {\n          this.flag = !this.flag\n        })\n      Button(\"change message in Index\")\n        .onClick(() => {\n          this.info.message = \"Index click to change Message\";\n        })\n      if (this.flag) {\n        Child({ info: this.info })\n      }\n    }\n  }\n}
在上面的例子中，可以通过创建和销毁Child组件来观察定义在自定义组件中的@Monitor的生效和失效时机。推荐按如下顺序进行操作：
当Index组件创建Info类实例时，日志输出in constructor message change to initialized。此时Index组件的@Monitor还未初始化成功，因此不会监听到message的变化。当Index组件创建完成，页面加载完成后，点击按钮“change message in Index”，此时Index组件中的@Monitor能够监听到变化，日志输出Index message change from initialized to Index click to change Message。点击按钮“show/hide Child”，创建Child组件，在Child组件初始化@Param装饰的变量以及@Monitor之后，调用Child组件的aboutToAppear回调，改变message。此时Index组件与Child组件的@Monitor均能监听到变化，日志输出Index message change from Index click to change Message to Child aboutToAppear以及Child message change from Index click to change Message to Child aboutToAppear。点击按钮“change message in Child”，改变message。此时Index组件与Child组件的@Monitor均能监听到变化，日志输出Index message change from Child aboutToAppear to Child click to change Message以及Child message change from Child aboutToAppear to Child click to change Message。点击按钮”show/hide Child“，销毁Child组件，调用Child组件的aboutToDisappear回调，改变message。此时Index组件与Child组件的@Monitor均能监听到变化，日志输出Child aboutToDisappear，Index message change from Child click to change Message to Child aboutToDisappear以及Child message change from Child click to change Message to Child aboutToDisappear。点击按钮“change message in Index”，改变message。此时Child组件已销毁，其注册的@Monitor监听也被解注册，仅有Index组件的@Monitor能够监听到变化，日志输出Index message change from Child aboutToDisappear to Index click to change Message。
这表明Child组件中定义的@Monitor监听随着Child组件的创建初始化生效，随着Child组件的销毁失效。
[h2]类中@Monitor对变量监听的生效及失效时间
当@Monitor定义在@ObservedV2装饰的类中时，@Monitor会在类创建完成后生效，在类销毁时失效。
@ObservedV2\nclass Info {\n  @Trace message: string = \"not initialized\";\n\n  constructor() {\n    this.message = \"initialized\";\n  }\n  @Monitor(\"message\")\n  onMessageChange(monitor: IMonitor) {\n    console.log(`message change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n\n  aboutToAppear(): void {\n    this.info.message = \"Index aboutToAppear\";\n  }\n\n  build() {\n    Column() {\n      Button(\"change message\")\n        .onClick(() => {\n          this.info.message = \"Index click to change message\";\n        })\n    }\n  }\n}
上面的例子中，@Monitor会在info创建完成后生效，这个时机晚于类的constructor，早于自定义组件的aboutToAppear。当界面加载完成后，点击“change message”，修改message变量。此时日志输出信息如下：
message change from initialized to Index aboutToAppear\nmessage change from Index aboutToAppear to Index click to change message
类中定义的@Monitor随着类的销毁失效。而由于类的实际销毁释放依赖于垃圾回收机制，因此会出现即使所在自定义组件已经销毁，类却还未及时销毁，导致类中定义的@Monitor仍在监听变化的情况。
@ObservedV2\nclass InfoWrapper {\n  info?: Info;\n  constructor(info: Info) {\n    this.info = info;\n  }\n  @Monitor(\"info.age\")\n  onInfoAgeChange(monitor: IMonitor) {\n    console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`)\n  }\n}\n@ObservedV2\nclass Info {\n  @Trace age: number;\n  constructor(age: number) {\n    this.age = age;\n  }\n}\n@ComponentV2\nstruct Child {\n  @Param @Require infoWrapper: InfoWrapper;\n  aboutToDisappear(): void {\n    console.log(\"Child aboutToDisappear\", this.infoWrapper.info?.age)\n  }\n  build() {\n    Column() {\n      Text(`${this.infoWrapper.info?.age}`)\n    }\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  dataArray: Info[] = [];\n  @Local showFlag: boolean = true;\n  aboutToAppear(): void {\n    for (let i = 0; i < 5; i++) {\n      this.dataArray.push(new Info(i));\n    }\n  }\n  build() {\n    Column() {\n      Button(\"change showFlag\")\n        .onClick(() => {\n          this.showFlag = !this.showFlag;\n        })\n      Button(\"change number\")\n        .onClick(() => {\n          console.log(\"click to change age\")\n          this.dataArray.forEach((info: Info) => {\n            info.age += 100;\n          })\n        })\n      if (this.showFlag) {\n        Column() {\n          Text(\"Childs\")\n          ForEach(this.dataArray, (info: Info) => {\n            Child({ infoWrapper: new InfoWrapper(info) })\n          })\n        }\n        .borderColor(Color.Red)\n        .borderWidth(2)\n      }\n    }\n  }\n}
在上面的例子中，当点击“change showFlag”切换if组件的条件时，Child组件会被销毁。此时，点击“change number”修改age的值时，可以通过日志观察到InfoWrapper中定义的@Monitor回调仍然被触发了。这是因为此时自定义组件Child虽然执行了aboutToDisappear，但是其成员变量infoWrapper还没有被立刻回收，当变量发生变化时，依然能够调用到infoWrapper中定义的onInfoAgeChange方法，所以从现象上看@Monitor回调仍会被触发。
借助垃圾回收机制去取消@Monitor的监听是不稳定的，开发者可以采用以下两种方式去管理@Monitor的失效时间：
1、将@Monitor定义在自定义组件中。由于自定义组件在销毁时，状态管理框架会手动取消@Monitor的监听，因此在自定义组件调用完aboutToDisappear，尽管自定义组件的数据不一定已经被释放，但@Monitor回调已不会再被触发。
@ObservedV2\nclass InfoWrapper {\n  info?: Info;\n  constructor(info: Info) {\n    this.info = info;\n  }\n}\n@ObservedV2\nclass Info {\n  @Trace age: number;\n  constructor(age: number) {\n    this.age = age;\n  }\n}\n@ComponentV2\nstruct Child {\n  @Param @Require infoWrapper: InfoWrapper;\n  @Monitor(\"infoWrapper.info.age\")\n  onInfoAgeChange(monitor: IMonitor) {\n    console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`)\n  }\n  aboutToDisappear(): void {\n    console.log(\"Child aboutToDisappear\", this.infoWrapper.info?.age)\n  }\n  build() {\n    Column() {\n      Text(`${this.infoWrapper.info?.age}`)\n    }\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  dataArray: Info[] = [];\n  @Local showFlag: boolean = true;\n  aboutToAppear(): void {\n    for (let i = 0; i < 5; i++) {\n      this.dataArray.push(new Info(i));\n    }\n  }\n  build() {\n    Column() {\n      Button(\"change showFlag\")\n        .onClick(() => {\n          this.showFlag = !this.showFlag;\n        })\n      Button(\"change number\")\n        .onClick(() => {\n          console.log(\"click to change age\")\n          this.dataArray.forEach((info: Info) => {\n            info.age += 100;\n          })\n        })\n      if (this.showFlag) {\n        Column() {\n          Text(\"Childs\")\n          ForEach(this.dataArray, (info: Info) => {\n            Child({ infoWrapper: new InfoWrapper(info) })\n          })\n        }\n        .borderColor(Color.Red)\n        .borderWidth(2)\n      }\n    }\n  }\n}
2、主动置空监听的对象。当自定义组件即将销毁时，主动置空@Monitor的监听目标，这样@Monitor无法再监听原监听目标的变化，达到取消@Monitor监听的效果。
@ObservedV2\nclass InfoWrapper {\n  info?: Info;\n  constructor(info: Info) {\n    this.info = info;\n  }\n  @Monitor(\"info.age\")\n  onInfoAgeChange(monitor: IMonitor) {\n    console.log(`age change from ${monitor.value()?.before} to ${monitor.value()?.now}`)\n  }\n}\n@ObservedV2\nclass Info {\n  @Trace age: number;\n  constructor(age: number) {\n    this.age = age;\n  }\n}\n@ComponentV2\nstruct Child {\n  @Param @Require infoWrapper: InfoWrapper;\n  aboutToDisappear(): void {\n    console.log(\"Child aboutToDisappear\", this.infoWrapper.info?.age)\n    this.infoWrapper.info = undefined; // 使InfoWrapper对info.age的监听失效\n  }\n  build() {\n    Column() {\n      Text(`${this.infoWrapper.info?.age}`)\n    }\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  dataArray: Info[] = [];\n  @Local showFlag: boolean = true;\n  aboutToAppear(): void {\n    for (let i = 0; i < 5; i++) {\n      this.dataArray.push(new Info(i));\n    }\n  }\n  build() {\n    Column() {\n      Button(\"change showFlag\")\n        .onClick(() => {\n          this.showFlag = !this.showFlag;\n        })\n      Button(\"change number\")\n        .onClick(() => {\n          console.log(\"click to change age\")\n          this.dataArray.forEach((info: Info) => {\n            info.age += 100;\n          })\n        })\n      if (this.showFlag) {\n        Column() {\n          Text(\"Childs\")\n          ForEach(this.dataArray, (info: Info) => {\n            Child({ infoWrapper: new InfoWrapper(info) })\n          })\n        }\n        .borderColor(Color.Red)\n        .borderWidth(2)\n      }\n    }\n  }\n}
[h2]正确设置@Monitor入参
由于@Monitor无法对入参做编译时校验，当前存在以下写法不符合@Monitor监听条件但@Monitor仍会触发的情况。开发者应当正确传入@Monitor入参，不传入非状态变量，避免造成功能异常或行为表现不符合预期。
【反例1】
@ObservedV2\nclass Info {\n  name: string = \"John\";\n  @Trace age: number = 24;\n  @Monitor(\"age\", \"name\") // 同时监听状态变量age和非状态变量name\n  onPropertyChange(monitor: IMonitor) {\n    monitor.dirty.forEach((path: string) => {\n      console.log(`property path:${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);\n    })\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n  build() {\n    Column() {\n      Button(\"change age&name\")\n        .onClick(() => {\n          this.info.age = 25; // 同时改变状态变量age和非状态变量name\n          this.info.name = \"Johny\";\n        })\n    }\n  }\n}
上面的代码中，当点击按钮同时更改状态变量age和非状态变量name时，会输出以下日志：
property path:age change from 24 to 25\nproperty path:name change from John to Johny
实际上name属性本身并不是可被观测的变量，不应被加入到@Monitor的入参当中。建议开发者去除对name属性的监听或者将给name加上@Trace装饰成为状态变量。
【正例1】
@ObservedV2\nclass Info {\n  name: string = \"John\";\n  @Trace age: number = 24;\n  @Monitor(\"age\") // 仅监听状态变量age\n  onPropertyChange(monitor: IMonitor) {\n    monitor.dirty.forEach((path: string) => {\n      console.log(`property path:${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);\n    })\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n  build() {\n    Column() {\n      Button(\"change age&name\")\n        .onClick(() => {\n          this.info.age = 25; // 状态变量age改变\n          this.info.name = \"Johny\";\n        })\n    }\n  }\n}
【反例2】
@ObservedV2\nclass Info {\n  name: string = \"John\";\n  @Trace age: number = 24;\n  get myAge() {\n    return this.age; // age为状态变量\n  }\n  @Monitor(\"myAge\") // 监听非@Computed装饰的getter访问器\n  onPropertyChange() {\n    console.log(\"age changed\");\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n  build() {\n    Column() {\n      Button(\"change age\")\n        .onClick(() => {\n          this.info.age = 25; // 状态变量age改变\n        })\n    }\n  }\n}
上面的代码中，@Monitor的入参为一个getter访问器的名字，但该getter访问器本身并未被@Computed装饰，不是一个可被监听的变量。但由于使用了状态变量参与了计算，在状态变量变化后，myAge也被认为发生了变化，因此触发了@Monitor回调。建议开发者给myAge添加@Computed装饰器或当getter访问器直接返回状态变量时，不监听getter访问器而是直接监听状态变量本身。
【正例2】
将myAge变为状态变量：
@ObservedV2\nclass Info {\n  name: string = \"John\";\n  @Trace age: number = 24;\n  @Computed // 给myAge添加@Computed成为状态变量\n  get myAge() {\n    return this.age;\n  }\n  @Monitor(\"myAge\") // 监听@Computed装饰的getter访问器\n  onPropertyChange() {\n    console.log(\"age changed\");\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n  build() {\n    Column() {\n      Button(\"change age\")\n        .onClick(() => {\n          this.info.age = 25; // 状态变量age改变\n        })\n    }\n  }\n}
或直接监听状态变量本身：
@ObservedV2\nclass Info {\n  name: string = \"John\";\n  @Trace age: number = 24;\n  @Monitor(\"age\") // 监听状态变量age\n  onPropertyChange() {\n    console.log(\"age changed\");\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n  build() {\n    Column() {\n      Button(\"change age\")\n        .onClick(() => {\n          this.info.age = 25; // 状态变量age改变\n        })\n    }\n  }\n}

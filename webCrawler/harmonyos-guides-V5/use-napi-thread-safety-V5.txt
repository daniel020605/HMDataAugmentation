使用Node-API接口进行线程安全开发
场景介绍
napi_create_threadsafe_function是Node-API接口之一，用于创建一个线程安全的JavaScript函数。主要用于在多个线程之间共享和调用，而不会出现竞争条件或死锁。例如以下场景：
异步计算：如果需要进行耗时的计算或IO操作，可以创建一个线程安全的函数，将计算或IO操作放在另一个线程中执行，避免阻塞主线程，提高程序的响应速度。 数据共享：如果多个线程需要访问同一份数据，可以创建一个线程安全的函数，确保数据的读写操作不会发生竞争条件或死锁等问题。 多线程编程：如果需要进行多线程编程，可以创建一个线程安全的函数，确保多个线程之间的通信和同步操作正确无误。 
使用示例
在Native入口定义线程安全函数。 #include \"napi/native_api.h\"\n#include \"hilog/log.h\"\n#include <future>\n\nstruct CallbackData {\n    napi_threadsafe_function tsfn;\n    napi_async_work work;\n};\n\nstatic napi_value StartThread(napi_env env, napi_callback_info info)\n{\n    size_t argc = 1;\n    napi_value jsCb = nullptr;\n    CallbackData *callbackData = nullptr;\n    napi_get_cb_info(env, info, &argc, &jsCb, nullptr, reinterpret_cast<void **>(&callbackData));\n\n    // 创建一个线程安全函数\n    napi_value resourceName = nullptr;\n    napi_create_string_utf8(env, \"Thread-safe Function Demo\", NAPI_AUTO_LENGTH, &resourceName);\n    napi_create_threadsafe_function(env, jsCb, nullptr, resourceName, 0, 1, callbackData, nullptr,\n        callbackData, CallJs, &callbackData->tsfn);\n\n    // 创建一个异步任务\n    // ExecuteWork会执行在一个由libuv创建的非JS线程上，此处使用napi_create_async_work是为了模拟在非JS线程场景使用napi_call_threadsafe_function接口向JS线程提交任务\n    napi_create_async_work(env, nullptr, resourceName, ExecuteWork, WorkComplete, callbackData,\n        &callbackData->work);\n\n    // 将异步任务加入到异步队列中\n    napi_queue_async_work(env, callbackData->work);\n    return nullptr;\n} 在工作线程中调用ExecuteWork，并执行线程安全函数。 static void ExecuteWork(napi_env env, void *data)\n{\n    CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\n    std::promise<std::string> promise;\n    auto future = promise.get_future();\n    napi_call_threadsafe_function(callbackData->tsfn, &promise, napi_tsfn_nonblocking);\n    try {\n        auto result = future.get();\n        // OH_LOG_INFO(LOG_APP, \"XXX, Result from JS %{public}s\", result.c_str());\n    } catch (const std::exception &e) {\n        // OH_LOG_INFO(LOG_APP, \"XXX, Result from JS %{public}s\", e.what());\n    }\n} 在JS线程执行异步回调函数。 static napi_value ResolvedCallback(napi_env env, napi_callback_info info)\n{\n    void *data = nullptr;\n    size_t argc = 1;\n    napi_value argv[1];\n    if (napi_get_cb_info(env, info, &argc, argv, nullptr, &data) != napi_ok) {\n        return nullptr;\n    }\n    size_t result = 0;\n    char buf[32] = {0};\n    napi_get_value_string_utf8(env, argv[0], buf, 32, &result);\n    reinterpret_cast<std::promise<std::string> *>(data)->set_value(std::string(buf));\n    return nullptr;\n}\n\nstatic napi_value RejectedCallback(napi_env env, napi_callback_info info)\n{\n    void *data = nullptr;\n    if (napi_get_cb_info(env, info, nullptr, nullptr, nullptr, &data) != napi_ok) {\n        return nullptr;\n    }\n    reinterpret_cast<std::promise<std::string> *>(data)->set_exception(\n        std::make_exception_ptr(std::runtime_error(\"Error in jsCallback\")));\n    return nullptr;\n}\n\nstatic void CallJs(napi_env env, napi_value jsCb, void *context, void *data)\n{\n    if (env == nullptr) {\n        return;\n    }\n    napi_value undefined = nullptr;\n    napi_value promise = nullptr;\n    napi_get_undefined(env, &undefined);\n    napi_call_function(env, undefined, jsCb, 0, nullptr, &promise);\n    napi_value thenFunc = nullptr;\n    if (napi_get_named_property(env, promise, \"then\", &thenFunc) != napi_ok) {\n        return;\n    }\n    napi_value resolvedCallback;\n    napi_value rejectedCallback;\n    napi_create_function(env, \"resolvedCallback\", NAPI_AUTO_LENGTH, ResolvedCallback, data,\n                         &resolvedCallback);\n    napi_create_function(env, \"rejectedCallback\", NAPI_AUTO_LENGTH, RejectedCallback, data,\n                         &rejectedCallback);\n    napi_value argv[2] = {resolvedCallback, rejectedCallback};\n    napi_call_function(env, promise, thenFunc, 2, argv, nullptr);\n} 任务执行完成后，进行资源清理回收。 static void WorkComplete(napi_env env, napi_status status, void *data)\n{\n    CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\n    napi_release_threadsafe_function(callbackData->tsfn, napi_tsfn_release);\n    napi_delete_async_work(env, callbackData->work);\n    callbackData->tsfn = nullptr;\n    callbackData->work = nullptr;\n} 模块初始化以及ArkTS侧调用接口。 // 模块初始化\nstatic napi_value Init(napi_env env, napi_value exports) {\n    CallbackData *callbackData = new CallbackData(); // 可在线程退出时释放\n    napi_property_descriptor desc[] = {\n        {\"startThread\", nullptr, StartThread, nullptr, nullptr, nullptr, napi_default, callbackData},\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n} // 接口对应的.d.ts描述\n export const startThread: (callback: () => Promise<string>) => void;\n\n// ArkTS侧调用接口\nimport nativeModule from 'libentry.so'; // 通过import的方式，引入Native能力\n\nlet callback = (): Promise<string> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n        resolve(\"string from promise\");\n      }, 5000);\n    });\n }\n nativeModule.startThread(callback); 

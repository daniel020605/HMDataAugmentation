自定义渲染 (XComponent)
概述
XComponent组件作为一种渲染组件，可用于EGL/OpenGLES和媒体数据写入，通过使用XComponent持有的“NativeWindow”来渲染画面，通常用于满足开发者较为复杂的自定义渲染需求，例如相机预览流的显示和游戏画面的渲染。其可通过指定type字段来实现不同的渲染方式，分别为XComponentType.SURFACE和XComponentType.TEXTURE。对于SURFACE类型，开发者将定制的绘制内容单独展示到屏幕上。对于TEXTURE类型，开发者将定制的绘制内容和XComponent组件的内容合成后展示到屏幕上。
目前XComponent组件主要有两个应用场景。一个是Native XComponent场景，在native层获取Native XComponent实例，在native侧注册XComponent的生命周期回调，以及触摸、鼠标、按键等事件回调。另一个是ArkTS XComponent场景，在ArkTS侧获取SurfaceId，生命周期回调、触摸、鼠标、按键等事件回调等均在ArkTS侧触发。
Native XComponent场景
在XComponent组件构造函数的libraryname中定义需要加载的动态库，而后应用就可以在Native层获取Native XComponent实例，其是XComponent组件提供在Native层的实例，可作为ArkTS层和Native层XComponent绑定的桥梁。XComponent所提供的NDK接口都依赖于该实例。接口能力包括获取NativeWindow实例、获取XComponent的布局/事件信息、注册XComponent的生命周期回调、注册XComponent的触摸、鼠标、按键等事件回调。针对Native XComponent，主要的开发场景如下：
 利用Native XComponent提供的接口注册XComponent的生命周期和事件回调。 在这些回调中进行初始化环境、获取当前状态、响应各类事件的开发。 利用NativeWindow和EGL接口开发自定义绘制内容以及申请和提交Buffer到图形队列。 
接口说明
上述接口不支持跨线程访问。
XComponent销毁（onSurfaceDestroyed回调触发后）时会释放上述接口中获取的OH_NativeXComponent和window对象。如果在之后再次使用获取的这些对象有可能会导致出现使用野指针或空指针的崩溃问题，需要开发者避免。
开发步骤
以下步骤以SURFACE类型为例，描述了如何使用XComponent组件调用Node-API接口来创建EGL/GLES环境，实现在主页面绘制图形，并可以改变图形的颜色。
 在界面中定义XComponent。 //在ets/interface/XComponentContext.ts中声明native侧接口\nexport default interface XComponentContext {\n  drawPattern(): void;\n\n  getStatus(): XComponentContextStatus;\n};\n\ntype XComponentContextStatus = {\n  hasDraw: boolean,\n  hasChangeColor: boolean,\n}; import XComponentContext from \"../interface/XComponentContext\"\n\n@Entry\n@Component\nstruct Index {\n    xComponentContext: XComponentContext | undefined = undefined;\n    xComponentAttrs: XComponentAttrs = {\n        id: 'xcomponentId',\n        type: XComponentType.SURFACE,\n        libraryname: 'nativerender'\n    }\n\n    build() {\n    Row() {\n        // ...\n        // 在xxx.ets 中定义 XComponent\n        XComponent(this.xComponentAttrs)\n            .focusable(true) // 可响应键盘事件\n            .onLoad((xComponentContext) => {\n                console.log(\"onLoad\");\n                this.xComponentContext = xComponentContext as XComponentContext;\n\n                // 调用drawPattern绘制内容\n                if (this.xComponentContext) {\n                    this.xComponentContext.drawPattern();\n                    if (this.xComponentContext.getStatus()) {\n                        this.xComponentContext.getStatus().hasDraw;\n                    }\n                }\n            })\n            .onDestroy(() => {\n                console.log(\"onDestroy\");\n            })\n        // ...\n        }\n        .onClick(() => {\n            // 调用getStatus改变绘制内容\n            if (this.xComponentContext && this.xComponentContext.getStatus()) {\n                this.xComponentContext.getStatus().hasChangeColor;\n            }\n        })\n        .height('100%')\n    }\n}\n    \ninterface XComponentAttrs {\n    id: string;\n    type: number;\n    libraryname: string;\n} Node-API模块注册，具体使用请参考Native API在应用工程中的使用指导。 #include <hilog/log.h>\n#include \"common/common.h\"\n#include \"manager/plugin_manager.h\"\n\n// 在napi_init.cpp文件中，Init方法注册接口函数，从而将封装的C++方法传递出来，供ArkTS侧调用\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports) {\n    // ...\n    // 向ArkTS侧暴露接口getContext()\n    napi_property_descriptor desc[] = {\n        { \"getContext\", nullptr, PluginManager::GetContext, nullptr, nullptr, nullptr, napi_default, nullptr }\n    };\n    if (napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"Init\", \"napi_define_properties failed\");\n        return nullptr;\n    }\n    // 方法内检查环境变量是否包含XComponent组件实例，若实例存在则导出绘制相关接口\n    PluginManager::GetInstance()->Export(env, exports);\n    return exports;\n}\nEXTERN_C_END\n\n// 编写接口的描述信息，根据实际需要可以修改对应参数\nstatic napi_module nativerenderModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    // 入口函数\n    .nm_register_func = Init,// 指定加载对应模块时的回调函数\n    // 模块名称\n    .nm_modname =\n        \"nativerender\", // 指定模块名称，对于XComponent相关开发，这个名称必须和ArkTS侧XComponent中libraryname的值保持一致\n    .nm_priv = ((void *)0),\n    .reserved = {0}};\n\n// __attribute__((constructor))修饰的方法由系统自动调用，使用Node-API接口napi_module_register()传入模块描述信息进行模块注册\nextern \"C\" __attribute__((constructor)) void RegisterModule(void) { napi_module_register(&nativerenderModule); } // 检查环境变量是否包含XComponent组件实例，若实例存在则导出绘制相关接口\nvoid PluginManager::Export(napi_env env, napi_value exports)\n{\n    if ((env == nullptr) || (exports == nullptr)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"Export: env or exports is null\");\n        return;\n    }\n\n    napi_value exportInstance = nullptr;\n    if (napi_get_named_property(env, exports, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"Export: napi_get_named_property fail\");\n    }\n\n    // 获取nativeXComponent\n    OH_NativeXComponent* nativeXComponent = nullptr;\n    if (napi_unwrap(env, exportInstance, reinterpret_cast<void**>(&nativeXComponent)) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"Export: napi_unwrap fail\");\n        return;\n    }\n\n    // 获取XComponent的id，即ArkTS侧XComponent组件构造中的id参数\n    char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {'\\0'};\n    uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n    if (OH_NativeXComponent_GetXComponentId(nativeXComponent, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"Export: OH_NativeXComponent_GetXComponentId fail\");\n        return;\n    }\n\n    std::string id(idStr);\n    auto context = PluginManager::GetInstance();\n    if ((context != nullptr) && (nativeXComponent != nullptr)) {\n        context->SetNativeXComponent(id, nativeXComponent);\n        auto render = context->GetRender(id);\n        if (render != nullptr) {\n            // 注册回调函数\n            render->RegisterCallback(nativeXComponent);\n            // 方法内使用Node-API，导出绘制相关接口，向ArkTS侧暴露绘制相关方法\n            render->Export(env, exports);\n        }\n    }\n} // 使用Node-API中的napi_define_properties方法，向ArkTS侧暴露drawPattern()和getStatus()方法，在ArkTS侧调用drawPattern()来绘制内容，\n// 调用getStatus()来改变绘制内容\nvoid PluginRender::Export(napi_env env, napi_value exports)\n{\n    // ...\n    // 将接口函数注册为ArkTS侧接口drawPattern和getStatus\n    napi_property_descriptor desc[] = {\n        {\"drawPattern\", nullptr, PluginRender::NapiDrawPattern, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"getStatus\", nullptr, PluginRender::TestGetXComponentStatus, nullptr, nullptr, nullptr, napi_default,\n         nullptr}};\n    if (napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginRender\", \"Export: napi_define_properties failed\");\n    }\n} 注册XComponent事件回调，使用Node-API实现XComponent事件回调函数。 (1) 定义surface创建成功，发生改变，销毁和XComponent的touch事件回调接口。 // 在头文件中定义PluginRender类\nclass PluginRender {\npublic:\n    explicit PluginRender(std::string& id);\n    ~PluginRender() {\n        if (eglCore_ != nullptr) {\n            eglCore_->Release();\n            delete eglCore_;\n            eglCore_ = nullptr;\n       }\n   }\n   static PluginRender* GetInstance(std::string& id);\n   static void Release(std::string& id);\n   static napi_value NapiDrawPattern(napi_env env, napi_callback_info info);\n   static napi_value TestGetXComponentStatus(napi_value env, napi_callback_info info);\n   void Export(napi_env env, napi_value exports);\n   void OnSurfaceChanged(OH_NativeXComponent* component, void* window);\n   void OnTouchEvent(OH_NativeXComponent* component, void* window);\n   void OnMouseEvent(OH_NativeXComponent* component, void* window);\n   void OnHoverEvent(OH_NativeXComponent* component, bool isHover);\n   void OnFocusEvent(OH_NativeXComponent* component, void* window);\n   void OnBlurEvent(OH_NativeXComponent* component, void* window);\n   void OnKeyEvent(OH_NativeXComponent* component, void* window);\n   void RegisterCallback(OH_NativeXComponent* NativeXComponent);\n\npublic:\n    static std::unordered_map<std::string, PluginRender*> instance_;\n    EGLCore* eglCore_;\n    std::string id_;\n    static int32_t hasDraw_;\n    static int32_t hasChangeColor_;\n\nprivate:\n    OH_NativeXComponent_Callback renderCallback_;\n    OH_NativeXComponent_MouseEvent_Callback mouseCallback_;\n}; // 在源文件中实现PluginRender类中方法\nstd::unordered_map<std::string, PluginRender *> PluginRender::instance_;\nint32_t PluginRender::hasDraw_ = 0;\nint32_t PluginRender::hasChangeColor_ = 0;\n\nPluginRender::PluginRender(std::string& id) {\n    this->id_ = id;\n    this->eglCore_ = new EGLCore();\n}\n\nPluginRender* PluginRender::GetInstance(std::string& id) {\n    if (instance_.find(id) == instance_.end()) {\n        PluginRender* instance = new PluginRender(id);\n        instance_[id] = instance;\n        return instance;\n    } else {\n        return instance_[id];\n    }\n}\n\n// 定义一个函数OnSurfaceCreatedCB()，封装初始化环境与绘制背景\nvoid OnSurfaceCreatedCB(OH_NativeXComponent *component, void *window) {\n       // ...\n       // 获取XComponent的id，即ArkTS侧XComponent组件构造中的id参数\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {'\\0'};\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       if (OH_NativeXComponent_GetXComponentId(component, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"Callback\",\n                        \"OnSurfaceCreatedCB: Unable to get XComponent id\");\n           return;\n       }\n\n       // 初始化环境与绘制背景\n       std::string id(idStr);\n       auto render = PluginRender::GetInstance(id);\n       uint64_t width;\n       uint64_t height;\n       // 获取XComponent拥有的surface的大小\n       int32_t xSize = OH_NativeXComponent_GetXComponentSize(component, window, &width, &height);\n       if ((xSize == OH_NATIVEXCOMPONENT_RESULT_SUCCESS) && (render != nullptr)) {\n           if (render->eglCore_->EglContextInit(window, width, height)) {\n               render->eglCore_->Background();\n           }\n       }\n}\n\n// 定义一个函数OnSurfaceChangedCB()\nvoid OnSurfaceChangedCB(OH_NativeXComponent *component, void *window) {\n       // ...\n       // 获取XComponent的id\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {'\\0'};\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       if (OH_NativeXComponent_GetXComponentId(component, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"Callback\",\n                        \"OnSurfaceChangedCB: Unable to get XComponent id\");\n           return;\n       }\n\n       std::string id(idStr);\n       auto render = PluginRender::GetInstance(id);\n       if (render != nullptr) {\n           // 封装OnSurfaceChanged方法\n           render->OnSurfaceChanged(component, window);\n       }\n}\n\n// 定义一个函数OnSurfaceDestroyedCB()，将PluginRender类内释放资源的方法Release()封装在其中\nvoid OnSurfaceDestroyedCB(OH_NativeXComponent *component, void *window) {\n       // ...\n       // 获取XComponent的id\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {'\\0'};\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       if (OH_NativeXComponent_GetXComponentId(component, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"Callback\",\n                        \"OnSurfaceDestroyedCB: Unable to get XComponent id\");\n           return;\n       }\n\n       std::string id(idStr);\n       // 释放资源\n       PluginRender::Release(id);\n}\n\n// 定义一个函数DispatchTouchEventCB()，响应触摸事件时触发该回调\nvoid DispatchTouchEventCB(OH_NativeXComponent *component, void *window) {\n       // ...\n       // 获取XComponent的id\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = { '\\0' };\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       if (OH_NativeXComponent_GetXComponentId(component, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"Callback\",\n                        \"DispatchTouchEventCB: Unable to get XComponent id\");\n           return;\n       }\n\n       std::string id(idStr);\n       PluginRender *render = PluginRender::GetInstance(id);\n       if (render != nullptr) {\n           // 封装OnTouchEvent方法\n           render->OnTouchEvent(component, window);\n       }\n}\n\n// 定义一个函数DispatchMouseEventCB()，响应鼠标事件时触发该回调\nvoid DispatchMouseEventCB(OH_NativeXComponent *component, void *window) {\n       // ...\n       int32_t ret;\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {};\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       ret = OH_NativeXComponent_GetXComponentId(component, idStr, &idSize);\n       if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           return;\n       }\n\n       std::string id(idStr);\n       auto render = PluginRender::GetInstance(id);\n       if (render) {\n           // 封装OnMouseEvent方法\n           render->OnMouseEvent(component, window);\n       }\n}\n\n// 定义一个函数DispatchHoverEventCB()，响应鼠标悬停事件时触发该回调\nvoid DispatchHoverEventCB(OH_NativeXComponent *component, bool isHover) {\n       // ...\n       int32_t ret;\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {};\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       ret = OH_NativeXComponent_GetXComponentId(component, idStr, &idSize);\n       if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           return;\n       }\n\n       std::string id(idStr);\n       auto render = PluginRender::GetInstance(id);\n       if (render) {\n           // 封装OnHoverEvent方法\n           render->OnHoverEvent(component, isHover);\n       }\n}\n\n// 定义一个函数OnFocusEventCB()，响应获焦事件时触发该回调\nvoid OnFocusEventCB(OH_NativeXComponent *component, void *window) {\n    // ...\n       int32_t ret;\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {};\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       ret = OH_NativeXComponent_GetXComponentId(component, idStr, &idSize);\n       if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           return;\n       }\n\n       std::string id(idStr);\n       auto render = PluginRender::GetInstance(id);\n       if (render) {\n           // 封装OnFocusEvent方法\n           render->OnFocusEvent(component, window);\n       }\n}\n\n// 定义一个函数OnBlurEventCB()，响应失去焦点事件时触发该回调\nvoid OnBlurEventCB(OH_NativeXComponent *component, void *window) {\n       // ...\n       int32_t ret;\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {};\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       ret = OH_NativeXComponent_GetXComponentId(component, idStr, &idSize);\n       if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           return;\n       }\n\n       std::string id(idStr);\n       auto render = PluginRender::GetInstance(id);\n       if (render) {\n           // 封装OnBlurEvent方法\n           render->OnBlurEvent(component, window);\n       }\n}\n\n// 定义一个函数OnKeyEventCB()，响应按键事件时触发该回调\nvoid OnKeyEventCB(OH_NativeXComponent *component, void *window) {\n       // ...\n       int32_t ret;\n       char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {};\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       ret = OH_NativeXComponent_GetXComponentId(component, idStr, &idSize);\n       if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           return;\n       }\n\n       std::string id(idStr);\n       auto render = PluginRender::GetInstance(id);\n       if (render) {\n           // 封装OnKeyEvent方法\n           render->OnKeyEvent(component, window);\n       }\n}\n\n// 定义一个OnSurfaceChanged()方法\nvoid PluginRender::OnSurfaceChanged(OH_NativeXComponent* component, void* window) {\n    char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = { '\\0' };\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       if (OH_NativeXComponent_GetXComponentId(component, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"Callback\", \"OnSurfaceChanged: Unable to get XComponent id\");\n           return;\n       }\n\n    std::string id(idStr);\n    PluginRender* render = PluginRender::GetInstance(id);\n    double offsetX;\n    double offsetY;\n    // 获取XComponent持有的surface相对其父组件左顶点的偏移量\n    OH_NativeXComponent_GetXComponentOffset(component, window, &offsetX, &offsetY);\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"OH_NativeXComponent_GetXComponentOffset\",\n                 \"offsetX = %{public}lf, offsetY = %{public}lf\", offsetX, offsetY);\n    uint64_t width;\n    uint64_t height;\n    OH_NativeXComponent_GetXComponentSize(component, window, &width, &height);\n    if (render != nullptr) {\n        render->eglCore_->UpdateSize(width, height);\n    }\n}\n\n// 定义一个OnTouchEvent()方法\nvoid PluginRender::OnTouchEvent(OH_NativeXComponent* component, void* window) {\n    char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = { '\\0' };\n       uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n       if (OH_NativeXComponent_GetXComponentId(component, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"Callback\",\n                        \"OnTouchEvent: Unable to get XComponent id\");\n           return;\n       }\n\n    OH_NativeXComponent_TouchEvent touchEvent;\n    // 获取由XComponent触发的触摸事件\n    OH_NativeXComponent_GetTouchEvent(component, window, &touchEvent);\n    // 获取XComponent触摸点相对于XComponent组件左边缘的坐标x和相对于XComponent组件上边缘的坐标y\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"OnTouchEvent\", \"touch info: x = %{public}lf, y = %{public}lf\",\n                 touchEvent.x, touchEvent.y);\n    // 获取XComponent触摸点相对于XComponent所在应用窗口左上角的x坐标和相对于XComponent所在应用窗口左上角的y坐标\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"OnTouchEvent\",\n                 \"touch info: screenX = %{public}lf, screenY = %{public}lf\", touchEvent.screenX, touchEvent.screenY);\n    std::string id(idStr);\n    PluginRender* render = PluginRender::GetInstance(id);\n    if (render != nullptr && touchEvent.type == OH_NativeXComponent_TouchEventType::OH_NATIVEXCOMPONENT_UP) {\n        render->eglCore_->ChangeColor();\n        hasChangeColor_ = 1;\n    }\n    float tiltX = 0.0f;\n    float tiltY = 0.0f;\n    OH_NativeXComponent_TouchPointToolType toolType =\n        OH_NativeXComponent_TouchPointToolType::OH_NATIVEXCOMPONENT_TOOL_TYPE_UNKNOWN;\n    // 获取XComponent触摸点的工具类型\n    OH_NativeXComponent_GetTouchPointToolType(component, 0, &toolType);\n    // 获取XComponent触摸点处相对X轴的倾斜角度\n    OH_NativeXComponent_GetTouchPointTiltX(component, 0, &tiltX);\n    // 获取XComponent触摸点处相对Y轴的倾斜角度\n    OH_NativeXComponent_GetTouchPointTiltY(component, 0, &tiltY);\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"OnTouchEvent\",\n                 \"touch info: toolType = %{public}d, tiltX = %{public}lf, tiltY = %{public}lf\", toolType, tiltX, tiltY);\n}\n\n// 定义一个OnMouseEvent()方法\nvoid PluginRender::OnMouseEvent(OH_NativeXComponent *component, void *window) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"PluginRender\", \"OnMouseEvent\");\n    OH_NativeXComponent_MouseEvent mouseEvent;\n    // 获取由XComponent触发的鼠标事件\n    int32_t ret = OH_NativeXComponent_GetMouseEvent(component, window, &mouseEvent);\n    if (ret == OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n           OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"PluginRender\",\n                     \"MouseEvent Info: x = %{public}f, y = %{public}f, action = %{public}d, button = %{public}d\",\n                     mouseEvent.x, mouseEvent.y, mouseEvent.action, mouseEvent.button);\n    } else {\n           OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginRender\", \"GetMouseEvent error\");\n    }\n}\n\n// 定义一个OnHoverEvent()方法\nvoid PluginRender::OnHoverEvent(OH_NativeXComponent* component, bool isHover) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"PluginRender\", \"OnHoverEvent isHover_ = %{public}d\", isHover);\n}\n\n// 定义一个OnFocusEvent()方法\nvoid PluginRender::OnFocusEvent(OH_NativeXComponent* component, void* window) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"PluginRender\", \"OnFocusEvent\");\n}\n\n// 定义一个OnBlurEvent()方法\nvoid PluginRender::OnBlurEvent(OH_NativeXComponent* component, void* window) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"PluginRender\", \"OnBlurEvent\");\n}\n\n// 定义一个OnKeyEvent()方法\nvoid PluginRender::OnKeyEvent(OH_NativeXComponent *component, void *window) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"PluginRender\", \"OnKeyEvent\");\n\n    OH_NativeXComponent_KeyEvent *keyEvent = nullptr;\n    // 获取由XComponent触发的按键事件\n    if (OH_NativeXComponent_GetKeyEvent(component, &keyEvent) >= 0) {\n           OH_NativeXComponent_KeyAction action;\n        // 获取按键事件的动作\n           OH_NativeXComponent_GetKeyEventAction(keyEvent, &action);\n           OH_NativeXComponent_KeyCode code;\n        // 获取按键事件的键码值\n           OH_NativeXComponent_GetKeyEventCode(keyEvent, &code);\n           OH_NativeXComponent_EventSourceType sourceType;\n        // 获取按键事件的输入源类型\n           OH_NativeXComponent_GetKeyEventSourceType(keyEvent, &sourceType);\n           int64_t deviceId;\n        // 获取按键事件的设备ID\n           OH_NativeXComponent_GetKeyEventDeviceId(keyEvent, &deviceId);\n           int64_t timeStamp;\n        // 获取按键事件的时间戳\n           OH_NativeXComponent_GetKeyEventTimestamp(keyEvent, &timeStamp);\n           OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"PluginRender\",\n                     \"KeyEvent Info: action=%{public}d, code=%{public}d, sourceType=%{public}d, deviceId=%{public}ld, \"\n                     \"timeStamp=%{public}ld\",\n                     action, code, sourceType, deviceId, timeStamp);\n    } else {\n           OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginRender\", \"GetKeyEvent error\");\n    }\n} (2) 注册XComponent事件回调函数，在XComponent事件触发时调用3.1步骤中定义的方法。 void PluginRender::RegisterCallback(OH_NativeXComponent *NativeXComponent) {\n    // 设置组件创建事件的回调函数，组件创建时触发相关操作，初始化环境与绘制背景\n    renderCallback_.OnSurfaceCreated = OnSurfaceCreatedCB;\n    // 设置组件改变事件的回调函数，组件改变时触发相关操作\n    renderCallback_.OnSurfaceChanged = OnSurfaceChangedCB;\n    // 设置组件销毁事件的回调函数，组件销毁时触发相关操作，释放申请的资源\n    renderCallback_.OnSurfaceDestroyed = OnSurfaceDestroyedCB;\n    // 设置触摸事件的回调函数，在触摸事件触发时调用Node-API接口函数，从而调用原C++方法\n    renderCallback_.DispatchTouchEvent = DispatchTouchEventCB;\n    // 将OH_NativeXComponent_Callback注册给NativeXComponent\n    OH_NativeXComponent_RegisterCallback(NativeXComponent, &renderCallback_);\n    \n    // 设置鼠标事件的回调函数，在触摸事件触发时调用Node-API接口函数，从而调用原C++方法\n    mouseCallback_.DispatchMouseEvent = DispatchMouseEventCB;\n    // 设置鼠标悬停事件的回调函数，在触摸事件触发时调用Node-API接口函数，从而调用原C++方法\n    mouseCallback_.DispatchHoverEvent = DispatchHoverEventCB;\n    // 将OH_NativeXComponent_MouseEvent_Callback注册给NativeXComponent\n    OH_NativeXComponent_RegisterMouseEventCallback(NativeXComponent, &mouseCallback_);\n    \n    // 将OnFocusEventCB方法注册给NativeXComponent\n    OH_NativeXComponent_RegisterFocusEventCallback(NativeXComponent, OnFocusEventCB);\n    // 将OnKeyEventCB方法注册给NativeXComponent\n    OH_NativeXComponent_RegisterKeyEventCallback(NativeXComponent, OnKeyEventCB);\n    // 将OnBlurEventCB方法注册给 NativeXComponent\n    OH_NativeXComponent_RegisterBlurEventCallback(NativeXComponent, OnBlurEventCB);\n} (3) 定义NapiDrawPattern方法，暴露到ArkTS侧的drawPattern()方法会执行该方法。 napi_value PluginRender::NapiDrawPattern(napi_env env, napi_callback_info info) {\n    // ...\n    // 获取环境变量参数\n    napi_value thisArg;\n    if (napi_get_cb_info(env, info, nullptr, nullptr, &thisArg, nullptr) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginRender\", \"NapiDrawPattern: napi_get_cb_info fail\");\n        return nullptr;\n    }\n   \n    // 获取环境变量中XComponent实例\n    napi_value exportInstance;\n    if (napi_get_named_property(env, thisArg, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginRender\",\n                     \"NapiDrawPattern: napi_get_named_property fail\");\n        return nullptr;\n    }\n   \n    // 通过napi_unwrap接口，获取XComponent的实例指针\n    OH_NativeXComponent *NativeXComponent = nullptr;\n    if (napi_unwrap(env, exportInstance, reinterpret_cast<void **>(&NativeXComponent)) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginRender\", \"NapiDrawPattern: napi_unwrap fail\");\n        return nullptr;\n    }\n   \n    // 获取XComponent实例的id\n    char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = { '\\0' };\n    uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n    if (OH_NativeXComponent_GetXComponentId(NativeXComponent, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginRender\",\n                     \"NapiDrawPattern: Unable to get XComponent id\");\n        return nullptr;\n    }\n   \n    std::string id(idStr);\n    PluginRender *render = PluginRender::GetInstance(id);\n    if (render) {\n        // 调用绘制方法\n        render->eglCore_->Draw();\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"PluginRender\", \"render->eglCore_->Draw() executed\");\n    }\n    return nullptr;\n} (4) 定义TestGetXComponentStatus方法，暴露到ArkTS侧的getStatus()方法会执行该方法。 napi_value PluginRender::TestGetXComponentStatus(napi_env env, napi_callback_info info) {\n    napi_value hasDraw;\n    napi_value hasChangeColor;\n\n    napi_create_int32(env, hasDraw_, &(hasDraw));\n    napi_create_int32(env, hasChangeColor_, &(hasChangeColor));\n\n    napi_value obj;\n    napi_create_object(env, &obj);\n    napi_set_named_property(env, obj, \"hasDraw\", hasDraw);\n    napi_set_named_property(env, obj, \"hasChangeColor\", hasChangeColor);\n\n    return obj;\n} 初始化环境，包括初始化可用的EGLDisplay、确定可用的surface配置、创建渲染区域surface、创建并关联上下文等。 void EGLCore::UpdateSize(int width, int height) {\n    // width_和height_在头文件中定义\n    width_ = width;\n    height_ = height;\n}\n\nbool EGLCore::EglContextInit(void *window, int width, int height) {\n    // ...\n    UpdateSize(width, height);\n    eglWindow_ = static_cast<EGLNativeWindowType>(window);\n\n    // 初始化display\n    eglDisplay_ = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n    if (eglDisplay_ == EGL_NO_DISPLAY) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"eglGetDisplay: unable to get EGL display\");\n        return false;\n    }\n\n    // 初始化EGL\n    EGLint majorVersion;\n    EGLint minorVersion;\n    if (!eglInitialize(eglDisplay_, &majorVersion, &minorVersion)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\",\n            \"eglInitialize: unable to get initialize EGL display\");\n        return false;\n    }\n\n    // 选择配置\n    const EGLint maxConfigSize = 1;\n    EGLint numConfigs;\n    if (!eglChooseConfig(eglDisplay_, ATTRIB_LIST, &eglConfig_, maxConfigSize, &numConfigs)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"eglChooseConfig: unable to choose configs\");\n        return false;\n    }\n\n    // 创建环境\n    return CreateEnvironment();\n} bool EGLCore::CreateEnvironment() {\n    // ...\n    // 创建surface\n    eglSurface_ = eglCreateWindowSurface(eglDisplay_, eglConfig_, eglWindow_, NULL);\n\n    // ...\n    // 创建context\n    eglContext_ = eglCreateContext(eglDisplay_, eglConfig_, EGL_NO_CONTEXT, CONTEXT_ATTRIBS);\n    if (!eglMakeCurrent(eglDisplay_, eglSurface_, eglSurface_, eglContext_)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"eglMakeCurrent failed\");\n        return false;\n    }\n\n    // 创建program\n    program_ = CreateProgram(VERTEX_SHADER, FRAGMENT_SHADER);\n    if (program_ == PROGRAM_ERROR) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"CreateProgram: unable to create program\");\n        return false;\n    }\n    return true;\n}\n\nGLuint EGLCore::CreateProgram(const char* vertexShader, const char* fragShader) {\n    if ((vertexShader == nullptr) || (fragShader == nullptr)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\",\n                     \"createProgram: vertexShader or fragShader is null\");\n        return PROGRAM_ERROR;\n    }\n\n    GLuint vertex = LoadShader(GL_VERTEX_SHADER, vertexShader);\n    if (vertex == PROGRAM_ERROR) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"createProgram vertex error\");\n        return PROGRAM_ERROR;\n    }\n\n    GLuint fragment = LoadShader(GL_FRAGMENT_SHADER, fragShader);\n    if (fragment == PROGRAM_ERROR) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"createProgram fragment error\");\n        return PROGRAM_ERROR;\n    }\n\n    GLuint program = glCreateProgram();\n    if (program == PROGRAM_ERROR) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"createProgram program error\");\n        glDeleteShader(vertex);\n        glDeleteShader(fragment);\n        return PROGRAM_ERROR;\n    }\n\n    // The gl function has no return value.\n    glAttachShader(program, vertex);\n    glAttachShader(program, fragment);\n    glLinkProgram(program);\n\n    GLint linked;\n    glGetProgramiv(program, GL_LINK_STATUS, &linked);\n    if (linked != 0) {\n        glDeleteShader(vertex);\n        glDeleteShader(fragment);\n        return program;\n    }\n\n    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"createProgram linked error\");\n    GLint infoLen = 0;\n    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLen);\n    if (infoLen > 1) {\n        char* infoLog = (char*)malloc(sizeof(char) * (infoLen + 1));\n        memset(infoLog, 0, infoLen + 1);\n        glGetProgramInfoLog(program, infoLen, nullptr, infoLog);\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"glLinkProgram error = %s\", infoLog);\n        free(infoLog);\n        infoLog = nullptr;\n    }\n    glDeleteShader(vertex);\n    glDeleteShader(fragment);\n    glDeleteProgram(program);\n    return PROGRAM_ERROR;\n}\n\nGLuint EGLCore::LoadShader(GLenum type, const char* shaderSrc) {\n    if ((type <= 0) || (shaderSrc == nullptr)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"glCreateShader type or shaderSrc error\");\n        return PROGRAM_ERROR;\n    }\n\n    GLuint shader = glCreateShader(type);\n    if (shader == 0) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"glCreateShader unable to load shader\");\n        return PROGRAM_ERROR;\n    }\n\n    // The gl function has no return value.\n    glShaderSource(shader, 1, &shaderSrc, nullptr);\n    glCompileShader(shader);\n\n    GLint compiled;\n    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n    if (compiled != 0) {\n        return shader;\n    }\n\n    GLint infoLen = 0;\n    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);\n    if (infoLen <= 1) {\n        glDeleteShader(shader);\n        return PROGRAM_ERROR;\n    }\n\n    char *infoLog = (char*)malloc(sizeof(char) * (infoLen + 1));\n    if (infoLog != nullptr) {\n        memset(infoLog, 0, infoLen + 1);\n        glGetShaderInfoLog(shader, infoLen, nullptr, infoLog);\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"glCompileShader error = %s\", infoLog);\n        free(infoLog);\n        infoLog = nullptr;\n    }\n    glDeleteShader(shader);\n    return PROGRAM_ERROR;\n} 渲染功能实现。 (1) 绘制背景。 // ...\n// 绘制背景颜色 #f4f4f4\nconst GLfloat BACKGROUND_COLOR[] = { 244.0f / 255, 244.0f / 255, 244.0f / 255, 1.0f };\n\n// 绘制图案颜色\nconst GLfloat DRAW_COLOR[] = {126.0f / 255, 143.0f / 255, 251.0f / 255, 1.0f};\n\n// 绘制图案改变后的颜色\nconst GLfloat CHANGE_COLOR[] = {146.0f / 255, 214.0f / 255, 204.0f / 255, 1.0f};\n\n// 绘制背景顶点\nconst GLfloat BACKGROUND_RECTANGLE_VERTICES[] = {\n    -1.0f, 1.0f,\n    1.0f, 1.0f,\n    1.0f, -1.0f,\n    -1.0f, -1.0f\n};\n// ... // 绘制背景颜色\nvoid EGLCore::Background() {\n    GLint position = PrepareDraw();\n    if (position == POSITION_ERROR) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Background get position failed\");\n        return;\n    }\n\n    if (!ExecuteDraw(position, BACKGROUND_COLOR, BACKGROUND_RECTANGLE_VERTICES,\n                     sizeof(BACKGROUND_RECTANGLE_VERTICES))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Background execute draw failed\");\n        return;\n    }\n\n    if (!FinishDraw()) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Background FinishDraw failed\");\n        return;\n    }\n}\n\n// 绘前准备，获取position，创建成功时position值从0开始\nGLint EGLCore::PrepareDraw() {\n    if ((eglDisplay_ == nullptr) || (eglSurface_ == nullptr) || (eglContext_ == nullptr) ||\n        (!eglMakeCurrent(eglDisplay_, eglSurface_, eglSurface_, eglContext_))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"PrepareDraw: param error\");\n        return POSITION_ERROR;\n    }\n\n    glViewport(DEFAULT_X_POSITION, DEFAULT_Y_POSITION, width_, height_);\n    glClearColor(GL_RED_DEFAULT, GL_GREEN_DEFAULT, GL_BLUE_DEFAULT, GL_ALPHA_DEFAULT);\n    glClear(GL_COLOR_BUFFER_BIT);\n    glUseProgram(program_);\n\n    return glGetAttribLocation(program_, POSITION_NAME);\n}\n\n// 依据传入参数在指定区域绘制指定颜色\nbool EGLCore::ExecuteDraw(GLint position, const GLfloat *color, const GLfloat shapeVertices[], unsigned long vertSize) {\n    if ((position > 0) || (color == nullptr) || (vertSize / sizeof(shapeVertices[0]) != SHAPE_VERTICES_SIZE)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"ExecuteDraw: param error\");\n        return false;\n    }\n\n    glVertexAttribPointer(position, POINTER_SIZE, GL_FLOAT, GL_FALSE, 0, shapeVertices);\n    glEnableVertexAttribArray(position);\n    glVertexAttrib4fv(1, color);\n    glDrawArrays(GL_TRIANGLE_FAN, 0, TRIANGLE_FAN_SIZE);\n    glDisableVertexAttribArray(position);\n\n    return true;\n}\n\n// 结束绘制操作\nbool EGLCore::FinishDraw() {\n    // 强制刷新缓冲\n    glFlush();\n    glFinish();\n    return eglSwapBuffers(eglDisplay_, eglSurface_);\n} (2) 绘制图形。 void EGLCore::Draw() {\n    flag_ = false;\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"EGLCore\", \"Draw\");\n    GLint position = PrepareDraw();\n    if (position == POSITION_ERROR) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Draw get position failed\");\n        return;\n    }\n\n    // 绘制背景\n    if (!ExecuteDraw(position, BACKGROUND_COLOR, BACKGROUND_RECTANGLE_VERTICES,\n                     sizeof(BACKGROUND_RECTANGLE_VERTICES))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Draw execute draw background failed\");\n        return;\n    }\n    \n    // 将五角星分为五个四边形，计算其中一个四边形的四个顶点\n    GLfloat rotateX = 0;\n    GLfloat rotateY = FIFTY_PERCENT * height_;\n    GLfloat centerX = 0;\n    GLfloat centerY = -rotateY * (M_PI / 180 * 54) * (M_PI / 180 * 18);\n    GLfloat leftX = -rotateY * (M_PI / 180 * 18);\n    GLfloat leftY = 0;\n    GLfloat rightX = rotateY * (M_PI / 180 * 18);\n    GLfloat rightY = 0;\n\n    // 确定绘制四边形的顶点，使用绘制区域的百分比表示\n    const GLfloat shapeVertices[] = {\n        centerX / width_, centerY / height_,\n        leftX / width_, leftY / height_,\n        rotateX / width_, rotateY / height_,\n        rightX / width_, rightY / height_\n    };\n    \n    if (!ExecuteDrawStar(position, DRAW_COLOR, shapeVertices, sizeof(shapeVertices))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Draw execute draw star failed\");\n        return;\n    }\n    \n    GLfloat rad = M_PI / 180 * 72;\n    for (int i = 0; i < 4; ++i) \n    {\n        // 旋转得其他四个四边形的顶点\n        rotate2d(centerX, centerY, &rotateX, &rotateY,rad);\n        rotate2d(centerX, centerY, &leftX, &leftY,rad);\n        rotate2d(centerX, centerY, &rightX, &rightY,rad);\n        \n        // 确定绘制四边形的顶点，使用绘制区域的百分比表示\n        const GLfloat shapeVertices[] = {\n                centerX / width_, centerY / height_,\n                leftX / width_, leftY / height_,\n                rotateX / width_, rotateY / height_,\n                rightX / width_, rightY / height_\n        };\n        \n        // 绘制图形\n        if (!ExecuteDrawStar(position, DRAW_COLOR, shapeVertices, sizeof(shapeVertices))) {\n            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Draw execute draw star failed\");\n            return;\n        }\n    }\n\n    // 结束绘制\n    if (!FinishDraw()) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Draw FinishDraw failed\");\n        return;\n    }\n\n    flag_ = true;\n} (3) 改变颜色，重新画一个大小相同颜色不同的图形，与原图形替换，达到改变颜色的效果。 void EGLCore::ChangeColor() {\n    if (!flag_) {\n        return;\n    }\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"EGLCore\", \"ChangeColor\");\n    GLint position = PrepareDraw();\n    if (position == POSITION_ERROR) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"ChangeColor get position failed\");\n        return;\n    }\n\n    // 绘制背景\n    if (!ExecuteDraw(position, BACKGROUND_COLOR, BACKGROUND_RECTANGLE_VERTICES,\n                     sizeof(BACKGROUND_RECTANGLE_VERTICES))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"ChangeColor execute draw background failed\");\n        return;\n    }\n\n    // 确定绘制四边形的顶点，使用绘制区域的百分比表示\n    GLfloat rotateX = 0;\n    GLfloat rotateY = FIFTY_PERCENT * height_;\n    GLfloat centerX = 0;\n    GLfloat centerY = -rotateY * (M_PI / 180 * 54) * (M_PI / 180 * 18);\n    GLfloat leftX = -rotateY * (M_PI / 180 * 18);\n    GLfloat leftY = 0;\n    GLfloat rightX = rotateY * (M_PI / 180 * 18);\n    GLfloat rightY = 0;\n\n    // 确定绘制四边形的顶点，使用绘制区域的百分比表示\n    const GLfloat shapeVertices[] = {\n        centerX / width_, centerY / height_,\n        leftX / width_, leftY / height_,\n        rotateX / width_, rotateY / height_,\n        rightX / width_, rightY / height_\n    };\n    \n    // 使用新的颜色绘制\n    if (!ExecuteDrawNewStar(position, CHANGE_COLOR, shapeVertices, sizeof(shapeVertices))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Draw execute draw star failed\");\n        return;\n    }\n\n    GLfloat rad = M_PI / 180 * 72;\n    for (int i = 0; i < 4; ++i) {\n        // 旋转得其他四个四边形的顶点\n        rotate2d(centerX, centerY, &rotateX, &rotateY,rad);\n        rotate2d(centerX, centerY, &leftX, &leftY,rad);\n        rotate2d(centerX, centerY, &rightX, &rightY,rad);\n        \n        // 确定绘制四边形的顶点，使用绘制区域的百分比表示\n        const GLfloat shapeVertices[] = {\n                centerX / width_, centerY / height_,\n                leftX / width_, leftY / height_,\n                rotateX / width_, rotateY / height_,\n                rightX / width_, rightY / height_\n        };\n\n        // 使用新的颜色绘制\n        if (!ExecuteDrawNewStar(position, CHANGE_COLOR, shapeVertices, sizeof(shapeVertices))) {\n            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Draw execute draw star failed\");\n            return;\n        }\n    }\n\n    // 结束绘制\n    if (!FinishDraw()) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"ChangeColor FinishDraw failed\");\n    }\n}\n\nbool EGLCore::ExecuteDrawNewStar(\n   GLint position, const GLfloat* color, const GLfloat shapeVertices[], unsigned long vertSize) {\n   if ((position > 0) || (color == nullptr) || (vertSize / sizeof(shapeVertices[0])) != SHAPE_VERTICES_SIZE) {\n       OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"ExecuteDraw: param error\");\n       return false;\n   }\n\n   // The gl function has no return value.\n   glVertexAttribPointer(position, POINTER_SIZE, GL_FLOAT, GL_FALSE, 0, shapeVertices);\n   glEnableVertexAttribArray(position);\n   glVertexAttrib4fv(1, color);\n   glDrawArrays(GL_TRIANGLE_FAN, 0, TRIANGLE_FAN_SIZE);\n   glDisableVertexAttribArray(position);\n\n   return true;\n} 释放相关资源。 (1) EGLCore类下创建Release()方法，释放初始化环境时申请的资源，包含窗口display、渲染区域surface、环境上下文context等。 void EGLCore::Release() {\n    // 释放surface\n    if ((eglDisplay_ == nullptr) || (eglSurface_ == nullptr) || (!eglDestroySurface(eglDisplay_, eglSurface_))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Release eglDestroySurface failed\");\n    }\n    // 释放context\n    if ((eglDisplay_ == nullptr) || (eglContext_ == nullptr) || (!eglDestroyContext(eglDisplay_, eglContext_))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Release eglDestroyContext failed\");\n    }\n    // 释放display\n    if ((eglDisplay_ == nullptr) || (!eglTerminate(eglDisplay_))) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"EGLCore\", \"Release eglTerminate failed\");\n    }\n} (2) PluginRender类添加Release()方法，释放EGLCore实例及PluginRender实例。 void PluginRender::Release(std::string &id) {\n    PluginRender *render = PluginRender::GetInstance(id);\n    if (render != nullptr) {\n        render->eglCore_->Release();\n        delete render->eglCore_;\n        render->eglCore_ = nullptr;\n        instance_.erase(instance_.find(id));\n    }\n} CMakeLists，使用CMake工具链将C++源代码编译成动态链接库文件。 # 设置CMake最小版本\ncmake_minimum_required(VERSION 3.4.1)\n# 项目名称\nproject(XComponent)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\nadd_definitions(-DOHOS_PLATFORM)\n# 设置头文件搜索目录\ninclude_directories(\n    ${NATIVERENDER_ROOT_PATH}\n    ${NATIVERENDER_ROOT_PATH}/include\n)\n# 添加名为nativerender的动态库，库文件名为libnativerender.so，添加cpp文件\nadd_library(nativerender SHARED\n    render/egl_core.cpp\n    render/plugin_render.cpp\n    manager/plugin_manager.cpp\n    napi_init.cpp\n)\n\nfind_library(\n    EGL-lib\n    EGL\n)\n\nfind_library(\n    GLES-lib\n    GLESv3\n)\n\nfind_library(\n    hilog-lib\n    hilog_ndk.z\n)\n\nfind_library(\n    libace-lib\n    ace_ndk.z\n)\n\nfind_library(\n    libnapi-lib\n    ace_napi.z\n)\n\nfind_library(\n    libuv-lib\n    uv\n)\n# 添加构建需要链接的库\ntarget_link_libraries(nativerender PUBLIC\n    ${EGL-lib} ${GLES-lib} ${hilog-lib} ${libace-lib} ${libnapi-lib} ${libuv-lib}) 
ArkTS XComponent场景
与Native XComponent不同，ArkTS XComponent不再需要libraryname参数。通过在ArkTS侧获取SurfaceId，布局信息、生命周期回调、触摸、鼠标、按键等事件回调等均在ArkTS侧触发，按需传递到Native侧进行处理。主要开发场景如下：
 基于ArkTS侧获取的SurfaceId，在Native侧调用OH_NativeWindow_CreateNativeWindowFromSurfaceId接口创建出NativeWindow实例。 利用NativeWindow和EGL接口开发自定义绘制内容以及申请和提交Buffer到图形队列。 ArkTS侧获取生命周期、事件等信息传递到Native侧处理。 
接口说明
ArkTS侧的XComponentController
Native侧
开发步骤
以下步骤以SURFACE类型为例，描述了如何使用XComponent组件在ArkTS侧传入SurfaceId，在native侧创建NativeWindow实例，然后创建EGL/GLES环境，实现在主页面绘制图形，并可以改变图形的颜色。
 在界面中定义XComponent。 // 函数声明，在cpp/types/libnativerender/Index.d.ts中定义\ntype XComponentContextStatus = {\n    hasDraw: boolean,\n    hasChangeColor: boolean,\n};\nexport const SetSurfaceId: (id: BigInt) => any;\nexport const ChangeSurface: (id: BigInt, w: number, h: number) =>any;\nexport const DrawPattern: (id: BigInt) => any;\nexport const GetXComponentStatus: (id: BigInt) => XComponentContextStatus\nexport const ChangeColor: (id: BigInt) => any;\nexport const DestroySurface: (id: BigInt) => any; import nativeRender from 'libnativerender.so'\n\n// 重写XComponentController，设置生命周期回调\nclass MyXComponentController extends XComponentController {\n    onSurfaceCreated(surfaceId: string): void {\n        console.log(`onSurfaceCreated surfaceId: ${surfaceId}`)\n        nativeRender.SetSurfaceId(BigInt(surfaceId));\n    }\n\n    onSurfaceChanged(surfaceId: string, rect: SurfaceRect): void {\n        console.log(`onSurfaceChanged surfaceId: ${surfaceId}, rect: ${JSON.stringify(rect)}}`)\n        // 在onSurfaceChanged中调用ChangeSurface绘制内容\n        nativeRender.ChangeSurface(BigInt(surfaceId), rect.surfaceWidth, rect.surfaceHeight)\n    }\n\n    onSurfaceDestroyed(surfaceId: string): void {\n        console.log(`onSurfaceDestroyed surfaceId: ${surfaceId}`)\n        nativeRender.DestroySurface(BigInt(surfaceId))\n    }\n}\n\n@Entry\n@Component\nstruct Index {\n    @State currentStatus: string = \"index\";\n    xComponentController: XComponentController = new MyXComponentController();\n\n    build() {\n        Column() {\n            //...\n            //在xxx.ets 中定义 XComponent\n            Column({ space: 10 }) {\n                XComponent({\n                    type: XComponentType.SURFACE,\n                    controller: this.xComponentController\n                })\n            Text(this.currentStatus)\n                .fontSize('24fp')\n                .fontWeight(500)\n            }\n            .onClick(() => {\n                let surfaceId = this.xComponentController.getXComponentSurfaceId()\n                nativeRender.ChangeColor(BigInt(surfaceId))\n                let hasChangeColor: boolean = false;\n                if (nativeRender.GetXComponentStatus(BigInt(surfaceId))) {\n                    hasChangeColor = nativeRender.GetXComponentStatus(BigInt(surfaceId)).hasChangeColor;\n                }\n                if (hasChangeColor) {\n                    this.currentStatus = \"change color\";\n                }\n            })\n\n            //...\n            Row() {\n                Button('Draw Star')\n                    .fontSize('16fp')\n                    .fontWeight(500)\n                    .margin({ bottom: 24 })\n                    .onClick(() => {\n                        let surfaceId = this.xComponentController.getXComponentSurfaceId()\n                        nativeRender.DrawPattern(BigInt(surfaceId))\n                        let hasDraw: boolean = false;\n                        if (nativeRender.GetXComponentStatus(BigInt(surfaceId))) {\n                            hasDraw = nativeRender.GetXComponentStatus(BigInt(surfaceId)).hasDraw;\n                        }\n                        if (hasDraw) {\n                            this.currentStatus = \"draw star\"\n                        }\n                    })\n                    .width('53.6%')\n                    .height(40)\n            }\n            .width('100%')\n            .justifyContent(FlexAlign.Center)\n            .alignItems(VerticalAlign.Bottom)\n            .layoutWeight(1)\n        }\n        .width('100%')\n        .height('100%')\n    }\n} Node-API模块注册，具体使用请参考Native API在应用工程中的使用指导。 #include <hilog/log.h>\n#include \"common/common.h\"\n#include \"manager/plugin_manager.h\"\nnamespace NativeXComponentSample {\n// 在napi_init.cpp文件中，Init方法注册接口函数，从而将封装的C++方法传递出来，供ArkTS侧调用\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports) {\n    // ...\n    // 向ArkTS侧暴露接口SetSurfaceId(),ChangeSurface(),DestroySurface(),\n    // DrawPattern(),ChangeColor(),GetXComponentStatus()\n    napi_property_descriptor desc[] = {\n        {\"SetSurfaceId\", nullptr, PluginManager::SetSurfaceId, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"ChangeSurface\", nullptr, PluginManager::ChangeSurface, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"DestroySurface\", nullptr, PluginManager::DestroySurface, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"DrawPattern\", nullptr, PluginManager::DrawPattern, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"ChangeColor\", nullptr, PluginManager::ChangeColor, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"GetXComponentStatus\", nullptr, PluginManager::GetXComponentStatus, nullptr, nullptr, nullptr, napi_default,\n         nullptr}};\n    if (napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"Init\", \"napi_define_properties failed\");\n        return nullptr;\n    }\n    return exports;\n}\nEXTERN_C_END\n// 编写接口的描述信息，根据实际需要可以修改对应参数\nstatic napi_module nativerenderModule = {.nm_version = 1,\n                                         .nm_flags = 0,\n                                         .nm_filename = nullptr,\n                                         // 入口函数\n                                         .nm_register_func = Init,\n                                         // 模块名称\n                                         .nm_modname = \"nativerender\",\n                                         .nm_priv = ((void *)0),\n                                         .reserved = {0}};\n} // namespace NativeXComponentSample\n// __attribute__((constructor))修饰的方法由系统自动调用，使用Node-API接口napi_module_register()传入模块描述信息进行模块注册\nextern \"C\" __attribute__((constructor)) void RegisterModule(void) {\n    napi_module_register(&NativeXComponentSample::nativerenderModule);\n} 上述注册的六个函数在native侧具体实现。 // PluginManager类定义\nclass PluginManager {\npublic:\n    ~PluginManager();\n    static PluginRender *GetPluginRender(int64_t &id);\n    static napi_value ChangeColor(napi_env env, napi_callback_info info);\n    static napi_value DrawPattern(napi_env env, napi_callback_info info);\n    static napi_value SetSurfaceId(napi_env env, napi_callback_info info);\n    static napi_value ChangeSurface(napi_env env, napi_callback_info info);\n    static napi_value DestroySurface(napi_env env, napi_callback_info info);\n    static napi_value GetXComponentStatus(napi_env env, napi_callback_info info);\n\npublic:\n    static std::unordered_map<int64_t, PluginRender *> pluginRenderMap_;\n    static std::unordered_map<int64_t, OHNativeWindow *> windowMap_;\n};\n\n// 解析从ArkTS侧传入的surfaceId，此处surfaceId是一个64位int值\nint64_t ParseId(napi_env env, napi_callback_info info) {\n    if ((env == nullptr) || (info == nullptr)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ParseId\", \"env or info is null\");\n        return -1;\n    }\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    if (napi_ok != napi_get_cb_info(env, info, &argc, args, nullptr, nullptr)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ParseId\", \"GetContext napi_get_cb_info failed\");\n        return -1;\n    }\n    int64_t value = 0;\n    bool lossless = true;\n    if (napi_ok != napi_get_value_bigint_int64(env, args[0], &value, &lossless)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ParseId\", \"Get value failed\");\n        return -1;\n    }\n    return value;\n}\n\n// 设置SurfaceId，基于SurfaceId完成对NativeWindow的初始化\nnapi_value PluginManager::SetSurfaceId(napi_env env, napi_callback_info info) {\n    int64_t surfaceId = ParseId(env, info);\n    OHNativeWindow *nativeWindow;\n    PluginRender *pluginRender;\n    if (windowMap_.find(surfaceId) == windowMap_.end()) {\n        OH_NativeWindow_CreateNativeWindowFromSurfaceId(surfaceId, &nativeWindow);\n        windowMap_[surfaceId] = nativeWindow;\n    }\n    if (pluginRenderMap_.find(surfaceId) == pluginRenderMap_.end()) {\n        pluginRender = new PluginRender(surfaceId);\n        pluginRenderMap_[surfaceId] = pluginRender;\n    }\n    pluginRender->InitNativeWindow(nativeWindow);\n    return nullptr;\n}\n\nvoid PluginRender::InitNativeWindow(OHNativeWindow *window) {\n    eglCore_->EglContextInit(window); // 参考Native XComponent场景 EglContextInit的实现\n}\n\n// 根据传入的surfaceId、width、height实现surface大小的变动\nnapi_value PluginManager::ChangeSurface(napi_env env, napi_callback_info info) {\n    if ((env == nullptr) || (info == nullptr)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"ChangeSurface: OnLoad env or info is null\");\n        return nullptr;\n    }\n    int64_t surfaceId = 0;\n    size_t argc = 3;\n    napi_value args[3] = {nullptr};\n\n    if (napi_ok != napi_get_cb_info(env, info, &argc, args, nullptr, nullptr)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"ChangeSurface: GetContext napi_get_cb_info failed\");\n        return nullptr;\n    }\n    bool lossless = true;\n    int index = 0;\n    if (napi_ok != napi_get_value_bigint_int64(env, args[index++], &surfaceId, &lossless)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"ChangeSurface: Get value failed\");\n        return nullptr;\n    }\n    double width;\n    if (napi_ok != napi_get_value_double(env, args[index++], &width)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"ChangeSurface: Get width failed\");\n        return nullptr;\n    }\n    double height;\n    if (napi_ok != napi_get_value_double(env, args[index++], &height)) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"ChangeSurface: Get height failed\");\n        return nullptr;\n    }\n    auto pluginRender = GetPluginRender(surfaceId);\n    if (pluginRender == nullptr) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"ChangeSurface: Get pluginRender failed\");\n        return nullptr;\n    }\n    pluginRender->UpdateNativeWindowSize(width, height);\n    return nullptr;\n}\n\nvoid PluginRender::UpdateNativeWindowSize(int width, int height) {\n    eglCore_->UpdateSize(width, height); // 参考Native XComponent场景 UpdateSize的实现\n    if (!hasChangeColor_ && !hasDraw_) {\n        eglCore_->Background(); // 参考Native XComponent场景 Background的实现\n    }\n}\n\n// 销毁surface\nnapi_value PluginManager::DestroySurface(napi_env env, napi_callback_info info) {\n    int64_t surfaceId = ParseId(env, info);\n    auto pluginRenderMapIter = pluginRenderMap_.find(surfaceId);\n    if (pluginRenderMapIter != pluginRenderMap_.end()) {\n        delete pluginRenderMapIter->second;\n        pluginRenderMap_.erase(pluginRenderMapIter);\n    }\n    auto windowMapIter = windowMap_.find(surfaceId);\n    if (windowMapIter != windowMap_.end()) {\n        OH_NativeWindow_DestroyNativeWindow(windowMapIter->second);\n        windowMap_.erase(windowMapIter);\n    }\n    return nullptr;\n}\n\n// 实现EGL绘画逻辑\nnapi_value PluginManager::DrawPattern(napi_env env, napi_callback_info info) {\n    int64_t surfaceId = ParseId(env, info);\n    auto pluginRender = GetPluginRender(surfaceId);\n    if (pluginRender == nullptr) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"DrawPattern: Get pluginRender failed\");\n        return nullptr;\n    }\n    pluginRender->DrawPattern();\n    return nullptr;\n}\n\nPluginRender *PluginManager::GetPluginRender(int64_t &id) {\n    if (pluginRenderMap_.find(id) != pluginRenderMap_.end()) {\n        return pluginRenderMap_[id];\n    }\n    return nullptr;\n}\n\nvoid PluginRender::DrawPattern() {\n    eglCore_->Draw(hasDraw_); // 参考Native XComponent场景 Draw实现\n}\n\n// 实现改变绘制图形颜色的功能\nnapi_value PluginManager::ChangeColor(napi_env env, napi_callback_info info) {\n    int64_t surfaceId = ParseId(env, info);\n    auto pluginRender = GetPluginRender(surfaceId);\n    if (pluginRender == nullptr) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\", \"ChangeColor: Get pluginRender failed\");\n        return nullptr;\n    }\n    pluginRender->ChangeColor(); // 参考Native XComponent场景 ChangeColor实现\n    return nullptr;\n}\n\nvoid PluginRender::ChangeColor() { eglCore_->ChangeColor(hasChangeColor_); }\n\n// 获得xcomponent状态，并返回至ArkTS侧\nnapi_value PluginManager::GetXComponentStatus(napi_env env, napi_callback_info info) {\n    int64_t surfaceId = ParseId(env, info);\n    auto pluginRender = GetPluginRender(surfaceId);\n    if (pluginRender == nullptr) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"GetXComponentStatus: Get pluginRender failed\");\n        return nullptr;\n    }\n    napi_value hasDraw;\n    napi_value hasChangeColor;\n    napi_status ret = napi_create_int32(env, pluginRender->HasDraw(), &(hasDraw));\n    if (ret != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"GetXComponentStatus: napi_create_int32 hasDraw_ error\");\n        return nullptr;\n    }\n    ret = napi_create_int32(env, pluginRender->HasChangedColor(), &(hasChangeColor));\n    if (ret != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"GetXComponentStatus: napi_create_int32 hasChangeColor_ error\");\n        return nullptr;\n    }\n    napi_value obj;\n    ret = napi_create_object(env, &obj);\n    if (ret != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"GetXComponentStatus: napi_create_object error\");\n        return nullptr;\n    }\n    ret = napi_set_named_property(env, obj, \"hasDraw\", hasDraw);\n    if (ret != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"GetXComponentStatus: napi_set_named_property hasDraw error\");\n        return nullptr;\n    }\n    ret = napi_set_named_property(env, obj, \"hasChangeColor\", hasChangeColor);\n    if (ret != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"PluginManager\",\n                     \"GetXComponentStatus: napi_set_named_property hasChangeColor error\");\n        return nullptr;\n    }\n    return obj;\n}\n\nint32_t PluginRender::HasDraw() { return hasDraw_; }\n\nint32_t PluginRender::HasChangedColor() { return hasChangeColor_; } 配置具体的CMakeLists，使用CMake工具链将C++源代码编译成动态链接库文件。 # 设置CMake最小版本.\ncmake_minimum_required(VERSION 3.4.1)\n# 项目名称\nproject(XComponent)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\nadd_definitions(-DOHOS_PLATFORM)\n# 设置头文件搜索目录\ninclude_directories(\n    ${NATIVERENDER_ROOT_PATH}\n    ${NATIVERENDER_ROOT_PATH}/include\n)\n# 添加名为nativerender的动态库，库文件名为libnativerender.so，添加cpp文件\nadd_library(nativerender SHARED\n    render/egl_core.cpp\n    render/plugin_render.cpp\n    manager/plugin_manager.cpp\n    napi_init.cpp\n)\n\nfind_library(\n    # Sets the name of the path variable.\n    EGL-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    EGL\n)\n\nfind_library(\n    # Sets the name of the path variable.\n    GLES-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    GLESv3\n)\n\nfind_library(\n    # Sets the name of the path variable.\n    hilog-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    hilog_ndk.z\n)\n\nfind_library(\n    # Sets the name of the path variable.\n    libace-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    ace_ndk.z\n)\n\nfind_library(\n    # Sets the name of the path variable.\n    libnapi-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    ace_napi.z\n)\n\nfind_library(\n    # Sets the name of the path variable.\n    libuv-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    uv\n)\n# 添加构建需要链接的库\ntarget_link_libraries(nativerender PUBLIC\n    ${EGL-lib} ${GLES-lib} ${hilog-lib} ${libace-lib} ${libnapi-lib} ${libuv-lib} libnative_window.so) 
自绘制原理说明
XComponent持有一个surface，开发者能通过调用NativeWindow等接口，申请并提交Buffer至图形队列，以此方式将自绘制内容传送至该surface。XComponent负责将此surface整合进UI界面，其中展示的内容正是开发者传送的自绘制内容。surface的默认位置与大小与XComponent组件一致，开发者可利用setXComponentSurfaceRect接口自定义调整surface的位置和大小。
当开发者传输的绘制内容包含透明元素时，surface区域的显示效果会与下方内容进行合成展示。例如，若传输的内容完全透明，且XComponent的背景色被设置为黑色，同时Surface保持默认的大小与位置，则最终显示的将是一片黑色区域。
生命周期说明
开发者在ArkTS侧使用如下代码即可用XComponent组件进行利用EGL/OpenGLES渲染的开发。
@Builder\nfunction myComponent() {\n  XComponent({ id: 'xcomponentId1', type: XComponentType.SURFACE, libraryname: 'nativerender' })\n    .onLoad((context) => {})\n    .onDestroy(() => {})\n}
[h2]onLoad事件
触发时刻：XComponent准备好surface后触发。
参数context：其上面挂载了暴露在模块上的Native方法，使用方法类似于利用 import context from \"libnativerender.so\" 直接加载模块后获得的context实例。
时序：
​ Native XComponent场景：
​ onLoad事件的触发和surface相关，其和Native侧的OnSurfaceCreated的时序如下图：
​ ArkTS XComponent场景：
​ onLoad事件的触发和surface相关，其和ArkTS侧的OnSurfaceCreated的时序如下图：
[h2]onDestroy事件
触发时刻：XComponent组件被销毁时触发，与一般ArkUI的组件销毁时机一致。
时序：
​ Native XComponent场景：
​ onDestroy事件的触发和surface相关，其和Native侧的OnSurfaceDestroyed的时序如下图：
​ ArkTS XComponent场景：
​ onDestroy事件的触发和surface相关，其和ArkTS侧的OnSurfaceDestroyed的时序如下图：
示例代码
 Native XComponent 

选择用户文件
用户需要分享文件、保存图片、视频等用户文件时，开发者可以通过系统预置的文件选择器（FilePicker），实现该能力。通过Picker访问相关文件，将拉起对应的应用，引导用户完成界面操作，接口本身无需申请权限。picker获取的uri只具有临时权限，获取持久化权限需要通过FilePicker设置永久授权方式获取。
根据用户文件的常见类型，选择器（FilePicker）分别提供以下选项：
 PhotoViewPicker：适用于图片或视频类型文件的选择与保存（该接口在后续版本不再演进）。请使用PhotoAccessHelper的PhotoViewPicker来选择图片文件。请使用安全控件创建媒体资源。 DocumentViewPicker：适用于文件类型文件的选择与保存。DocumentViewPicker对接的选择资源来自于FilePicker, 负责文件类型的资源管理，文件类型不区分后缀，比如浏览器下载的图片、文档等，都属于文件类型。 AudioViewPicker：适用于音频类型文件的选择与保存。AudioViewPicker目前对接的选择资源来自于FilePicker。 
选择图片或视频类文件
PhotoViewPicker在后续版本不再演进，请PhotoAccessHelper的PhotoViewPicker来选择图片文件。
选择文档类文件
 导入选择器模块和基础文件API模块。 import  { picker } from '@kit.CoreFileKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit'; 创建文件类型、文件选择选项实例。 const documentSelectOptions = new picker.DocumentSelectOptions();\n// 选择文档的最大数目（可选）。\ndocumentSelectOptions.maxSelectNumber = 5;\n// 指定选择的文件或者目录路径（可选）。\ndocumentSelectOptions.defaultFilePathUri = \"file://docs/storage/Users/currentUser/test\";\n// 选择文件的后缀类型['后缀类型描述|后缀类型']（可选） 若选择项存在多个后缀名，则每一个后缀名之间用英文逗号进行分隔（可选），后缀类型名不能超过100,选择所有文件：'所有文件(*.*)|.*'。\n documentSelectOptions.fileSuffixFilters = ['图片(.png, .jpg)|.png,.jpg', '文档|.txt', '视频|.mp4', '.pdf']; \n//选择是否对指定文件或目录授权，true为授权，当为true时，defaultFilePathUri为必选参数，拉起文管授权界面；false为非授权，拉起常规文管界面（可选），仅支持2in1设备。\ndocumentSelectOptions.authMode = true; 创建文件选择器DocumentViewPicker实例。调用select()接口拉起FilePicker应用界面进行文件选择。 let uris: Array<string> = [];\nlet context = getContext(this) as common.Context; // 请确保 getContext(this) 返回结果为 UIAbilityContext\n// 创建文件选择器实例\nconst documentViewPicker = new picker.DocumentViewPicker(context);\ndocumentViewPicker.select(documentSelectOptions).then((documentSelectResult: Array<string>) => {\n  //文件选择成功后，返回被选中文档的uri结果集。\n  uris = documentSelectResult;\n  console.info('documentViewPicker.select to file succeed and uris are:' + uris);\n}).catch((err: BusinessError) => {\n  console.error(`Invoke documentViewPicker.select failed, code is ${err.code}, message is ${err.message}`);\n}) 
1、使用picker获取的select()返回的uri权限是临时只读权限,待退出应用后台后，获取的临时权限就会失效。
2、如果想要获取持久化权限(仅在2in1设备上生效)，请参考文件持久化授权访问。
3、开发者可以根据结果集中uri做进一步的处理。建议定义一个全局变量保存uri。
4、如有获取元数据需求，可以通过基础文件API和文件URI根据uri获取部分文件属性信息，比如文件大小、访问时间、修改时间、文件名、文件路径等。
 待界面从FilePicker返回后，使用基础文件API的fs.openSync接口通过uri打开这个文件得到文件描述符(fd)。 let uri: string = '';\n//这里需要注意接口权限参数是fs.OpenMode.READ_ONLY。\nlet file = fs.openSync(uri, fs.OpenMode.READ_ONLY);\nconsole.info('file fd: ' + file.fd); 通过fd使用fs.readSync接口读取这个文件内的数据。 let buffer = new ArrayBuffer(4096);\nlet readLen = fs.readSync(file.fd, buffer);\nconsole.info('readSync data to file succeed and buffer size is:' + readLen);\n//读取完成后关闭fd。\nfs.closeSync(file); 
选择音频类文件
 导入选择器模块和基础文件API模块。 import  { picker } from '@kit.CoreFileKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { common } from '@kit.AbilityKit'; 创建音频类型文件选择选项实例。     目前AudioSelectOptions不支持参数配置，默认可以选择所有类型的用户文件。   const audioSelectOptions = new picker.AudioSelectOptions(); 创建音频选择器AudioViewPicker实例。调用select()接口拉起FilePicker应用界面进行文件选择。 let uris: string = '';\n// 请确保 getContext(this) 返回结果为 UIAbilityContext\nlet context = getContext(this) as common.Context; \nconst audioViewPicker = new picker.AudioViewPicker(context);\naudioViewPicker.select(audioSelectOptions).then((audioSelectResult: Array<string>) => {\n  //文件选择成功后，返回被选中音频的uri结果集。\n  uris = audioSelectResult[0];\n  console.info('audioViewPicker.select to file succeed and uri is:' + uris);\n}).catch((err: BusinessError) => {\n  console.error(`Invoke audioViewPicker.select failed, code is ${err.code}, message is ${err.message}`);\n}) 
1、使用picker获取的select()返回的uri权限是临时只读权限,待退出应用后台后，获取的临时权限就会失效。
2、如果想要获取持久化权限(仅在2in1设备上生效)，请参考文件持久化授权访问。
3、开发者可以根据结果集中的uri做读取文件数据操作。建议定义一个全局变量保存uri。例如通过基础文件API根据uri拿到音频资源的文件描述符(fd)，再配合媒体服务实现音频播放的开发，具体请参考音频播放开发指导。
 待界面从FilePicker返回后，可以使用基础文件API的fs.openSync接口通过uri打开这个文件得到文件描述符(fd)。 let uri: string = '';\n//这里需要注意接口权限参数是fs.OpenMode.READ_ONLY。\nlet file = fs.openSync(uri, fs.OpenMode.READ_ONLY);\nconsole.info('file fd: ' + file.fd); 通过fd可以使用基础文件API的fs.readSync接口读取这个文件内的数据。 let buffer = new ArrayBuffer(4096);\nlet readLen = fs.readSync(file.fd, buffer);\nconsole.info('readSync data to file succeed and buffer size is:' + readLen);\n//读取完成后关闭fd。\nfs.closeSync(file); 
示例代码
 选择并查看文档与媒体文件 

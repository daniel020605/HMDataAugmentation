视频编码
调用者可以调用本模块的Native API接口，完成视频编码，即将未压缩的视频数据压缩成视频码流。
具体实现可参考示例工程。
当前支持的编码能力请参考AVCodec支持的格式。
如果需要对HDRVivid视频进行编码，需要配置MimeType为H265 (OH_AVCODEC_MIMETYPE_VIDEO_HEVC)，本功能从API version 11开始支持。
视频编码支持以下能力：
限制约束
 Buffer模式不支持10bit的图像数据。 由于硬件编码器资源有限，每个编码器在使用完毕后都必须调用OH_VideoEncoder_Destroy接口来销毁实例并释放资源。 Flush，Reset，Stop，Destroy在非回调线程中执行时，会等待所有回调执行完成后，将执行结果返回给用户。 一旦调用Flush，Reset，Stop接口，会触发系统回收OH_AVBuffer，调用者不应对之前回调函数获取到的OH_AVBuffer继续进行操作。 Buffer模式和Surface模式使用方式一致的接口，所以只提供了Surface模式的示例。 在Buffer模式下，调用者通过输入回调函数OH_AVCodecOnNeedInputBuffer获取到OH_AVBuffer的指针对象后，必须通过调用OH_VideoEncoder_PushInputBuffer接口 来通知系统该对象已被使用完毕。这样系统才能够将该对象里面的数据进行编码。如果调用者在调用OH_AVBuffer_GetNativeBuffer接口时获取到OH_NativeBuffer指针对象，并且该对象的生命周期超过了当前的OH_AVBuffer指针对象，那么需要进行一次数据的拷贝操作。在这种情况下，调用者需要自行管理新生成的OH_NativeBuffer对象的生命周期，确保其正确使用和释放。 
surface输入与buffer输入
 两者的数据来源不同。 两者的适用场景不同：  surface输入是指用OHNativeWindow来传递输入数据，可以与其他模块对接，例如相机模块。 buffer输入是指有一块预先分配好的内存区域，调用者需要将原始数据拷贝进这块内存区域中。更适用于从文件中读取视频数据等场景。  在接口调用的过程中，两种方式的接口调用方式基本一致，但存在以下差异点：  Buffer模式下，调用者通过OH_VideoEncoder_PushInputBuffer接口输入数据；Surface模式下，调用者应在编码器就绪前调用OH_VideoEncoder_GetSurface接口，获取OHNativeWindow用于传递视频数据。 Buffer模式下，调用者通过OH_AVBuffer中的attr传入结束flag，编码器读取到尾帧后，停止编码；Surface模式下，需要调用OH_VideoEncoder_NotifyEndOfStream接口通知编码器输入流结束。  
两种模式的开发步骤详细说明请参考：Surface模式和Buffer模式。
状态机调用关系
如下为状态机调用关系图：
 有两种方式可以使编码器进入Initialized状态：  初始创建编码器实例时，编码器处于Initialized状态。 任何状态下，调用OH_VideoEncoder_Reset接口，编码器将会移回Initialized状态。  Initialized状态下，调用OH_VideoEncoder_Configure接口配置编码器，配置成功后编码器进入Configured状态。 Configured状态下，调用OH_VideoEncoder_Prepare()进入Prepared状态。 Prepared状态下，调用OH_VideoEncoder_Start接口使编码器进入Executing状态：  处于Executing状态时，调用OH_VideoEncoder_Stop接口可以使编码器返回到Prepared状态。  在极少数情况下，编码器可能会遇到错误并进入Error状态。编码器的错误传递，可以通过队列操作返回无效值或者抛出异常：  Error状态下，可以调用OH_VideoEncoder_Reset接口将编码器移到Initialized状态；或者调用OH_VideoEncoder_Destroy接口移动到最后的Released状态。  Executing 状态具有三个子状态：Flushed、Running和End-of-Stream：  在调用了OH_VideoEncoder_Start接口之后，编码器立即进入Running子状态。 对于处于Executing状态的编码器，可以调用OH_VideoEncoder_Flush接口返回到Flushed子状态。 当待处理数据全部传递给编码器后，可以在input buffers队列中为最后一个入队的input buffer中添加AVCODEC_BUFFER_FLAGS_EOS标记，遇到这个标记时，编码器会转换为End-of-Stream子状态。在此状态下，编码器不再接受新的输入，但是仍然会继续生成输出，直到输出到达尾帧。  使用完编码器后，必须调用OH_VideoEncoder_Destroy接口销毁编码器实例。使编码器进入Released状态。 
开发指导
详细的API说明请参考API文档。
如下为视频编码调用关系图：
 虚线表示可选。 实线表示必选。 
[h2]在 CMake 脚本中链接动态库
target_link_libraries(sample PUBLIC libnative_media_codecbase.so)\ntarget_link_libraries(sample PUBLIC libnative_media_core.so)\ntarget_link_libraries(sample PUBLIC libnative_media_venc.so)
上述'sample'字样仅为示例，此处由调用者根据实际工程目录自定义。
[h2]定义基础结构
本部分示例代码按照C++17标准编写，仅作参考。开发者可以参考此部分，定义自己的buffer对象。
 添加头文件。 #include <condition_variable>\n#include <memory>\n#include <mutex>\n#include <queue>\n#include <shared_mutex> 编码器回调buffer的信息。 struct CodecBufferInfo {\n    CodecBufferInfo(uint32_t index, OH_AVBuffer *buffer): index(index), buffer(buffer), isValid(true) {}\n    CodecBufferInfo(uint32_t index, OH_AVFormat *parameter): index(index), parameter(parameter), isValid(true) {}\n    // 回调buffer\n    OH_AVBuffer *buffer = nullptr;\n    // Surface模式下，输入回调的随帧参数，需要注册随帧通路后使用\n    OH_AVFormat *parameter = nullptr;\n    // 回调buffer对应的index\n    uint32_t index = 0;\n    // 判断当前buffer信息是否有效\n    bool isValid = true;\n}; 编码输入输出队列。 class CodecBufferQueue {\npublic:\n    // 将回调buffer的信息传入队列\n    void Enqueue(const std::shared_ptr<CodecBufferInfo> bufferInfo)\n    {\n        std::unique_lock<std::mutex> lock(mutex_);\n        bufferQueue_.push(bufferInfo);\n        cond_.notify_all();\n    }\n\n    // 获取回调buffer的信息\n    std::shared_ptr<CodecBufferInfo> Dequeue(int32_t timeoutMs = 1000)\n    {\n        std::unique_lock<std::mutex> lock(mutex_);\n        (void)cond_.wait_for(lock, std::chrono::milliseconds(timeoutMs), [this]() { return !bufferQueue_.empty(); });\n        if (bufferQueue_.empty()) {\n            return nullptr;\n        }\n        std::shared_ptr<CodecBufferInfo> bufferInfo = bufferQueue_.front();\n        bufferQueue_.pop();\n        return bufferInfo;\n    }\n\n    // 清空队列，之前的回调buffer设置为不可用\n    void Flush()\n    {\n        std::unique_lock<std::mutex> lock(mutex_);\n        while (!bufferQueue_.empty()) {\n            std::shared_ptr<CodecBufferInfo> bufferInfo = bufferQueue_.front();\n            // Flush、Stop、Reset、Destroy操作之后，之前回调的buffer信息设置为无效\n            bufferInfo->isValid = false;\n            bufferQueue_.pop();\n        }\n    }\n\nprivate:\n    std::mutex mutex_;\n    std::condition_variable cond_;\n    std::queue<std::shared_ptr<CodecBufferInfo>> bufferQueue_;\n}; 全局变量 仅做参考，可以根据实际情况将其封装到对象中。 // 视频帧宽度\nint32_t width = 320;\n// 视频帧高度\nint32_t height = 240;\n// 视频像素格式\n OH_AVPixelFormat pixelFormat = AV_PIXEL_FORMAT_NV12;\n// 视频宽跨距\nint32_t widthStride = 0;\n// 视频高跨距\nint32_t heightStride = 0;\n// 编码器实例指针\nOH_AVCodec *videoEnc = nullptr;\n// 编码器同步锁\nstd::shared_mutex codecMutex;\n// 编码器输入队列\nCodecBufferQueue inQueue;\n// 编码器输出队列\nCodecBufferQueue outQueue; 
[h2]Surface模式
参考以下示例代码，调用者可以完成Surface模式下视频编码的全流程。此处以surface数据输入，编码成H.264格式为例。
本模块目前仅支持异步模式的数据轮转。
 添加头文件。 #include <multimedia/player_framework/native_avcodec_videoencoder.h>\n#include <multimedia/player_framework/native_avcapability.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <fstream> 创建编码器实例对象。 调用者可以通过名称或媒体类型创建编码器。示例中的变量说明如下：  videoEnc：视频编码器实例的指针； capability：编解码器能力查询实例的指针； OH_AVCODEC_MIMETYPE_VIDEO_AVC：AVC格式视频编解码器。  创建方式示例如下： // 通过codec name创建编码器，应用有特殊需求，比如选择支持某种分辨率规格的编码器，可先查询capability，再根据codec name创建编码器。\nOH_AVCapability *capability = OH_AVCodec_GetCapability(OH_AVCODEC_MIMETYPE_VIDEO_AVC, true);\n// 创建硬件编码器实例\nOH_AVCapability *capability= OH_AVCodec_GetCapabilityByCategory(OH_AVCODEC_MIMETYPE_VIDEO_AVC, true, HARDWARE);\nconst char *codecName = OH_AVCapability_GetName(capability);\nOH_AVCodec *videoEnc = OH_VideoEncoder_CreateByName(codecName); // 通过MIME TYPE创建编码器，只能创建系统推荐的特定编解码器\n// 只能创建硬件编码器\nOH_AVCodec *videoEnc = OH_VideoEncoder_CreateByMime(OH_AVCODEC_MIMETYPE_VIDEO_AVC); 调用OH_VideoEncoder_RegisterCallback()设置回调函数。 注册回调函数指针集合OH_AVCodecCallback，包括：  OH_AVCodecOnError 编码器运行错误，返回的错误码详情请参见OH_AVCodecOnError； OH_AVCodecOnStreamChanged 码流信息变化，如格式变化等； OH_AVCodecOnNeedInputBuffer 输入回调无作用，调用者通过获取的surface输入数据； OH_AVCodecOnNewOutputBuffer 运行过程中产生了新的输出数据，即编码完成。  回调函数的具体实现可参考示例工程。 示例如下所示： int32_t qpAverage = 20;\ndouble mseValue = 0.0;\n// 设置OH_AVCodecOnError 回调函数，编码异常\nstatic void OnError(OH_AVCodec *codec, int32_t errorCode, void *userData)\n{\n    // 回调的错误码由用户判断处理\n    (void)codec;\n    (void)errorCode;\n    (void)userData;\n} // 设置OH_AVCodecOnStreamChanged 回调函数，编码数据流变化\nstatic void OnStreamChanged(OH_AVCodec *codec, OH_AVFormat *format, void *userData)\n{\n    // Surface模式下，该回调函数在surface分辨率变化时触发\n    (void)codec;\n    (void)userData;\n    OH_AVFormat_GetIntValue(format, OH_MD_KEY_VIDEO_WIDTH, &width);\n    OH_AVFormat_GetIntValue(format, OH_MD_KEY_VIDEO_HEIGHT, &height);\n} // 设置 OH_AVCodecOnNeedInputBuffer 回调函数，编码输入帧送入数据队列\nstatic void OnNeedInputBuffer(OH_AVCodec *codec, uint32_t index, OH_AVBuffer *buffer, void *userData)\n{\n    // Surface模式下，该回调函数无作用，调用者通过获取的surface输入数据\n    (void)userData;\n    (void)index;\n    (void)buffer;\n} // 设置 OH_AVCodecOnNewOutputBuffer 回调函数，编码完成帧送入输出队列\nstatic void OnNewOutputBuffer(OH_AVCodec *codec, uint32_t index, OH_AVBuffer *buffer, void *userData)\n{\n    // 获取视频帧的平均量化参数，平方误差\n    OH_AVFormat *format = OH_AVBuffer_GetParameter(buffer);\n    OH_AVFormat_GetIntValue(format, OH_MD_KEY_VIDEO_ENCODER_QP_AVERAGE, &qpAverage);\n    OH_AVFormat_GetDoubleValue(format, OH_MD_KEY_VIDEO_ENCODER_MSE, &mseValue);\n    OH_AVFormat_Destroy(format);\n    // 完成帧的数据buffer和对应的index送入outQueue队列\n    (void)codec;\n    (void)userData;\n    outQueue.Enqueue(std::make_shared<CodecBufferInfo>(index, buffer));\n} // 配置异步回调，调用 OH_VideoEncoder_RegisterCallback()接口\nOH_AVCodecCallback cb = {&OnError, &OnStreamChanged, &OnNeedInputBuffer, &OnNewOutputBuffer};\nint32_t ret = OH_VideoEncoder_RegisterCallback(videoEnc, cb, NULL); // NULL:用户特定数据userData为空 \nif (ret != AV_ERR_OK) {\n    // 异常处理\n}     在回调函数中，对数据队列进行操作时，需要注意多线程同步的问题。   （可选）调用OH_VideoEncoder_RegisterParameterCallback()在Configur接口之前注册随帧通路回调。 详情请参考时域可分层视频编码。  // 5.1 编码输入参数回调OH_VideoEncoder_OnNeedInputParameter实现\n static void OnNeedInputParameter(OH_AVCodec *codec, uint32_t index, OH_AVFormat *parameter, void *userData)\n {\n     // 输入帧parameter对应的index，送入InParameterIndexQueue队列\n     // 输入帧的数据parameter送入InParameterQueue队列\n     // 数据处理\n     // 随帧参数写入\n     // 配置OH_MD_KEY_VIDEO_ENCODER_QP_MAX 的值应大于等于OH_MD_KEY_VIDEO_ENCODER_QP_MIN\n     OH_AVFormat_SetIntValue(parameter, OH_MD_KEY_VIDEO_ENCODER_QP_MAX, 30);\n     OH_AVFormat_SetIntValue(parameter, OH_MD_KEY_VIDEO_ENCODER_QP_MIN, 20);\n }\n\n // 5.2 注册随帧参数回调\n OH_VideoEncoder_OnNeedInputParameter inParaCb = OnNeedInputParameter;\n OH_VideoEncoder_RegisterParameterCallback(videoEnc, inParaCb, NULL); // NULL:用户特定数据userData为空 调用OH_VideoEncoder_Configure()配置编码器。 详细可配置选项的说明请参考视频专有键值对。 参数校验规则请参考OH_VideoEncoder_Configure()参考文档。 参数取值范围可以通过能力查询接口获取，具体示例请参考获取支持的编解码能力文档。 目前支持的所有格式都必须配置以下选项：视频帧宽度、视频帧高度、视频像素格式。示例中的变量如下：  DEFAULT_WIDTH：320像素宽度； DEFAULT_HEIGHT：240像素高度； DEFAULT_PIXELFORMAT： 像素格式，因为示例使用YUV的文件保存的像素格式是NV12，所以设置为 AV_PIXEL_FORMAT_NV12。  // 配置视频帧速率\ndouble frameRate = 30.0;\n// 配置视频YUV值范围标志\nbool rangeFlag = false;\n// 配置视频原色\nint32_t primary = static_cast<int32_t>(OH_ColorPrimary::COLOR_PRIMARY_BT709);\n// 配置传输特性\nint32_t transfer = static_cast<int32_t>(OH_TransferCharacteristic::TRANSFER_CHARACTERISTIC_BT709);\n// 配置最大矩阵系数\nint32_t matrix = static_cast<int32_t>(OH_MatrixCoefficient::MATRIX_COEFFICIENT_IDENTITY);\n// 配置编码Profile\nint32_t profile = static_cast<int32_t>(OH_AVCProfile::AVC_PROFILE_HIGH);\n// 配置编码比特率模式\nint32_t rateMode = static_cast<int32_t>(OH_VideoEncodeBitrateMode::VBR);\n// 配置关键帧的间隔，单位为毫秒\nint32_t iFrameInterval = 1000;\n// 配置比特率，单位为bps\nint64_t bitRate = 5000000;\n// 配置编码质量\nint64_t quality = 90;\n\nOH_AVFormat *format = OH_AVFormat_Create();\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_WIDTH, width); // 必须配置\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_HEIGHT, height); // 必须配置\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_PIXEL_FORMAT, pixelFormat); // 必须配置\n\nOH_AVFormat_SetDoubleValue(format, OH_MD_KEY_FRAME_RATE, frameRate);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_RANGE_FLAG, rangeFlag);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_COLOR_PRIMARIES, primary);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_TRANSFER_CHARACTERISTICS, transfer);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_MATRIX_COEFFICIENTS, matrix);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_I_FRAME_INTERVAL, iFrameInterval);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_PROFILE, profile);\n//只有当OH_MD_KEY_BITRATE = CQ时，才需要配置OH_MD_KEY_QUALITY\nif (rateMode == static_cast<int32_t>(OH_VideoEncodeBitrateMode::CQ)) {\n    OH_AVFormat_SetIntValue(format, OH_MD_KEY_QUALITY, quality);\n} else if (rateMode == static_cast<int32_t>(OH_VideoEncodeBitrateMode::CBR) ||\n           rateMode == static_cast<int32_t>(OH_VideoEncodeBitrateMode::VBR)){\n    OH_AVFormat_SetLongValue(format, OH_MD_KEY_BITRATE, bitRate);\n}\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_VIDEO_ENCODE_BITRATE_MODE, rateMode);\nint32_t ret = OH_VideoEncoder_Configure(videoEnc, format);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\nOH_AVFormat_Destroy(format);     配置非必须参数错误时，会返回AV_ERR_INVAILD_VAL错误码。但OH_VideoEncoder_Configure()不会失败，而是使用默认值继续执行。   获取Surface。 获取编码器Surface模式的OHNativeWindow输入，获取surface需要在准备编码器之前完成。 // 获取需要输入的surface，以进行编码\nOHNativeWindow *nativeWindow;\nint32_t ret = OH_VideoEncoder_GetSurface(videoEnc, &nativeWindow);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\n// 通过OHNativeWindow*变量类型，可通过生产者接口获取待填充数据地址。 OHNativeWindow*变量类型的使用方法请参考图形子系统 OHNativeWindow。 调用OH_VideoEncoder_Prepare()编码器就绪。 该接口将在编码器运行前进行一些数据的准备工作。 int32_t ret = OH_VideoEncoder_Prepare(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_VideoEncoder_Start()启动编码器。 // 配置待编码文件路径\nstd::string_view outputFilePath = \"/*yourpath*.h264\";\nstd::unique_ptr<std::ofstream> outputFile = std::make_unique<std::ofstream>();\noutputFile->open(outputFilePath.data(), std::ios::out | std::ios::binary | std::ios::ate);\n// 启动编码器，开始编码\nint32_t ret = OH_VideoEncoder_Start(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} （可选）OH_VideoEncoder_SetParameter()在运行过程中动态配置编码器参数。 详细可配置选项的说明请参考视频专有键值对。 OH_AVFormat *format = OH_AVFormat_Create();\n\n// 支持动态请求IDR帧\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_REQUEST_I_FRAME, true);\n// 支持动态重置比特率\nint64_t bitRate = 2000000;\nOH_AVFormat_SetLongValue(format, OH_MD_KEY_BITRATE, bitRate);\n// 支持动态重置视频帧速率\ndouble frameRate = 60.0;\nOH_AVFormat_SetDoubleValue(format, OH_MD_KEY_FRAME_RATE, frameRate);\n// 支持动态设置QP值\n// 配置OH_MD_KEY_VIDEO_ENCODER_QP_MAX 的值应大于等于OH_MD_KEY_VIDEO_ENCODER_QP_MIN\nOH_AVFormat_SetIntValue(parameter, OH_MD_KEY_VIDEO_ENCODER_QP_MAX, 30);\nOH_AVFormat_SetIntValue(parameter, OH_MD_KEY_VIDEO_ENCODER_QP_MIN, 20);\n\nint32_t ret = OH_VideoEncoder_SetParameter(videoEnc, format);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\nOH_AVFormat_Destroy(format); 写入编码图像。 在之前的第7步中，开发者已经对OH_VideoEncoder_GetSurface接口返回的OHNativeWindow*类型变量进行配置。因为编码所需的数据，由配置的Surface进行持续地输入，所以开发者无需对OnNeedInputBuffer回调函数进行处理，也无需使用OH_VideoEncoder_PushInputBuffer接口输入数据。 （可选）调用OH_VideoEncoder_PushInputParameter()通知编码器随帧参数配置输入完成。 在之前的第4步中，调用者已经注册随帧通路回调 以下示例中：  index：回调函数OnNeedInputParameter传入的参数，与buffer唯一对应的标识。  std::shared_ptr<CodecBufferInfo> bufferInfo = inQueue.Dequeue();\nstd::shared_lock<std::shared_mutex> lock(codecMutex);\nif (bufferInfo == nullptr || !bufferInfo->isValid) {\n    // 异常处理\n}\n// 值由调用者决定\nint32_t isIFrame;\nOH_AVFormat_SetIntValue(bufferInfo->parameter, OH_MD_KEY_REQUEST_I_FRAME, isIFrame);\nint32_t ret = OH_VideoEncoder_PushInputParameter(videoEnc, bufferInfo->index);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_VideoEncoder_NotifyEndOfStream()通知编码器结束。 // Surface模式：通知视频编码器输入流已结束，只能使用此接口进行通知\n// 不能像Buffer模式中将flag设为AVCODEC_BUFFER_FLAGS_EOS，再调用OH_VideoEncoder_PushInputBuffer接口通知编码器输入结束\nint32_t ret = OH_VideoEncoder_NotifyEndOfStream(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_VideoEncoder_FreeOutputBuffer()释放编码帧。 以下示例中：  index：回调函数OnNewOutputBuffer传入的参数，与buffer唯一对应的标识。 buffer：回调函数OnNewOutputBuffer传入的参数，可以通过OH_AVBuffer_GetAddr接口得到共享内存地址的指针。  std::shared_ptr<CodecBufferInfo> bufferInfo = outQueue.Dequeue();\nstd::shared_lock<std::shared_mutex> lock(codecMutex);\nif (bufferInfo == nullptr || !bufferInfo->isValid) {\n    // 异常处理\n}\n// 获取编码后信息\nOH_AVCodecBufferAttr info;\nint32_t ret = OH_AVBuffer_GetBufferAttr(bufferInfo->buffer, &info);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\n// 将编码完成帧数据buffer写入到对应输出文件中\noutputFile->write(reinterpret_cast<char *>(OH_AVBuffer_GetAddr(bufferInfo->buffer)), info.size);\n// 释放已完成写入的数据，index为对应输出队列下标\nret = OH_VideoEncoder_FreeOutputBuffer(videoEnc, bufferInfo->index);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} （可选）调用OH_VideoEncoder_Flush()刷新编码器。 调用OH_VideoEncoder_Flush接口后，编码器仍处于运行态，但会清除编码器中缓存的输入和输出数据及参数集如H264格式的PPS/SPS。 此时需要调用OH_VideoEncoder_Start接口重新开始编码。 std::unique_lock<std::shared_mutex> lock(codecMutex);\n// 刷新编码器videoEnc\nint32_t ret = OH_VideoEncoder_Flush(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\ninQueue.Flush();\noutQueue.Flush();\n// 重新开始编码\nret = OH_VideoEncoder_Start(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} （可选）调用OH_VideoEncoder_Reset()重置编码器。 调用OH_VideoEncoder_Reset接口后，编码器将回到初始化的状态，需要调用OH_VideoEncoder_Configure接口和OH_VideoEncoder_Prepare接口重新配置。 std::unique_lock<std::shared_mutex> lock(codecMutex);\n// 重置编码器videoEnc\nint32_t ret = OH_VideoEncoder_Reset(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\ninQueue.Flush();\noutQueue.Flush();\n// 重新配置编码器参数\nret = OH_VideoEncoder_Configure(videoEnc, format);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\n// 编码器重新就绪\nret = OH_VideoEncoder_Prepare(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} （可选）调用OH_VideoEncoder_Stop()停止编码器。 调用OH_VideoEncoder_Stop接口后，编码器保留了编码实例，释放输入输出buffer。调用者可以直接调用OH_VideoEncoder_Start接口继续编码， 输入的第一个buffer需要携带参数集，从IDR帧开始送入。 std::unique_lock<std::shared_mutex> lock(codecMutex);\n// 终止编码器videoEnc\nint32_t ret = OH_VideoEncoder_Stop(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\ninQueue.Flush();\noutQueue.Flush(); 调用OH_VideoEncoder_Destroy()销毁编码器实例，释放资源。      不能在回调函数中调用； 执行该步骤之后，需要调用者将videoEnc指向NULL，防止野指针导致程序错误。    std::unique_lock<std::shared_mutex> lock(codecMutex);\n// 释放nativeWindow实例\nif(nativeWindow != NULL){\n    OH_NativeWindow_DestroyNativeWindow(nativeWindow);\n    nativeWindow = NULL;\n}\n// 调用OH_VideoEncoder_Destroy，注销编码器\nint32_t ret = AV_ERR_OK;\nif (videoEnc != NULL) {\n    ret = OH_VideoEncoder_Destroy(videoEnc);\n    videoEnc = NULL;\n}\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\ninQueue.Flush();\noutQueue.Flush(); 
[h2]Buffer模式
参考以下示例代码，调用者可以完成Buffer模式下视频编码的全流程。此处以YUV文件输入，编码成H.264格式为例。
本模块目前仅支持异步模式的数据轮转。
 添加头文件。 #include <multimedia/player_framework/native_avcodec_videoencoder.h>\n#include <multimedia/player_framework/native_avcapability.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <fstream> 创建编码器实例对象。 与Surface模式相同，此处不再赘述。 // 通过codec name创建编码器，应用有特殊需求，比如选择支持某种分辨率规格的编码器，可先查询capability，再根据codec name创建编码器。\nOH_AVCapability *capability = OH_AVCodec_GetCapability(OH_AVCODEC_MIMETYPE_VIDEO_AVC, true);\nconst char *codecName = OH_AVCapability_GetName(capability);\nOH_AVCodec *videoEnc = OH_VideoEncoder_CreateByName(codecName); // 通过MIME TYPE创建编码器，只能创建系统推荐的特定编解码器\n// 涉及创建多路编解码器时，优先创建硬件编码器实例，硬件资源不够时再创建软件编码器实例\nOH_AVCodec *videoEnc = OH_VideoEncoder_CreateByMime(OH_AVCODEC_MIMETYPE_VIDEO_AVC); 调用OH_VideoEncoder_RegisterCallback()设置回调函数。 注册回调函数指针集合OH_AVCodecCallback，包括：  OH_AVCodecOnError 编码器运行错误，返回的错误码详情请参见OH_AVCodecOnError； OH_AVCodecOnStreamChanged 码流信息变化，如格式变化等； OH_AVCodecOnNeedInputBuffer 运行过程中需要新的输入数据，即编码器已准备好，可以输入YUV/RGB数据； OH_AVCodecOnNewOutputBuffer 运行过程中产生了新的输出数据，即编码完成。  调用者可以通过处理该回调报告的信息，确保编码器正常运转。 回调函数的具体实现可参考示例工程。 bool isFirstFrame = true;\nint32_t qpAverage = 20;\ndouble mseValue = 0.0; // 编码异常回调OH_AVCodecOnError实现\nstatic void OnError(OH_AVCodec *codec, int32_t errorCode, void *userData)\n{\n    // 回调的错误码由调用者判断处理\n    (void)codec;\n    (void)errorCode;\n    (void)userData;\n} // 编码数据流变化回调OH_AVCodecOnStreamChanged实现\nstatic void OnStreamChanged(OH_AVCodec *codec, OH_AVFormat *format, void *userData)\n{\n    // Buffer模式下，该回调函数无作用\n    (void)codec;\n    (void)format;\n    (void)userData;\n} // 编码输入回调OH_AVCodecOnNeedInputBuffer实现\nstatic void OnNeedInputBuffer(OH_AVCodec *codec, uint32_t index, OH_AVBuffer *buffer, void *userData)\n{\n    // 获取视频宽、高跨距\n    if (isFirstFrame) {\n        OH_AVFormat *format = OH_VideoEncoder_GetInputDescription(codec);\n        OH_AVFormat_GetIntValue(format, OH_MD_KEY_VIDEO_STRIDE, &widthStride);\n        OH_AVFormat_GetIntValue(format, OH_MD_KEY_VIDEO_SLICE_HEIGHT, &heightStride);\n        OH_AVFormat_Destroy(format);\n        isFirstFrame = false;\n    }\n    // 输入帧的数据buffer和对应的index送入inQueue队列\n    (void)codec;\n    (void)userData;\n    inQueue.Enqueue(std::make_shared<CodecBufferInfo>(index, buffer));\n} // 编码输出回调OH_AVCodecOnNewOutputBuffer实现\nstatic void OnNewOutputBuffer(OH_AVCodec *codec, uint32_t index, OH_AVBuffer *buffer, void *userData)\n{\n    // 获取视频帧的平均量化参数，平方误差\n    OH_AVFormat *format = OH_AVBuffer_GetParameter(buffer);\n    OH_AVFormat_GetIntValue(format, OH_MD_KEY_VIDEO_ENCODER_QP_AVERAGE, &qpAverage);\n    OH_AVFormat_GetDoubleValue(format, OH_MD_KEY_VIDEO_ENCODER_MSE, &mseValue);\n    OH_AVFormat_Destroy(format);\n    // 完成帧的数据buffer和对应的index送入outQueue队列\n    (void)userData;\n    outQueue.Enqueue(std::make_shared<CodecBufferInfo>(index, buffer));\n} // 配置异步回调，调用OH_VideoEncoder_RegisterCallback接口\nOH_AVCodecCallback cb = {&OnError, &OnStreamChanged, &OnNeedInputBuffer, &OnNewOutputBuffer};\nint32_t ret = OH_VideoEncoder_RegisterCallback(videoEnc, cb, NULL);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}     在回调函数中，对数据队列进行操作时，需要注意多线程同步的问题。   调用OH_VideoEncoder_Configure()配置编码器。 与Surface模式相同，此处不再赘述。 OH_AVFormat *format = OH_AVFormat_Create();\n// 写入format\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_WIDTH, width); // 必须配置\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_HEIGHT, height); // 必须配置\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_PIXEL_FORMAT, pixelFormat); // 必须配置\n// 配置编码器\nint32_t ret = OH_VideoEncoder_Configure(videoEnc, format);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\nOH_AVFormat_Destroy(format); 调用OH_VideoEncoder_Prepare()编码器就绪。 该接口将在编码器运行前进行一些数据的准备工作。 ret = OH_VideoEncoder_Prepare(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_VideoEncoder_Start()启动编码器，进入运行态。 启动编码器后，回调函数将开始响应事件。所以，需要先配置输入文件、输出文件。 // 配置待编码文件路径\nstd::string_view inputFilePath = \"/*yourpath*.yuv\";\nstd::string_view outputFilePath = \"/*yourpath*.h264\";\nstd::unique_ptr<std::ifstream> inputFile = std::make_unique<std::ifstream>();\nstd::unique_ptr<std::ofstream> outputFile = std::make_unique<std::ofstream>();\ninputFile->open(inputFilePath.data(), std::ios::in | std::ios::binary);\noutputFile->open(outputFilePath.data(), std::ios::out | std::ios::binary | std::ios::ate);\n// 启动编码器，开始编码\nint32_t ret = OH_VideoEncoder_Start(videoEnc);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} （可选）在运行过程中动态配置编码器参数。 OH_AVFormat *format = OH_AVFormat_Create();\n\n// 支持动态请求IDR帧\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_REQUEST_I_FRAME, true);\n// 支持动态重置比特率\nint64_t bitRate = 2000000;\nOH_AVFormat_SetLongValue(format, OH_MD_KEY_BITRATE, bitRate);\n// 支持动态重置视频帧速率\ndouble frameRate = 60.0;\nOH_AVFormat_SetDoubleValue(format, OH_MD_KEY_FRAME_RATE, frameRate);\n\nint32_t ret = OH_VideoEncoder_SetParameter(videoEnc, format);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\nOH_AVFormat_Destroy(format); 调用OH_VideoEncoder_PushInputBuffer()写入编码图像。 送入输入队列进行编码，以下示例中：  buffer：回调函数OnNeedInputBuffer传入的参数，可以通过OH_AVBuffer_GetAddr接口得到共享内存地址的指针； index：回调函数OnNeedInputBuffer传入的参数，与buffer唯一对应的标识； flags：缓冲区标记的类别，请参考OH_AVCodecBufferFlags widthStride: 获取到的buffer数据的跨距。  std::shared_ptr<CodecBufferInfo> bufferInfo = inQueue.Dequeue();\nstd::shared_lock<std::shared_mutex> lock(codecMutex);\nif (bufferInfo == nullptr || !bufferInfo->isValid) {\n    // 异常处理\n}\n// 写入图像数据\nif (widthStride == width) {\n    // 处理文件流得到帧的长度，再将需要编码的数据写入到对应index的buffer中\n    int32_t frameSize = width * height * 3 / 2; // NV12像素格式下，每帧数据大小的计算公式\n    inputFile->read(reinterpret_cast<char *>(OH_AVBuffer_GetAddr(bufferInfo->buffer)), frameSize);\n} else {\n    // 如果跨距不等于宽，需要调用者按照跨距进行偏移，具体可参考以下示例\n}\n// 配置buffer info信息\nOH_AVCodecBufferAttr info;\ninfo.size = frameSize;\ninfo.offset = 0;\ninfo.pts = 0;\ninfo.flags = flags;\nint32_t ret = OH_AVBuffer_SetBufferAttr(bufferInfo->buffer, &info);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\n// 配置buffer 随帧信息\n// 值由调用者决定\nint32_t isIFrame;\nOH_AVFormat *parameter = OH_AVBuffer_GetParameter(bufferInfo->buffer);\nOH_AVFormat_SetIntValue(parameter, OH_MD_KEY_REQUEST_I_FRAME, isIFrame);\nret = OH_AVBuffer_SetParameter(bufferInfo->buffer, parameter);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\nOH_AVFormat_Destroy(parameter);\n// 送入编码输入队列进行编码，index为对应输入队列的下标\nret = OH_VideoEncoder_PushInputBuffer(videoEnc, bufferInfo->index);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 对跨距进行偏移，以NV12图像为例，示例如下： 以NV12图像为例，width、height、wStride、hStride图像排布参考下图：  OH_MD_KEY_VIDEO_PIC_WIDTH表示width； OH_MD_KEY_VIDEO_PIC_HEIGHT表示height； OH_MD_KEY_VIDEO_STRIDE表示wStride； OH_MD_KEY_VIDEO_SLICE_HEIGHT表示hStride。   添加头文件。 #include <string.h> 使用示例： struct Rect   // 源内存区域的宽、高，由调用者自行设置\n{\n    int32_t width;\n    int32_t height;\n};\n\nstruct DstRect // 目标内存区域的宽、高跨距，通过接口OH_VideoEncoder_GetInputDescription获取\n{\n    int32_t wStride;\n    int32_t hStride;\n};\n\nstruct SrcRect // 源内存区域的宽、高跨距，由调用者自行设置\n{\n    int32_t wStride;\n    int32_t hStride;\n};\n\nRect rect = {320, 240};\nDstRect dstRect = {320, 256};\nSrcRect srcRect = {320, 250};\nuint8_t* dst = new uint8_t[dstRect.hStride * dstRect.wStride * 3 / 2]; // 目标内存区域的指针\nuint8_t* src = new uint8_t[srcRect.hStride * srcRect.wStride * 3 / 2]; // 源内存区域的指针\nuint8_t* dstTemp = dst;\nuint8_t* srcTemp = src;\n\n// Y 将Y区域的源数据复制到另一个区域的目标数据中\nfor (int32_t i = 0; i < rect.height; ++i) {\n    //将源数据的一行数据复制到目标数据的一行中\n    memcpy_s(dstTemp, srcTemp, rect.width);\n    // 更新源数据和目标数据的指针，进行下一行的复制。每更新一次源数据和目标数据的指针都向下移动一个wStride\n    dstTemp += dstRect.wStride;\n    srcTemp += srcRect.wStride;\n}\n// padding\n// 更新源数据和目标数据的指针，指针都向下移动一个padding\ndstTemp += (dstRect.hStride - rect.height) * dstRect.wStride;\nsrcTemp += (srcRect.hStride - rect.height) * srcRect.wStride;\nrect.height >>= 1;\n// UV 将UV区域的源数据复制到另一个区域的目标数据中\nfor (int32_t i = 0; i < rect.height; ++i) {\n    memcpy_s(dstTemp, srcTemp, rect.width);\n    dstTemp += dstRect.wStride;\n    srcTemp += srcRect.wStride;\n}\n\ndelete[] dst;\ndst = nullptr;\ndelete[] src;\nsrc = nullptr; 硬件编码在处理buffer数据时（推送数据前），需要调用者拷贝宽高对齐后的图像数据到输入回调的AVbuffer中。 一般需要获取数据的宽高、跨距、像素格式来保证编码输入数据被正确的处理。 具体实现请参考：Buffer模式的步骤3-调用OH_VideoEncoder_RegisterCallback接口设置回调函数来获取数据的宽高、跨距、像素格式。 通知编码器结束。 以下示例中：  index：回调函数OnNeedInputBuffer传入的参数，与buffer唯一对应的标识。 buffer：回调函数OnNeedInputBuffer传入的参数，可以通过OH_AVBuffer_GetAddr接口得到共享内存地址的指针；  与“8. 写入编码图像”一样，使用同一个接口OH_VideoEncoder_PushInputBuffer，通知编码器输入结束，需要将flag标识成AVCODEC_BUFFER_FLAGS_EOS。 std::shared_ptr<CodecBufferInfo> bufferInfo = inQueue.Dequeue();\nstd::shared_lock<std::shared_mutex> lock(codecMutex);\nif (bufferInfo == nullptr || !bufferInfo->isValid) {\n    // 异常处理\n}\nOH_AVCodecBufferAttr info;\ninfo.size = 0;\ninfo.offset = 0;\ninfo.pts = 0;\ninfo.flags = AVCODEC_BUFFER_FLAGS_EOS;\nint32_t ret = OH_AVBuffer_SetBufferAttr(bufferInfo->buffer, &info);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\nret = OH_VideoEncoder_PushInputBuffer(videoEnc, bufferInfo->index);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_VideoEncoder_FreeOutputBuffer()释放编码帧。 与Surface模式相同，此处不再赘述。 std::shared_ptr<CodecBufferInfo> bufferInfo = outQueue.Dequeue();\nstd::shared_lock<std::shared_mutex> lock(codecMutex);\nif (bufferInfo == nullptr || !bufferInfo->isValid) {\n    // 异常处理\n}\n// 获取编码后信息\nOH_AVCodecBufferAttr info;\nint32_t ret = OH_AVBuffer_GetBufferAttr(bufferInfo->buffer, &info);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\n// 将编码完成帧数据buffer写入到对应输出文件中\noutputFile->write(reinterpret_cast<char *>(OH_AVBuffer_GetAddr(bufferInfo->buffer)), info.size);\n// 释放已完成写入的数据，index为对应输出队列的下标\nret = OH_VideoEncoder_FreeOutputBuffer(videoEnc, bufferInfo->index);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 
后续流程（包括刷新编码器、重置编码器、停止编码器、销毁编码器）与Surface模式一致，请参考Surface模式的步骤14-17。

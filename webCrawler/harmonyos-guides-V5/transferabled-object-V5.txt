Transferable对象（NativeBinding对象）
Transferable对象（也称为NativeBinding对象）指的是一个JS对象，绑定了一个C++对象，且主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。跨线程传输时可以直接复用同一个C++对象，相比于JS对象的拷贝模式，传输效率较高。因此，可共享或转移的NativeBinding对象也被称为Transferable对象。
共享模式
如果C++实现能够保证线程安全性，则这个NativeBinding对象的C++部分可以支持共享传输。此时，NativeBinding对象跨线程传输后，只需要重新创建JS壳，就可以桥接到相同的C++对象上。通信过程如下图所示：
常见的共享模式NativeBinding对象包括Context，Context对象包含应用程序组件的上下文信息，它提供了一种访问系统服务和资源的方式，使得应用程序组件可以与系统进行交互。获取Context信息的方法可以参考获取上下文信息。
示例可参考使用TaskPool进行频繁数据库操作。
转移模式
如果C++实现包含了数据，且无法保证线程安全性，则这个NativeBinding对象的C++部分需要采用转移方式传输。此时，NativeBinding对象跨线程传输后，只需要重新创建JS壳，就可以桥接到C++对象上，不过原对象需要移除对此对象的绑定关系。通信过程如下图所示：
常见的转移模式NativeBinding对象包括PixelMap，PixelMap对象可以读取或写入图像数据以及获取图像信息，常用于在应用或系统中显示图片。
[h2]使用示例
这里提供了一个跨线程传递PixelMap对象的示例以帮助更好理解。首先获取rawfile文件夹中的图片资源，然后在子线程中创建PixelMap对象传递给主线程，具体实现如下：
// Index.ets\nimport { taskpool } from '@kit.ArkTS';\nimport { loadPixelMap } from './pixelMapTest';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n  @State pixelMap: PixelMap | undefined = undefined;\n\n  private loadImageFromThread(): void {\n    const resourceMgr = getContext(this).resourceManager;\n    // 此处‘startIcon.png’为media下复制到rawfile文件夹中，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。\n    resourceMgr.getRawFd('startIcon.png').then(rawFileDescriptor => {\n      taskpool.execute(loadPixelMap, rawFileDescriptor).then(pixelMap => {\n        if (pixelMap) {\n          this.pixelMap = pixelMap as PixelMap;\n          console.log('Succeeded in creating pixelMap.');\n          // 主线程释放pixelMap。由于子线程返回pixelMap时已调用setTransferDetached，所以此处能够立即释放pixelMap。\n          this.pixelMap.release();\n        } else {\n          console.error('Failed to create pixelMap.');\n        }\n      }).catch((e: BusinessError) => {\n        console.error('taskpool execute loadPixelMap failed. Code: ' + e.code + ', message: ' + e.message);\n      });\n    });\n  }\n\n  build() {\n    RelativeContainer() {\n      Text(this.message)\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .alignRules({\n          center: { anchor: 'container', align: VerticalAlign.Center },\n          middle: { anchor: 'container', align: HorizontalAlign.Center }\n        })\n        .onClick(() => {\n          this.loadImageFromThread();\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
// pixelMapTest.ets\nimport { image } from '@kit.ImageKit';\n\n@Concurrent\nexport async function loadPixelMap(rawFileDescriptor: number): Promise<PixelMap> {\n  // 创建imageSource。\n  const imageSource = image.createImageSource(rawFileDescriptor);\n  // 创建pixelMap。\n  const pixelMap = imageSource.createPixelMapSync();\n  // 释放imageSource。\n  imageSource.release();\n  // 使pixelMap在跨线程传输完成后，断开原线程的引用。\n  pixelMap.setTransferDetached(true);\n  // 返回pixelMap给主线程。\n  return pixelMap;\n}

使用 code cache 加速编译
code cache 简介
JSVM 提供了生成并使用 code cache 加速编译过程的方法, 其获取和使用分为下面几个部分:
首先使用 compile 系列接口编译得到 JSVM_Script使用 OH_JSVM_CreateCodeCache 接口, 传入编译完成后生成的 JSVM_Script将 OH_JSVM_CreateCodeCache 生成的 code cache 保存, 等待下一次编译时, 作为参数传递给 compile 系列接口
通过上述流程, 将会在使用 code cache 的那次编译中, 极大减少编译时间, 其原理为将编译完成的 script 序列化, 然后使用 code cache 编译时就不再需要重新解析/编译已经被序列化的函数, 只需要进行一次反序列化即可, 编译就简化为了一次数据读取。
场景示例
下面的伪代码是一个典型的使用方法, 其中第二次编译, 如果 cacheRejected 的值没有被置为 true, 那么说明 code cache 使用成功, 这次运行将会极大加快。
其中使用到的 JSVM-API 可以参考 JSVM 数据类型与接口说明, 这里仅展示调用的步骤。
外层跨语言交互的部分可以参考 使用 JSVM-API 实现 JS 与 C/C++ 语言交互开发流程。
#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n\nvoid UseCodeCache(JSVM_Env env, JSVM_CallbackInfo info) {\n    // 编译参数准备\n    JSVM_Value jsSrc;\n    JSVM_Script script;\n    size_t length = 0;\n    const uint8_t* dataPtr = nullptr;\n    bool cacheRejected = true;\n    static std::string src = R\"JS(\n        a = 65536;\n        b = 32768;\n        c = a + b;\n    )JS\";\n\n    // 生成 code cache\n    {\n        JSVM_HandleScope handleScope;\n        OH_JSVM_OpenHandleScope(env, &handleScope);\n\n        // 源码字符串转换为 js 字符串\n        OH_JSVM_CreateStringUtf8(env, src.c_str(), src.size(), &jsSrc);\n\n        // 编译js代码\n        OH_JSVM_CompileScript(env, jsSrc, nullptr, 0, true, nullptr, &script);\n\n        // 执行js代码\n        JSVM_Value result;\n        OH_JSVM_RunScript(env, script, &result);\n        int value = 0;\n        OH_JSVM_GetValueInt32(env, result, &value);\n        OH_LOG_INFO(LOG_APP, \"first run result: %{public}d\\n\", value);\n\n        if (dataPtr && lengthPtr && *dataPtr == nullptr) {\n            // 将js源码编译出的脚本保存到 cache, 可以避免重复编译, 带来性能提升\n            OH_JSVM_CreateCodeCache(env, script, &dataPtr, &length);\n        }\n\n        OH_JSVM_CloseHandleScope(env, handleScope);\n    }\n\n    // 使用 code cache\n    {\n        JSVM_HandleScope handleScope;\n        OH_JSVM_OpenHandleScope(env, &handleScope);\n\n        // 源码字符串转换为 js 字符串\n        OH_JSVM_CreateStringUtf8(env, src.c_str(), src.size(), &jsSrc);\n\n        // 使用 code cache 编译js代码\n        OH_JSVM_CompileScript(env, jsSrc, dataPtr, length, true, &cacheRejected, &script);\n\n        // 执行js代码\n        JSVM_Value result;\n        OH_JSVM_RunScript(env, script, &result);\n        int value = 0;\n        OH_JSVM_GetValueInt32(env, result, &value);\n        OH_LOG_INFO(LOG_APP, \"second run result: %{public}d\\n\", value);\n\n        OH_JSVM_CloseHandleScope(env, handleScope);\n    }\n    OH_LOG_INFO(LOG_APP, \"cache rejected: %{public}d\\n\", cacheRejected);\n}\n\n// Register a WasmDemo callback.\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = UseCodeCache}\n};\nstatic JSVM_CallbackStruct *method = param;\n// Register the C++ WasmDemo callback as a JSVM globalThis.UseCodeCache property for the JS to call.\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"UseCodeCache\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};
预期输出结果
first run result: 98304\nsecond run result: 98304\ncache rejected: 0
注意事项
上述代码中使用了 code cache 进行编译: OH_JSVM_CompileScript(env, jsSrc, dataPtr, length, true, &cacheRejected, &script);
这个接口的传入参数中包含了 cacheRejected，其作用是接收实际的编译过程中，code cache 是否被拒绝的状态，这里包含了多种情况：
code cache 校验失败code cache 校验成功内存中存在编译缓存，code cache 没有被校验
对于第一种情况，这个参数会被置为 true，而后两种情况都是 false，因此需要注意即使 reject 为 false，也不能说明 code cache 被接收了。

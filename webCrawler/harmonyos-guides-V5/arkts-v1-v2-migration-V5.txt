V1->V2迁移指导
概述
ArkUI状态管理的主要职责是：负责将可观察数据的变化自动同步到UI界面，实现数据驱动的UI刷新，使开发者能更加够专注于UI界面的实现和设计。
在状态管理框架的演进过程中，先后推出了状态管理V1和V2两个版本。V1强调组件层级的状态管理，而V2则增强了对数据对象的深度观察与管理能力，不再局限于组件层级。通过V2，开发者能够更灵活地控制数据和状态，实现更高效的UI刷新。具体V1和V2的区别可以参见状态管理概述。
V1V2使用指引
 V2是V1的增强版本，为开发者提供更多功能和灵活性。 对于新开发的应用，建议直接使用V2版本范式来进行开发。 对于已经使用V1的应用，如果V1的功能和性能已能满足需求，则不必立即切换到V2。如果开发者在开发过程中受限于V1不能深度观察等特性，则建议开发者尽早规划向V2的迁移，以便未来实现平滑过渡和改进。 对于需要在现阶段混用V1和V2的场景，请参阅混用文档。编译器、工具链、IDE对某些不推荐的误用和混用场景会进行校验，虽然开发者可能可以通过特殊手段绕过这些校验，但还是强烈建议开发者遵循混用文档的指导，避免因双重代理等问题给应用带来不确定性。 
迁移指南的目的
 对希望将现有V1应用迁移到V2的开发者，提供系统化的模板和指导，帮助完成V1到V2的迁移。 对希望逐步将V1应用过渡到V2的开发者，提供参考，结合本迁移文档与混用文档，可以帮助开发者实现逐步改造。 尚未开始开发应用但已熟悉V1状态管理规则的开发者，可以参考本迁移文档及V2各个装饰器和接口的文档，开始使用V2进行应用开发。 
V1V2能力对比及迁移简表
表明当前对象为可观察对象。但两者能力并不相同。
@Observed可观察第一层的属性，需要搭配@ObjectLink使用才能生效。
@ObservedV2本身无观察能力，仅代表当前class可被观察，如果要观察其属性，需要搭配@Trace使用。
V1装饰器@Track为精确观察，不使用则无法做到类属性的精准观察。
V2@Trace装饰的属性可以被精确跟踪观察。
@Component为搭配V1状态变量使用的自定义组件装饰器。
@ComponentV2为搭配V2状态变量使用的自定义组件装饰器。
无外部初始化：@Local
外部初始化一次：@Param@Once
@Watch用于监听V1状态变量的变化，具有监听状态变量本身和其第一层属性变化的能力。状态变量可观察到的变化会触发其@Watch监听事件。
@Monitor用于监听V2状态变量的变化，搭配@Trace使用，可有深层监听的能力。状态变量在一次事件中多次变化时，仅会以最终的结果判断是否触发@Monitor监听事件。
各装饰器迁移示例
[h2]@State->@Local
迁移规则
在V1中，@State装饰器用于装饰组件内部的状态变量，在V2中提供了@Local作为其替代能力，但两者在观察能力和初始化规则上存在明显差异。针对不同的使用场景，迁移策略如下：
 简单类型：对于简单类型的变量，可以直接将@State替换为@Local。 复杂类型：V1中的@State可以观察复杂对象的第一层属性变化，而V2中的@Local只能观察对象自身的变化。如果需要追踪对象内部的属性变化，可以结合使用@ObservedV2和@Trace。 外部初始化：V1中，@State支持从外部传递初始值，但在V2中，@Local禁止外部初始化。若需要从外部传递初始值，可以使用@Param和@Once装饰器来实现类似的效果。 
示例
简单类型
对于简单类型变量，V1的@State可以直接替换为替换为V2的@Local。
V1：
@Entry\n@Component\nstruct Child {\n  @State val: number = 10;\n  build(){\n    Text(this.val.toString())\n  }\n}
V2迁移策略：直接替换。
@Entry\n@ComponentV2\nstruct Child {\n  @Local val: number = 10;\n  build(){\n    Text(this.val.toString())\n  }\n}
复杂类型
V1的@State能够观察复杂对象的第一层属性变化，但V2的@Local无法观察对象内部变化。为了解决这个问题，需要在类上添加@ObservedV2，并在需要观察的属性上添加@Trace。这样，框架就能追踪对象内部的属性变化。
V1：
class Child {\n  value: number = 10;\n}\n\n@Component\n@Entry\nstruct example {\n  @State child: Child = new Child();\n  build(){\n    Column() {\n      Text(this.child.value.toString())\n      // @State可以观察第一层变化\n      Button('value+1')\n        .onClick(() => {\n          this.child.value++;\n        })\n    }\n  }\n}
V2迁移策略：使用@ObservedV2和@Trace。
@ObservedV2\nclass Child {\n  @Trace public value: number = 10;\n}\n\n@ComponentV2\n@Entry\nstruct example {\n  @Local child: Child = new Child();\n  build(){\n    Column() {\n      Text(this.child.value.toString())\n      // @Local只能观察自身，需要给Child加上@ObservedV2和@Trace\n      Button('value+1')\n        .onClick(() => {\n          this.child.value++;\n        })\n    }\n  }\n}
外部初始化状态变量
V1的@State变量可以从外部初始化，V2的@Local禁止外部初始化。为实现类似功能，需要用@Param和@Once代替@State，允许外部传入初始值，并确保该值只初始化时同步一次。
V1实现：
@Component\nstruct Child {\n  @State value: number = 0;\n  build() {\n    Text(this.value.toString())\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  build() {\n    Column(){\n      // @State可以从外部初始化\n      Child({ value: 30 })\n    }\n  }\n}
V2迁移策略：使用@Param和@Once。
@ComponentV2\nstruct Child {\n  @Param @Once value: number = 0;\n  build() {\n    Text(this.value.toString())\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Parent {\n  build() {\n    Column(){\n      // @Local禁止从外部初始化，可以用@Param和@Once替代实现\n      Child({ value: 30 })\n    }\n  }\n}
[h2]@Link -> @Param/@Event
迁移规则
在V1中，@Link允许父组件和子组件之间进行双向数据绑定。迁移到V2时，可以用@Param和@Event模拟双向同步。@Param实现父到子的单向传递，子组件再通过@Event回调函数触发父组件的状态更新。
示例
V1实现：
@Component\nstruct Child {\n  // @Link可以双向同步数据\n  @Link val: number;\n  build() {\n    Column(){\n      Text(\"child: \" + this.val.toString())\n      Button(\"+1\")\n        .onClick(() => {\n          this.val++;\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State myVal: number = 10;\n  build() {\n    Column(){\n      Text(\"parent: \" + this.myVal.toString())\n      Child({val: this.myVal})\n    }\n  }\n}
V2迁移策略：使用@Param和@Event
@ComponentV2\nstruct Child {\n  // @Param搭配@Event回调实现数据双向同步\n  @Param val: number  = 0;\n  @Event addOne: () => void;\n  build() {\n    Column(){\n      Text(\"child: \" + this.val.toString())\n      Button(\"+1\")\n        .onClick(()=> { \n          this.addOne();\n        })\n    }\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Parent {\n  @Local myVal: number = 10\n  build() {\n    Column() {\n      Text(\"parent: \" + this.myVal.toString())\n      Child({ val: this.myVal, addOne: () => this.myVal++})\n    }\n  }\n}
[h2]@Prop -> @Param
迁移规则
在V1中，@Prop装饰器用于从父组件传递参数给子组件，这些参数在子组件中可以被直接修改。在V2中，@Param取代了@Prop的作用，但@Param是只读的，子组件不能直接修改参数的值。因此，根据场景的不同，有几种迁移策略：
 简单类型：对于简单类型的参数，可以直接将@Prop替换@Param。 复杂类型：如果传递的是复杂对象且需要严格的单向数据绑定，可以对对象进行深拷贝，防止子组件修改父组件的数据。 子组件修改变量：如果子组件需要修改传入的参数，可以使用@Once来允许子组件对在本地修改该变量。但需要注意，如果使用了@Once，则代表当前子组件只会被初始化一次，后续并没有父组件到子组件的同步能力。 
示例
简单类型
对于简单类型变量，V1的@Prop可以直接替换为V2的@Param。
V1实现：
@Component\nstruct Child {\n  @Prop value: number;\n  build() {\n    Text(this.value.toString())\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  build() {\n    Column(){\n      Child({ value: 30 })\n    }\n  }\n}
V2迁移策略：直接替换
@ComponentV2\nstruct Child {\n  @Param value: number = 0;\n  build() {\n    Text(this.value.toString())\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Parent {\n  build() {\n    Column(){\n      Child({ value: 30 })\n    }\n  }\n}
复杂类型的单向数据传递
在V2中，传递复杂类型时，如果希望实现严格的单向数据绑定，防止子组件修改父组件的数据，需要在使用@Param传递复杂对象时进行深拷贝以避免传递对象的引用。
V1实现：
class Fruit {\n  apple: number = 5;\n  orange: number = 10;\n}\n\n@Component\nstruct Child {\n  // @Prop传递Fruit类，当子类修改属性，父类不受影响\n  @Prop fruit: Fruit;\n  build() {\n    Column() {\n      Text(\"child apple: \"+ this.fruit.apple.toString())\n      Text(\"child orange: \"+ this.fruit.orange.toString())\n      Button(\"apple+1\")\n        .onClick(() => {\n          this.fruit.apple++;\n        })\n      Button(\"orange+1\")\n        .onClick(() => {\n          this.fruit.orange++;\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State parentFruit: Fruit = new Fruit();\n  build() {\n    Column(){\n      Text(\"parent apple: \"+this.parentFruit.apple.toString())\n      Text(\"parent orange: \"+this.parentFruit.orange.toString())\n      Child({ fruit: this.parentFruit })\n    }\n  }\n}
​
V2迁移策略：使用深拷贝
@ObservedV2\nclass Fruit{\n  @Trace apple: number = 5;\n  @Trace orange: number = 10;\n  // 实现深拷贝，子组件不会修改父组件的数据\n  clone(): Fruit {\n    let newFruit: Fruit = new Fruit();\n    newFruit.apple = this.apple;\n    newFruit.orange = this.orange;\n    return newFruit;\n  }\n}\n\n@ComponentV2\nstruct Child {\n  @Param fruit: Fruit = new Fruit();\n  build() {\n    Column() {\n      Text(\"child\")\n      Text(this.fruit.apple.toString())\n      Text(this.fruit.orange.toString())\n      Button(\"apple+1\")\n        .onClick( ()=> {\n          this.fruit.apple++;\n        })\n      Button(\"orange+1\")\n        .onClick(() => {\n          this.fruit.orange++;\n        })\n    }\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Parent {\n  @Local parentFruit: Fruit = new Fruit();\n  build() {\n    Column(){\n      Text(\"parent\")\n      Text(this.parentFruit.apple.toString())\n      Text(this.parentFruit.orange.toString())\n      Child({ fruit: this.parentFruit.clone()})\n    }\n  }\n}
子组件修改变量
在V1中，子组件可以修改@Prop的变量，然而在V2中，@Param是只读的。如果子组件需要修改传入的值，可以使用@Param和@Once允许子组件在本地修改。
V1实现：
@Component\nstruct Child {\n  // @Prop可以直接修改变量值\n  @Prop value: number;\n  build() {\n    Column(){\n      Text(this.value.toString())\n      Button(\"+1\")\n        .onClick(()=> {\n          this.value++;\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  build() {\n    Column(){\n      Child({ value: 30 })\n    }\n  }\n}
V2迁移策略：使用@Param和@Once
@ComponentV2\nstruct Child {\n  // @Param搭配@Once使用，可以在本地修改@Param变量\n  @Param @Once value: number = 0;\n  build() {\n    Column(){\n      Text(this.value.toString())\n      Button(\"+1\")\n        .onClick(() => {\n          this.value++;\n        })\n    }\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Parent {\n  build() {\n    Column(){\n      Child({ value: 30 })\n    }\n  }\n}
在V1中，子组件可以修改@Prop的变量，且只会在本地更新，不会同步回父组件。父组件数据源更新时，会通知子组件更新，并覆写子组件本地@Prop的值。
V1：
 改变子组件Child的localValue，不会同步回父组件Parent。 父组件更新value，通知子组件Child更新，并覆写本地子组件localValue的值。 
@Component\nstruct Child {\n  @Prop localValue: number = 0;\n\n  build() {\n    Column() {\n      Text(`${this.localValue}`).fontSize(25)\n      Button('Child +100')\n        .onClick(() => {\n          // 改变localValue不会传递给父组件Parent\n          this.localValue += 100;\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State value: number = 10;\n  build() {\n    Column() {\n      Button('Parent +1')\n        .onClick(() => {\n          // 改变value的值，通知子组件Child value更新\n          this.value += 1;\n        })\n      Child({ localValue: this.value })\n    }\n  }\n}
V2中，@Param本地不可写，和@Once搭配使用只会同步一次。如果要实现子组件本地可写，且父组件后续更新还是能通知子组件，可以借助@Monitor来实现这一效果。
V2实现：
 父组件Parent更新通知子组件value的刷新，并回调@Monitor修饰的onValueChange回调方法，onValueChange将更新后的值赋值给localValue。 子组件Child改变localValue的值，不会同步给父组件Parent。 父组件Parent中再次改变value，将会继续通知给子组件，并覆写子组件本地localValue的值。 
@ComponentV2\nstruct Child {\n  @Local localValue: number = 0;\n  @Param value: number = 0;\n  @Monitor('value')\n  onValueChange(mon: IMonitor) {\n    console.info(`value has been changed from ${mon.value()?.before} to ${mon.value()?.now}`);\n    // 父组件value变化时，通知子组件value更新，回调Monitor函数，将更新的值覆写给本地的localValue\n    this.localValue = this.value;\n  }\n\n  build() {\n    Column() {\n      Text(`${this.localValue}`).fontSize(25)\n      Button('Child +100')\n        .onClick(() => {\n          // 改变localValue不会传递给父组件Parent\n          this.localValue += 100;\n        })\n    }\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Parent {\n  @Local value: number = 10;\n  build() {\n    Column() {\n      Button('Parent +1')\n        .onClick(() => {\n          // 改变value的值，通知子组件Child value更新\n          this.value += 1;\n        })\n      Child({ value: this.value })\n    }\n  }\n}
[h2]@ObjectLink/@Observed/@Track -> @ObservedV2/@Trace
迁移规则
在V1中，@Observed与@ObjectLink装饰器用于观察类对象及其嵌套属性的变化，但V1只能直接观察对象的第一层属性。对于嵌套对象的属性，必须通过自定义组件和@ObjectLink实现观察。此外，V1中提供了@Track装饰器来实现对属性级别变化的精确控制。
在V2中，@ObservedV2与@Trace结合使用，可以高效地实现类对象及其嵌套属性的深度观察，省去了对自定义组件的依赖，简化了开发流程。同时，@Trace装饰器还具备精确更新的能力，替代了V1中的@Track，从而实现更高效的UI刷新控制。根据不同的场景，有以下迁移策略：
 嵌套对象的属性观察：V1中需要通过自定义组件和@ObjectLink观察嵌套属性，V2中则可以使用@ObservedV2和@Trace直接观察嵌套对象，简化了代码结构。 类属性的精确更新：V1中的@Track可以用V2中的@Trace取代，@Trace可以同时观察和精确更新属性变化，使代码更简洁高效。 
示例
嵌套对象属性观察方法
在V1中，无法直接观察嵌套对象的属性变化，只能观察到第一层属性的变化。必须通过创建自定义组件并使用@ObjectLink来实现对嵌套属性的观察。V2中使用@ObservedV2和@Trace，可以直接对嵌套对象的属性进行深度观察，减少复杂度。
V1实现：
@Observed\nclass Address {\n  city: string;\n\n  constructor(city: string) {\n    this.city = city;\n  }\n}\n\n@Observed\nclass User {\n  name: string;\n  address: Address;\n\n  constructor(name: string, address: Address) {\n    this.name = name;\n    this.address = address;\n  }\n}\n\n@Component\nstruct AddressView {\n  // 子组件中@ObjectLink装饰的address从父组件初始化，接收被@Observed装饰的Address实例\n  @ObjectLink address: Address;\n\n  build() {\n    Column() {\n      Text(`City: ${this.address.city}`)\n      Button(\"city +a\")\n        .onClick(() => {\n          this.address.city += \"a\";\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct UserProfile {\n  @State user: User = new User(\"Alice\", new Address(\"New York\"));\n\n  build() {\n    Column() {\n      Text(`Name: ${this.user.name}`)\n      // 无法直接观察嵌套对象的属性变化，例如this.user.address.city\n      // 只能观察到对象第一层属性变化，所以需要将嵌套的对象Address抽取到自定义组件AddressView\n      AddressView({ address: this.user.address })\n    }\n  }\n}
V2迁移策略：使用@ObservedV2和@Trace
@ObservedV2\nclass Address {\n  @Trace city: string;\n\n  constructor(city: string) {\n    this.city = city;\n  }\n}\n\n@ObservedV2\nclass User {\n  @Trace name: string;\n  @Trace address: Address;\n\n  constructor(name: string, address: Address) {\n    this.name = name;\n    this.address = address;\n  }\n}\n\n@Entry\n@ComponentV2\nstruct UserProfile {\n  @Local user: User = new User(\"Alice\", new Address(\"New York\"));\n\n  build() {\n    Column() {\n      Text(`Name: ${this.user.name}`)\n      // 通过@ObservedV2和@Trace可以直接观察嵌套属性\n      Text(`City: ${this.user.address.city}`)\n      Button(\"city +a\")\n        .onClick(() => {\n          this.user.address.city += \"a\";\n        })\n    }\n  }\n}
类属性变化观测
在V1中，@Observed用于观察类实例及其属性的变化，@Track则用于对属性级别的变化优化，使得只有被@Track装饰的属性触发UI更新。在V2中，@Trace结合了观察和更新属性级别变化的能力，搭配@ObservedV2实现高效的UI更新。
V1实现：
@Observed\nclass User {\n  @Track name: string;\n  @Track age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\n@Entry\n@Component\nstruct UserProfile {\n  @State user: User = new User('Alice', 30);\n\n  build() {\n    Column() {\n      Text(`Name: ${this.user.name}`)\n      Text(`Age: ${this.user.age}`)\n      Button(\"increase age\")\n        .onClick(() => {\n          this.user.age++;\n        })\n    }\n  }\n}
V2迁移策略：使用@ObservedV2和@Trace
@ObservedV2\nclass User {\n  @Trace name: string;\n  @Trace age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\n@Entry\n@ComponentV2\nstruct UserProfile {\n  @Local user: User = new User('Alice', 30);\n\n  build() {\n    Column() {\n      Text(`Name: ${this.user.name}`)\n      Text(`Age: ${this.user.age}`)\n      Button(\"Increase age\")\n        .onClick(() => {\n          this.user.age++;\n        })\n    }\n  }\n}
[h2]@Provide/@Consume -> @Provider/@Consumer
迁移规则
V1的@Provide/@Consume和V2@Provider/@Consumer定位和作用大体类似，基本可以实现丝滑替换，但是有以下细微差距，开发者可根据自己代码实现来参考是否需要调整：
在V1中，@Provide和@Consume用于父子组件之间的数据共享，可以通过alias（别名）或属性名匹配，同时@Consume必须依赖父组件的@Provide，不允许本地初始化。而V2中，@Provider和@Consumer增强了这些特性，使数据共享更加灵活。根据不同的场景，有以下迁移策略：
 V1中@Provide/@Consume在没有指定alias的情况下，可以直接使用。V2中@Provider/@Consumer是标准装饰器，且参数可选，所以不管有无指定alias后面需要必须跟随“()”。 alias和属性名匹配规则：V1中，@Provide和@Consume可以通过alias或属性名匹配；V2中，alias是唯一的匹配key，指定alias后只能通过alias匹配。 本地初始化支持：V1中，@Consume不允许本地初始化，必须依赖父组件；V2中，@Consumer支持本地初始化，当找不到对应的@Provider时使用本地默认值。 从父组件初始化：V1中，@Provide可以直接从父组件初始化；V2中，@Provider不支持外部初始化，需用@Param和@Once接受初始值并赋给 @Provider。 重载支持：V1中，@Provide默认不支持重载，需设置 allowOverride；V2中，@Provider默认支持重载，@Consumer会向上查找最近的@Provider。 
示例
alias和属性名匹配规则
在V1中，@Provide和@Consume的匹配既可以通过alias，也可以通过属性名。在V2中，alias成为唯一的key，如果在@Consumer中制定了alias，只能通过alias而非属性名进行匹配。
V1实现:
@Component\nstruct Child {\n  // alias和属性名都为key，alias和属性名都可以匹配\n  @Consume('text') childMessage: string;\n  @Consume message: string;\n  build(){\n    Column(){\n      Text(this.childMessage)\n      Text(this.message) // Text是Hello World\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @Provide('text') message: string = \"Hello World\";\n  build(){\n    Column(){\n      Child()\n    }\n  }\n}
V2迁移策略：确保alias一致，没有指定alias的情况下，依赖属性名进行匹配
@ComponentV2\nstruct Child {\n  // alias是唯一匹配的key，有alias情况下无法通过属性名匹配\n  @Consumer('text') childMessage: string = \"default\";\n  @Consumer() message: string = \"default\";\n  build(){\n    Column(){\n      Text(this.childMessage)\n      Text(this.message) // Text是default\n    }\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Parent {\n  @Provider('text') message: string = \"Hello World\";\n  build(){\n    Column(){\n      Child()\n    }\n  }\n}
V1的@Consume不支持本地初始化，V2支持
V1中，@Consume不允许本地初始化变量，必须依赖父组件的@Provide，否则会抛出异常。迁移到V2后，@Consumer允许本地初始化，当找不到对应的@Provider，会使用本地默认值。
V1实现：
@Component\nstruct Child {\n  // @Consume禁止本地初始化，当找不到对应的@Provide时抛出异常\n  @Consume message: string;\n  build(){\n    Text(this.message)\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @Provide message: string = \"Hello World\";\n  build(){\n    Column(){\n      Child()\n    }\n  }\n}
V2迁移策略：@Consumer可以本地初始化
@ComponentV2\nstruct Child {\n  // @Consumer允许本地初始化，当找不到@Provider的时候使用本地默认值\n  @Consumer() message: string = \"Hello World\";\n  build(){\n    Text(this.message)\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Parent {\n  build(){\n    Column(){\n      Child()\n    }\n  }\n}
V1的@Provide可以从父组件初始化，V2不支持
在V1中，@Provide允许从父组件初始化，可以直接通过组件参数传递初始值。在V2中，@Provider禁止从外部初始化。为实现相同功能，可以在子组件中使用@Param @Once接受初始值，然后将其赋值给@Provider变量。
V1实现：
@Entry\n@Component\nstruct Parent {\n  @State parentValue: number = 42;\n  build() {\n    Column() {\n      // @Provide可以从父组件初始化\n      Child({ childValue: this.parentValue })\n    }\n  }\n}\n\n@Component\nstruct Child {\n  @Provide childValue: number = 0;\n  build(){\n    Column(){\n      Text(this.childValue.toString())\n    }\n  }\n}
V2迁移策略：使用@Param接受初始值，再赋值给@Provider
@Entry\n@ComponentV2\nstruct Parent {\n  @Local parentValue: number = 42;\n  build() {\n    Column() {\n      // @Provider禁止从父组件初始化，替代方案为先用@Param接受，再赋值给@Provider\n      Child({ initialValue: this.parentValue })\n    }\n  }\n}\n\n@ComponentV2\nstruct Child {\n  @Param @Once initialValue: number = 0;\n  @Provider() childValue: number = this.initialValue;\n  build() {\n    Column(){\n      Text(this.childValue.toString())\n    }\n  }\n}
V1的@Provide默认不支持重载，V2默认支持
在V1中，@Provide默认不支持重载，无法覆盖上层组件的同名@Provide。若需支持重载，必须设置allowOverride。在V2中，@Provider默认支持重载，@Consumer会向上查找最近的@Provider，无需额外设置。
V1实现:
@Entry\n@Component\nstruct GrandParent {\n  @Provide(\"reviewVotes\") reviewVotes: number = 40;\n  build() {\n    Column(){\n      Parent()\n    }\n  }\n}\n\n@Component\nstruct Parent {\n  // @Provide默认不支持重载，支持重载需设置allowOverride函数\n  @Provide({ allowOverride: \"reviewVotes\" }) reviewVotes: number = 20;\n  build() {\n    Child()\n  }\n}\n\n@Component\nstruct Child {\n  @Consume(\"reviewVotes\") reviewVotes: number;\n  build() {\n    Text(this.reviewVotes.toString()) // Text显示20\n  }\n}
V2迁移策略：去掉allowOverride
@Entry\n@ComponentV2\nstruct GrandParent {\n  @Provider(\"reviewVotes\") reviewVotes: number = 40;\n  build() {\n    Column(){\n      Parent()\n    }\n  }\n}\n\n@ComponentV2\nstruct Parent {\n  // @Provider默认支持重载，@Consumer向上查找最近的@Provider\n  @Provider() reviewVotes: number = 20;\n  build() {\n    Child()\n  }\n}\n\n@ComponentV2\nstruct Child {\n  @Consumer() reviewVotes: number = 0;\n  build() {\n    Text(this.reviewVotes.toString()) // Text显示20\n  }\n}
[h2]@Watch -> @Monitor
迁移规则
在V1中，@Watch用于监听状态变量的变化，并在变量变化时触发指定回调函数。在V2中，@Monitor替代了@Watch，可以更灵活地监听变量的变化，并获取变量变化前后的值。具体的迁移策略如下：
 单变量监听：对于简单的场景，可以直接用@Monitor替换@Watch，效果一致。 多变量监听：V1的@Watch无法获取变化前的值。在V2中，@Monitor支持同时监听多个变量，并可以访问变量变化前后的状态。 
示例
单变量监听
对于简单案例，V1的@Watch可以直接替换为替换为V2的@Monitor。
V1实现：
@Entry\n@Component\nstruct watchExample {\n  @State @Watch('onAppleChange') apple: number = 0;\n  onAppleChange(): void {\n    console.log(\"apple count changed to \"+this.apple);\n  }\n\n  build() {\n    Column(){\n      Text(`apple count: ${this.apple}`)\n      Button(\"add apple\")\n        .onClick(() => {\n          this.apple++;\n        })\n    }\n  }\n}
V2迁移策略：直接替换
@Entry\n@ComponentV2\nstruct monitorExample {\n  @Local apple: number = 0;\n  @Monitor('apple')\n  onFruitChange(monitor: IMonitor) {\n    console.log(`apple changed from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n\n  build() {\n    Column(){\n      Text(`apple count: ${this.apple}`)\n      Button(\"add apple\")\n        .onClick(()=> {\n          this.apple++;\n        })\n    }\n  }\n}
多变量监听
在V1中，每个@Watch回调函数只能监听一个变量，且无法获取变化前的值。迁移到V2后，可以使用一个@Monitor同时监听多个变量以及获取监听变量的变化前后的值。
V1实现：
@Entry\n@Component\nstruct watchExample {\n  @State @Watch('onAppleChange') apple: number = 0;\n  @State @Watch('onOrangeChange') orange: number = 0;\n  // @Watch 回调，只能监听单个变量，不能获取变化前的值\n  onAppleChange(): void {\n    console.log(\"apple count changed to \"+this.apple);\n  }\n  onOrangeChange(): void {\n    console.log(\"orange count changed to \"+this.orange);\n  }\n\n  build() {\n    Column(){\n      Text(`apple count: ${this.apple}`)\n      Text(`orange count: ${this.orange}`)\n      Button(\"add apple\")\n        .onClick(() => {\n          this.apple++;\n        })\n      Button(\"add orange\")\n        .onClick(() => {\n          this.orange++;\n        })\n    }\n  }\n}
V2迁移策略：同时监听多个变量，以及获取变化前的值
@Entry\n@ComponentV2\nstruct monitorExample {\n  @Local apple: number = 0;\n  @Local orange: number = 0;\n\n  // @Monitor回调，支持监听多个变量，可以获取变化前的值\n  @Monitor('apple','orange')\n  onFruitChange(monitor: IMonitor) {\n    monitor.dirty.forEach((name: string) => {\n      console.log(`${name} changed from ${monitor.value(name)?.before} to ${monitor.value(name)?.now}`);\n    });\n  }\n\n  build() {\n    Column() {\n      Text(`apple count: ${this.apple}`)\n      Text(`orange count: ${this.orange}`)\n      Button(\"add apple\")\n        .onClick(() => {\n          this.apple++;\n        })\n      Button(\"add orange\")\n        .onClick(() => {\n          this.orange++;\n        })\n    }\n  }\n}
[h2]@Computed
迁移规则
V1中并没有提供计算属性的概念，所以对于UI中的冗余计算，并没有办法可以减少重复计算。V2针对该场景，提供了@Computed装饰器，可以帮助开发者减少重复计算。
V1：
在下面的例子中，每次改变lastName都会触发Text组件的刷新，每次Text组件的刷新，都需要重复计算this.lastName + ' ' + this.firstName。
@Entry\n@Component\nstruct Index {\n  @State firstName: string = 'Li';\n  @State lastName: string = 'Hua';\n\n  build() {\n    Column() {\n      Text(this.lastName + ' ' + this.firstName)\n      Text(this.lastName + ' ' + this.firstName)\n      Button('changed lastName').onClick(() => {\n        this.lastName += 'a';\n      })\n\n    }\n  }\n}
V2:
使用V2中的@Computed，每次改变lastName仅会触发一次计算。
@Entry\n@ComponentV2\nstruct Index {\n  @Local firstName: string = 'Li';\n  @Local lastName: string = 'Hua';\n\n  @Computed\n  get fullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n\n  build() {\n    Column() {\n      Text(this.fullName)\n      Text(this.fullName)\n      Button('changed lastName').onClick(() => {\n        this.lastName += 'a';\n      })\n    }\n  }\n}
[h2]LocalStorage->全局@ObservedV2/@Trace
迁移规则
LocalStorage的目的是为了实现页面间的状态变量共享。之所以提供这个能力，是因为V1状态变量和View层耦合，无法由开发者自主地实现页面间状态变量的共享。
对于状态管理V2，状态变量的观察能力内嵌到数据本身，不再和View层耦合，所以对于状态管理V2，不再需要类似LocalStorage的能力，可以使用全局@ObservedV2/@Trace，由开发者自己import和export，自己实现状态变量的页面间共享。
示例
基本场景
V1:
通过windowStage.loadContent和getShared接口实现页面间的状态变量共享。
// EntryAbility.ets\nimport { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\n\nexport default class EntryAbility extends UIAbility {\n  para:Record<string, number> = { 'count': 47 };\n  storage: LocalStorage = new LocalStorage(this.para);\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    windowStage.loadContent('pages/Page1', this.storage);\n  }\n}
在下面的示例中，使用@LocalStorageLink，可以使得开发者本地的修改同步回LocalStorage中。
// Page1.ets\n// 通过getShared接口获取stage共享的LocalStorage实例\n@Entry(LocalStorage.getShared())\n@Component\nstruct Page1 {\n  @LocalStorageLink('count') count: number = 0;\n  pageStack: NavPathStack = new NavPathStack();\n  build() {\n    Navigation(this.pageStack) {\n      Column() {\n        Text(`${this.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.count++;\n          })\n        Button('push to Page2')\n          .onClick(() => {\n            this.pageStack.pushPathByName('Page2', null);\n          })\n      }\n    }\n  }\n}
// Page2.ets\n@Builder\nexport function Page2Builder() {\n  Page2()\n}\n\n// Page2组件获得了父亲Page1组件的LocalStorage实例\n@Component\nstruct Page2 {\n  @LocalStorageLink('count') count: number = 0;\n  pathStack: NavPathStack = new NavPathStack();\n  build() {\n    NavDestination() {\n      Column() {\n        Text(`${this.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.count++;\n          })\n      }\n    }\n    .onReady((context: NavDestinationContext) => {\n      this.pathStack = context.pathStack;\n    })\n  }\n}
使用Navigation时，需要添加配置系统路由表文件src/main/resources/base/profile/route_map.json，并替换pageSourceFile为Page2页面的路径，并且在module.json5中添加：\"routerMap\": \"$profile:route_map\"。
{\n  \"routerMap\": [\n    {\n      \"name\": \"Page2\",\n      \"pageSourceFile\": \"src/main/ets/pages/Page2.ets\",\n      \"buildFunction\": \"Page2Builder\",\n      \"data\": {\n        \"description\" : \"LocalStorage example\"\n      }\n    }\n  ]\n}
V2:
 声明@ObservedV2装饰的MyStorage类，并import需要使用的页面中。 声明被@Trace的属性作为页面间共享的可观察的数据。 
// Storage.ets\n@ObservedV2\nexport class MyStorage {\n  static singleton_: MyStorage;\n  static instance() {\n    if(!MyStorage.singleton_) {\n      MyStorage.singleton_ = new MyStorage();\n    };\n    return MyStorage.singleton_;\n  }\n  @Trace count: number = 47;\n}
// Page1.ets\nimport { MyStorage } from './storage';\n\n@Entry\n@ComponentV2\nstruct Page1 {\n  storage: MyStorage = MyStorage.instance();\n  pageStack: NavPathStack = new NavPathStack();\n  build() {\n    Navigation(this.pageStack) {\n      Column() {\n        Text(`${this.storage.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.storage.count++;\n          })\n        Button('push to Page2')\n          .onClick(() => {\n            this.pageStack.pushPathByName('Page2', null);\n          })\n      }\n    }\n  }\n}
// Page2.ets\nimport { MyStorage } from './storage';\n\n@Builder\nexport function Page2Builder() {\n  Page2()\n}\n\n@ComponentV2\nstruct Page2 {\n  storage: MyStorage = MyStorage.instance();\n  pathStack: NavPathStack = new NavPathStack();\n  build() {\n    NavDestination() {\n      Column() {\n        Text(`${this.storage.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.storage.count++;\n          })\n      }\n    }\n    .onReady((context: NavDestinationContext) => {\n      this.pathStack = context.pathStack;\n    })\n  }\n}
使用Navigation时，需要添加配置系统路由表文件src/main/resources/base/profile/route_map.json，并替换pageSourceFile为Page2页面的路径，并且在module.json5中添加：\"routerMap\": \"$profile:route_map\"。
{\n  \"routerMap\": [\n    {\n      \"name\": \"Page2\",\n      \"pageSourceFile\": \"src/main/ets/pages/Page2.ets\",\n      \"buildFunction\": \"Page2Builder\",\n      \"data\": {\n        \"description\" : \"LocalStorage example\"\n      }\n    }\n  ]\n}
如果开发者需要实现类似于@LocalStorageProp的效果，希望本地的修改不要同步回LocalStorage中，如以下示例:
 在Page1中改变count值，因为count是@LocalStorageProp装饰的，所以其改变只会在本地生效，并不会同步回LocalStorage。 点击push to Page2，跳转到Page2中。因为在Page1中改变count值并不会同步会LocalStorage，所以在Page2中Text组件依旧显示原本的值47。 点击change Storage Count，调用LocalStorage的setOrCreate，改变count对应的值，并通知所有绑定该key的变量。 
// Page1.ets\nexport let storage: LocalStorage = new LocalStorage();\nstorage.setOrCreate('count', 47);\n\n@Entry(storage)\n@Component\nstruct Page1 {\n  @LocalStorageProp('count') count: number = 0;\n  pageStack: NavPathStack = new NavPathStack();\n  build() {\n    Navigation(this.pageStack) {\n      Column() {\n        Text(`${this.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.count++;\n          })\n        Button('change Storage Count')\n          .onClick(() => {\n            storage.setOrCreate('count', storage.get<number>('count') as number + 100);\n          })\n        Button('push to Page2')\n          .onClick(() => {\n            this.pageStack.pushPathByName('Page2', null);\n          })\n      }\n    }\n  }\n}
// Page2.ets\nimport { storage } from './Page1'\n@Builder\nexport function Page2Builder() {\n  Page2()\n}\n\n// Page2组件获得了父亲Page1组件的LocalStorage实例\n@Component\nstruct Page2 {\n  @LocalStorageProp('count') count: number = 0;\n  pathStack: NavPathStack = new NavPathStack();\n  build() {\n    NavDestination() {\n      Column() {\n        Text(`${this.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.count++;\n          })\n        Button('change Storage Count')\n          .onClick(() => {\n            storage.setOrCreate('count', storage.get<number>('count') as number + 100);\n          })\n      }\n    }\n    .onReady((context: NavDestinationContext) => {\n      this.pathStack = context.pathStack;\n    })\n  }\n}
在V2中，可以借助@Local和@Monitor实现类似的效果。
 @Local装饰的count变量为组件本地的值，其改变不会同步回storage。 @Monitor监听storage.count的变化，当storage.count改变时，在@Monitor的回调里改变本地@Local的值。 
// Page1.ets\nimport { MyStorage } from './storage';\n\n@Entry\n@ComponentV2\nstruct Page1 {\n  storage: MyStorage = MyStorage.instance();\n  pageStack: NavPathStack = new NavPathStack();\n  @Local count: number = this.storage.count;\n\n  @Monitor('storage.count')\n  onCountChange(mon: IMonitor) {\n    console.log(`Page1 ${mon.value()?.before} to ${mon.value()?.now}`);\n    this.count = this.storage.count;\n  }\n  build() {\n    Navigation(this.pageStack) {\n      Column() {\n        Text(`${this.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.count++;\n          })\n        Button('change Storage Count')\n          .onClick(() => {\n            this.storage.count += 100;\n          })\n        Button('push to Page2')\n          .onClick(() => {\n            this.pageStack.pushPathByName('Page2', null);\n          })\n      }\n    }\n  }\n}
// Page2.ets\nimport { MyStorage } from './storage';\n\n@Builder\nexport function Page2Builder() {\n  Page2()\n}\n\n@ComponentV2\nstruct Page2 {\n  storage: MyStorage = MyStorage.instance();\n  pathStack: NavPathStack = new NavPathStack();\n  @Local count: number = this.storage.count;\n\n  @Monitor('storage.count')\n  onCountChange(mon: IMonitor) {\n    console.log(`Page2 ${mon.value()?.before} to ${mon.value()?.now}`);\n    this.count = this.storage.count;\n  }\n  build() {\n    NavDestination() {\n      Column() {\n        Text(`${this.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.count++;\n          })\n        Button('change Storage Count')\n          .onClick(() => {\n            this.storage.count += 100;\n          })\n      }\n    }\n    .onReady((context: NavDestinationContext) => {\n      this.pathStack = context.pathStack;\n    })\n  }\n}
自定义组件接收LocalStorage实例场景
为了配合Navigation的场景，LocalStorage支持作为自定义组件的入参，传递给以当前自定义组件为根节点的所有子自定义组件。
对于该场景，V2可以采用多个全局@ObservedV2/@Trace实例来替代。
V1:
let localStorageA: LocalStorage = new LocalStorage();\nlocalStorageA.setOrCreate('PropA', 'PropA');\n\nlet localStorageB: LocalStorage = new LocalStorage();\nlocalStorageB.setOrCreate('PropB', 'PropB');\n\nlet localStorageC: LocalStorage = new LocalStorage();\nlocalStorageC.setOrCreate('PropC', 'PropC');\n\n@Entry\n@Component\nstruct MyNavigationTestStack {\n  @Provide('pageInfo') pageInfo: NavPathStack = new NavPathStack();\n\n  @Builder\n  PageMap(name: string) {\n    if (name === 'pageOne') {\n      // 传递不同的LocalStorage实例\n      pageOneStack({}, localStorageA)\n    } else if (name === 'pageTwo') {\n      pageTwoStack({}, localStorageB)\n    } else if (name === 'pageThree') {\n      pageThreeStack({}, localStorageC)\n    }\n  }\n\n  build() {\n    Column({ space: 5 }) {\n      Navigation(this.pageInfo) {\n        Column() {\n          Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n            .width('80%')\n            .height(40)\n            .margin(20)\n            .onClick(() => {\n              this.pageInfo.pushPath({ name: 'pageOne' }); //将name指定的NavDestination页面信息入栈\n            })\n        }\n      }.title('NavIndex')\n      .navDestination(this.PageMap)\n      .mode(NavigationMode.Stack)\n      .borderWidth(1)\n    }\n  }\n}\n\n@Component\nstruct pageOneStack {\n  @Consume('pageInfo') pageInfo: NavPathStack;\n  @LocalStorageLink('PropA') PropA: string = 'Hello World';\n\n  build() {\n    NavDestination() {\n      Column() {\n        // 显示'PropA'\n        NavigationContentMsgStack()\n        // 显示'PropA'\n        Text(`${this.PropA}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageTwo', null);\n          })\n      }.width('100%').height('100%')\n    }.title('pageOne')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@Component\nstruct pageTwoStack {\n  @Consume('pageInfo') pageInfo: NavPathStack;\n  @LocalStorageLink('PropB') PropB: string = 'Hello World';\n\n  build() {\n    NavDestination() {\n      Column() {\n        // 显示'Hello'，当前LocalStorage实例localStorageB没有PropA对应的值，使用本地默认值'Hello'\n        NavigationContentMsgStack()\n        // 显示'PropB'\n        Text(`${this.PropB}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageThree', null);\n          })\n\n      }.width('100%').height('100%')\n    }.title('pageTwo')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@Component\nstruct pageThreeStack {\n  @Consume('pageInfo') pageInfo: NavPathStack;\n  @LocalStorageLink('PropC') PropC: string = 'pageThreeStack';\n\n  build() {\n    NavDestination() {\n      Column() {\n        // 显示'Hello'，当前LocalStorage实例localStorageC没有PropA对应的值，使用本地默认值'Hello'\n        NavigationContentMsgStack()\n        // 显示'PropC'\n        Text(`${this.PropC}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageOne', null);\n          })\n\n      }.width('100%').height('100%')\n    }.title('pageThree')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@Component\nstruct NavigationContentMsgStack {\n  @LocalStorageLink('PropA') PropA: string = 'Hello';\n\n  build() {\n    Column() {\n      Text(`${this.PropA}`)\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold)\n    }\n  }\n}
V2：
声明@ObservedV2装饰的class代替LocalStorage。其中LocalStorage的key可以用@Trace装饰的属性代替。
// Storage.ets\n@ObservedV2\nexport class MyStorageA {\n  @Trace propA: string = 'Hello';\n  constructor(propA?: string) {\n      this.propA = propA? propA : this.propA;\n  }\n}\n\n@ObservedV2\nexport class MyStorageB extends MyStorageA {\n  @Trace propB: string = 'Hello';\n  constructor(propB: string) {\n    super();\n    this.propB = propB;\n  }\n}\n\n@ObservedV2\nexport class MyStorageC extends MyStorageA {\n  @Trace propC: string = 'Hello';\n  constructor(propC: string) {\n    super();\n    this.propC = propC;\n  }\n}
在pageOneStack、pageTwoStack和pageThreeStack组件内分别创建MyStorageA、MyStorageB、MyStorageC的实例，并通过@Param传递给其子组件NavigationContentMsgStack，从而实现类似LocalStorage实例在子组件树上共享的能力。
// Index.ets\nimport { MyStorageA, MyStorageB, MyStorageC } from './storage';\n\n@Entry\n@ComponentV2\nstruct MyNavigationTestStack {\n   pageInfo: NavPathStack = new NavPathStack();\n\n  @Builder\n  PageMap(name: string) {\n    if (name === 'pageOne') {\n      pageOneStack()\n    } else if (name === 'pageTwo') {\n      pageTwoStack()\n    } else if (name === 'pageThree') {\n      pageThreeStack()\n    }\n  }\n\n  build() {\n    Column({ space: 5 }) {\n      Navigation(this.pageInfo) {\n        Column() {\n          Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n            .width('80%')\n            .height(40)\n            .margin(20)\n            .onClick(() => {\n              this.pageInfo.pushPath({ name: 'pageOne' }); //将name指定的NavDestination页面信息入栈\n            })\n        }\n      }.title('NavIndex')\n      .navDestination(this.PageMap)\n      .mode(NavigationMode.Stack)\n      .borderWidth(1)\n    }\n  }\n}\n\n@ComponentV2\nstruct pageOneStack {\n  pageInfo: NavPathStack = new NavPathStack();\n  @Local storageA: MyStorageA = new MyStorageA('PropA');\n\n  build() {\n    NavDestination() {\n      Column() {\n        // 显示'PropA'\n        NavigationContentMsgStack({storage: this.storageA})\n        // 显示'PropA'\n        Text(`${this.storageA.propA}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageTwo', null);\n          })\n      }.width('100%').height('100%')\n    }.title('pageOne')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n    .onReady((context: NavDestinationContext) => {\n      this.pageInfo = context.pathStack;\n    })\n  }\n}\n\n@ComponentV2\nstruct pageTwoStack {\n  pageInfo: NavPathStack = new NavPathStack();\n  @Local storageB: MyStorageB = new MyStorageB('PropB');\n\n  build() {\n    NavDestination() {\n      Column() {\n        // 显示'Hello'\n        NavigationContentMsgStack({ storage: this.storageB })\n        // 显示'PropB'\n        Text(`${this.storageB.propB}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageThree', null);\n          })\n\n      }.width('100%').height('100%')\n    }.title('pageTwo')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n    .onReady((context: NavDestinationContext) => {\n      this.pageInfo = context.pathStack;\n    })\n  }\n}\n\n@ComponentV2\nstruct pageThreeStack {\n  pageInfo: NavPathStack = new NavPathStack();\n  @Local storageC: MyStorageC = new MyStorageC(\"PropC\");\n\n  build() {\n    NavDestination() {\n      Column() {\n        // 显示'Hello'\n        NavigationContentMsgStack({ storage: this.storageC })\n        // 显示'PropC'\n        Text(`${this.storageC.propC}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageOne', null);\n          })\n\n      }.width('100%').height('100%')\n    }.title('pageThree')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n    .onReady((context: NavDestinationContext) => {\n      this.pageInfo = context.pathStack;\n    })\n  }\n}\n\n@ComponentV2\nstruct NavigationContentMsgStack {\n  @Require@Param storage: MyStorageA;\n\n  build() {\n    Column() {\n      Text(`${this.storage.propA}`)\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold)\n    }\n  }\n}
[h2]AppStorage->AppStorageV2
上一小节中，对于全局的@ObserveV2/@Trace的改造并不适合跨Ability的数据共享，该场景可以使用AppStorageV2来替换。
V1:
AppStorage是和应用进程绑定了，可以跨Ability实现数据共享。
在下面的示例中，使用@StorageLink，可以使得开发者本地的修改同步回AppStorage中。
// EntryAbility Index.ets\nimport { common, Want } from '@kit.AbilityKit';\n@Entry\n@Component\nstruct Index {\n  @StorageLink('count') count: number = 0;\n  private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;\n  build() {\n    Column() {\n      Text(`EntryAbility count: ${this.count}`)\n        .fontSize(50)\n        .onClick(() => {\n          this.count++;\n        })\n      Button('Jump to EntryAbility1').onClick(() => {\n        let wantInfo: Want = {\n          bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName\n          abilityName: 'EntryAbility1'\n        };\n        this.context.startAbility(wantInfo);\n      })\n    }\n  }\n}
// EntryAbility1 Index1.ets\nimport { common, Want } from '@kit.AbilityKit';\n@Entry\n@Component\nstruct Index1 {\n  @StorageLink('count') count: number = 0;\n  private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;\n  build() {\n    Column() {\n      Text(`EntryAbility1 count: ${this.count}`)\n        .fontSize(50)\n        .onClick(() => {\n          this.count++;\n        })\n      Button('Jump to EntryAbility').onClick(() => {\n        let wantInfo: Want = {\n          bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName\n          abilityName: 'EntryAbility'\n        };\n        this.context.startAbility(wantInfo);\n      })\n    }\n  }\n}
V2:
可以使用AppStorageV2实现跨Ability共享。
如下面示例：
import { common, Want } from '@kit.AbilityKit';\nimport { AppStorageV2 } from '@kit.ArkUI';\n\n@ObservedV2\nexport class MyStorage {\n  @Trace count: number = 0\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  @Local storage: MyStorage = AppStorageV2.connect(MyStorage, 'storage', () => new MyStorage())!;\n  private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;\n  build() {\n    Column() {\n      Text(`EntryAbility1 count: ${this.storage.count}`)\n        .fontSize(50)\n        .onClick(() => {\n          this.storage.count++;\n        })\n      Button('Jump to EntryAbility1').onClick(() => {\n        let wantInfo: Want = {\n          bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName\n          abilityName: 'EntryAbility1'\n        };\n        this.context.startAbility(wantInfo);\n      })\n    }\n  }\n}
import { common, Want } from '@kit.AbilityKit';\nimport { AppStorageV2 } from '@kit.ArkUI';\n\n@ObservedV2\nexport class MyStorage {\n  @Trace count: number = 0\n}\n\n@Entry\n@ComponentV2\nstruct Index1 {\n  @Local storage: MyStorage = AppStorageV2.connect(MyStorage, 'storage', () => new MyStorage())!;\n  private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;\n    build() {\n      Column() {\n        Text(`EntryAbility1 count: ${this.storage.count}`)\n          .fontSize(50)\n          .onClick(() => {\n            this.storage.count++;\n          })\n        Button('Jump to EntryAbility').onClick(() => {\n          let wantInfo: Want = {\n            bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName\n            abilityName: 'EntryAbility'\n          };\n          this.context.startAbility(wantInfo);\n        })\n      }\n    }\n}
如果开发者需要实现类似于@StorageProp的效果，希望本地的修改不要同步回AppStorage中，而AppStorage的变化又可以通知给使用@StorageProp装饰器的组件，可以参考以下示例对比。
V1：
// EntryAbility Index.ets\nimport { common, Want } from '@kit.AbilityKit';\n@Entry\n@Component\nstruct Index {\n  @StorageProp('count') count: number = 0;\n  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;\n  build() {\n    Column() {\n      Text(`EntryAbility count: ${this.count}`)\n        .fontSize(25)\n        .onClick(() => {\n          this.count++;\n        })\n      Button('change Storage Count')\n        .onClick(() => {\n          AppStorage.setOrCreate('count', AppStorage.get<number>('count') as number + 100);\n        })\n      Button('Jump to EntryAbility1').onClick(() => {\n        let wantInfo: Want = {\n          bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName\n          abilityName: 'EntryAbility1'\n        };\n        this.context.startAbility(wantInfo);\n      })\n    }\n  }\n}
// EntryAbility1 Index1.ets\nimport { common, Want } from '@kit.AbilityKit';\n@Entry\n@Component\nstruct Index1 {\n  @StorageProp('count') count: number = 0;\n  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;\n  build() {\n    Column() {\n      Text(`EntryAbility1 count: ${this.count}`)\n        .fontSize(50)\n        .onClick(() => {\n          this.count++;\n        })\n      Button('change Storage Count')\n        .onClick(() => {\n          AppStorage.setOrCreate('count', AppStorage.get<number>('count') as number + 100);\n        })\n      Button('Jump to EntryAbility').onClick(() => {\n        let wantInfo: Want = {\n          bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName\n          abilityName: 'EntryAbility'\n        };\n        this.context.startAbility(wantInfo);\n      })\n    }\n  }\n}
V2:
开发者可以借助@Monitor和@Local来实现类似的效果，示例如下。
import { common, Want } from '@kit.AbilityKit';\nimport { AppStorageV2 } from '@kit.ArkUI';\n\n@ObservedV2\nexport class MyStorage {\n  @Trace count: number = 0;\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  @Local storage: MyStorage = AppStorageV2.connect(MyStorage, 'storage', () => new MyStorage())!;\n  @Local count: number = this.storage.count;\n  private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;\n\n  @Monitor('storage.count')\n  onCountChange(mon: IMonitor) {\n    console.log(`Index1 ${mon.value()?.before} to ${mon.value()?.now}`);\n    this.count = this.storage.count;\n  }\n  build() {\n    Column() {\n      Text(`EntryAbility1 count: ${this.count}`)\n        .fontSize(25)\n        .onClick(() => {\n          this.count++;\n        })\n      Button('change Storage Count')\n        .onClick(() => {\n          this.storage.count += 100;\n        })\n      Button('Jump to EntryAbility1').onClick(() => {\n        let wantInfo: Want = {\n          bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName\n          abilityName: 'EntryAbility1'\n        };\n        this.context.startAbility(wantInfo);\n      })\n    }\n  }\n}
import { common, Want } from '@kit.AbilityKit';\nimport { AppStorageV2 } from '@kit.ArkUI';\n\n@ObservedV2\nexport class MyStorage {\n  @Trace count: number = 0;\n}\n\n@Entry\n@ComponentV2\nstruct Index1 {\n  @Local storage: MyStorage = AppStorageV2.connect(MyStorage, 'storage', () => new MyStorage())!;\n  @Local count: number = this.storage.count;\n  private context: common.UIAbilityContext= getContext(this) as common.UIAbilityContext;\n\n  @Monitor('storage.count')\n  onCountChange(mon: IMonitor) {\n    console.log(`Index1 ${mon.value()?.before} to ${mon.value()?.now}`);\n    this.count = this.storage.count;\n  }\n\n  build() {\n    Column() {\n      Text(`EntryAbility1 count: ${this.count}`)\n        .fontSize(25)\n        .onClick(() => {\n          this.count++;\n        })\n      Button('change Storage Count')\n        .onClick(() => {\n          this.storage.count += 100;\n        })\n      Button('Jump to EntryAbility').onClick(() => {\n        let wantInfo: Want = {\n          bundleName: 'com.example.myapplication', // 替换成AppScope/app.json5里的bundleName\n          abilityName: 'EntryAbility'\n        };\n        this.context.startAbility(wantInfo);\n      })\n    }\n  }\n}
[h2]Environment->调用Ability接口直接获取系统环境变量
V1中，开发者可以通过Environment来获取环境变量，但Environment获取的结果无法直接使用，需要配合AppStorage才能得到对应环境变量的值。
在切换V2的过程中，开发者无需再通过Environment来获取环境变量，可以直接通过UIAbilityContext的config属性获取系统环境变量。
V1:
以languageCode为例。
// 将设备languageCode存入AppStorage中\nEnvironment.envProp('languageCode', 'en');\n\n@Entry\n@Component\nstruct Index {\n  @StorageProp('languageCode') languageCode: string = 'en';\n  build() {\n    Row() {\n      Column() {\n        // 输出当前设备的languageCode\n        Text(this.languageCode)\n      }\n    }\n  }\n}
V2:
封装Env类型来传递多个系统环境变量。
// Env.ts\nimport { ConfigurationConstant } from '@kit.AbilityKit';\n\nexport class Env {\n  language: string | undefined;\n  colorMode: ConfigurationConstant.ColorMode | undefined;\n  fontSizeScale: number | undefined;\n  fontWeightScale: number | undefined;\n}\n\nexport let env: Env = new Env();
在onCreate里获得需要的系统环境变量：
// EntryAbility.ets\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nimport { env } from '../pages/Env';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    env.language = this.context.config.language;\n    env.colorMode = this.context.config.colorMode;\n    env.fontSizeScale = this.context.config.fontSizeScale;\n    env.fontWeightScale = this.context.config.fontWeightScale;\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    windowStage.loadContent('pages/Index');\n  }\n}
在页面中获得当前Env的值。
// Index.ets\nimport { env } from '../pages/Env';\n\n@Entry\n@ComponentV2\nstruct Index {\n  build() {\n    Row() {\n      Column() {\n        // 输出当前设备的环境变量\n        Text(`languageCode: ${env.language}`).fontSize(20)\n        Text(`colorMode: ${env.colorMode}`).fontSize(20)\n        Text(`fontSizeScale: ${env.fontSizeScale}`).fontSize(20)\n        Text(`fontWeightScale: ${env.fontWeightScale}`).fontSize(20)\n      }\n    }\n  }\n}
[h2]PersistentStorage->PersistenceV2
V1中PersistentStorage提供了持久化UI数据的能力，而V2则提供了更加方便使用的PersistenceV2接口来替代它。
 PersistentStorage持久化的触发时机依赖AppStorage的观察能力，且与AppStorage耦合，开发者无法自主选择写入或读取持久化数据的时机。 PersistentStorage使用序列化和反序列化，并没有传入类型，所以在持久化后，会丢失其类型，且对象的属性方法不能持久化。 
对于PersistenceV2：
 与PersistenceV2关联的@ObservedV2对象，其@Trace属性的变化，会触发整个关联对象的自动持久化。 开发者也可以调用PersistenceV2.save和PersistenceV2.connect接口来手动触发持久化写入和读取。 
V1:
PersistentStorage.persistProp('aProp', 47);\n\n@Entry\n@Component\nstruct Index {\n  @StorageLink('aProp') aProp: number = 48;\n\n  build() {\n    Row() {\n      Column() {\n        // 应用退出时会保存当前结果。重新启动后，会显示上一次的保存结果\n        Text(`${this.aProp}`)\n          .onClick(() => {\n            this.aProp += 1;\n          })\n      }\n    }\n  }\n}
V2:
下面的案例展示了：
 对标V1的PersistentStorage能力：aProp的改变自动触发PersistenceV2的持久化。 对比V1的PersistentStorage能力增强：bProp是非状态变量，其变化不能被观察和监听，但是开发者仍然可以主动调用PersistenceV2.save接口，进行持久化。        点击aProp，UI刷新。 点击bProp，UI没有刷新。 点击save storage，触发PersistentStorage链接数据的落盘。 退出重启应用，Text组件显示的aProp和bProp为上次改变的值。  
import { PersistenceV2 } from '@kit.ArkUI';\n// 数据中心\n@ObservedV2\nclass Storage {\n  @Trace aProp: number = 0;\n  bProp: number = 10;\n}\n\n// 接受序列化失败的回调\nPersistenceV2.notifyOnError((key: string, reason: string, msg: string) => {\n  console.error(`error key: ${key}, reason: ${reason}, message: ${msg}`);\n});\n\n@Entry\n@ComponentV2\nstruct Page1 {\n  // 在PersistenceV2中创建一个key为Sample的键值对（如果存在，则返回PersistenceV2中的数据），并且和prop关联\n  @Local storage: Storage = PersistenceV2.connect(Storage, () => new Storage())!;\n\n  build() {\n    Column() {\n      Text(`@Trace aProp: ${this.storage.aProp}`)\n        .fontSize(30)\n        .onClick(() => {\n          this.storage.aProp++;\n        })\n\n      Text(`bProp:: ${this.storage.bProp}`)\n        .fontSize(30)\n        .onClick(() => {\n          // 页面不刷新，但是bProp的值改变了\n          this.storage.bProp++;\n        })\n\n      Button('save storage')\n        .onClick(() => {\n          // 和V1不同，PersistenceV2不依赖状态变量的观察能力，开发者可以主动持久化\n          PersistenceV2.save(Storage);\n        })\n    }\n  }\n}
存量迁移场景
对于已经使用V1开发的大型应用，一般不太可能做到一次性的从V1迁移到V2，而是分批次和分组件的部分迁移，这就必然会带来V1和V2的混用。
这种场景，一般是父组件是状态管理V1，而迁移的子组件为状态管理V2。为了模拟这种场景，我们举出下面的示例：
 父组件是@Component，数据源是@LocalStorageLink。 子组件是@ComponentV2，使用@Param接受数据源的数据。 
这种情况，我们可以通过以下策略进行迁移：
 声明一个@ObservedV2装饰的class来封装V1的数据。 在@Component和@ComponentV2之间，定义一个桥接的@Component自定义组件。 在桥接层：        V1->V2的数据同步，可通过@Watch的监听触发@ObservedV2装饰的class的属性的赋值。 V2->V1的数据同步，可通过在@ObservedV2装饰的class里声明Monitor，通过LocalStorage的API反向通知给V1状态变量。  
具体示例如下：
let storage: LocalStorage = new LocalStorage();\n\n@ObservedV2\nclass V1StorageData {\n  @Trace title: string = 'V1OldComponent'\n  @Monitor('title')\n  onStrChange(monitor: IMonitor) {\n    monitor.dirty.forEach((path: string) => {\n      console.log(`${path} changed from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`)\n      if (path === 'title') {\n        storage.setOrCreate('title', this.title);\n      }\n    })\n  }\n}\nlet v1Data: V1StorageData = new V1StorageData();\n\n@Entry(storage)\n@Component\nstruct V1OldComponent {\n  @LocalStorageLink('title') title: string = 'V1OldComponent';\n\n  build() {\n    Column() {\n      Text(`V1OldComponent: ${this.title}`)\n        .fontSize(20)\n        .onClick(() => {\n          this.title = 'new value from V1OldComponent';\n        })\n      Bridge()\n    }\n  }\n}\n\n\n@Component\nstruct Bridge {\n  @LocalStorageLink('title')@Watch('titleWatch') title: string = 'Bridge';\n  titleWatch() {\n    v1Data.title = this.title;\n  }\n\n  build() {\n    NewV2Component()\n  }\n}\n@ComponentV2\nstruct NewV2Component {\n  build() {\n    Column() {\n      Text(`NewV2Component: ${v1Data.title}`)\n        .fontSize(20)\n        .onClick(() => {\n          v1Data.title = 'NewV2Component';\n        })\n    }\n  }\n}
其他迁移场景
[h2]滑动组件
List
开发者可以通过ChildrenMainSize来设置List的子组件在主轴方向的大小信息。
V1：
在状态管理V1中，可以通过@State装饰观察其api调用。
具体示例如下：
@Entry\n@Component\nstruct ListExample {\n  private arr: Array<number> = new Array(10).fill(0);\n  private scroller: ListScroller = new ListScroller();\n  @State listSpace: number = 10;\n  @State listChildrenSize: ChildrenMainSize = new ChildrenMainSize(100);\n\n  build() {\n    Column() {\n      Button('change Default').onClick(() => {\n        this.listChildrenSize.childDefaultSize += 10;\n      })\n\n      Button('splice 5').onClick(() => {\n        this.listChildrenSize.splice(0, 5, [100, 100, 100, 100, 100]);\n      })\n\n      Button('update 5').onClick(() => {\n        this.listChildrenSize.update(0, 200);\n      })\n\n      List({ space: this.listSpace, scroller: this.scroller }) {\n        ForEach(this.arr, (item: number) => {\n          ListItem() {\n            Text(`item-` + item)\n          }.backgroundColor(Color.Pink)\n        })\n      }\n      .childrenMainSize(this.listChildrenSize) // 10\n    }\n  }\n}
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，又因为ChildrenMainSize定义在框架中，开发者无法使用@Trace来标注ChildrenMainSize的属性，此时可以使用makeObserved替代。
具体示例如下：
import { UIUtils } from '@kit.ArkUI';\n\n@Entry\n@ComponentV2\nstruct ListExample {\n  private arr: Array<number> = new Array(10).fill(0);\n  private scroller: ListScroller = new ListScroller();\n  listSpace: number = 10;\n  // 使用makeObserved的能力来观测ChildrenMainSize\n  listChildrenSize: ChildrenMainSize = UIUtils.makeObserved(new ChildrenMainSize(100));\n\n  build() {\n    Column() {\n      Button('change Default').onClick(() => {\n        this.listChildrenSize.childDefaultSize += 10;\n      })\n\n      Button('splice 5').onClick(() => {\n        this.listChildrenSize.splice(0, 5, [100, 100, 100, 100, 100]);\n      })\n\n      Button('update 5').onClick(() => {\n        this.listChildrenSize.update(0, 200);\n      })\n\n      List({ space: this.listSpace, scroller: this.scroller }) {\n        ForEach(this.arr, (item: number) => {\n          ListItem() {\n            Text(`item-` + item)\n          }.backgroundColor(Color.Pink)\n        })\n      }\n      .childrenMainSize(this.listChildrenSize) // 10\n    }\n  }\n}
WaterFlow
开发者可以通过WaterFlowSections来设置WaterFlow瀑布流分组信息。
需要注意的是，数组arr的长度需要与WaterFlowSections的中所有SectionOptions的itemsCount的总和保持一致，否则WaterFlow无法处理，导致UI不刷新。
以下两个示例请按照'push option' -> 'splice option' -> 'update option'的顺序进行点击。
V1：
在状态管理V1中，可以通过@State装饰观察其api调用。
具体示例如下：
@Entry\n@Component\nstruct WaterFlowSample {\n  @State colors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Blue, Color.Pink];\n  @State sections: WaterFlowSections = new WaterFlowSections();\n  scroller: Scroller = new Scroller();\n  @State private arr: Array<number> = new Array(9).fill(0);\n  oneColumnSection: SectionOptions = {\n    itemsCount: 4,\n    crossCount: 1,\n    columnsGap: '5vp',\n    rowsGap: 10,\n  };\n  twoColumnSection: SectionOptions = {\n    itemsCount: 2,\n    crossCount: 2,\n  };\n  lastSection: SectionOptions = {\n    itemsCount: 3,\n    crossCount: 3,\n  };\n\n  aboutToAppear(): void {\n    let sectionOptions: SectionOptions[] = [this.oneColumnSection, this.twoColumnSection, this.lastSection];\n    this.sections.splice(0, 0, sectionOptions);\n  }\n\n  build() {\n    Column() {\n      Text(`${this.arr.length}`)\n\n      Button('push option').onClick(() => {\n        let section: SectionOptions = {\n          itemsCount: 1,\n          crossCount: 1,\n        };\n        this.sections.push(section);\n        this.arr.push(100);\n      })\n\n      Button('splice option').onClick(() => {\n        let section: SectionOptions = {\n          itemsCount: 8,\n          crossCount: 2,\n        };\n        this.sections.splice(0, this.arr.length, [section]);\n        this.arr = new Array(8).fill(10);\n      })\n\n      Button('update option').onClick(() => {\n        let section: SectionOptions = {\n          itemsCount: 8,\n          crossCount: 2,\n        };\n        this.sections.update(1, section);\n        this.arr = new Array(16).fill(1);\n      })\n\n      WaterFlow({ scroller: this.scroller, sections: this.sections }) {\n        ForEach(this.arr, (item: number) => {\n          FlowItem() {\n            Text(`${item}`)\n              .border({ width: 1 })\n              .backgroundColor(this.colors[item % 6])\n              .height(30)\n              .width(50)\n          }\n        })\n      }\n    }\n  }\n}
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，又因为WaterFlowSections定义在框架中，开发者无法使用@Trace来标注WaterFlowSections的属性，此时可以使用makeObserved替代。
具体示例如下：
import { UIUtils } from '@kit.ArkUI';\n\n@Entry\n@ComponentV2\nstruct WaterFlowSample {\n  colors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Blue, Color.Pink];\n  // 使用makeObserved的能力来观测WaterFlowSections\n  sections: WaterFlowSections = UIUtils.makeObserved(new WaterFlowSections());\n  scroller: Scroller = new Scroller();\n  @Local private arr: Array<number> = new Array(9).fill(0);\n  oneColumnSection: SectionOptions = {\n    itemsCount: 4,\n    crossCount: 1,\n    columnsGap: '5vp',\n    rowsGap: 10,\n  };\n  twoColumnSection: SectionOptions = {\n    itemsCount: 2,\n    crossCount: 2,\n  };\n  lastSection: SectionOptions = {\n    itemsCount: 3,\n    crossCount: 3,\n  };\n\n  aboutToAppear(): void {\n    let sectionOptions: SectionOptions[] = [this.oneColumnSection, this.twoColumnSection, this.lastSection];\n    this.sections.splice(0, 0, sectionOptions);\n  }\n\n  build() {\n    Column() {\n      Text(`${this.arr.length}`)\n\n      Button('push option').onClick(() => {\n        let section: SectionOptions = {\n          itemsCount: 1,\n          crossCount: 1,\n        };\n        this.sections.push(section);\n        this.arr.push(100);\n      })\n\n      Button('splice option').onClick(() => {\n        let section: SectionOptions = {\n          itemsCount: 8,\n          crossCount: 2,\n        };\n        this.sections.splice(0, this.arr.length, [section]);\n        this.arr = new Array(8).fill(10);\n      })\n\n      Button('update option').onClick(() => {\n        let section: SectionOptions = {\n          itemsCount: 8,\n          crossCount: 2,\n        };\n        this.sections.update(1, section);\n        this.arr = new Array(16).fill(1);\n      })\n\n      WaterFlow({ scroller: this.scroller, sections: this.sections }) {\n        ForEach(this.arr, (item: number) => {\n          FlowItem() {\n            Text(`${item}`)\n              .border({ width: 1 })\n              .backgroundColor(this.colors[item % 6])\n              .height(30)\n              .width(50)\n          }\n        })\n      }\n    }\n  }\n}
[h2]Modifier
attributeModifier
开发者可以通过attributeModifier动态设置组件的属性方法。
V1：
在状态管理V1中，可以通过@State装饰观察其变化。
具体示例如下：
class MyButtonModifier implements AttributeModifier<ButtonAttribute> {\n  isDark: boolean = false;\n\n  applyNormalAttribute(instance: ButtonAttribute): void {\n    if (this.isDark) {\n      instance.backgroundColor(Color.Black);\n    } else {\n      instance.backgroundColor(Color.Red);\n    }\n  }\n}\n\n@Entry\n@Component\nstruct AttributeDemo {\n  @State modifier: MyButtonModifier = new MyButtonModifier();\n\n  build() {\n    Row() {\n      Column() {\n        Button('Button')\n          .attributeModifier(this.modifier)\n          .onClick(() => {\n            this.modifier.isDark = !this.modifier.isDark;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，如果要观察attributeModifier的属性变化，可以使用makeObserved替代。
具体示例如下：
import { UIUtils } from '@kit.ArkUI';\n\nclass MyButtonModifier implements AttributeModifier<ButtonAttribute> {\n  isDark: boolean = false;\n\n  applyNormalAttribute(instance: ButtonAttribute): void {\n    if (this.isDark) {\n      instance.backgroundColor(Color.Black);\n    } else {\n      instance.backgroundColor(Color.Red);\n    }\n  }\n}\n\n@Entry\n@ComponentV2\nstruct AttributeDemo {\n  // 使用makeObserved的能力观测attributeModifier的属性this.modifier\n  modifier: MyButtonModifier = UIUtils.makeObserved(new MyButtonModifier());\n\n  build() {\n    Row() {\n      Column() {\n        Button('Button')\n          .attributeModifier(this.modifier)\n          .onClick(() => {\n            this.modifier.isDark = !this.modifier.isDark;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
CommonModifier
动态设置组件的属性类。以CommonModifier为例。
V1：
在状态管理V1中，可以通过@State装饰观察其变化。
具体实例如下：
import { CommonModifier } from '@ohos.arkui.modifier';\n\nclass MyModifier extends CommonModifier {\n  applyNormalAttribute(instance: CommonAttribute): void {\n    super.applyNormalAttribute?.(instance);\n  }\n\n  public setGroup1(): void {\n    this.borderStyle(BorderStyle.Dotted);\n    this.borderWidth(8);\n  }\n\n  public setGroup2(): void {\n    this.borderStyle(BorderStyle.Dashed);\n    this.borderWidth(8);\n  }\n}\n\n@Component\nstruct MyImage1 {\n  @Link modifier: CommonModifier;\n\n  build() {\n    // 此处'app.media.app_icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。\n    Image($r('app.media.app_icon'))\n      .attributeModifier(this.modifier as MyModifier)\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State myModifier: CommonModifier = new MyModifier().width(100).height(100).margin(10);\n  index: number = 0;\n\n  build() {\n    Column() {\n      Button($r('app.string.EntryAbility_label'))\n        .margin(10)\n        .onClick(() => {\n          console.log('Modifier', 'onClick');\n          this.index++;\n          if (this.index % 2 === 1) {\n            (this.myModifier as MyModifier).setGroup1();\n            console.log('Modifier', 'setGroup1');\n          } else {\n            (this.myModifier as MyModifier).setGroup2();\n            console.log('Modifier', 'setGroup2');\n          }\n        })\n\n      MyImage1({ modifier: this.myModifier })\n    }\n    .width('100%')\n  }\n}
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，又因为CommonModifier在框架内是通过其属性触发刷新，此时可以使用makeObserved替代。
具体示例如下：
import { UIUtils } from '@kit.ArkUI';\nimport { CommonModifier } from '@ohos.arkui.modifier';\n\nclass MyModifier extends CommonModifier {\n  applyNormalAttribute(instance: CommonAttribute): void {\n    super.applyNormalAttribute?.(instance);\n  }\n\n  public setGroup1(): void {\n    this.borderStyle(BorderStyle.Dotted);\n    this.borderWidth(8);\n  }\n\n  public setGroup2(): void {\n    this.borderStyle(BorderStyle.Dashed);\n    this.borderWidth(8);\n  }\n}\n\n@ComponentV2\nstruct MyImage1 {\n  @Param @Require modifier: CommonModifier;\n\n  build() {\n    // 此处'app.media.app_icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。\n    Image($r('app.media.app_icon'))\n      .attributeModifier(this.modifier as MyModifier)\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  // 使用makeObserved的能力来观测CommonModifier\n  @Local myModifier: CommonModifier = UIUtils.makeObserved(new MyModifier().width(100).height(100).margin(10));\n  index: number = 0;\n\n  build() {\n    Column() {\n      Button($r('app.string.EntryAbility_label'))\n        .margin(10)\n        .onClick(() => {\n          console.log('Modifier', 'onClick');\n          this.index++;\n          if (this.index % 2 === 1) {\n            (this.myModifier as MyModifier).setGroup1();\n            console.log('Modifier', 'setGroup1');\n          } else {\n            (this.myModifier as MyModifier).setGroup2();\n            console.log('Modifier', 'setGroup2');\n          }\n        })\n\n      MyImage1({ modifier: this.myModifier })\n    }\n    .width('100%')\n  }\n}
组件Modfier
动态设置组件的属性类。以Text组件为例。
V1：
在状态管理V1中，可以通过@State装饰观察其变化。
具体示例如下：
import { TextModifier } from '@ohos.arkui.modifier';\n\nclass MyModifier extends TextModifier {\n  applyNormalAttribute(instance: TextModifier): void {\n    super.applyNormalAttribute?.(instance);\n  }\n\n  public setGroup1(): void {\n    this.fontSize(50);\n    this.fontColor(Color.Pink);\n  }\n\n  public setGroup2(): void {\n    this.fontSize(50);\n    this.fontColor(Color.Gray);\n  }\n}\n\n@Component\nstruct MyImage1 {\n  @Link modifier: TextModifier;\n  index: number = 0;\n\n  build() {\n    Column() {\n      Text('Test')\n        .attributeModifier(this.modifier as MyModifier)\n\n      Button($r('app.string.EntryAbility_label'))\n        .margin(10)\n        .onClick(() => {\n          console.log('Modifier', 'onClick');\n          this.index++;\n          if (this.index % 2 === 1) {\n            (this.modifier as MyModifier).setGroup1();\n            console.log('Modifier', 'setGroup1');\n          } else {\n            (this.modifier as MyModifier).setGroup2();\n            console.log('Modifier', 'setGroup2');\n          }\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State myModifier: TextModifier = new MyModifier().width(100).height(100).margin(10);\n  index: number = 0;\n\n  build() {\n    Column() {\n      MyImage1({ modifier: this.myModifier })\n\n      Button('replace whole')\n        .margin(10)\n        .onClick(() => {\n          this.myModifier = new MyModifier().backgroundColor(Color.Orange);\n        })\n    }\n    .width('100%')\n  }\n}
V2：
但在状态管理V2中，@Local只能观察本身的变化，无法观察第一层的变化，此时可以使用makeObserved替代。
具体示例如下：
import { UIUtils } from '@kit.ArkUI';\nimport { TextModifier } from '@ohos.arkui.modifier';\n\nclass MyModifier extends TextModifier {\n  applyNormalAttribute(instance: TextModifier): void {\n    super.applyNormalAttribute?.(instance);\n  }\n\n  public setGroup1(): void {\n    this.fontSize(50);\n    this.fontColor(Color.Pink);\n  }\n\n  public setGroup2(): void {\n    this.fontSize(50);\n    this.fontColor(Color.Gray);\n  }\n}\n\n@ComponentV2\nstruct MyImage1 {\n  @Param @Require modifier: TextModifier;\n  index: number = 0;\n\n  build() {\n    Column() {\n      Text('Test')\n        .attributeModifier(this.modifier as MyModifier)\n\n      Button($r('app.string.EntryAbility_label'))\n        .margin(10)\n        .onClick(() => {\n          console.log('Modifier', 'onClick');\n          this.index++;\n          if (this.index % 2 === 1) {\n            (this.modifier as MyModifier).setGroup1();\n            console.log('Modifier', 'setGroup1');\n          } else {\n            (this.modifier as MyModifier).setGroup2();\n            console.log('Modifier', 'setGroup2');\n          }\n        })\n    }\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  // 使用makeObserved的能力观测TextModifier\n  @Local myModifier: TextModifier = UIUtils.makeObserved(new MyModifier().width(100).height(100).margin(10));\n  index: number = 0;\n\n  build() {\n    Column() {\n      MyImage1({ modifier: this.myModifier })\n\n      Button('replace whole')\n        .margin(10)\n        .onClick(() => {\n          this.myModifier = UIUtils.makeObserved(new MyModifier().backgroundColor(Color.Orange));\n        })\n    }\n    .width('100%')\n  }\n}

应用侧与前端页面的相互调用(C/C++)
本指导适用于ArkWeb应用侧与前端网页通信场景，开发者可根据应用架构选择使用ArkWeb Native接口完成业务通信机制（以下简称Native JSBridge）。
适用的应用架构
应用使用ArkTS、C++语言混合开发，或本身应用架构较贴近于小程序架构，自带C++侧环境，推荐使用ArkWeb在Native侧提供的ArkWeb_ControllerAPI、ArkWeb_ComponentAPI实现JSBridge功能。
上图展示了具有普遍适用性的小程序的通用架构。在这一架构中，逻辑层依赖于应用程序自带的JavaScript运行时，该运行时在一个已有的C++环境中运行。通过Native接口，逻辑层能够直接在C++环境中与视图层（其中ArkWeb充当渲染器）进行通信，无需回退至ArkTS环境使用ArkTS JSBridge接口。
左图是使用ArkTS JSBridge接口构建小程序的方案，如红框所示，应用需要先调用到ArkTS环境，再调用到C++环境。右图是使用Native JSBridge接口构建小程序的方案，不需要ArkTS环境和C++环境的切换，执行效率更高。
Native JSBridge方案可以解决ArkTS环境的冗余切换，同时允许回调在非UI线程上运行，避免造成UI阻塞。
使用Native接口实现JSBridge通信
[h2]使用Native接口绑定ArkWeb
 ArkWeb组件声明在ArkTS侧，需要用户自定义一个标识webTag，并将webTag通过Node-API传至应用Native侧，后续ArkWeb Native接口使用，均需webTag作为对应组件的唯一标识。 ArkTS侧 // 自定义webTag，在WebviewController创建时作为入参传入，建立controller与webTag的映射关系\nwebTag: string = 'ArkWeb1';\ncontroller: web_webview.WebviewController = new web_webview.WebviewController(this.webTag);\n\n// aboutToAppear中将webTag通过Node-API接口传入C++侧，作为C++侧ArkWeb组件的唯一标识\naboutToAppear() {\n  console.info(\"aboutToAppear\")\n  //初始化web ndk\n  testNapi.nativeWebInit(this.webTag);\n} C++侧 // 解析存储webTag\nstatic napi_value NativeWebInit(napi_env env, napi_callback_info info) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk NativeWebInit start\");\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n    // 获取第一个参数webTag\n    size_t webTagSize = 0;\n    napi_get_value_string_utf8(env, args[0], nullptr, 0, &webTagSize);\n    char *webTagValue = new (std::nothrow) char[webTagSize + 1];\n    size_t webTagLength = 0;\n    napi_get_value_string_utf8(env, args[0], webTagValue, webTagSize + 1, &webTagLength);\n    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk NativeWebInit webTag:%{public}s\", webTagValue);\n\n    // 将webTag保存在实例对象中\n    jsbridge_object_ptr = std::make_shared<JSBridgeObject>(webTagValue);\n    // ... 
[h2]使用Native接口获取API结构体
ArkWeb Native侧得先获取API结构体，才能调用结构体里的Native API。ArkWeb Native侧API通过函数OH_ArkWeb_GetNativeAPI获取，根据入参type不同，可分别获取ArkWeb_ControllerAPI、ArkWeb_ComponentAPI函数指针结构体。其中ArkWeb_ControllerAPI对应ArkTS侧web_webview.WebviewController API，ArkWeb_ComponentAPI对应ArkTS侧ArkWeb组件API。
static ArkWeb_ControllerAPI *controller = nullptr;\nstatic ArkWeb_ComponentAPI *component = nullptr;\n...\ncontroller = reinterpret_cast<ArkWeb_ControllerAPI *>(OH_ArkWeb_GetNativeAPI(ARKWEB_NATIVE_CONTROLLER));\ncomponent = reinterpret_cast<ArkWeb_ComponentAPI *>(OH_ArkWeb_GetNativeAPI(ARKWEB_NATIVE_COMPONENT));
[h2]Native侧注册组件生命周期回调
通过ArkWeb_ComponentAPI注册组件生命周期回调，在调用API前建议通过ARKWEB_MEMBER_MISSING校验该函数结构体是否有对应函数指针，避免SDK与设备ROM不匹配导致crash问题。
if (!ARKWEB_MEMBER_MISSING(component, onControllerAttached)) {\n    component->onControllerAttached(webTagValue, ValidCallback,\n                                    static_cast<void *>(jsbridge_object_ptr->GetWeakPtr()));\n} else {\n    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"component onControllerAttached func not exist\");\n}\n\nif (!ARKWEB_MEMBER_MISSING(component, onPageBegin)) {\n    component->onPageBegin(webTagValue, LoadStartCallback,\n                                    static_cast<void *>(jsbridge_object_ptr->GetWeakPtr()));\n} else {\n    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"component onPageBegin func not exist\");\n}\n\nif (!ARKWEB_MEMBER_MISSING(component, onPageEnd)) {\n    component->onPageEnd(webTagValue, LoadEndCallback,\n                                    static_cast<void *>(jsbridge_object_ptr->GetWeakPtr()));\n} else {\n    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"component onPageEnd func not exist\");\n}\n\nif (!ARKWEB_MEMBER_MISSING(component, onDestroy)) {\n    component->onDestroy(webTagValue, DestroyCallback,\n                                    static_cast<void *>(jsbridge_object_ptr->GetWeakPtr()));\n} else {\n    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"component onDestroy func not exist\");\n}
[h2]前端页面调用应用侧函数
通过registerJavaScriptProxy将应用侧函数注册至前端页面，推荐在onControllerAttached回调中注册，其它时机注册需要手动调用refresh才能生效。
// 注册对象\nOH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk RegisterJavaScriptProxy begin\");\nArkWeb_ProxyMethod method1 = {\"method1\", ProxyMethod1, static_cast<void *>(jsbridge_object_ptr->GetWeakPt  ())};\nArkWeb_ProxyMethod method2 = {\"method2\", ProxyMethod2, static_cast<void *>(jsbridge_object_ptr->GetWeakPt  ())};\nArkWeb_ProxyMethod methodList[2] = {method1, method2};\n// 调用ndk接口注册对象\n// 如此注册的情况下，在H5页面就可以使用proxy.method1、proxy.method2调用此文件下的ProxyMethod1和ProxyMethod2方法了\nArkWeb_ProxyObject proxyObject = {\"ndkProxy\", methodList, 2};\ncontroller->registerJavaScriptProxy(webTag, &proxyObject);
[h2]应用侧调用前端页面函数
通过runJavaScript调用前端页面函数。
// 构造runJS执行的结构体\nchar* jsCode = \"runJSRetStr()\";\nArkWeb_JavaScriptObject object = {(uint8_t *)jsCode, bufferSize, &JSBridgeObject::StaticRunJavaScriptCallback,\n                                     static_cast<void *>(jsbridge_object_ptr->GetWeakPtr())};\n// 调用前端页面runJSRetStr()函数\ncontroller->runJavaScript(webTagValue, &object);
[h2]完整示例
 前端页面代码 <!-- entry/src/main/resources/rawfile/runJS.html -->\n<!-- runJS.html -->\n<!DOCTYPE html>\n<html lang=\"en-gb\">\n<head>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>run javascript demo</title>\n</head>\n<body>\n<h1>run JavaScript Ext demo</h1>\n<p id=\"webDemo\"></p>\n<br>\n<button type=\"button\" style=\"height:30px;width:200px\" onclick=\"testNdkProxyObjMethod1()\">test ndk method1 ! </button>\n<br>\n<br>\n<button type=\"button\" style=\"height:30px;width:200px\" onclick=\"testNdkProxyObjMethod2()\">test ndk method2 ! </button>\n<br>\n\n</body>\n<script type=\"text/javascript\">\n\nfunction testNdkProxyObjMethod1() {\n      if (window.ndkProxy == undefined) {\n            document.getElementById(\"webDemo\").innerHTML = \"ndkProxy undefined\"\n            return \"objName undefined\"\n      }\n\n      if (window.ndkProxy.method1 == undefined) {\n            document.getElementById(\"webDemo\").innerHTML = \"ndkProxy method1 undefined\"\n            return \"objName  test undefined\"\n      }\n\n      if (window.ndkProxy.method2 == undefined) {\n            document.getElementById(\"webDemo\").innerHTML = \"ndkProxy method2 undefined\"\n            return \"objName  test undefined\"\n      }\n      window.ndkProxy.method1(\"hello\", \"world\", [1.2, -3.4, 123.456], [\"Saab\", \"Volvo\", \"BMW\", undefined], 1.23456, 123789, true, false, 0,  undefined);\n}\n\nfunction testNdkProxyObjMethod2() {\n      if (window.ndkProxy == undefined) {\n            document.getElementById(\"webDemo\").innerHTML = \"ndkProxy undefined\"\n            return \"objName undefined\"\n      }\n\n      if (window.ndkProxy.method1 == undefined) {\n            document.getElementById(\"webDemo\").innerHTML = \"ndkProxy method1 undefined\"\n            return \"objName  test undefined\"\n      }\n\n      if (window.ndkProxy.method2 == undefined) {\n            document.getElementById(\"webDemo\").innerHTML = \"ndkProxy method2 undefined\"\n            return \"objName  test undefined\"\n      }\n\n    var student = {\n            name:\"zhang\",\n            sex:\"man\",\n            age:25\n    };\n    var cars = [student, 456, false, 4.567];\n    let params = \"[\\\"{\\\\\\\"scope\\\\\\\"]\";\n\n    window.ndkProxy.method2(\"hello\", \"world\", false, cars, params);\n}\n\nfunction runJSRetStr(data) {\n    const d = new Date();\n    let time = d.getTime();\n    return JSON.stringify(time)\n}\n</script>\n</html> ArkTS侧代码 // entry/src/main/ets/pages/Index.ets\nimport testNapi from 'libentry.so';\nimport { webview } from '@kit.ArkWeb';\n\nclass testObj {\n  constructor() {\n  }\n\n  test(): string {\n    console.log('ArkUI Web Component');\n    return \"ArkUI Web Component\";\n  }\n\n  toString(): void {\n    console.log('Web Component toString');\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  webTag: string = 'ArkWeb1';\n  controller: webview.WebviewController = new webview.WebviewController(this.webTag);\n  @State testObjtest: testObj = new testObj();\n\n  aboutToAppear() {\n    console.info(\"aboutToAppear\")\n    //初始化web ndk\n    testNapi.nativeWebInit(this.webTag);\n  }\n\n  build() {\n    Column() {\n      Row() {\n        Button('runJS hello')\n          .fontSize(12)\n          .onClick(() => {\n            testNapi.runJavaScript(this.webTag, \"runJSRetStr(\\\"\" + \"hello\" + \"\\\")\");\n          })\n      }.height('20%')\n\n      Row() {\n        Web({ src: $rawfile('runJS.html'), controller: this.controller })\n          .javaScriptAccess(true)\n          .fileAccess(true)\n          .onControllerAttached(() => {\n            console.error(\"ndk onControllerAttached webId: \" + this.controller.getWebId());\n          })\n      }.height('80%')\n    }\n  }\n} Node-API侧暴露ArkTS接口 // entry/src/main/cpp/types/libentry/index.d.ts\nexport const nativeWebInit: (webName: string) => void;\nexport const runJavaScript: (webName: string, jsCode: string) => void; Node-API侧编译配置entry/src/main/cpp/CMakeLists.txt # the minimum version of CMake.\ncmake_minimum_required(VERSION 3.4.1)\nproject(NDKJSBridg)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n\nif(DEFINED PACKAGE_FIND_FILE)\n    include(${PACKAGE_FIND_FILE})\nendif()\n\ninclude_directories(${NATIVERENDER_ROOT_PATH}\n                    ${NATIVERENDER_ROOT_PATH}/include)\n\nadd_library(entry SHARED hello.cpp jsbridge_object.cpp)\n\nfind_library(\n    # Sets the name of the path variable.\n    hilog-lib\n    # Specifies the name of the NDK library that\n    # you want CMake to locate.\n    hilog_ndk.z\n)\n\ntarget_link_libraries(entry PUBLIC libace_napi.z.so ${hilog-lib} libohweb.so) Node-API层代码 // entry/src/main/cpp/hello.cpp\n#include \"napi/native_api.h\"\n#include <bits/alltypes.h>\n#include <memory>\n#include <string>\n#include <sys/types.h>\n#include <thread>\n\n#include \"hilog/log.h\"\n#include \"web/arkweb_interface.h\"\n#include \"jsbridge_object.h\"\n\nconstexpr unsigned int LOG_PRINT_DOMAIN = 0xFF00;\nstd::shared_ptr<JSBridgeObject> jsbridge_object_ptr = nullptr;\nstatic ArkWeb_ControllerAPI *controller = nullptr;\nstatic ArkWeb_ComponentAPI *component = nullptr;\n\n// 发送JS脚本到H5侧执行，该方法为执行结果的回调。\nstatic void RunJavaScriptCallback(const char *webTag, const char *result, void *userData) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk RunJavaScriptCallback webTag:%{public}s\", webTag);\n    if (!userData) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk RunJavaScriptCallback userData is nullptr\");\n        return;\n    }\n    std::weak_ptr<JSBridgeObject> jsb_weak_ptr = *static_cast<std::weak_ptr<JSBridgeObject> *>(userData);\n    if (auto jsb_ptr = jsb_weak_ptr.lock()) {\n        jsb_ptr->RunJavaScriptCallback(result);\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\",\n                     \"ndk RunJavaScriptCallback jsb_weak_ptr lock failed\");\n    }\n}\n\n// 示例代码 ，注册了1个对象，2个方法\nstatic void ProxyMethod1(const char *webTag, const ArkWeb_JavaScriptBridgeData *dataArray, size_t arraySize, void *userData) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ProxyMethod1 webTag:%{public}s\", webTag);\n    if (!userData) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ProxyMethod1 userData is nullptr\");\n        return;\n    }\n    std::weak_ptr<JSBridgeObject> jsb_weak_ptr = *static_cast<std::weak_ptr<JSBridgeObject> *>(userData);\n    if (auto jsb_ptr = jsb_weak_ptr.lock()) {\n        jsb_ptr->ProxyMethod1(dataArray, arraySize);\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ProxyMethod1 jsb_weak_ptr lock failed\");\n    }\n}\n\nstatic void ProxyMethod2(const char *webTag, const ArkWeb_JavaScriptBridgeData *dataArray, size_t arraySize, void *userData) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ProxyMethod2 webTag:%{public}s\", webTag);\n    if (!userData) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ProxyMethod2 userData is nullptr\");\n        return;\n    }\n    std::weak_ptr<JSBridgeObject> jsb_weak_ptr = *static_cast<std::weak_ptr<JSBridgeObject> *>(userData);\n\n    std::string jsCode = \"runJSRetStr()\";\n    ArkWeb_JavaScriptObject object = {(uint8_t *)jsCode.c_str(), jsCode.size(),\n                                     &JSBridgeObject::StaticRunJavaScriptCallback,\n                                     static_cast<void *>(jsbridge_object_ptr->GetWeakPtr())};\n    controller->runJavaScript(webTag, &object);\n\n    if (auto jsb_ptr = jsb_weak_ptr.lock()) {\n        jsb_ptr->ProxyMethod2(dataArray, arraySize);\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ProxyMethod2 jsb_weak_ptr lock failed\");\n    }\n}\n\nvoid ValidCallback(const char *webTag, void *userData) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ValidCallback webTag: %{public}s\", webTag);\n    if (!userData) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ValidCallback userData is nullptr\");\n        return;\n    }\n    std::weak_ptr<JSBridgeObject> jsb_weak_ptr = *static_cast<std::weak_ptr<JSBridgeObject> *>(userData);\n    if (auto jsb_ptr = jsb_weak_ptr.lock()) {\n        jsb_ptr->SaySomething(\"ValidCallback\");\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk ValidCallback jsb_weak_ptr lock failed\");\n    }\n\n    // 注册对象\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk RegisterJavaScriptProxy begin\");\n    ArkWeb_ProxyMethod method1 = {\"method1\", ProxyMethod1, static_cast<void *>(jsbridge_object_ptr->GetWeakPtr())};\n    ArkWeb_ProxyMethod method2 = {\"method2\", ProxyMethod2, static_cast<void *>(jsbridge_object_ptr->GetWeakPtr())};\n    ArkWeb_ProxyMethod methodList[2] = {method1, method2};\n    // 调用ndk接口注册对象\n    // 如此注册的情况下，在H5页面就可以使用proxy.method1、proxy.method2调用此文件下的ProxyMethod1和ProxyMethod2方法了\n    ArkWeb_ProxyObject proxyObject = {\"ndkProxy\", methodList, 2};\n    controller->registerJavaScriptProxy(webTag, &proxyObject);\n\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk RegisterJavaScriptProxy end\");\n}\n\nvoid LoadStartCallback(const char *webTag, void *userData) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk LoadStartCallback webTag: %{public}s\", webTag);\n    if (!userData) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk LoadStartCallback userData is nullptr\");\n        return;\n    }\n    std::weak_ptr<JSBridgeObject> jsb_weak_ptr = *static_cast<std::weak_ptr<JSBridgeObject> *>(userData);\n    if (auto jsb_ptr = jsb_weak_ptr.lock()) {\n        jsb_ptr->SaySomething(\"LoadStartCallback\");\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk LoadStartCallback jsb_weak_ptr lock failed\");\n    }\n}\n\nvoid LoadEndCallback(const char *webTag, void *userData) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk LoadEndCallback webTag: %{public}s\", webTag);\n    if (!userData) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk LoadEndCallback userData is nullptr\");\n        return;\n    }\n    std::weak_ptr<JSBridgeObject> jsb_weak_ptr = *static_cast<std::weak_ptr<JSBridgeObject> *>(userData);\n    if (auto jsb_ptr = jsb_weak_ptr.lock()) {\n        jsb_ptr->SaySomething(\"LoadEndCallback\");\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk LoadEndCallback jsb_weak_ptr lock failed\");\n    }\n}\n\nvoid DestroyCallback(const char *webTag, void *userData) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk DestoryCallback webTag: %{public}s\", webTag);\n    if (!userData) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk DestroyCallback userData is nullptr\");\n        return;\n    }\n    std::weak_ptr<JSBridgeObject> jsb_weak_ptr = *static_cast<std::weak_ptr<JSBridgeObject> *>(userData);\n    if (auto jsb_ptr = jsb_weak_ptr.lock()) {\n        jsb_ptr->SaySomething(\"DestroyCallback\");\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk DestroyCallback jsb_weak_ptr lock failed\");\n    }\n}\n\nvoid SetComponentCallback(ArkWeb_ComponentAPI * component, const char* webTagValue) {\n    if (!ARKWEB_MEMBER_MISSING(component, onControllerAttached)) {\n        component->onControllerAttached(webTagValue, ValidCallback,\n                                        static_cast<void *>(jsbridge_object_ptr->GetWeakPtr()));\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"component onControllerAttached func not exist\");\n    }\n\n    if (!ARKWEB_MEMBER_MISSING(component, onPageBegin)) {\n        component->onPageBegin(webTagValue, LoadStartCallback,\n                                        static_cast<void *>(jsbridge_object_ptr->GetWeakPtr()));\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"component onPageBegin func not exist\");\n    }\n\n    if (!ARKWEB_MEMBER_MISSING(component, onPageEnd)) {\n        component->onPageEnd(webTagValue, LoadEndCallback,\n                                        static_cast<void *>(jsbridge_object_ptr->GetWeakPtr()));\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"component onPageEnd func not exist\");\n    }\n\n    if (!ARKWEB_MEMBER_MISSING(component, onDestroy)) {\n        component->onDestroy(webTagValue, DestroyCallback,\n                                        static_cast<void *>(jsbridge_object_ptr->GetWeakPtr()));\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"component onDestroy func not exist\");\n    }\n}\n\n// 解析存储webTag\nstatic napi_value NativeWebInit(napi_env env, napi_callback_info info) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk NativeWebInit start\");\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n    // 获取第一个参数webTag\n    size_t webTagSize = 0;\n    napi_get_value_string_utf8(env, args[0], nullptr, 0, &webTagSize);\n    char *webTagValue = new (std::nothrow) char[webTagSize + 1];\n    size_t webTagLength = 0;\n    napi_get_value_string_utf8(env, args[0], webTagValue, webTagSize + 1, &webTagLength);\n    OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk NativeWebInit webTag:%{public}s\", webTagValue);\n\n    // 将webTag保存在实例对象中\n    jsbridge_object_ptr = std::make_shared<JSBridgeObject>(webTagValue);\n    if (jsbridge_object_ptr)\n        jsbridge_object_ptr->Init();\n\n    controller = reinterpret_cast<ArkWeb_ControllerAPI *>(OH_ArkWeb_GetNativeAPI(ARKWEB_NATIVE_CONTROLLER));\n    component = reinterpret_cast<ArkWeb_ComponentAPI *>(OH_ArkWeb_GetNativeAPI(ARKWEB_NATIVE_COMPONENT));\n    SetComponentCallback(component, webTagValue);\n\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk NativeWebInit end\");\n    return nullptr;\n}\n\n// 发送JS脚本到H5侧执行\nstatic napi_value RunJavaScript(napi_env env, napi_callback_info info) {\n    size_t argc = 2;\n    napi_value args[2] = {nullptr};\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    // 获取第一个参数webTag\n    size_t webTagSize = 0;\n    napi_get_value_string_utf8(env, args[0], nullptr, 0, &webTagSize);\n    char *webTagValue = new (std::nothrow) char[webTagSize + 1];\n    size_t webTagLength = 0;\n    napi_get_value_string_utf8(env, args[0], webTagValue, webTagSize + 1, &webTagLength);\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"ndk OH_NativeArkWeb_RunJavaScript webTag:%{public}s\",\n                 webTagValue);\n\n    // 获取第二个参数 jsCode\n    size_t bufferSize = 0;\n    napi_get_value_string_utf8(env, args[1], nullptr, 0, &bufferSize);\n    char *jsCode = new (std::nothrow) char[bufferSize + 1];\n    size_t byteLength = 0;\n    napi_get_value_string_utf8(env, args[1], jsCode, bufferSize + 1, &byteLength);\n\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\",\n                 \"ndk OH_NativeArkWeb_RunJavaScript jsCode len:%{public}zu\", strlen(jsCode));\n\n    // 构造runJS执行的结构体\n    ArkWeb_JavaScriptObject object = {(uint8_t *)jsCode, bufferSize, &JSBridgeObject::StaticRunJavaScriptCallback,\n                                     static_cast<void *>(jsbridge_object_ptr->GetWeakPtr())};\n    controller->runJavaScript(webTagValue, &object);\n    return nullptr;\n}\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports) {\n    napi_property_descriptor desc[] = {\n        {\"nativeWebInit\", nullptr, NativeWebInit, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"runJavaScript\", nullptr, RunJavaScript, nullptr, nullptr, nullptr, napi_default, nullptr},\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void *)0),\n    .reserved = {0},\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void) { napi_module_register(&demoModule); } Native侧业务代码 // entry/src/main/cpp/jsbridge_object.h\n#include \"web/arkweb_type.h\"\n#include <string>\n\nclass JSBridgeObject : public std::enable_shared_from_this<JSBridgeObject> {\npublic:\n    JSBridgeObject(const char* webTag);\n    ~JSBridgeObject() = default;\n    void Init();\n    std::weak_ptr<JSBridgeObject>* GetWeakPtr();\n    static void StaticRunJavaScriptCallback(const char *webTag, const ArkWeb_JavaScriptBridgeData *data, void *userData);\n    void RunJavaScriptCallback(const char *result);\n    void ProxyMethod1(const ArkWeb_JavaScriptBridgeData *dataArray, int32_t arraySize);\n    void ProxyMethod2(const ArkWeb_JavaScriptBridgeData *dataArray, int32_t arraySize);\n    void SaySomething(const char* say);\n\nprivate:\n    std::string webTag_;\n    std::weak_ptr<JSBridgeObject> weak_ptr_;\n}; // entry/src/main/cpp/jsbridge_object.cpp\n#include \"jsbridge_object.h\"\n\n#include \"hilog/log.h\"\n\nconstexpr unsigned int LOG_PRINT_DOMAIN = 0xFF00;\n\nJSBridgeObject::JSBridgeObject(const char *webTag) : webTag_(webTag) {}\n\nvoid JSBridgeObject::Init() { weak_ptr_ = shared_from_this(); }\n\nstd::weak_ptr<JSBridgeObject> *JSBridgeObject::GetWeakPtr() { return &weak_ptr_; }\n\nvoid JSBridgeObject::StaticRunJavaScriptCallback(const char *webTag, const ArkWeb_JavaScriptBridgeData *data,\n                                                 void *userData) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\",\n                 \"JSBridgeObject StaticRunJavaScriptCallback webTag:%{public}s\", webTag);\n    if (!userData) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\",\n                     \"JSBridgeObject StaticRunJavaScriptCallback userData is nullptr\");\n        return;\n    }\n    std::weak_ptr<JSBridgeObject> jsb_weak_ptr = *static_cast<std::weak_ptr<JSBridgeObject> *>(userData);\n    if (auto jsb_ptr = jsb_weak_ptr.lock()) {\n        std::string result((char *)data->buffer, data->size);\n        jsb_ptr->RunJavaScriptCallback(result.c_str());\n    } else {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\",\n                     \"JSBridgeObject StaticRunJavaScriptCallback jsb_weak_ptr lock failed\");\n    }\n}\n\nvoid JSBridgeObject::RunJavaScriptCallback(const char *result) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\",\n                 \"JSBridgeObject OH_NativeArkWeb_RunJavaScript result:%{public}s\", result);\n}\n\nvoid JSBridgeObject::ProxyMethod1(const ArkWeb_JavaScriptBridgeData *dataArray, int32_t arraySize) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"JSBridgeObject ProxyMethod1 argc:%{public}d\",\n                 arraySize);\n    for (int i = 0; i < arraySize; i++) {\n        std::string result((char *)dataArray[i].buffer, dataArray[i].size);\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\",\n                     \"JSBridgeObject ProxyMethod1 argv[%{public}d]:%{public}s, size:%{public}d\", i, result.c_str(),\n                     dataArray[i].size);\n    }\n}\n\nvoid JSBridgeObject::ProxyMethod2(const ArkWeb_JavaScriptBridgeData *dataArray, int32_t arraySize) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"JSBridgeObject ProxyMethod2 argc:%{public}d\",\n                 arraySize);\n    for (int i = 0; i < arraySize; i++) {\n        std::string result((char *)dataArray[i].buffer, dataArray[i].size);\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\",\n                     \"JSBridgeObject ProxyMethod2 argv[%{public}d]:%{public}s, size:%{public}d\", i, result.c_str(),\n                     dataArray[i].size);\n    }\n}\n\nvoid JSBridgeObject::SaySomething(const char *say) {\n    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, \"ArkWeb\", \"JSBridgeObject SaySomething argc:%{public}s\", say);\n} 

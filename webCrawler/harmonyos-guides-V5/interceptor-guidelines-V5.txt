事件拦截开发指导（C/C++）
功能介绍
多模为应用提供了创建和删除按键、输入事件（鼠标、触摸和轴事件）拦截的能力。使用场景例如：云桌面应用需要拦截按键、鼠标、触摸和轴事件。
接口说明
创建和删除事件拦截相关接口如下表所示，接口详细介绍请参考Input文档。
开发步骤
[h2]链接动态库
调用创建和删除事件拦截前，需链接相关动态库。链接动态库的方法是，在CMakeList.txt文件中做下面例子所示的配置：
   target_link_libraries(entry PUBLIC libohinput.so)
[h2]申请所需权限
应用需要在module.json5中添加下面权限的配置，详细的配置方法参考声明声明权限文档。
\"requestPermissions\": [\n    {\n        \"name\": \"ohos.permission.INTERCEPT_INPUT_EVENT\"\n    }\n]
[h2]创建事件拦截
按键事件
#include \"multimodalinput/oh_input_manager.h\"\n\nstruct KeyEvent {\n    int32_t action;\n    int32_t keyCode;\n    int64_t actionTime { -1 };\n};\n\n//定义按键事件回调函数\nvoid OnKeyEventCallback(const Input_KeyEvent* keyEvent)\n{\n    KeyEvent event;\n    //Input_KeyEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    event.action = OH_Input_GetKeyEventAction(keyEvent);\n    event.keyCode = OH_Input_GetKeyEventKeyCode(keyEvent);\n    event.actionTime = OH_Input_GetKeyEventActionTime(keyEvent);\n}\n\nvoid TestInterceptor()\n{\n    //添加按键事件拦截\n    Input_Result ret = OH_Input_AddKeyEventInterceptor(OnKeyEventCallback, nullptr);\n    //移除按键事件监听\n    ret = OH_Input_RemoveKeyEventInterceptor();\n}
输入拦截（鼠标、触摸和轴事件）
#include \"multimodalinput/oh_input_manager.h\"\n#include <map>\n\nstruct MouseEvent {\n    int32_t action;\n    int32_t displayX;\n    int32_t displayY;\n    int32_t button { -1 };\n    int32_t axisType { -1 };\n    float axisValue { 0.0f };\n    int64_t actionTime { -1 };\n};\n\nstruct TouchEvent {\n    int32_t action;\n    int32_t id;\n    int32_t displayX;\n    int32_t displayY;\n    int64_t actionTime { -1 };\n};\n\nstruct AxisEvent {\n    int32_t axisAction;\n    float displayX;\n    float displayY;\n    std::map<int32_t, double> axisValues;\n    int64_t actionTime { -1 };\n    int32_t sourceType;\n    int32_t axisEventType { -1 };\n};\n\n//定义鼠标事件回调函数\nvoid OnMouseEventCallback(const Input_MouseEvent* mouseEvent)\n{\n    MouseEvent event;\n    //Input_MouseEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    event.action = OH_Input_GetMouseEventAction(mouseEvent);\n    event.displayX = OH_Input_GetMouseEventDisplayX(mouseEvent);\n    event.displayY = OH_Input_GetMouseEventDisplayY(mouseEvent);\n    event.button = OH_Input_GetMouseEventButton(mouseEvent);\n    event.axisType = OH_Input_GetMouseEventAxisType(mouseEvent);\n    event.axisValue = OH_Input_GetMouseEventAxisValue(mouseEvent);\n    event.actionTime = OH_Input_GetMouseEventActionTime(mouseEvent);\n}\n\n//定义触摸事件回调函数\nvoid OnTouchEventCallback(const Input_TouchEvent* touchEvent)\n{\n    TouchEvent event;\n    //Input_TouchEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    event.action = OH_Input_GetTouchEventAction(touchEvent);\n    event.id = OH_Input_GetTouchEventFingerId(touchEvent);\n    event.displayX = OH_Input_GetTouchEventDisplayX(touchEvent);\n    event.displayY = OH_Input_GetTouchEventDisplayY(touchEvent);\n    event.actionTime = OH_Input_GetTouchEventActionTime(touchEvent);\n}\n\n//定义轴事件回调函数\nvoid OnAxisEventCallback(const Input_AxisEvent* axisEvent)\n{\n    AxisEvent event;\n    \n    //Input_AxisEvent的生命周期仅在回调函数内，出了回调函数会被销毁\n    InputEvent_AxisAction action;\n    Input_Result ret = OH_Input_GetAxisEventAction(axisEvent, &action);\n    event.axisAction = action;\n    ret = OH_Input_GetAxisEventDisplayX(axisEvent, &event.displayX);\n    ret = OH_Input_GetAxisEventDisplayY(axisEvent, &event.displayY);\n    ret = OH_Input_GetAxisEventActionTime(axisEvent, &event.actionTime);\n    InputEvent_SourceType sourceType;\n    ret = OH_Input_GetAxisEventSourceType(axisEvent, &sourceType);\n    event.sourceType = sourceType;\n    InputEvent_AxisEventType axisEventType;\n    ret = OH_Input_GetAxisEventType(axisEvent, &axisEventType);\n    event.axisEventType = axisEventType;\n    if (event.axisEventType == AXIS_EVENT_TYPE_PINCH) {\n        double value = 0;\n        ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_PINCH, &value);\n        event.axisValues.insert(std::make_pair(AXIS_TYPE_PINCH, value));\n        ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_ROTATE, &value);\n        event.axisValues.insert(std::make_pair(AXIS_TYPE_ROTATE, value));\n    } else if (event.axisEventType == AXIS_EVENT_TYPE_SCROLL) {\n        double value = 0;\n        ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_SCROLL_VERTICAL, &value);\n        event.axisValues.insert(std::make_pair(AXIS_TYPE_SCROLL_VERTICAL, value));\n        ret = OH_Input_GetAxisEventAxisValue(axisEvent, AXIS_TYPE_SCROLL_HORIZONTAL, &value);\n        event.axisValues.insert(std::make_pair(AXIS_TYPE_SCROLL_HORIZONTAL, value));\n    }\n}\n\n//输入事件回调函数结构体\nInput_InterceptorEventCallback g_eventCallback;\n\nvoid TestInterceptor()\n{\n    //设置鼠标事件回调函数\n    g_eventCallback.mouseCallback = OnMouseEventCallback;\n    //设置触摸事件回调函数\n    g_eventCallback.touchCallback = OnTouchEventCallback;\n    //设置轴事件回调函数\n    g_eventCallback.axisCallback = OnAxisEventCallback;\n\n    //添加输入事件拦截\n    Input_Result ret = OH_Input_AddInputEventInterceptor(&g_eventCallback, nullptr);\n    //移除输入事件监听\n    ret = OH_Input_RemoveInputEventInterceptor();\n}

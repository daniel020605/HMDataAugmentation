拦截器 (C/C++)
场景介绍
请求拦截器。可用于拦截请求，修改Rcp_Request请求相关内容，或者检查本地缓存直接返回响应等等。
开发步骤
CPP侧导入模块。#include \"RemoteCommunicationKit/rcp.h\"\n#include <cstdlib>\n#include <stdio.h>\n#include <unistd.h> CMakeLists.txt中添加以下lib。（具体请见C API开发准备）。librcp_c.so 定义自己的拦截器。uint32_t RcpTestFirstIntercept(Rcp_Request *request, const Rcp_RequestHandler *next,\n                               const Rcp_ResponseCallbackObject *responseCallback) {\n    printf(\"%s\\n\", request->url);\n    return HMS_Rcp_CallNextRequestHandler(request, next, responseCallback);\n}\nuint32_t RcpTestSecondIntercept(Rcp_Request *request, const Rcp_RequestHandler *next,\n                                const Rcp_ResponseCallbackObject *responseCallback) {\n    printf(\"%s\\n\", request->url);\n    return HMS_Rcp_CallNextRequestHandler(request, next, responseCallback);\n} 发起请求，触发拦截器，执行拦截器内相关操作（用户可自定义拦截器）。“http://www.example.com”请根据实际情况替换为想要请求的URL地址。等待响应返回后，销毁request并关闭session。const int DEFAULT_INTERCEPTOR_ARRAY_SIZE = 2;\n\nvoid RcpCreateInterceptors(Rcp_InterceptorArray *interceptorsArray) {\n    interceptorsArray->interceptors =\n        (Rcp_Interceptor *)calloc(1, DEFAULT_INTERCEPTOR_ARRAY_SIZE * sizeof(Rcp_Interceptor));\n    interceptorsArray->size = DEFAULT_INTERCEPTOR_ARRAY_SIZE;\n\n    interceptorsArray->interceptors[0].intercept = RcpTestFirstIntercept;\n    interceptorsArray->interceptors[1].intercept = RcpTestSecondIntercept;\n}\n\nbool g_callback = false;\nvoid ResponseCallback(void *usrCtx, Rcp_Response *response, uint32_t errCode) {\n    (void *)usrCtx;\n    if (response != NULL) {\n        printf(\"Response status: %d\\n\", response->statusCode);\n    } else {\n        printf(\"Fetch failed: errCode: %u\\n\", errCode);\n    }\n    if (response != NULL) {\n        response->destroyResponse(response);\n    }\n    g_callback = true;\n}\n\nint main() {\n    const char *kHttpServerAddress = \"http://www.example.com\";\n    Rcp_SessionConfiguration sessionConfig{};\n    RcpCreateInterceptors(&sessionConfig.interceptors);\n    Rcp_Request *request = HMS_Rcp_CreateRequest(kHttpServerAddress);\n    request->method = RCP_METHOD_GET;\n    uint32_t errCode = 0;\n    // 创建session\n    Rcp_Session *session = HMS_Rcp_CreateSession(&sessionConfig, &errCode);\n    // 配置请求回调\n    Rcp_ResponseCallbackObject responseCallback = {ResponseCallback, NULL};\n    // 发起fetch请求\n    errCode = HMS_Rcp_Fetch(session, request, &responseCallback);\n    // 等待fetch结果\n    int timeout = 100;\n    while (timeout-- > 0 && !g_callback) {\n        usleep(1000);\n    }\n    // 在退出前取消可能还在执行的requests \n    errCode = HMS_Rcp_CancelSession(session);\n    // 清理request\n    HMS_Rcp_DestroyRequest(request);\n    // 关闭session\n    errCode = HMS_Rcp_CloseSession(&session);\n    // 处理errCode\n    // 清理拦截器\n    free(sessionConfig.syncInterceptors.interceptors);\n    return 0;\n} 

使用JSVM-API实现JS与C/C++语言交互开发流程
使用JSVM-API实现跨语言交互，首先需要按照JSVM-API的机制实现模块的注册和加载等相关动作。
ArkTS/JS侧：实现C++方法的调用。代码比较简单，import一个对应的so库后，即可调用C++方法。 Native侧：.cpp文件，实现模块的注册。需要提供注册lib库的名称，并在注册回调方法中定义接口的映射关系，即Native方法及对应的JS/ArkTS接口名称等。 
此处以在ArkTS/JS侧实现RunJsVm()接口、在Native侧实现RunJsVm()接口，从而实现跨语言交互为例，呈现使用JSVM-API进行跨语言交互的流程。
创建Native C++工程
具体见创建NDK工程
Native侧方法的实现
设置模块注册信息 具体见设置模块注册信息 模块初始化 实现ArkTS接口与C++接口的绑定和映射。 // entry/src/main/cpp/hello.cpp\nEXTERN_C_START\n// 模块初始化\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    // ArkTS接口与C++接口的绑定和映射\n    napi_property_descriptor desc[] = {\n        {\"runTest\", nullptr, RunTest, nullptr, nullptr, nullptr, napi_default, nullptr},\n    };\n    // 在exports对象上挂载RunJsVm的Native方法\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END 在index.d.ts文件中，提供JS侧的接口方法。 // entry/src/main/cpp/types/libentry/index.d.ts\nexport const runTest: () => void; 在oh-package.json5文件中将index.d.ts与cpp文件关联起来。 {\n  \"name\": \"libentry.so\",\n  \"types\": \"./index.d.ts\",\n  \"version\": \"\",\n  \"description\": \"Please describe the basic information.\"\n} 在CMakeLists.txt文件中配置CMake打包参数。 # entry/src/main/cpp/CMakeLists.txt\ncmake_minimum_required(VERSION 3.4.1)\nproject(JSVMDemo)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n# 日志打印配置\nadd_definitions( \"-DLOG_DOMAIN=0xd0d0\" )\nadd_definitions( \"-DLOG_TAG=\\\"testTag\\\"\" )\ninclude_directories(${NATIVERENDER_ROOT_PATH}\n                    ${NATIVERENDER_ROOT_PATH}/include)\n\n# 添加名为entry的库\nadd_library(entry SHARED hello.cpp)\n# 构建此可执行文件需要链接的库\ntarget_link_libraries(entry PUBLIC libace_napi.z.so libjsvm.so libhilog_ndk.z.so) 实现Native侧的runTest接口。具体代码如下： #include \"napi/native_api.h\"\n#include \"hilog/log.h\"\n#include \"ark_runtime/jsvm.h\"\n\n#define LOG_DOMAIN 0x3200\n#define LOG_TAG \"APP\"\n\nstatic int g_aa = 0;\n\n#define CHECK_RET(theCall)                                                                                             \\\n    do {                                                                                                               \\\n        JSVM_Status cond = theCall;                                                                                    \\\n        if ((cond) != JSVM_OK) {                                                                                       \\\n            const JSVM_ExtendedErrorInfo *info;                                                                        \\\n            OH_JSVM_GetLastErrorInfo(env, &info);                                                                      \\\n            OH_LOG_ERROR(LOG_APP, \"jsvm fail file: %{public}s line: %{public}d ret = %{public}d message = %{public}s\", \\\n                         __FILE__, __LINE__, cond, info != nullptr ? info->errorMessage : \"\");                         \\\n            return -1;                                                                                                 \\\n        }                                                                                                              \\\n    } while (0)\n\n#define CHECK(theCall)                                                                                                 \\\n    do {                                                                                                               \\\n        JSVM_Status cond = theCall;                                                                                    \\\n        if ((cond) != JSVM_OK) {                                                                                       \\\n            OH_LOG_ERROR(LOG_APP, \"jsvm fail file: %{public}s line: %{public}d ret = %{public}d\", __FILE__, __LINE__,  \\\n                         cond);                                                                                        \\\n            return -1;                                                                                                 \\\n        }                                                                                                              \\\n    } while (0)\n\n// 用于调用theCall并检查其返回值是否为JSVM_OK。\n// 如果不是，则调用OH_JSVM_GetLastErrorInfo处理错误并返回retVal。\n#define JSVM_CALL_BASE(env, theCall, retVal)                                                                           \\\n    do {                                                                                                               \\\n        JSVM_Status cond = theCall;                                                                                    \\\n        if (cond != JSVM_OK) {                                                                                         \\\n            const JSVM_ExtendedErrorInfo *info;                                                                        \\\n            OH_JSVM_GetLastErrorInfo(env, &info);                                                                      \\\n            OH_LOG_ERROR(LOG_APP, \"jsvm fail file: %{public}s line: %{public}d ret = %{public}d message = %{public}s\", \\\n                         __FILE__, __LINE__, cond, info != nullptr ? info->errorMessage : \"\");                         \\\n            return retVal;                                                                                             \\\n        }                                                                                                              \\\n    } while (0)\n\n// JSVM_CALL_BASE的简化版本，返回nullptr\n#define JSVM_CALL(theCall) JSVM_CALL_BASE(env, theCall, nullptr)\n\n// OH_JSVM_StrictEquals的样例方法\nstatic JSVM_Value IsStrictEquals(JSVM_Env env, JSVM_CallbackInfo info) {\n    // 接受两个入参\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    JSVM_CALL(OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr));\n    // 调用OH_JSVM_StrictEquals接口判断给定的两个JavaScript value是否严格相等\n    bool result = false;\n    JSVM_Status status = OH_JSVM_StrictEquals(env, args[0], args[1], &result);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_StrictEquals: failed\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM OH_JSVM_StrictEquals: success: %{public}d\", result);\n    }\n    JSVM_Value isStrictEqual;\n    JSVM_CALL(OH_JSVM_GetBoolean(env, result, &isStrictEqual));\n    return isStrictEqual;\n}\n// IsStrictEquals注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = IsStrictEquals},\n};\nstatic JSVM_CallbackStruct *method = param;\n// IsStrictEquals方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"isStrictEquals\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(    let data = '123';\n    let value = 123;\n    isStrictEquals(data,value);)JS\";\n\nstatic int32_t TestJSVM() {\n    JSVM_InitOptions initOptions = {0};\n    JSVM_VM vm;\n    JSVM_Env env = nullptr;\n    JSVM_VMScope vmScope;\n    JSVM_EnvScope envScope;\n    JSVM_HandleScope handleScope;\n    JSVM_Value result;\n    // 初始化JavaScript引擎实例\n    if (g_aa == 0) {\n        g_aa++;\n       CHECK(OH_JSVM_Init(&initOptions));\n    }\n    // 创建JSVM环境\n    CHECK(OH_JSVM_CreateVM(nullptr, &vm));\n    CHECK(OH_JSVM_CreateEnv(vm, sizeof(descriptor) / sizeof(descriptor[0]), descriptor, &env));\n    CHECK(OH_JSVM_OpenVMScope(vm, &vmScope));\n    CHECK_RET(OH_JSVM_OpenEnvScope(env, &envScope));\n    CHECK_RET(OH_JSVM_OpenHandleScope(env, &handleScope));\n\n    // 通过script调用测试函数\n    JSVM_Script script;\n    JSVM_Value jsSrc;\n    CHECK_RET(OH_JSVM_CreateStringUtf8(env, srcCallNative, JSVM_AUTO_LENGTH, &jsSrc));\n    CHECK_RET(OH_JSVM_CompileScript(env, jsSrc, nullptr, 0, true, nullptr, &script));\n    CHECK_RET(OH_JSVM_RunScript(env, script, &result));\n\n    // 销毁JSVM环境\n    CHECK_RET(OH_JSVM_CloseHandleScope(env, handleScope));\n    CHECK_RET(OH_JSVM_CloseEnvScope(env, envScope));\n    CHECK(OH_JSVM_CloseVMScope(vm, vmScope));\n    CHECK(OH_JSVM_DestroyEnv(env));\n    CHECK(OH_JSVM_DestroyVM(vm));\n    return 0;\n}\n\nstatic napi_value RunTest(napi_env env, napi_callback_info info)\n{\n    TestJSVM();\n    return nullptr;\n}\n\n// 模块注册信息，供arkts侧调用\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports) {\nnapi_property_descriptor desc[] = {{\"runTest\", nullptr, RunTest, nullptr, nullptr, nullptr, napi_default, nullptr}};\nnapi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\nreturn exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n.nm_version = 1,\n.nm_flags = 0,\n.nm_filename = nullptr,\n.nm_register_func = Init,\n.nm_modname = \"entry\",\n.nm_priv = ((void *)0),\n.reserved = {0},\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void) { napi_module_register(&demoModule); } 
ArkTS侧调用C/C++方法实现
import hilog from '@ohos.hilog'\n// 通过import的方式，引入Native能力。\nimport napitest from 'libentry.so'\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            // runtest\n            napitest.runTest();\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
预期输出结果
JSVM OH_JSVM_StrictEquals: success: 0

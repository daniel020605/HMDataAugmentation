密钥协商(C/C++)
以协商密钥类型为ECDH，并密钥仅在HUKS内使用为例，完成密钥协商。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
在CMake脚本中链接相关动态库
target_link_libraries(entry PUBLIC libhuks_ndk.z.so)
开发步骤
生成密钥
设备A、设备B各自生成一个非对称密钥，具体请参考密钥生成或密钥导入。
密钥生成时，可指定参数，OH_HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识此步骤生成的密钥是否由HUKS管理。
导出密钥
设备A、B导出非对称密钥对的公钥材料，具体请参考密钥导出。
密钥协商
设备A、B分别基于本端私钥和对端设备的公钥，协商出共享密钥。
密钥协商时，可指定参数OH_HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识协商得到的密钥是否由HUKS管理。
当TAG设置为OH_HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥协商出的密钥，由HUKS管理，可保证协商密钥全生命周期不出安全环境。 当TAG设置为OH_HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥协商出的密钥，返回给调用方管理，由业务自行保证密钥安全。 若业务未设置TAG的具体值，表示基于该密钥协商出的密钥，既可由HUKS管理，也可返回给调用方管理，业务可在后续协商时再选择使用何种方式保护密钥。 
注：协商时指定的TAG值，不可与生成时指定的TAG值冲突。表格中仅列举有效的指定方式。
删除密钥
当密钥废弃不用时，设备A、B均需要删除密钥，具体请参考密钥删除。
#include \"huks/native_huks_api.h\"\n#include \"huks/native_huks_param.h\"\n#include \"napi/native_api.h\"\n#include <string.h>\n/* 初始化参数 */\nOH_Huks_Result InitParamSet(\n    struct OH_Huks_ParamSet **paramSet,\n    const struct OH_Huks_Param *params,\n    uint32_t paramCount)\n{\n    OH_Huks_Result ret = OH_Huks_InitParamSet(paramSet);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    ret = OH_Huks_AddParams(*paramSet, params, paramCount);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        OH_Huks_FreeParamSet(paramSet);\n        return ret;\n    }\n    ret = OH_Huks_BuildParamSet(paramSet);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        OH_Huks_FreeParamSet(paramSet);\n        return ret;\n    }\n    return ret;\n}\nstatic const uint32_t IV_SIZE = 16;\nstatic uint8_t IV[IV_SIZE] = { 0 }; // this is a test value, for real use the iv should be different every time\nstatic struct OH_Huks_Blob g_keyAliasFinal1001 = {\n    (uint32_t)strlen(\"HksECDHAgreeKeyAliasTest001_1_final\"),\n    (uint8_t *)\"HksECDHAgreeKeyAliasTest001_1_final\"\n};\n/* 集成密钥参数集 */\nstatic struct OH_Huks_Param g_genAgreeParams[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_ECC\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_AGREE\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_ECC_KEY_SIZE_256\n    }, {\n        .tag = OH_HUKS_TAG_DIGEST,\n        .uint32Param = OH_HUKS_DIGEST_NONE\n    }\n};\nstatic struct OH_Huks_Param g_agreeParamsInit01[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_ECDH\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_AGREE\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_ECC_KEY_SIZE_256\n    }\n};\nstatic struct OH_Huks_Param g_agreeParamsFinish01[] = {\n    {\n        .tag = OH_HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n        .uint32Param = OH_HUKS_STORAGE_ONLY_USED_IN_HUKS\n    }, {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_AES\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_AES_KEY_SIZE_256\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_AGREE\n    }, {\n        .tag = OH_HUKS_TAG_KEY_ALIAS,\n        .blob = g_keyAliasFinal1001\n    }, {\n        .tag = OH_HUKS_TAG_PADDING,\n        .uint32Param = OH_HUKS_PADDING_NONE\n    }, {\n        .tag = OH_HUKS_TAG_BLOCK_MODE,\n        .uint32Param = OH_HUKS_MODE_CBC\n    }\n};\nstatic struct OH_Huks_Blob g_keyAliasFinal2001 = {\n    (uint32_t)strlen(\"HksECDHAgreeKeyAliasTest001_2_final\"),\n    (uint8_t *)\"HksECDHAgreeKeyAliasTest001_2_final\"\n};\nstatic struct OH_Huks_Param g_agreeParamsInit02[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_ECDH\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_AGREE\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_ECC_KEY_SIZE_256\n    }\n};\nstatic struct OH_Huks_Param g_agreeParamsFinish02[] = {\n    {\n        .tag = OH_HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n        .uint32Param = OH_HUKS_STORAGE_ONLY_USED_IN_HUKS\n    }, {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_AES\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_AES_KEY_SIZE_256\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_AGREE\n    }, {\n        .tag = OH_HUKS_TAG_KEY_ALIAS,\n        .blob = g_keyAliasFinal2001\n    }, {\n        .tag = OH_HUKS_TAG_PADDING,\n        .uint32Param = OH_HUKS_PADDING_NONE\n    }, {\n        .tag = OH_HUKS_TAG_BLOCK_MODE,\n        .uint32Param = OH_HUKS_MODE_CBC\n    }\n};\nstatic const uint32_t ECDH_COMMON_SIZE = 1024;\nstatic struct OH_Huks_Blob g_keyAlias01001 = {\n    (uint32_t)strlen(\"HksECDHAgreeKeyAliasTest001_1\"),\n    (uint8_t *)\"HksECDHAgreeKeyAliasTest001_1\"\n};\nstatic struct OH_Huks_Blob g_keyAlias02001 = {\n    (uint32_t)strlen(\"HksECDHAgreeKeyAliasTest001_2\"),\n    (uint8_t *)\"HksECDHAgreeKeyAliasTest001_2\"\n};\nOH_Huks_Result MallocAndCheckBlobData(\n    struct OH_Huks_Blob *blob,\n    const uint32_t blobSize)\n{\n    struct OH_Huks_Result ret;\n    ret.errorCode = OH_HUKS_SUCCESS;\n    blob->data = (uint8_t *)malloc(blobSize);\n    if (blob->data == NULL) {\n        ret.errorCode = OH_HUKS_ERR_CODE_INTERNAL_ERROR;\n    }\n    return ret;\n}\n/* 导出密钥 */\nOH_Huks_Result HksEcdhAgreeExport(const struct OH_Huks_Blob *keyAlias1, const struct OH_Huks_Blob *keyAlias2,\n    struct OH_Huks_Blob *publicKey1, struct OH_Huks_Blob *publicKey2, const struct OH_Huks_ParamSet *genParamSet)\n{\n    OH_Huks_Result ret = OH_Huks_ExportPublicKeyItem(keyAlias1, genParamSet, publicKey1);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    ret = OH_Huks_ExportPublicKeyItem(keyAlias2, genParamSet, publicKey2);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    return ret;\n}\nstatic const char *g_inData = \"Hks_ECDH_Agree_Test_000000000000000000000000000000000000000000000000000000000000\"\n                                    \"00000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n                                    \"0000000000000000000000000000000000000000000000000000000000000000000000000_string\";\n/* 协商密钥操作 */\nOH_Huks_Result HksEcdhAgreeFinish(const struct OH_Huks_Blob *keyAlias, const struct OH_Huks_Blob *publicKey,\n    const struct OH_Huks_ParamSet *initParamSet, const struct OH_Huks_ParamSet *finishParamSet, struct OH_Huks_Blob *outData)\n{\n    struct OH_Huks_Blob inData = {\n        (uint32_t)strlen(g_inData),\n        (uint8_t *)g_inData\n    };\n    uint8_t handleU[sizeof(uint64_t)] = {0};\n    struct OH_Huks_Blob handle = { sizeof(uint64_t), handleU };\n    OH_Huks_Result ret = OH_Huks_InitSession(keyAlias, initParamSet, &handle, nullptr);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    uint8_t outDataU[ECDH_COMMON_SIZE] = {0};\n    struct OH_Huks_Blob outDataUpdate = { ECDH_COMMON_SIZE, outDataU };\n    ret = OH_Huks_UpdateSession(&handle, initParamSet, publicKey, &outDataUpdate);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    ret = OH_Huks_FinishSession(&handle, finishParamSet, &inData, outData);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    return ret;\n}\n/* 协商密钥整体流程 */\nstatic napi_value AgreeKey(napi_env env, napi_callback_info info)\n{\n    struct OH_Huks_ParamSet *genParamSet = nullptr;\n    struct OH_Huks_ParamSet *initParamSet01 = nullptr;\n    struct OH_Huks_ParamSet *finishParamSet01 = nullptr;\n    struct OH_Huks_ParamSet *initParamSet02 = nullptr;\n    struct OH_Huks_ParamSet *finishParamSet02 = nullptr;\n    struct OH_Huks_Blob publicKey01 = { .size = OH_HUKS_ECC_KEY_SIZE_256, .data = nullptr };\n    struct OH_Huks_Blob publicKey02 = { .size = OH_HUKS_ECC_KEY_SIZE_256, .data = nullptr };\n    struct OH_Huks_Blob outData01 = { .size = ECDH_COMMON_SIZE, .data = nullptr };\n    struct OH_Huks_Blob outData02 = { .size = ECDH_COMMON_SIZE, .data = nullptr };\n    OH_Huks_Result ohResult;\n    do {\n        /* 1.确定密钥别名集成密钥参数集 */\n        ohResult = InitParamSet(&genParamSet, g_genAgreeParams, sizeof(g_genAgreeParams) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = InitParamSet(&initParamSet01, g_agreeParamsInit01, sizeof(g_agreeParamsInit01) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = InitParamSet(&finishParamSet01, g_agreeParamsFinish01,\n            sizeof(g_agreeParamsFinish01) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = InitParamSet(&initParamSet02, g_agreeParamsInit02, sizeof(g_agreeParamsInit02) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = InitParamSet(&finishParamSet02, g_agreeParamsFinish02,\n            sizeof(g_agreeParamsFinish02) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 2.设备A生成密钥 */\n        ohResult = OH_Huks_GenerateKeyItem(&g_keyAlias01001, genParamSet, nullptr);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 3.设备B生成密钥 */\n        ohResult = OH_Huks_GenerateKeyItem(&g_keyAlias02001, genParamSet, nullptr);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = MallocAndCheckBlobData(&publicKey01, publicKey01.size);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = MallocAndCheckBlobData(&publicKey02, publicKey02.size);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 4.设备A、B导出公钥 */\n        ohResult = HksEcdhAgreeExport(&g_keyAlias01001, &g_keyAlias02001, &publicKey01, &publicKey02, genParamSet);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = MallocAndCheckBlobData(&outData01, outData01.size);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = MallocAndCheckBlobData(&outData02, outData02.size);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 5.设备A协商密钥 */\n        ohResult = HksEcdhAgreeFinish(&g_keyAlias01001, &publicKey02, initParamSet01, finishParamSet01, &outData01);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 5.设备B协商密钥 */\n        ohResult = HksEcdhAgreeFinish(&g_keyAlias02001, &publicKey01, initParamSet02, finishParamSet02, &outData02);\n    } while (0);\n    free(publicKey01.data);\n    free(publicKey02.data);\n    free(outData01.data);\n    free(outData02.data);\n    /* 6.设备A、B删除密钥 */\n    OH_Huks_DeleteKeyItem(&g_keyAlias01001, genParamSet);\n    OH_Huks_DeleteKeyItem(&g_keyAlias02001, genParamSet);\n    OH_Huks_DeleteKeyItem(&g_keyAliasFinal1001, NULL);\n    OH_Huks_DeleteKeyItem(&g_keyAliasFinal2001, NULL);\n    OH_Huks_FreeParamSet(&genParamSet);\n    OH_Huks_FreeParamSet(&initParamSet01);\n    OH_Huks_FreeParamSet(&finishParamSet01);\n    OH_Huks_FreeParamSet(&initParamSet02);\n    OH_Huks_FreeParamSet(&finishParamSet02);\n    \n    napi_value ret;\n    napi_create_int32(env, ohResult.errorCode, &ret);\n    return ret;\n}

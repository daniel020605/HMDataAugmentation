拉起图片编辑类应用（startAbilityByType）
使用场景
当应用自身不具备图片编辑能力、但存在图片编辑的场景时，可以通过startAbilityByType拉起图片编辑类应用扩展面板，由对应的应用完成图片编辑操作。图片编辑类应用可以通过PhotoEditorExtensionAbility实现图片编辑页面，并将该页面注册到图片编辑面板，从而将图片编辑能力开放给其他应用。
流程示意图如下：
例如：用户在图库App中选择编辑图片时，图库App可以通过startAbilityByType拉起图片编辑类应用扩展面板。用户可以从已实现PhotoEditorExtensionAbility应用中选择一款，并进行图片编辑。
接口说明
接口详情参见PhotoEditorExtensionAbility和PhotoEditorExtensionContext。
图片编辑类应用实现图片编辑页面
 在DevEco Studio工程中手动新建一个PhotoEditorExtensionAbility。  在工程Module对应的ets目录下，右键选择“New > Directory”，新建一个目录，如PhotoEditorExtensionAbility。 在PhotoEditorExtensionAbility目录中，右键选择“New > File”，新建一个.ets文件，如ExamplePhotoEditorAbility.ets。  在ExamplePhotoEditorAbility.ets中重写onCreate、onForeground、onBackground、onDestroy和onStartContentEditing的生命周期回调。 其中，需要在onStartContentEditing中加载入口页面文件pages/Index.ets，并将session、uri、实例对象等保存在LocalStorage中传递给页面。 import { PhotoEditorExtensionAbility,UIExtensionContentSession,Want } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\n\nconst TAG = '[ExamplePhotoEditorAbility]';\nexport default class ExamplePhotoEditorAbility extends PhotoEditorExtensionAbility {\n  onCreate() {\n    hilog.info(0x0000, TAG, 'onCreate');\n  }\n\n  // 获取图片，加载页面并将需要的参数传递给页面\n  onStartContentEditing(uri: string, want: Want, session: UIExtensionContentSession): void {\n    hilog.info(0x0000, TAG, `onStartContentEditing want: ${JSON.stringify(want)}, uri: ${uri}`);\n\n    const storage: LocalStorage = new LocalStorage({\n      \"session\": session,\n      \"uri\": uri\n    } as Record<string, Object>);\n\n    session.loadContent('pages/Index', storage);\n  }\n\n  onForeground() {\n    hilog.info(0x0000, TAG, 'onForeground');\n  }\n\n  onBackground() {\n    hilog.info(0x0000, TAG, 'onBackground');\n  }\n\n  onDestroy() {\n    hilog.info(0x0000, TAG, 'onDestroy');\n  }\n} 在page中实现图片编辑功能。 图片编辑完成后调用saveEditedContentWithImage保存图片，并将回调结果通过terminateSelfWithResult返回给调用方。 import { common } from '@kit.AbilityKit';\nimport { UIExtensionContentSession, Want } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { fileIo } from '@kit.CoreFileKit';\nimport { image } from '@kit.ImageKit';\n\nconst storage = LocalStorage.getShared()\nconst TAG = '[ExamplePhotoEditorAbility]';\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'editImg';\n  @State originalImage: PixelMap | null = null;\n  @State editedImage: PixelMap | null = null;\n  private newWant ?: Want;\n\n  aboutToAppear(): void {\n    let originalImageUri = storage?.get<string>(\"uri\") ?? \"\";\n    hilog.info(0x0000, TAG, `OriginalImageUri: ${originalImageUri}.`);\n\n    this.readImageByUri(originalImageUri).then(imagePixMap => {\n      this.originalImage = imagePixMap;\n    })\n  }\n\n  // 根据uri读取图片内容\n  async readImageByUri(uri: string): Promise < PixelMap | null > {\n    hilog.info(0x0000, TAG, \"uri: \" + uri);\n    let file: fileIo.File | undefined;\n    try {\n      file = await fileIo.open(uri, fileIo.OpenMode.READ_ONLY);\n      hilog.info(0x0000, TAG, \"Original image file id: \" + file.fd);\n\n      let imageSourceApi: image.ImageSource = image.createImageSource(file.fd);\n      if(!imageSourceApi) {\n        hilog.info(0x0000, TAG, \"ImageSourceApi failed\");\n        return null;\n      }\n      let pixmap: image.PixelMap = await imageSourceApi.createPixelMap();\n      if(!pixmap) {\n        hilog.info(0x0000, TAG, \"createPixelMap failed\");\n        return null;\n      }\n      this.originalImage = pixmap;\n      return pixmap;\n    } catch(e) {\n      hilog.info(0x0000, TAG, `ReadImage failed:${e}`);\n    } finally {\n      fileIo.close(file);\n    }\n    return null;\n  }\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n\n        Button(\"RotateAndSaveImg\").onClick(event => {\n          hilog.info(0x0000, TAG, `Start to edit image and save.`);\n          // 编辑图片功能实现\n          this.originalImage?.rotate(90).then(() => {\n            let packOpts: image.PackingOption = { format: \"image/jpeg\", quality: 98 };\n            try {\n              // 调用saveEditedContentWithImage保存图片\n              (getContext(this) as common.PhotoEditorExtensionContext).saveEditedContentWithImage(this.originalImage as image.PixelMap,\n                packOpts).then(data => {\n                if (data.resultCode == 0) {\n                  hilog.info(0x0000, TAG, `Save succeed.`);\n                }\n                hilog.info(0x0000, TAG,\n                    `saveContentEditingWithImage result: ${JSON.stringify(data)}`);\n                this.newWant = data.want;\n                // data.want.uri存有编辑过图片的uri\n                this.readImageByUri(this.newWant?.uri ?? \"\").then(imagePixMap => {\n                  this.editedImage = imagePixMap;\n                })\n              })\n            } catch (e) {\n              hilog.error(0x0000, TAG, `saveContentEditingWithImage failed:${e}`);\n              return;\n            }\n          })\n        }).margin({ top: 10 })\n\n        Button(\"terminateSelfWithResult\").onClick((event => {\n          hilog.info(0x0000, TAG, `Finish the current editing.`);\n\n          let session = storage.get('session') as UIExtensionContentSession;\n          // 关闭并回传修改结果给调用方\n          session.terminateSelfWithResult({ resultCode: 0, want: this.newWant });\n\n        })).margin({ top: 10 })\n\n        Image(this.originalImage).width(\"100%\").height(200).margin({ top: 10 }).objectFit(ImageFit.Contain)\n\n        Image(this.editedImage).width(\"100%\").height(200).margin({ top: 10 }).objectFit(ImageFit.Contain)\n      }\n      .width('100%')\n    }\n    .height('100%')\n    .backgroundColor(Color.Pink)\n    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])\n  }\n} 在工程Module对应的module.json5配置文件中注册PhotoEditorExtensionAbility。 type标签需要配置为\"photoEditor\"，srcEntry需要配置为PhotoEditorExtensionAbility组件所对应的代码路径。 {\n  \"module\": {\n    \"extensionAbilities\": [\n      {\n        \"name\": \"ExamplePhotoEditorAbility\",\n        \"icon\": \"$media:icon\",\n        \"description\": \"ExamplePhotoEditorAbility\",\n        \"type\": \"photoEditor\",\n        \"exported\": true,\n        \"srcEntry\": \"./ets/PhotoEditorExtensionAbility/ExamplePhotoEditorAbility.ets\",\n        \"label\": \"$string:EntryAbility_label\",\n        \"extensionProcessMode\": \"bundle\"\n      },\n    ]\n  }\n} 
调用方拉起图片编辑类应用编辑图片
开发者可以在UIAbility或者UIExtensionAbility的页面中通过接口startAbilityByType拉起图片编辑类应用扩展面板，系统将自动查找并在面板上展示基于PhotoEditorExtensionAbility实现的图片编辑应用，由用户选择某个应用来完成图片编辑的功能，最终将编辑的结果返回给到调用方，具体步骤如下：
 导入模块。import { common, wantConstant } from '@kit.AbilityKit';\nimport { fileUri, picker } from '@kit.CoreFileKit'; （可选）实现从图库中选取图片。async photoPickerGetUri(): Promise < string > {\n  try {\n    let PhotoSelectOptions = new picker.PhotoSelectOptions();\n    PhotoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE;\n    PhotoSelectOptions.maxSelectNumber = 1;\n    let photoPicker = new picker.PhotoViewPicker();\n    let photoSelectResult: picker.PhotoSelectResult = await photoPicker.select(PhotoSelectOptions);\n    return photoSelectResult.photoUris[0];\n  } catch(error) {\n    let err: BusinessError = error as BusinessError;\n    hilog.info(0x0000, TAG, 'PhotoViewPicker failed with err: ' + JSON.stringify(err));\n  }\n  return \"\";\n} 将图片拷贝到本地沙箱路径。 let context = getContext(this) as common.UIAbilityContext;\n let file: fileIo.File | undefined;\n try {\n   file = fileIo.openSync(uri, fileIo.OpenMode.READ_ONLY);\n   hilog.info(0x0000, TAG, \"file: \" + file.fd);\n\n   let timeStamp = Date.now();\n   // 将用户图片拷贝到应用沙箱路径\n   fileIo.copyFileSync(file.fd, context.filesDir + `/original-${timeStamp}.jpg`);\n\n   this.filePath = context.filesDir + `/original-${timeStamp}.jpg`;\n   this.originalImage = fileUri.getUriFromPath(this.filePath);\n } catch (e) {\n   hilog.info(0x0000, TAG, `readImage failed:${e}`);\n } finally {\n   fileIo.close(file);\n } 在startAbilityByType回调函数中，通过want.uri获取编辑后的图片uri，并做对应的处理。  let context = getContext(this) as common.UIAbilityContext;\n  let abilityStartCallback: common.AbilityStartCallback = {\n    onError: (code, name, message) => {\n      const tip: string = `code:` + code + ` name:` + name + ` message:` + message;\n      hilog.error(0x0000, TAG, \"startAbilityByType:\", tip);\n    },\n    onResult: (result) => {\n      // 获取到回调结果中编辑后的图片uri并做对应的处理\n      let uri = result.want?.uri ?? \"\";\n      hilog.info(0x0000, TAG, \"PhotoEditorCaller result: \" + JSON.stringify(result));\n      this.readImage(uri).then(imagePixMap => {\n        this.editedImage = imagePixMap;\n      });\n    }\n  } 将图片转换为图片uri，并调用startAbilityByType拉起图片编辑应用面板。 let uri = fileUri.getUriFromPath(this.filePath);\n context.startAbilityByType(\"photoEditor\", {\n   \"ability.params.stream\": [uri], // 原始图片的uri,只支持传入一个uri\n   \"ability.want.params.uriPermissionFlag\": wantConstant.Flags.FLAG_AUTH_READ_URI_PERMISSION // 至少需要分享读权限给到图片编辑面板\n } as Record<string, Object>, abilityStartCallback, (err) => {\n   let tip: string;\n   if (err) {\n     tip = `Start error: ${JSON.stringify(err)}`;\n     hilog.error(0x0000, TAG, `startAbilityByType: fail, err: ${JSON.stringify(err)}`);\n   } else {\n     tip = `Start success`;\n     hilog.info(0x0000, TAG, \"startAbilityByType: \", `success`);\n   }\n }); 
示例：
import { common, wantConstant } from '@kit.AbilityKit';\nimport { fileUri, picker } from '@kit.CoreFileKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { fileIo } from '@kit.CoreFileKit';\nimport { image } from '@kit.ImageKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { JSON } from '@kit.ArkTS';\n\nconst TAG = 'PhotoEditorCaller';\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'selectImg';\n  @State originalImage: ResourceStr = \"\";\n  @State editedImage: PixelMap | null = null;\n  private filePath: string = \"\";\n\n  // 根据uri读取图片内容\n  async readImage(uri: string): Promise < PixelMap | null > {\n    hilog.info(0x0000, TAG, \"image uri: \" + uri);\n    let file: fileIo.File | undefined;\n    try {\n      file = await fileIo.open(uri, fileIo.OpenMode.READ_ONLY);\n      hilog.info(0x0000, TAG, \"file: \" + file.fd);\n\n      let imageSourceApi: image.ImageSource = image.createImageSource(file.fd);\n      if(!imageSourceApi) {\n        hilog.info(0x0000, TAG, \"imageSourceApi failed\");\n        return null;\n      }\n      let pixmap: image.PixelMap = await imageSourceApi.createPixelMap();\n      if(!pixmap) {\n        hilog.info(0x0000, TAG, \"createPixelMap failed\");\n        return null;\n      }\n      this.editedImage = pixmap;\n      return pixmap;\n    } catch(e) {\n      hilog.info(0x0000, TAG, `readImage failed:${e}`);\n    } finally {\n      fileIo.close(file);\n    }\n    return null;\n  }\n\n  // 图库中选取图片\n  async photoPickerGetUri(): Promise < string > {\n    try {\n      let PhotoSelectOptions = new picker.PhotoSelectOptions();\n      PhotoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE;\n      PhotoSelectOptions.maxSelectNumber = 1;\n      let photoPicker = new picker.PhotoViewPicker();\n      let photoSelectResult: picker.PhotoSelectResult = await photoPicker.select(PhotoSelectOptions);\n      hilog.info(0x0000, TAG,\n        'PhotoViewPicker.select successfully, PhotoSelectResult uri: ' + JSON.stringify(photoSelectResult));\n      return photoSelectResult.photoUris[0];\n    } catch(error) {\n      let err: BusinessError = error as BusinessError;\n      hilog.info(0x0000, TAG, 'PhotoViewPicker failed with err: ' + JSON.stringify(err));\n    }\n    return \"\";\n  }\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n\n        Button(\"selectImg\").onClick(event => {\n          // 图库中选取图片\n          this.photoPickerGetUri().then(uri => {\n            hilog.info(0x0000, TAG, \"uri: \" + uri);\n\n            let context = getContext(this) as common.UIAbilityContext;\n            let file: fileIo.File | undefined;\n            try {\n              file = fileIo.openSync(uri, fileIo.OpenMode.READ_ONLY);\n              hilog.info(0x0000, TAG, \"file: \" + file.fd);\n\n              let timeStamp = Date.now();\n              // 将用户图片拷贝到应用沙箱路径\n              fileIo.copyFileSync(file.fd, context.filesDir + `/original-${timeStamp}.jpg`);\n\n              this.filePath = context.filesDir + `/original-${timeStamp}.jpg`;\n              this.originalImage = fileUri.getUriFromPath(this.filePath);\n            } catch (e) {\n              hilog.info(0x0000, TAG, `readImage failed:${e}`);\n            } finally {\n              fileIo.close(file);\n            }\n          })\n\n        }).width('200').margin({ top: 20 })\n\n        Button(\"editImg\").onClick(event => {\n          let context = getContext(this) as common.UIAbilityContext;\n          let abilityStartCallback: common.AbilityStartCallback = {\n            onError: (code, name, message) => {\n              const tip: string = `code:` + code + ` name:` + name + ` message:` + message;\n              hilog.error(0x0000, TAG, \"startAbilityByType:\", tip);\n            },\n            onResult: (result) => {\n              // 获取到回调结果中编辑后的图片uri并做对应的处理\n              let uri = result.want?.uri ?? \"\";\n              hilog.info(0x0000, TAG, \"PhotoEditorCaller result: \" + JSON.stringify(result));\n              this.readImage(uri).then(imagePixMap => {\n                this.editedImage = imagePixMap;\n              });\n            }\n          }\n          // 将图片转换为图片uri，并调用startAbilityByType拉起图片编辑应用面板\n          let uri = fileUri.getUriFromPath(this.filePath);\n          context.startAbilityByType(\"photoEditor\", {\n            \"ability.params.stream\": [uri], // 原始图片的uri,只支持传入一个uri\n            \"ability.want.params.uriPermissionFlag\": wantConstant.Flags.FLAG_AUTH_READ_URI_PERMISSION // 至少需要分享读权限给到图片编辑面板\n          } as Record<string, Object>, abilityStartCallback, (err) => {\n            let tip: string;\n            if (err) {\n              tip = `Start error: ${JSON.stringify(err)}`;\n              hilog.error(0x0000, TAG, `startAbilityByType: fail, err: ${JSON.stringify(err)}`);\n            } else {\n              tip = `Start success`;\n              hilog.info(0x0000, TAG, \"startAbilityByType: \", `success`);\n            }\n          });\n\n        }).width('200').margin({ top: 20 })\n\n        Image(this.originalImage).width(\"100%\").height(200).margin({ top: 20 }).objectFit(ImageFit.Contain)\n\n        Image(this.editedImage).width(\"100%\").height(200).margin({ top: 20 }).objectFit(ImageFit.Contain)\n      }\n      .width('100%')\n    }\n    .height('100%')\n    .backgroundColor(Color.Orange)\n    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])\n  }\n}

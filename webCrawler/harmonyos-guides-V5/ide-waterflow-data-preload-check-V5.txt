@performance/waterflow-data-preload-check
建议对waterflow子组件进行数据预加载。
滑动丢帧场景下，建议优先修改。
规则配置
// code-linter.json5\n{\n  \"rules\": {\n    \"@performance/waterflow-data-preload-check\": \"suggestion\",\n  }\n}
选项
该规则无需配置额外选项。
正例
下文中WaterFlowDataSource.ets为依赖代码：
// WaterFlowDataSource.ets\n\n// 实现IDataSource接口的对象，用于瀑布流组件加载数据\nexport class WaterFlowDataSource implements IDataSource {\n  private dataArray: number[] = []\n  private listeners: DataChangeListener[] = []\n\n  constructor() {\n    for (let i = 0; i < 100; i++) {\n      this.dataArray.push(i)\n    }\n  }\n\n  // 获取索引对应的数据\n  public getData(index: number): number {\n    return this.dataArray[index]\n  }\n\n  // 通知控制器数据重新加载\n  notifyDataReload(): void {\n    this.listeners.forEach(listener => {\n      listener.onDataReloaded()\n    })\n  }\n\n  // 通知控制器数据增加\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index)\n    })\n  }\n\n  // 通知控制器数据变化\n  notifyDataChange(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataChange(index)\n    })\n  }\n\n  // 通知控制器数据删除\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataDelete(index)\n    })\n  }\n\n  // 通知控制器数据位置变化\n  notifyDataMove(from: number, to: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataMove(from, to)\n    })\n  }\n\n  // 获取数据总数\n  public totalCount(): number {\n    return this.dataArray.length\n  }\n\n  // 注册改变数据的控制器\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener)\n    }\n  }\n\n  // 注销改变数据的控制器\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener)\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1)\n    }\n  }\n\n  // 增加数据\n  public add1stItem(): void {\n    this.dataArray.splice(0, 0, this.dataArray.length)\n    this.notifyDataAdd(0)\n  }\n\n  // 在数据尾部增加一个元素\n  public addLastItem(): void {\n    this.dataArray.splice(this.dataArray.length, 0, this.dataArray.length)\n    this.notifyDataAdd(this.dataArray.length - 1)\n  }\n\n  // 在指定索引位置增加一个元素\n  public addItem(index: number): void {\n    this.dataArray.splice(index, 0, this.dataArray.length)\n    this.notifyDataAdd(index)\n  }\n\n  // 删除第一个元素\n  public delete1stItem(): void {\n    this.dataArray.splice(0, 1)\n    this.notifyDataDelete(0)\n  }\n\n  // 删除第二个元素\n  public delete2ndItem(): void {\n    this.dataArray.splice(1, 1)\n    this.notifyDataDelete(1)\n  }\n\n  // 删除最后一个元素\n  public deleteLastItem(): void {\n    this.dataArray.splice(-1, 1)\n    this.notifyDataDelete(this.dataArray.length)\n  }\n\n  // 重新加载数据\n  public reload(): void {\n    this.dataArray.splice(1, 1)\n    this.dataArray.splice(3, 2)\n    this.notifyDataReload()\n  }\n}\n
下文中Index.ets为正例测试代码，依赖上文中WaterFlowDataSource.ets：
// Index.ets\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\n\n@Entry\n@Component\nstruct WaterFlowDemo {\n  @State minSize: number = 80\n  @State maxSize: number = 180\n  @State fontSize: number = 24\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F]\n  scroller: Scroller = new Scroller()\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource()\n  private itemWidthArray: number[] = []\n  private itemHeightArray: number[] = []\n\n  // 计算FlowItem宽/高\n  getSize() {\n    let ret = Math.floor(Math.random() * this.maxSize)\n    return (ret > this.minSize ? ret : this.minSize)\n  }\n\n  // 设置FlowItem的宽/高数组\n  setItemSizeArray() {\n    for (let i = 0; i < 100; i++) {\n      this.itemWidthArray.push(this.getSize())\n      this.itemHeightArray.push(this.getSize())\n    }\n  }\n\n  aboutToAppear() {\n    this.setItemSizeArray()\n  }\n\n  @Builder\n  itemFoot() {\n    Text(`Footer`)\n      .fontSize(10)\n    \n      .width(50)\n      .height(50)\n      .align(Alignment.Center)\n      .margin({ top: 2 })\n  }\n\n  build() {\n    Column({ space: 2 }) {\n      WaterFlow() {\n        LazyForEach(this.dataSource, (item: number) => {\n          FlowItem() {\n            ReusableFlowItem({ item: item })\n          }\n          .onAppear(() => {\n            // 即将触底时提前增加数据，即执行数据预加载\n            if (item + 20 == this.dataSource.totalCount()) {\n              for (let i = 0; i < 100; i++) {\n                this.dataSource.addLastItem()\n              }\n            }\n          })\n          .width('100%')\n          .height(this.itemHeightArray[item % 100])\n          .backgroundColor(this.colors[item % 5])\n        }, (item: string) => item)\n      }\n      .columnsTemplate('1fr 1fr')\n      .columnsGap(10)\n      .rowsGap(5)\n      .width('100%')\n      .height('100%')\n    }\n  }\n}\n\n@Reusable\n@Component\nstruct ReusableFlowItem {\n  @State item: number = 0\n\n  // 从复用缓存中加入到组件树之前调用，可在此处更新组件的状态变量以展示正确的内容\n  aboutToReuse(params: Record<string, ESObject>) {\n    this.item = params.item;\n  }\n\n  build() {\n    Column() {\n      Text('N' + this.item).fontSize(12).height('16')\n      Image('res/waterFlowTest (' + this.item % 5 + ').jpg')\n        .objectFit(ImageFit.Fill)\n        .width('100%')\n        .layoutWeight(1)\n    }\n  }\n}
反例
下文中WaterFlowDataSource.ets为依赖代码：
// WaterFlowDataSource.ets\n\n// 实现IDataSource接口的对象，用于瀑布流组件加载数据\nexport class WaterFlowDataSource implements IDataSource {\n  private dataArray: number[] = []\n  private listeners: DataChangeListener[] = []\n\n  constructor() {\n    for (let i = 0; i < 100; i++) {\n      this.dataArray.push(i)\n    }\n  }\n\n  // 获取索引对应的数据\n  public getData(index: number): number {\n    return this.dataArray[index]\n  }\n\n  // 通知控制器数据重新加载\n  notifyDataReload(): void {\n    this.listeners.forEach(listener => {\n      listener.onDataReloaded()\n    })\n  }\n\n  // 通知控制器数据增加\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index)\n    })\n  }\n\n  // 通知控制器数据变化\n  notifyDataChange(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataChange(index)\n    })\n  }\n\n  // 通知控制器数据删除\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataDelete(index)\n    })\n  }\n\n  // 通知控制器数据位置变化\n  notifyDataMove(from: number, to: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataMove(from, to)\n    })\n  }\n\n  // 获取数据总数\n  public totalCount(): number {\n    return this.dataArray.length\n  }\n\n  // 注册改变数据的控制器\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener)\n    }\n  }\n\n  // 注销改变数据的控制器\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener)\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1)\n    }\n  }\n\n  // 增加数据\n  public add1stItem(): void {\n    this.dataArray.splice(0, 0, this.dataArray.length)\n    this.notifyDataAdd(0)\n  }\n\n  // 在数据尾部增加一个元素\n  public addLastItem(): void {\n    this.dataArray.splice(this.dataArray.length, 0, this.dataArray.length)\n    this.notifyDataAdd(this.dataArray.length - 1)\n  }\n\n  // 在指定索引位置增加一个元素\n  public addItem(index: number): void {\n    this.dataArray.splice(index, 0, this.dataArray.length)\n    this.notifyDataAdd(index)\n  }\n\n  // 删除第一个元素\n  public delete1stItem(): void {\n    this.dataArray.splice(0, 1)\n    this.notifyDataDelete(0)\n  }\n\n  // 删除第二个元素\n  public delete2ndItem(): void {\n    this.dataArray.splice(1, 1)\n    this.notifyDataDelete(1)\n  }\n\n  // 删除最后一个元素\n  public deleteLastItem(): void {\n    this.dataArray.splice(-1, 1)\n    this.notifyDataDelete(this.dataArray.length)\n  }\n\n  // 重新加载数据\n  public reload(): void {\n    this.dataArray.splice(1, 1)\n    this.dataArray.splice(3, 2)\n    this.notifyDataReload()\n  }\n}\n
下文中Index.ets为反例测试代码，依赖上文中WaterFlowDataSource.ets：
// Index.ets\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\n\n@Entry\n@Component\nstruct WaterFlowDemo {\n  @State minSize: number = 80\n  @State maxSize: number = 180\n  @State fontSize: number = 24\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F]\n  scroller: Scroller = new Scroller()\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource()\n  private itemWidthArray: number[] = []\n  private itemHeightArray: number[] = []\n\n  // 计算FlowItem宽/高\n  getSize() {\n    let ret = Math.floor(Math.random() * this.maxSize)\n    return (ret > this.minSize ? ret : this.minSize)\n  }\n\n  // 设置FlowItem的宽/高数组\n  setItemSizeArray() {\n    for (let i = 0; i < 100; i++) {\n      this.itemWidthArray.push(this.getSize())\n      this.itemHeightArray.push(this.getSize())\n    }\n  }\n\n  aboutToAppear() {\n    this.setItemSizeArray()\n  }\n\n  @Builder\n  itemFoot() {\n    Text(`Footer`)\n      .fontSize(10)\n      .backgroundColor(Color.Red)\n      .width(50)\n      .height(50)\n      .align(Alignment.Center)\n      .margin({ top: 2 })\n  }\n\n  build() {\n    Column({ space: 2 }) {\n      WaterFlow() {\n        LazyForEach(this.dataSource, (item: number) => {\n          FlowItem() {\n            ReusableFlowItem({ item: item })\n          }\n          .width('100%')\n          .height(this.itemHeightArray[item % 100])\n          .backgroundColor(this.colors[item % 5])\n        }, (item: string) => item)\n      }\n      .onReachEnd(() => {\n        console.info(\"onReachEnd\")\n        setTimeout(() => {\n          for (let i = 0; i < 100; i++) {\n            this.datasource.AddLastItem()\n          }\n        }, 1000)\n      })\n      .columnsTemplate(\"1fr 1fr\")\n      .columnsGap(10)\n      .rowsGap(5)\n      .backgroundColor(0xFAEEE0)\n      .width('100%')\n      .height('100%')\n    }\n  }\n}\n\n@Reusable\n@Component\nstruct ReusableFlowItem {\n  @State item: number = 0\n\n  // 从复用缓存中加入到组件树之前调用，可在此处更新组件的状态变量以展示正确的内容\n  aboutToReuse(params: Record<string, ESObject>) {\n    this.item = params.item;\n  }\n\n  build() {\n    Column() {\n      Text(\"N\" + this.item).fontSize(12).height('16')\n      Image('res/waterFlowTest (' + this.item % 5 + ').jpg')\n        .objectFit(ImageFit.Fill)\n        .width('100%')\n        .layoutWeight(1)\n    }\n  }\n}
规则集
plugin:@performance/recommended\nplugin:@performance/all
Code Linter代码检查规则的配置指导请参考代码Code Linter检查。

@ObservedV2装饰器和@Trace装饰器：类属性变化观测
为了增强状态管理框架对类对象中属性的观测能力，开发者可以使用@ObservedV2装饰器和@Trace装饰器装饰类以及类中的属性。
@ObservedV2和@Trace提供了对嵌套类对象属性变化直接观测的能力，是状态管理V2中相对核心的能力之一。在阅读本文当前，建议提前阅读：状态管理概述来了解状态管理V2整体的能力架构。
@ObservedV2与@Trace装饰器从API version 12开始支持。
概述
@ObservedV2装饰器与@Trace装饰器用于装饰类以及类中的属性，使得被装饰的类和属性具有深度观测的能力：
@ObservedV2装饰器与@Trace装饰器需要配合使用，单独使用@ObservedV2装饰器或@Trace装饰器没有任何作用。被@Trace装饰器装饰的属性property变化时，仅会通知property关联的组件进行刷新。在嵌套类中，嵌套类中的属性property被@Trace装饰且嵌套类被@ObservedV2装饰时，才具有触发UI刷新的能力。在继承类中，父类或子类中的属性property被@Trace装饰且该property所在类被@ObservedV2装饰时，才具有触发UI刷新的能力。未被@Trace装饰的属性用在UI中无法感知到变化，也无法触发UI刷新。@ObservedV2的类实例目前不支持使用JSON.stringify进行序列化。
状态管理V1版本对嵌套类对象属性变化直接观测的局限性
现有状态管理V1版本无法实现对嵌套类对象属性变化的直接观测。
@Observed\nclass Father {\n  son: Son;\n\n  constructor(name: string, age: number) {\n    this.son = new Son(name, age);\n  }\n}\n@Observed\nclass Son {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n@Entry\n@Component\nstruct Index {\n  @State father: Father = new Father(\"John\", 8);\n\n  build() {\n    Row() {\n      Column() {\n        Text(`name: ${this.father.son.name} age: ${this.father.son.age}`)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            this.father.son.age++;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
上述代码中，点击Text组件增加age的值时，不会触发UI刷新。因为在现有的状态管理框架下，无法观测到嵌套类中属性age的值变化。V1版本的解决方案是使用@ObjectLink装饰器与自定义组件的方式实现观测。
@Observed\nclass Father {\n  son: Son;\n\n  constructor(name: string, age: number) {\n    this.son = new Son(name, age);\n  }\n}\n@Observed\nclass Son {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n@Component\nstruct Child {\n  @ObjectLink son: Son;\n\n  build() {\n    Row() {\n      Column() {\n        Text(`name: ${this.son.name} age: ${this.son.age}`)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            this.son.age++;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}\n@Entry\n@Component\nstruct Index {\n  @State father: Father = new Father(\"John\", 8);\n\n  build() {\n    Column() {\n      Child({son: this.father.son})\n    }\n  }\n}
通过这种方式虽然能够实现对嵌套类中属性变化的观测，但是当嵌套层级较深时，代码将会变得十分复杂，易用性差。因此推出类装饰器@ObservedV2与成员变量装饰器@Trace，增强对嵌套类中属性变化的观测能力。
装饰器说明
观察变化
使用@ObservedV2装饰的类中被@Trace装饰的属性具有被观测变化的能力，当该属性值变化时，会触发该属性绑定的UI组件刷新。
在嵌套类中使用@Trace装饰的属性具有被观测变化的能力。
@ObservedV2\nclass Son {\n  @Trace age: number = 100;\n}\nclass Father {\n  son: Son = new Son();\n}\n@Entry\n@ComponentV2\nstruct Index {\n  father: Father = new Father();\n\n  build() {\n    Column() {\n      // 当点击改变age时，Text组件会刷新\n      Text(`${this.father.son.age}`)\n        .onClick(() => {\n          this.father.son.age++;\n        })\n    }\n  }\n}
在继承类中使用@Trace装饰的属性具有被观测变化的能力。
@ObservedV2\nclass Father {\n  @Trace name: string = \"Tom\";\n}\nclass Son extends Father {\n}\n@Entry\n@ComponentV2\nstruct Index {\n  son: Son = new Son();\n\n  build() {\n    Column() {\n      // 当点击改变name时，Text组件会刷新\n      Text(`${this.son.name}`)\n        .onClick(() => {\n          this.son.name = \"Jack\";\n        })\n    }\n  }\n}
类中使用@Trace装饰的静态属性具有被观测变化的能力。
@ObservedV2\nclass Manager {\n  @Trace static count: number = 1;\n}\n@Entry\n@ComponentV2\nstruct Index {\n  build() {\n    Column() {\n      // 当点击改变count时，Text组件会刷新\n      Text(`${Manager.count}`)\n        .onClick(() => {\n          Manager.count++;\n        })\n    }\n  }\n}
@Trace装饰内置类型时，可以观测各自API导致的变化： 类型 可观测变化的API   Array push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort  Date setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds  Map set, clear, delete  Set add, clear, delete    
使用限制
@ObservedV2与@Trace装饰器存在以下使用限制：
非@Trace装饰的成员属性用在UI上无法触发UI刷新。
@ObservedV2\nclass Person {\n  id: number = 0;\n  @Trace age: number = 8;\n}\n@Entry\n@ComponentV2\nstruct Index {\n  person: Person = new Person();\n\n  build() {\n    Column() {\n      // age被@Trace装饰，用在UI中可以触发UI刷新\n      Text(`${this.person.age}`)\n        .onClick(() => {\n          this.person.age++; // 点击会触发UI刷新\n        })\n      // id未被@Trace装饰，用在UI中不会触发UI刷新\n      Text(`${this.person.id}`) // 当id变化时不会刷新\n        .onClick(() => {\n          this.person.id++; // 点击不会触发UI刷新\n        })\n    }\n  }\n}
@ObservedV2仅能装饰class，无法装饰自定义组件。
@ObservedV2 // 错误用法，编译时报错\nstruct Index {\n  build() {\n  }\n}
@Trace不能用在没有被@ObservedV2装饰的class上。
class User {\n  id: number = 0;\n  @Trace name: string = \"Tom\"; // 错误用法，编译时报错\n}
@Trace是class中属性的装饰器，不能用在struct中。
@ComponentV2\nstruct Comp {\n  @Trace message: string = \"Hello World\"; // 错误用法，编译时报错\n\n  build() {\n  }\n}
@ObservedV2、@Trace不能与@Observed、@Track混合使用。
@Observed\nclass User {\n  @Trace name: string = \"Tom\"; // 错误用法，编译时报错\n}\n\n@ObservedV2\nclass Person {\n  @Track name: string = \"Jack\"; // 错误用法，编译时报错\n}
使用@ObservedV2与@Trace装饰的类不能和@State等V1的装饰器混合使用，编译时报错。
// 以@State装饰器为例\n@ObservedV2\nclass Job {\n  @Trace jobName: string = \"Teacher\";\n}\n@ObservedV2\nclass Info {\n  @Trace name: string = \"Tom\";\n  @Trace age: number = 25;\n  job: Job = new Job();\n}\n@Entry\n@Component\nstruct Index {\n  @State info: Info = new Info(); // 无法混用，编译时报错\n\n  build() {\n    Column() {\n      Text(`name: ${this.info.name}`)\n      Text(`age: ${this.info.age}`)\n      Text(`jobName: ${this.info.job.jobName}`)\n      Button(\"change age\")\n        .onClick(() => {\n          this.info.age++;\n        })\n      Button(\"Change job\")\n        .onClick(() => {\n          this.info.job.jobName = \"Doctor\";\n        })\n    }\n  }\n}
继承自@ObservedV2的类无法和@State等V1的装饰器混用，运行时报错。
// 以@State装饰器为例\n@ObservedV2\nclass Job {\n  @Trace jobName: string = \"Teacher\";\n}\n@ObservedV2\nclass Info {\n  @Trace name: string = \"Tom\";\n  @Trace age: number = 25;\n  job: Job = new Job();\n}\nclass Message extends Info {\n    constructor() {\n        super();\n    }\n}\n@Entry\n@Component\nstruct Index {\n  @State message: Message = new Message(); // 无法混用，运行时报错\n\n  build() {\n    Column() {\n      Text(`name: ${this.message.name}`)\n      Text(`age: ${this.message.age}`)\n      Text(`jobName: ${this.message.job.jobName}`)\n      Button(\"change age\")\n        .onClick(() => {\n          this.message.age++;\n        })\n      Button(\"Change job\")\n        .onClick(() => {\n          this.message.job.jobName = \"Doctor\";\n        })\n    }\n  }\n}
@ObservedV2的类实例目前不支持使用JSON.stringify进行序列化。
使用场景
[h2]嵌套类场景
在下面的嵌套类场景中，Pencil类是Son类中最里层的类，Pencil类被@ObservedV2装饰且属性length被@Trace装饰，此时length的变化能够被观测到。
@Trace装饰器与现有状态管理框架的@Track与@State装饰器的能力不同，@Track使class具有属性级更新的能力，但并不具备深度观测的能力；而@State只能观测到对象本身以及第一层的变化，对于多层嵌套场景只能通过封装自定义组件，搭配@Observed和@ObjectLink来实现观测。
点击Button(\"change length\")，length是被@Trace装饰的属性，它的变化可以触发关联的UI组件，即UINode (1)的刷新，并输出\"id: 1 renderTimes: x\"的日志，其中x根据点击次数依次增长。自定义组件Page中的son是常规变量，因此点击Button(\"assign Son\")并不会观测到变化。当点击Button(\"assign Son\")后，再点击Button(\"change length\")并不会引起UI刷新。因为此时son的地址改变，其关联的UI组件并没有关联到最新的son。
@ObservedV2\nclass Pencil {\n  @Trace length: number = 21; // 当length变化时，会刷新关联的组件\n}\nclass Bag {\n  width: number = 50;\n  height: number = 60;\n  pencil: Pencil = new Pencil();\n}\nclass Son {\n  age: number = 5;\n  school: string = \"some\";\n  bag: Bag = new Bag();\n}\n\n@Entry\n@ComponentV2\nstruct Page {\n  son: Son = new Son();\n  renderTimes: number = 0;\n  isRender(id: number): number {\n    console.info(`id: ${id} renderTimes: ${this.renderTimes}`);\n    this.renderTimes++;\n    return 40;\n  }\n\n  build() {\n    Column() {\n      Text('pencil length'+ this.son.bag.pencil.length)\n        .fontSize(this.isRender(1))   // UINode (1)\n      Button(\"change length\")\n        .onClick(() => {\n          // 点击更改length值，UINode（1）会刷新\n          this.son.bag.pencil.length += 100;\n        })\n      Button(\"assign Son\")\n        .onClick(() => {\n          // 由于变量son非状态变量，因此无法刷新UINode（1）\n          this.son = new Son();\n        })\n    }\n  }\n}
[h2]继承类场景
@Trace支持在类的继承场景中使用，无论是在基类还是继承类中，只有被@Trace装饰的属性才具有被观测变化的能力。
以下例子中，声明class GrandFather、Father、Uncle、Son、Cousin，继承关系如下图。
创建类Son和类Cousin的实例，点击Button('change Son age')和Button('change Cousin age')可以触发UI的刷新。
@ObservedV2\nclass GrandFather {\n  @Trace age: number = 0;\n\n  constructor(age: number) {\n    this.age = age;\n  }\n}\nclass Father extends GrandFather{\n  constructor(father: number) {\n    super(father);\n  }\n}\nclass Uncle extends GrandFather {\n  constructor(uncle: number) {\n    super(uncle);\n  }\n}\nclass Son extends Father {\n  constructor(son: number) {\n    super(son);\n  }\n}\nclass Cousin extends Uncle {\n  constructor(cousin: number) {\n    super(cousin);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  son: Son = new Son(0);\n  cousin: Cousin = new Cousin(0);\n  renderTimes: number = 0;\n\n  isRender(id: number): number {\n    console.info(`id: ${id} renderTimes: ${this.renderTimes}`);\n    this.renderTimes++;\n    return 40;\n  }\n\n  build() {\n    Row() {\n      Column() {\n        Text(`Son ${this.son.age}`)\n          .fontSize(this.isRender(1))\n          .fontWeight(FontWeight.Bold)\n        Text(`Cousin ${this.cousin.age}`)\n          .fontSize(this.isRender(2))\n          .fontWeight(FontWeight.Bold)\n        Button('change Son age')\n          .onClick(() => {\n            this.son.age++;\n          })\n        Button('change Cousin age')\n          .onClick(() => {\n            this.cousin.age++;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]@Trace装饰基础类型的数组
@Trace装饰数组时，使用支持的API能够观测到变化。支持的API见观察变化。
在下面的示例中@ObservedV2装饰的Arr类中的属性numberArr是@Trace装饰的数组，当使用数组API操作numberArr时，可以观测到对应的变化。注意使用数组长度进行判断以防越界访问。
let nextId: number = 0;\n\n@ObservedV2\nclass Arr {\n  id: number = 0;\n  @Trace numberArr: number[] = [];\n\n  constructor() {\n    this.id = nextId++;\n    this.numberArr = [0, 1, 2];\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  arr: Arr = new Arr();\n\n  build() {\n    Column() {\n      Text(`length: ${this.arr.numberArr.length}`)\n        .fontSize(40)\n      Divider()\n      if (this.arr.numberArr.length >= 3) {\n        Text(`${this.arr.numberArr[0]}`)\n          .fontSize(40)\n          .onClick(() => {\n            this.arr.numberArr[0]++;\n          })\n        Text(`${this.arr.numberArr[1]}`)\n          .fontSize(40)\n          .onClick(() => {\n            this.arr.numberArr[1]++;\n          })\n        Text(`${this.arr.numberArr[2]}`)\n          .fontSize(40)\n          .onClick(() => {\n            this.arr.numberArr[2]++;\n          })\n      }\n\n      Divider()\n\n      ForEach(this.arr.numberArr, (item: number, index: number) => {\n        Text(`${index} ${item}`)\n          .fontSize(40)\n      })\n\n      Button('push')\n        .onClick(() => {\n          this.arr.numberArr.push(50);\n        })\n\n      Button('pop')\n        .onClick(() => {\n          this.arr.numberArr.pop();\n        })\n\n      Button('shift')\n        .onClick(() => {\n          this.arr.numberArr.shift();\n        })\n\n      Button('splice')\n        .onClick(() => {\n          this.arr.numberArr.splice(1, 0, 60);\n        })\n\n\n      Button('unshift')\n        .onClick(() => {\n          this.arr.numberArr.unshift(100);\n        })\n\n      Button('copywithin')\n        .onClick(() => {\n          this.arr.numberArr.copyWithin(0, 1, 2);\n        })\n\n      Button('fill')\n        .onClick(() => {\n          this.arr.numberArr.fill(0, 2, 4);\n        })\n\n      Button('reverse')\n        .onClick(() => {\n          this.arr.numberArr.reverse();\n        })\n\n      Button('sort')\n        .onClick(() => {\n          this.arr.numberArr.sort();\n        })\n    }\n  }\n}
[h2]@Trace装饰对象数组
@Trace装饰对象数组personList以及Person类中的age属性，因此当personList、age改变时均可以观测到变化。点击Text组件更改age时，Text组件会刷新。
let nextId: number = 0;\n\n@ObservedV2\nclass Person {\n  @Trace age: number = 0;\n\n  constructor(age: number) {\n    this.age = age;\n  }\n}\n\n@ObservedV2\nclass Info {\n  id: number = 0;\n  @Trace personList: Person[] = [];\n\n  constructor() {\n    this.id = nextId++;\n    this.personList = [new Person(0), new Person(1), new Person(2)];\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info();\n\n  build() {\n    Column() {\n      Text(`length: ${this.info.personList.length}`)\n        .fontSize(40)\n      Divider()\n      if (this.info.personList.length >= 3) {\n        Text(`${this.info.personList[0].age}`)\n          .fontSize(40)\n          .onClick(() => {\n            this.info.personList[0].age++;\n          })\n\n        Text(`${this.info.personList[1].age}`)\n          .fontSize(40)\n          .onClick(() => {\n            this.info.personList[1].age++;\n          })\n\n        Text(`${this.info.personList[2].age}`)\n          .fontSize(40)\n          .onClick(() => {\n            this.info.personList[2].age++;\n          })\n      }\n\n      Divider()\n\n      ForEach(this.info.personList, (item: Person, index: number) => {\n        Text(`${index} ${item.age}`)\n          .fontSize(40)\n      })\n    }\n  }\n}
[h2]@Trace装饰Map类型
被@Trace装饰的Map类型属性可以观测到调用API带来的变化，包括 set、clear、delete。因为Info类被@ObservedV2装饰且属性memberMap被@Trace装饰，点击Button('init map')对memberMap赋值也可以观测到变化。
@ObservedV2\nclass Info {\n  @Trace memberMap: Map<number, string> = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n}\n\n@Entry\n@ComponentV2\nstruct MapSample {\n  info: Info = new Info();\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.info.memberMap.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`)\n            .fontSize(30)\n          Text(`${item[1]}`)\n            .fontSize(30)\n          Divider()\n        })\n        Button('init map')\n          .onClick(() => {\n            this.info.memberMap = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n          })\n        Button('set new one')\n          .onClick(() => {\n            this.info.memberMap.set(4, \"d\");\n          })\n        Button('clear')\n          .onClick(() => {\n            this.info.memberMap.clear();\n          })\n        Button('set the key: 0')\n          .onClick(() => {\n            this.info.memberMap.set(0, \"aa\");\n          })\n        Button('delete the first one')\n          .onClick(() => {\n            this.info.memberMap.delete(0);\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]@Trace装饰Set类型
被@Trace装饰的Set类型属性可以观测到调用API带来的变化，包括 add, clear, delete。因为Info类被@ObservedV2装饰且属性memberSet被@Trace装饰，点击Button('init set')对memberSet赋值也可以观察变化。
@ObservedV2\nclass Info {\n  @Trace memberSet: Set<number> = new Set([0, 1, 2, 3, 4]);\n}\n\n@Entry\n@ComponentV2\nstruct SetSample {\n  info: Info = new Info();\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.info.memberSet.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`)\n            .fontSize(30)\n          Divider()\n        })\n        Button('init set')\n          .onClick(() => {\n            this.info.memberSet = new Set([0, 1, 2, 3, 4]);\n          })\n        Button('set new one')\n          .onClick(() => {\n            this.info.memberSet.add(5);\n          })\n        Button('clear')\n          .onClick(() => {\n            this.info.memberSet.clear();\n          })\n        Button('delete the first one')\n          .onClick(() => {\n            this.info.memberSet.delete(0);\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]@Trace装饰Date类型
@Trace装饰的Date类型属性可以观测调用API带来的变化，包括 setFullYear、setMonth、setDate、setHours、setMinutes、setSeconds、setMilliseconds、setTime、setUTCFullYear、setUTCMonth、setUTCDate、setUTCHours、setUTCMinutes、setUTCSeconds、setUTCMilliseconds。因为Info类被@ObservedV2装饰且属性selectedDate被@Trace装饰，点击Button('set selectedDate to 2023-07-08')对selectedDate赋值也可以观测到变化。
@ObservedV2\nclass Info {\n  @Trace selectedDate: Date = new Date('2021-08-08')\n}\n\n@Entry\n@ComponentV2\nstruct DateSample {\n  info: Info = new Info()\n\n  build() {\n    Column() {\n      Button('set selectedDate to 2023-07-08')\n        .margin(10)\n        .onClick(() => {\n          this.info.selectedDate = new Date('2023-07-08');\n        })\n      Button('increase the year by 1')\n        .margin(10)\n        .onClick(() => {\n          this.info.selectedDate.setFullYear(this.info.selectedDate.getFullYear() + 1);\n        })\n      Button('increase the month by 1')\n        .margin(10)\n        .onClick(() => {\n          this.info.selectedDate.setMonth(this.info.selectedDate.getMonth() + 1);\n        })\n      Button('increase the day by 1')\n        .margin(10)\n        .onClick(() => {\n          this.info.selectedDate.setDate(this.info.selectedDate.getDate() + 1);\n        })\n      DatePicker({\n        start: new Date('1970-1-1'),\n        end: new Date('2100-1-1'),\n        selected: this.info.selectedDate\n      })\n    }.width('100%')\n  }\n}

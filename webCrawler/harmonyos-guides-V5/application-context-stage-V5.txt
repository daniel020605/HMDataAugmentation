应用上下文Context
概述
Context是应用中对象的上下文，其提供了应用的一些基础信息，例如resourceManager（资源管理）、applicationInfo（当前应用信息）、dir（应用文件路径）、area（文件分区）等，以及应用的一些基本方法，例如createBundleContext()、getApplicationContext()等。UIAbility组件和各种ExtensionAbility派生类组件都有各自不同的Context类。分别有基类Context、ApplicationContext、AbilityStageContext、UIAbilityContext、ExtensionContext、ServiceExtensionContext等Context。
 各类Context的继承关系  各类Context的持有关系  各类Context的获取方式  获取UIAbilityContext。每个UIAbility中都包含了一个Context属性，提供操作应用组件、获取应用组件的配置信息等能力。 import { UIAbility, AbilityConstant, Want } from '@kit.AbilityKit';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    let uiAbilityContext = this.context;\n    //...\n  }\n}     页面中获取UIAbility实例的上下文信息请参见获取UIAbility的上下文信息。   获取特定场景ExtensionContext。以ServiceExtensionContext为例，表示后台服务的上下文环境，继承自ExtensionContext，提供后台服务相关的接口能力。 import { ServiceExtensionAbility, Want } from '@kit.AbilityKit';\n\nexport default class ServiceExtAbility extends ServiceExtensionAbility {\n  onCreate(want: Want) {\n    let serviceExtensionContext = this.context;\n    //...\n  }\n} 获取AbilityStageContext（Module级别的Context）。和基类Context相比，额外提供HapModuleInfo、Configuration等信息。 import { AbilityStage } from '@kit.AbilityKit';\n\nexport default class MyAbilityStage extends AbilityStage {\n  onCreate(): void {\n    let abilityStageContext = this.context;\n    //...\n  }\n} 获取ApplicationContext（应用级别的Context）。ApplicationContext在基类Context的基础上提供了订阅应用内应用组件的生命周期的变化、订阅系统内存变化、订阅应用内系统环境变化、设置应用语言、设置应用颜色模式、清除应用自身数据的同时撤销应用向用户申请的权限等能力，在UIAbility、ExtensionAbility、AbilityStage中均可以获取。 import { UIAbility, AbilityConstant, Want } from '@kit.AbilityKit';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    let applicationContext = this.context.getApplicationContext();\n    //...\n  }\n}  
Context的典型使用场景
本章节通过如下典型场景来介绍Context的用法：
 获取应用文件路径 获取和修改加密分区 获取本应用中其他module的context 订阅进程内UIAbility生命周期变化 
[h2]获取应用文件路径
基类Context提供了获取应用文件路径的能力，ApplicationContext、AbilityStageContext、UIAbilityContext和ExtensionContext均继承该能力。不同类型的Context获取的路径可能存在差异。
 通过ApplicationContext可以获取应用级的文件路径。该路径用于存放应用全局信息，路径下的文件会跟随应用的卸载而删除。 通过AbilityStageContext、UIAbilityContext、ExtensionContext，可以获取Module级的文件路径。该路径用于存放Module相关信息，路径下的文件会跟随HAP/HSP的卸载而删除。HAP/HSP的卸载不会影响应用级路径下的文件，除非该应用的HAP/HSP已全部卸载。  UIAbilityContext：可以获取UIAbility所在Module的文件路径。 ExtensionContext：可以获取ExtensionAbility所在Module的文件路径。 AbilityStageContext：由于AbilityStageContext创建时机早于UIAbilityContext和ExtensionContext，通常用于在AbilityStage中获取文件路径。  
应用文件路径属于应用沙箱路径，具体请参见应用沙箱目录。
表1 不同级别Context获取的应用文件路径说明
资源目录。
说明：
需要开发者手动在\\<module-name>\\resource路径下创建resfile目录。
本节以使用ApplicationContext获取filesDir为例，介绍如何获取应用文件路径，并在对应文件路径下新建文件和读写文件。示例代码如下：
import { common } from '@kit.AbilityKit';\nimport { buffer } from '@kit.ArkTS';\nimport { fileIo, ReadOptions } from '@kit.CoreFileKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\n\nconst TAG: string = '[Page_Context]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n  private context = getContext(this) as common.UIAbilityContext;\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n        // ...\n        Button() {\n          Text('create file')\n            // ...\n            .onClick(() => {\n              let applicationContext = this.context.getApplicationContext();\n              // 获取应用文件路径\n              let filesDir = applicationContext.filesDir;\n              hilog.info(DOMAIN_NUMBER, TAG, `filePath: ${filesDir}`);\n              // 文件不存在时创建并打开文件，文件存在时打开文件\n              let file = fileIo.openSync(filesDir + '/test.txt', fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);\n              // 写入一段内容至文件\n              let writeLen = fileIo.writeSync(file.fd, \"Try to write str.\");\n              hilog.info(DOMAIN_NUMBER, TAG, `The length of str is: ${writeLen}`);\n              // 创建一个大小为1024字节的ArrayBuffer对象，用于存储从文件中读取的数据\n              let arrayBuffer = new ArrayBuffer(1024);\n              // 设置读取的偏移量和长度\n              let readOptions: ReadOptions = {\n                offset: 0,\n                length: arrayBuffer.byteLength\n              };\n              // 读取文件内容到ArrayBuffer对象中，并返回实际读取的字节数\n              let readLen = fileIo.readSync(file.fd, arrayBuffer, readOptions);\n              // 将ArrayBuffer对象转换为Buffer对象，并转换为字符串输出\n              let buf = buffer.from(arrayBuffer, 0, readLen);\n              hilog.info(DOMAIN_NUMBER, TAG, `the content of file: ${buf.toString()}`);\n              // 关闭文件\n              fileIo.closeSync(file);\n            })\n        }\n        // ...\n      }\n      // ...\n    }\n    // ...\n  }\n}
[h2]获取和修改加密分区
应用文件加密是一种保护数据安全的方法，可以使得文件在未经授权访问的情况下得到保护。在不同的场景下，应用需要不同程度的文件保护。
在实际应用中，开发者需要根据不同场景的需求选择合适的加密分区，从而保护应用数据的安全。通过合理使用不同级别的加密分区，可以有效提高应用数据的安全性。关于不同分区的权限说明，详见ContextConstant的AreaMode。
 EL1：对于私有文件，如闹铃、壁纸等，应用可以将这些文件放到设备级加密分区（EL1）中，以保证在用户输入密码前就可以被访问。 EL2：对于更敏感的文件，如个人隐私信息等，应用可以将这些文件放到更高级别的加密分区（EL2）中，以保证更高的安全性。 EL3：对于应用中的记录步数、文件下载、音乐播放，需要在锁屏时读写和创建新文件，放在（EL3）的加密分区比较合适。 EL4：对于用户安全信息相关的文件，锁屏时不需要读写文件、也不能创建文件，放在（EL4）的加密分区更合适。 EL5：对于用户隐私敏感数据文件，锁屏后默认不可读写，如果锁屏后需要读写文件，则锁屏前可以调用Access接口申请继续读写文件，或者锁屏后也需要创建新文件且可读写，放在（EL5）的应用级加密分区更合适。 
要实现获取和设置当前加密分区，可以通过读写Context的area属性来实现。
// EntryAbility.ets\nimport { UIAbility, contextConstant, AbilityConstant, Want } from '@kit.AbilityKit';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {\n    // 存储普通信息前，切换到EL1设备级加密\n    this.context.area = contextConstant.AreaMode.EL1; // 切换area\n    // 存储普通信息\n\n    // 存储敏感信息前，切换到EL2用户级加密\n    this.context.area = contextConstant.AreaMode.EL2; // 切换area\n    // 存储敏感信息\n\n    // 存储敏感信息前，切换到EL3用户级加密\n    this.context.area = contextConstant.AreaMode.EL3; // 切换area\n    // 存储敏感信息\n\n    // 存储敏感信息前，切换到EL4用户级加密\n    this.context.area = contextConstant.AreaMode.EL4; // 切换area\n    // 存储敏感信息\n\n    // 存储敏感信息前，切换到EL5应用级加密\n    this.context.area = contextConstant.AreaMode.EL5; // 切换area\n    // 存储敏感信息\n  }\n}
// Index.ets\nimport { contextConstant, common } from '@kit.AbilityKit';\nimport { promptAction } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct Page_Context {\n  private context = getContext(this) as common.UIAbilityContext;\n\n  build() {\n    Column() {\n      //...\n      List({ initialIndex: 0 }) {\n        //...\n        ListItem() {\n          Row() {\n            //...\n          }\n          .onClick(() => {\n            // 存储普通信息前，切换到EL1设备级加密\n            if (this.context.area === contextConstant.AreaMode.EL2) { // 获取area\n              this.context.area = contextConstant.AreaMode.EL1; // 修改area\n              promptAction.showToast({\n                message: 'SwitchToEL1'\n              });\n            }\n            // 存储普通信息\n          })\n        }\n        //...\n        ListItem() {\n          Row() {\n            //...\n          }\n          .onClick(() => {\n            // 存储敏感信息前，切换到EL2用户级加密\n            if (this.context.area === contextConstant.AreaMode.EL1) { // 获取area\n              this.context.area = contextConstant.AreaMode.EL2; // 修改area\n              promptAction.showToast({\n                message: 'SwitchToEL2'\n              });\n            }\n            // 存储敏感信息\n          })\n        }\n        //...\n      }\n      //...\n    }\n    //...\n  }\n}
[h2]获取本应用中其他Module的Context
调用createModuleContext(context: Context, moduleName: string)方法，获取本应用中其他Module的Context。获取到其他Module的Context之后，即可获取到相应Module的资源信息。
import { common, application } from '@kit.AbilityKit';\nimport { promptAction } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet storageEventCall = new LocalStorage();\n\n@Entry(storageEventCall)\n@Component\nstruct Page_Context {\n  private context = getContext(this) as common.UIAbilityContext;\n\n  build() {\n    Column() {\n      //...\n      List({ initialIndex: 0 }) {\n        ListItem() {\n          Row() {\n            //...\n          }\n          .onClick(() => {\n            let moduleName2: string = 'entry';\n            application.createModuleContext(this.context, moduleName2)\n              .then((data: common.Context) => {\n                console.info(`CreateModuleContext success, data: ${JSON.stringify(data)}`);\n                if (data !== null) {\n                  promptAction.showToast({\n                    message: ('成功获取Context')\n                  });\n                }\n              })\n              .catch((err: BusinessError) => {\n                console.error(`CeateMudleContext failed, err code:${err.code}, err msg: ${err.message}`);\n              });\n          })\n        }\n        //...\n      }\n      //...\n    }\n    //...\n  }\n}
[h2]订阅进程内UIAbility生命周期变化
在应用内的DFX统计场景中，如需要统计对应页面停留时间和访问频率等信息，可以使用订阅进程内UIAbility生命周期变化功能。
通过ApplicationContext提供的能力，可以订阅进程内UIAbility生命周期变化。当进程内的UIAbility生命周期变化时，如创建、可见/不可见、获焦/失焦、销毁等，会触发相应的回调函数。每次注册回调函数时，都会返回一个监听生命周期的ID，此ID会自增+1。当超过监听上限数量2^63-1时，会返回-1。以UIAbilityContext中的使用为例进行说明。
import { AbilityConstant, AbilityLifecycleCallback, UIAbility, Want } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { window } from '@kit.ArkUI';\nimport  { BusinessError } from '@kit.BasicServicesKit';\n\nconst TAG: string = '[LifecycleAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class LifecycleAbility extends UIAbility {\n  // 定义生命周期ID\n  lifecycleId: number = -1;\n\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    // 定义生命周期回调对象\n    let abilityLifecycleCallback: AbilityLifecycleCallback = {\n      // 当UIAbility创建时被调用\n      onAbilityCreate(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityCreate uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      },\n      // 当窗口创建时被调用\n      onWindowStageCreate(uiAbility, windowStage: window.WindowStage) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageCreate uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageCreate windowStage: ${JSON.stringify(windowStage)}`);\n      },\n      // 当窗口处于活动状态时被调用\n      onWindowStageActive(uiAbility, windowStage: window.WindowStage) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageActive uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageActive windowStage: ${JSON.stringify(windowStage)}`);\n      },\n      // 当窗口处于非活动状态时被调用\n      onWindowStageInactive(uiAbility, windowStage: window.WindowStage) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageInactive uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageInactive windowStage: ${JSON.stringify(windowStage)}`);\n      },\n      // 当窗口被销毁时被调用\n      onWindowStageDestroy(uiAbility, windowStage: window.WindowStage) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageDestroy uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageDestroy windowStage: ${JSON.stringify(windowStage)}`);\n      },\n      // 当UIAbility被销毁时被调用\n      onAbilityDestroy(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityDestroy uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      },\n      // 当UIAbility从后台转到前台时触发回调\n      onAbilityForeground(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityForeground uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      },\n      // 当UIAbility从前台转到后台时触发回调\n      onAbilityBackground(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityBackground uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      },\n      // 当UIAbility迁移时被调用\n      onAbilityContinue(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityContinue uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      }\n    };\n    // 获取应用上下文\n    let applicationContext = this.context.getApplicationContext();\n    try {\n      // 注册应用内生命周期回调\n      this.lifecycleId = applicationContext.on('abilityLifecycle', abilityLifecycleCallback);\n    } catch (err) {\n      let code = (err as BusinessError).code;\n      let message = (err as BusinessError).message;\n      hilog.error(DOMAIN_NUMBER, TAG, `Failed to register applicationContext. Code is ${code}, message is ${message}`);\n    }\n\n    hilog.info(DOMAIN_NUMBER, TAG, `register callback number: ${this.lifecycleId}`);\n  }\n  //...\n  onDestroy(): void {\n    // 获取应用上下文\n    let applicationContext = this.context.getApplicationContext();\n    try {\n      // 取消应用内生命周期回调\n      applicationContext.off('abilityLifecycle', this.lifecycleId);\n    } catch (err) {\n      let code = (err as BusinessError).code;\n      let message = (err as BusinessError).message;\n      hilog.error(DOMAIN_NUMBER, TAG, `Failed to unregister applicationContext. Code is ${code}, message is ${message}`);\n    }\n  }\n}

保存用户文件
在从网络下载文件到本地、或将已有用户文件另存为新的文件路径等场景下，需要使用FilePicker提供的保存用户文件的能力。Picker获取的URI只具有临时权限，获取持久化权限需要通过FilePicker设置永久授权方式获取。
对音频、图片、视频、文档类文件的保存操作类似，均通过调用对应Picker的save()接口并传入对应的saveOptions来实现。通过Picker访问相关文件，无需申请权限。
当前所有Picker的save接口都是用户可感知的，具体行为是拉起FilePicker, 将文件保存在系统文件管理器管理的特定目录，与图库管理的资源隔离，无法在图库中看到。
如果开发者需要保存图片、视频资源到图库，可使用用户无感的安全控件进行保存。
保存图片或视频类文件
PhotoViewPicker在后续版本不再演进，建议使用Media Library Kit（媒体文件管理服务）中能力来保存媒体库资源。
如果开发场景无法调用安全控件进行图片、视频保存，可使用相册管理模块PhotoAccessHelper.showAssetsCreationDialog接口进行保存操作。
保存文档类文件
 导入选择器模块和基础文件API模块。 import { picker } from '@kit.CoreFileKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { common } from '@kit.AbilityKit'; 创建文档保存选项实例。 // 创建文件管理器选项实例\nconst documentSaveOptions = new picker.DocumentSaveOptions();\n// 保存文件名（可选） \ndocumentSaveOptions.newFileNames = [\"DocumentViewPicker01.txt\"];\n// 保存文件类型['后缀类型描述|后缀类型'],选择所有文件：'所有文件(*.*)|.*'（可选） ，如果选择项存在多个后缀，默认选择第一个。\ndocumentSaveOptions.fileSuffixChoices = ['文档|.txt', '.pdf'];  创建文件选择器DocumentViewPicker实例。调用save()接口拉起FilePicker界面进行文件保存。 let uris: Array<string> = [];\n// 请确保 getContext(this) 返回结果为 UIAbilityContext\nlet context = getContext(this) as common.Context;\n// 创建文件选择器实例。\nconst documentViewPicker = new picker.DocumentViewPicker(context);\n//用户选择目标文件夹，用户选择与文件类型相对应的文件夹，即可完成文件保存操作。保存成功后，返回保存文档的URI。\ndocumentViewPicker.save(documentSaveOptions).then((documentSaveResult: Array<string>) => {\n  uris = documentSaveResult;\n  console.info('documentViewPicker.save to file succeed and uris are:' + uris);\n}).catch((err: BusinessError) => {\n  console.error(`Invoke documentViewPicker.save failed, code is ${err.code}, message is ${err.message}`);\n})     1、建议不在Picker的回调里直接使用此URI进行打开文件操作，需要定义一个全局变量保存URI。 2、使用Picker的save()接口获取到URI的权限是临时读写权限,待退出应用后台后，获取的临时权限就会失效。 3、如果想要获取持久化权限(仅在2in1设备上生效)，请参考文件持久化授权访问。 4、可以通过便捷方式，直接将文件保存到Download目录下。   待界面从FilePicker返回后，使用基础文件API的fs.openSync接口，通过URI打开这个文件得到文件描述符(fd)。 const uri = '';\n//这里需要注意接口权限参数是fs.OpenMode.READ_WRITE。\nlet file = fs.openSync(uri, fs.OpenMode.READ_WRITE);\nconsole.info('file fd: ' + file.fd); 通过(fd)使用基础文件API的fs.writeSync接口对这个文件进行编辑修改，编辑修改完成后关闭(fd)。 let writeLen: number = fs.writeSync(file.fd, 'hello, world');\nconsole.info('write data to file succeed and size is:' + writeLen);\nfs.closeSync(file); 
保存音频类文件
 导入选择器模块和基础文件API模块。 import { picker } from '@kit.CoreFileKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { common } from '@kit.AbilityKit'; 创建音频保存选项实例。 // 创建文件管理器选项实例\nconst audioSaveOptions = new picker.AudioSaveOptions();\n// 保存文件名（可选） \naudioSaveOptions.newFileNames = ['AudioViewPicker01.mp3'];  创建音频选择器AudioViewPicker实例。调用save()接口拉起FilePicker界面进行文件保存。 let uri: string = '';\n// 请确保 getContext(this) 返回结果为 UIAbilityContext\nlet context = getContext(this) as common.Context; \nconst audioViewPicker = new picker.AudioViewPicker(context);\n//用户选择目标文件夹，用户选择与文件类型相对应的文件夹，即可完成文件保存操作。保存成功后，返回保存文档的uri。\naudioViewPicker.save(audioSaveOptions).then((audioSelectResult: Array<string>) => {\n  uri = audioSelectResult[0];\n  console.info('audioViewPicker.save to file succeed and uri is:' + uri);\n}).catch((err: BusinessError) => {\n  console.error(`Invoke audioViewPicker.save failed, code is ${err.code}, message is ${err.message}`);\n})     1、建议不在Picker的回调里直接使用此URI进行打开文件操作，需要定义一个全局变量保存URI。 2、使用Picker获取的save()URI权限是临时读写权限,待退出应用后台后，获取的临时权限就会失效。 3、如果想要获取持久化权限(仅在2in1设备上生效)，请参考文件持久化授权访问。 4、可以通过便捷方式，直接将文件保存到Download目录下。   待界面从FilePicker返回后，可以使用基础文件API的fs.openSync接口，通过URI打开这个文件得到文件描述符(fd)。 //这里需要注意接口权限参数是fileIo.OpenMode.READ_WRITE。\nlet file = fs.openSync(uri, fs.OpenMode.READ_WRITE);\nconsole.info('file fd: ' + file.fd); 通过(fd)使用基础文件API的fs.writeSync接口对这个文件进行编辑修改，编辑修改完成后关闭(fd)。 let writeLen = fs.writeSync(file.fd, 'hello, world');\nconsole.info('write data to file succeed and size is:' + writeLen);\nfs.closeSync(file); 
DOWNLOAD模式保存文件
用户在使用save接口时，可以将pickerMode配置为DOWNLOAD模式，该模式下会在公共路径download目录下创建用户当前hap包名的文件夹，并通过save接口返回值回传相应的URI，后续用户可以直接将文件保存在该URI下。
 导入选择器模块和文件管理模块。 import { picker } from '@kit.CoreFileKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { common } from '@kit.AbilityKit'; 创建文件保存选项实例。 // 创建文件管理器选项实例\nconst documentSaveOptions = new picker.DocumentSaveOptions();\n// 配置保存的模式为DOWNLOAD，若配置了DOWNLOAD模式，此时配置的其他documentSaveOptions参数将不会生效。\ndocumentSaveOptions.pickerMode = picker.DocumentPickerMode.DOWNLOAD;  创建文件选择器实例。调用save()接口拉起FilePicker模态窗界面进行文件保存。用户点击同意，即可在download目录下创建对应应用的专属目录，返回该目录的URI。 let uri: string = '';\n// 请确保 getContext(this) 返回结果为 UIAbilityContext\nlet context = getContext(this) as common.Context; \nconst documentViewPicker = new picker.DocumentViewPicker(context);\nconst documentSaveOptions = new picker.DocumentSaveOptions();\ndocumentSaveOptions.pickerMode = picker.DocumentPickerMode.DOWNLOAD;\ndocumentViewPicker.save(documentSaveOptions ).then((documentSaveResult: Array<string>) => {\n  uri = documentSaveResult[0];\n  console.info('documentViewPicker.save succeed and uri is:' + uri);\n}).catch((err: BusinessError) => {\n  console.error(`Invoke documentViewPicker.save failed, code is ${err.code}, message is ${err.message}`);\n}) 

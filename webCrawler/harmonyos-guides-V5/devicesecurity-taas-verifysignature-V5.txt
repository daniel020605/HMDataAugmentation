验证签名
如果有在端侧验证图像数据或地理位置数据签名的需求，可以使用Crypto Architecture Kit，使用方法请参考开发指南中“使用ECDSA密钥对签名验签”章节。
推荐应用开发者在服务器端完成安全图像或安全地理位置的签名验证，请参考“Device Certificate Kit 设备真实性证明服务器端开发”。
获取签名数据
[h2]安全摄像头图像数据
安全图像数据的结构如下所示：
其中用户数据和图像数据为被签名的原始数据，图像数据长度固定为460800字节，签名数据是Base64编码的签名结果，使用者需要解析出这些数据用来验证安全图像数据签名。参考代码如下：
import { util } from '@kit.ArkTS';\n\n// 获取被签名的原始数据\nconst secureImageBuffer = new ArrayBuffer(461844); // 实际使用时请替换为Camera Kit获取到的安全图像buffer\nconst view = new DataView(secureImageBuffer);\nconst imageBufferLength = 460800; // 安全图像buffer长度固定为460800\nconst userDataLength = view.getUint32(0, true); // 获取用户数据长度\nconst originData = secureImageBuffer.slice(4, 4 + userDataLength + imageBufferLength);\n// 获取签名结果\nconst maxSignatureBufferLength = 512;\nconst signatureBuffer = secureImageBuffer.slice(4 + userDataLength + imageBufferLength,\n  4 + userDataLength + imageBufferLength + maxSignatureBufferLength);\nconst signatureString = String.fromCharCode(...new Uint8Array(signatureBuffer).filter(code => code !== 0));\nconst base64Helper = new util.Base64Helper();\nconst signatureData = base64Helper.decodeSync(signatureString);
[h2]安全地理位置数据
安全地理位置数据的结构请参考SecureLocation。
对安全地理位置数据验签时，需要将返回的结构体中的数据拼接成字符串形式，格式要求如下：
 数据排列顺序为：纬度、经度、高度、精确度、时间戳和用户数据。 纬度、经度和高度类型为浮点型，精度为小数点后保留15位；精确度为浮点型，精度为小数点后保留6位；时间戳类型为64位正整数；用户数据类型为字符串。 数据之间的分隔符使用英文逗号。 
签名数据的格式和安全摄像头一致，为Base64编码后的结果。忽略异常处理，获取签名和签名原始数据的参考代码如下：
import { trustedAppService } from '@kit.DeviceSecurityKit';\nimport { util } from '@kit.ArkTS';\n\n// 以均为示例值，仅用于展示如何获取原始签名数据和签名结果\nconst location: trustedAppService.Location = {\n  latitude: 40.053903635898685,\n  longitude: 116.17356591910897,\n  altitude: 0,\n  accuracy: 11.160304069519043,\n  timestamp: 1722151680187\n};\nconst userData = \"trusted_app_service_userdata\";\nconst secureLocation: trustedAppService.SecureLocation = {\n  originalLocation: location,\n  userData: userData,\n  signature: \"MEQCIEAcJHgaU8aAoMqD1wgoxiXR5I4jmwVG6ncgSKkW4uBHAiBnfv96T+gt1ef83kNZ+U0gBLsq9byuBLP1RBx30hByuQ==\"\n};\n// 获取原始数据\nconst originString = secureLocation.originalLocation.latitude.toFixed(15) + ',' +\n  secureLocation.originalLocation.longitude.toFixed(15) + ',' +\n  secureLocation.originalLocation.altitude.toFixed(15) + ',' +\n  secureLocation.originalLocation.accuracy.toFixed(6) + ',' +\n  secureLocation.originalLocation.timestamp + ',' + secureLocation.userData.toString();\nconst textEncoder = new util.TextEncoder();\nconst originData = textEncoder.encodeInto(originString);\n// 获取签名结果\nconst base64Helper = new util.Base64Helper();\nconst signatureData = base64Helper.decodeSync(secureLocation.signature.toString());
验证签名
在安全摄像头场景和安全地理位置场景中，由于使用的是相同的证明密钥，因此签名验证的流程是一致的。结合上一节中获取到的原始数据和签名结果，忽略异常处理，验证签名的参考代码如下：
 从匿名证书链中获取公钥。import { cert } from '@kit.DeviceCertificateKit';\nimport { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { util } from '@kit.ArkTS';\nimport { trustedAppService } from '@kit.DeviceSecurityKit';\n\n// 以安全摄像头场景为例，忽略异常情况处理\nconst userData = \"trusted_app_service_demo\";\nconst deviceId = 7483679320805398131;\nconst initProperties: Array<trustedAppService.AttestParam> = [\n  {\n    tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_TYPE,\n    value: trustedAppService.AttestType.ATTEST_TYPE_CAMERA\n  },\n  {\n    tag: trustedAppService.AttestTag.ATTEST_TAG_DEVICE_ID,\n    value: BigInt(deviceId)\n  }\n];\nconst initOptions: trustedAppService.AttestOptions = {\n  properties: initProperties\n};\nconst returnResult = await trustedAppService.initializeAttestContext(userData, initOptions);\n// 解析匿名证书链数据，获取三级证书\nconst certChain = returnResult.certChains;\nconst certList = certChain[0].split('-----BEGIN CERTIFICATE-----');\nconst thirdCert = '-----BEGIN CERTIFICATE-----' + certList[1];\n// 获取公钥\nconst textEncoder = new util.TextEncoder();\nconst encodingBlob: cert.EncodingBlob = {\n  data: textEncoder.encodeInto(thirdCert),\n  encodingFormat: cert.EncodingFormat.FORMAT_PEM\n};\nconst x509Cert = await cert.createX509Cert(encodingBlob);\nconst asyKeyGenerator = cryptoFramework.createAsyKeyGenerator('ECC256');\nconst keyPair = asyKeyGenerator.convertKeySync(x509Cert.getPublicKey().getEncoded(), null);\nconst pubKey = keyPair.pubKey; // 证书中的公钥需要转换成cryptoFramework能够接收的格式  创建非对称密钥类型为ECC256、摘要算法为SHA256的verify实例，并使用步骤1中获取到的公钥进行初始化。const verifier = cryptoFramework.createVerify('ECC256|SHA256');\nverifier.initSync(pubKey);  使用原始数据和签名结果进行验证签名。const originData = ...; // 请使用获取到的安全图像原始数据\nconst signatureData = ...; // 请使用获取到的签名结果\nconst inputData: cryptoFramework.DataBlob = {\n  data: new Uint8Array(originData)\n};\nconst signature: cryptoFramework.DataBlob = {\n  data: new Uint8Array(signatureData)\n};\n// 验证签名结果\nconst result = verifier.verifySync(inputData, signature);  

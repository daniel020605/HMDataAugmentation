拦截器
场景介绍
请求拦截器。
开发步骤
导包。import { rcp } from '@kit.RemoteCommunicationKit'; 定义自己的拦截器。class ResponseCache {\n  private readonly cache: Record<string, rcp.Response> = {};\n\n  getResponse(url: string): rcp.Response {\n    return this.cache[url];\n  }\n\n  setResponse(url: string, response: rcp.Response): void {\n    this.cache[url] = response;\n  }\n}\n\nconst cache = new ResponseCache();\n\n//自定义拦截器\nclass ResponseCachingInterceptor implements rcp.Interceptor {\n  private readonly cache: ResponseCache;\n\n  constructor(cache: ResponseCache) {\n    this.cache = cache;\n  }\n\n  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {\n    const url = context.request.url.href;\n    const responseFromCache = this.cache.getResponse(url);\n    if (responseFromCache) {\n      return Promise.resolve(responseFromCache);\n    }\n    const promise = next.handle(context);\n    promise.then((resp) => {\n      resp.statusCode;\n      cache.setResponse(url, resp);\n    });\n    return promise;\n  }\n} 使用拦截器。async function testInterceptor() {\n  const session = rcp.createSession({\n    interceptors: [new ResponseCachingInterceptor(cache)]\n  });\n}\n\n  // 方法一：使用get请求方式\n  const response1 = await session.get('https://www.example.com');\n  // 方法二：使用fetch请求方式\n  let request = new rcp.Request(\"https://www.example.com\", 'GET');\n  const response2 = await session.fetch(request); 

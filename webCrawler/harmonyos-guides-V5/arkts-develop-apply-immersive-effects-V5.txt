开发应用沉浸式效果
概述
典型应用全屏窗口UI元素包括状态栏、应用界面和底部导航条，其中状态栏和导航条，通常在沉浸式布局下称为避让区；避让区之外的区域称为安全区。开发应用沉浸式效果主要指通过调整状态栏、应用界面和导航条的显示效果来减少状态栏导航条等系统界面的突兀感，从而使用户获得最佳的UI体验。
开发应用沉浸式效果主要要考虑如下几个设计要素：
UI元素避让处理：导航条底部区域可以响应点击事件，除此之外的可交互UI元素和应用关键信息不建议放到导航条区域。状态栏显示系统信息，如果与界面元素有冲突，需要考虑避让状态栏。沉浸式效果处理：将状态栏和导航条颜色与界面元素颜色相匹配，不出现明显的突兀感。
针对上面的设计要求，可以通过如下两种方式实现应用沉浸式效果：
窗口全屏布局方案：调整布局系统为全屏布局，界面元素延伸到状态栏和导航条区域实现沉浸式效果。当不隐藏避让区时，可通过接口查询状态栏和导航条区域进行可交互元素避让处理，并设置状态栏或导航条的颜色等属性与界面元素匹配。当隐藏避让区时，通过对应接口设置全屏布局即可。组件安全区方案：布局系统保持安全区内布局，然后通过接口延伸绘制内容（如背景色，背景图）到状态栏和导航条区域实现沉浸式效果。该方案下，界面元素仅做绘制延伸，无法单独布局到状态栏和导航条区域，针对需要单独布局UI元素到状态栏和导航条区域的场景建议使用窗口全屏布局方案处理。 
窗口全屏布局方案
窗口全屏布局方案主要涉及以下应用扩展布局，全屏显示，不隐藏避让区和应用扩展布局，隐藏避让区两个应用场景。
[h2]应用扩展布局，全屏显示，不隐藏避让区
可以通过调用窗口强制全屏布局接口setWindowLayoutFullScreen()实现界面元素延伸到状态栏和导航条；然后通过接口getWindowAvoidArea()和on('avoidAreaChange')获取并动态监听避让区域的变更信息，页面布局根据避让区域信息进行动态调整；设置状态栏或导航条的颜色等属性与界面元素进行匹配。
调用setWindowLayoutFullScreen()接口设置窗口全屏。// EntryAbility.ets\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport default class EntryAbility extends UIAbility {\n  // ...\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    windowStage.loadContent('pages/Index', (err, data) => {\n      if (err.code) {\n        return;\n      }\n\n      let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口\n      // 1. 设置窗口全屏\n      let isLayoutFullScreen = true;\n      windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {\n        console.info('Succeeded in setting the window layout to full-screen mode.');\n      }).catch((err: BusinessError) => {\n        console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));\n      });\n      // 进行后续步骤2-3中的操作\n    });\n  }\n} 使用getWindowAvoidArea()接口获取当前布局遮挡区域（例如状态栏、导航条）。// EntryAbility.ets\n// 2. 获取布局避让遮挡的区域\nlet type = window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR; // 以导航条避让为例\nlet avoidArea = windowClass.getWindowAvoidArea(type);\nlet bottomRectHeight = avoidArea.bottomRect.height; // 获取到导航条区域的高度\nAppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);\n\ntype = window.AvoidAreaType.TYPE_SYSTEM; // 以状态栏避让为例\navoidArea = windowClass.getWindowAvoidArea(type);\nlet topRectHeight = avoidArea.topRect.height; // 获取状态栏区域高度\nAppStorage.setOrCreate('topRectHeight', topRectHeight); 注册监听函数，动态获取避让区域的实时数据。常见的触发避让区回调的场景如下：应用窗口在全屏模式、悬浮模式、分屏模式之间的切换；应用窗口旋转；多折叠设备在屏幕折叠态和展开态之间的切换；应用窗口在多设备之间的流转。// EntryAbility.ets\n// 3. 注册监听函数，动态获取避让区域数据\nwindowClass.on('avoidAreaChange', (data) => {\n  if (data.type === window.AvoidAreaType.TYPE_SYSTEM) {\n    let topRectHeight = data.area.topRect.height;\n    AppStorage.setOrCreate('topRectHeight', topRectHeight);\n  } else if (data.type == window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR) {\n    let bottomRectHeight = data.area.bottomRect.height;\n    AppStorage.setOrCreate('bottomRectHeight', bottomRectHeight);\n  }\n}); 布局中的UI元素需要避让状态栏和导航条，否则可能产生UI元素重叠等情况。 避让区域存在大小为0的情况，当获取到的避让区域为0时，开发者需注意针对性处理适配此时的页面区域和布局，避免贴边、内容裁剪等问题，影响应用界面正常显示或美观性。  如下例子中，对控件顶部设置padding（具体数值与状态栏高度一致），实现对状态栏的避让；对底部设置padding（具体数值与底部导航条区域高度一致），实现对底部导航条的避让。如果去掉顶部和底部的padding设置，即不避让状态栏和导航条，UI元素就会发生重叠。具体可见下文步骤中图2和图3的效果对比。 // Index.ets\n@Entry\n@Component\nstruct Index {\n  @StorageProp('bottomRectHeight')\n  bottomRectHeight: number = 0;\n  @StorageProp('topRectHeight')\n  topRectHeight: number = 0;\n\n  build() {\n    Row() {\n      Column() {\n        Row() {\n          Text('DEMO-ROW1').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('DEMO-ROW2').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('DEMO-ROW3').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('DEMO-ROW4').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('DEMO-ROW5').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('DEMO-ROW6').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n      }\n      .width('100%')\n      .height('100%')\n      .alignItems(HorizontalAlign.Center)\n      .justifyContent(FlexAlign.SpaceBetween)\n      .backgroundColor('#008000')\n      // top数值与状态栏区域高度保持一致；bottom数值与导航条区域高度保持一致\n      .padding({ top: px2vp(this.topRectHeight), bottom: px2vp(this.bottomRectHeight) })\n    }\n  }\n} 根据实际的UI界面显示或相关UI元素背景颜色等，还可以按需设置状态栏的文字颜色、背景色或设置导航条的显示或隐藏，以使UI界面效果呈现和谐。状态栏默认是透明的，透传的是应用界面的背景色。此例中UI颜色主要有两种，比较简单，故未对状态栏文字颜色、背景色进行设置。 图2 布局避让状态栏和导航条 图3 布局未避让状态栏和导航条，UI元素重叠 
[h2]应用扩展布局，隐藏避让区
此场景下导航条会自动隐藏，适用于游戏、电影等应用场景。可以通过从底部上滑唤出导航条。
调用setWindowLayoutFullScreen()接口设置窗口全屏。// EntryAbility.ets\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport default class EntryAbility extends UIAbility {\n  // ...\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    windowStage.loadContent('pages/Index', (err, data) => {\n      if (err.code) {\n        return;\n      }\n\n      let windowClass: window.Window = windowStage.getMainWindowSync(); // 获取应用主窗口\n      // 1. 设置窗口全屏\n      let isLayoutFullScreen = true;\n      windowClass.setWindowLayoutFullScreen(isLayoutFullScreen).then(() => {\n        console.info('Succeeded in setting the window layout to full-screen mode.');\n      }).catch((err: BusinessError) => {\n        console.error(`Failed to set the window layout to full-screen mode. Code is ${err.code}, message is ${err.message}`);\n      });\n      // 进行后续步骤2中的状态栏和导航条的隐藏操作\n    });\n  }\n} 调用setSpecificSystemBarEnabled()接口设置状态栏和导航条的具体显示/隐藏状态，此场景下将其设置为隐藏。// EntryAbility.ets\n// 2. 设置状态栏隐藏\nwindowClass.setSpecificSystemBarEnabled('status', false).then(() => {\n  console.info('Succeeded in setting the status bar to be invisible.');\n}).catch((err: BusinessError) => {\n  console.error(`Failed to set the status bar to be invisible. Code is ${err.code}, message is ${err.message}`);\n});\n// 2. 设置导航条隐藏\nwindowClass.setSpecificSystemBarEnabled('navigationIndicator', false).then(() => {\n  console.info('Succeeded in setting the navigation indicator to be invisible.');\n}).catch((err: BusinessError) => {\n  console.error(`Failed to set the navigation indicator to be invisible. Code is ${err.code}, message is ${err.message}`);\n}); 在界面中无需进行导航条避让操作。// Index.ets\n@Entry()\n@Component\nstruct Index {\n  build() {\n    Row() {\n      Column() {\n        Row() {\n          Text('ROW1').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('ROW2').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('ROW3').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('ROW4').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('ROW5').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n\n        Row() {\n          Text('ROW6').fontSize(40)\n        }.backgroundColor(Color.Orange).padding(20)\n      }\n      .width('100%')\n      .height('100%')\n      .alignItems(HorizontalAlign.Center)\n      .justifyContent(FlexAlign.SpaceBetween)\n      .backgroundColor('#008000')\n    }\n  }\n} 
组件安全区方案
应用未使用setWindowLayoutFullScreen()接口设置窗口全屏布局时，默认使能组件安全区布局。
应用在默认情况下窗口背景绘制范围是全屏，但UI元素被限制在安全区内（自动排除状态栏和导航条）进行布局，来避免界面元素被状态栏和导航条遮盖。
针对状态栏和导航条颜色与界面元素颜色不匹配问题，可以通过如下两种方式实现沉浸式效果：
状态栏和导航条颜色相同场景，可以通过设置窗口的背景色来实现沉浸式效果。窗口背景色可通过setWindowBackgroundColor()进行设置。import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\n\nexport default class EntryAbility extends UIAbility {\n  // ...\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    windowStage.loadContent('pages/Index', (err, data) => {\n      if (err.code) {\n        return;\n      }\n\n      // 设置全窗颜色和应用元素颜色一致\n      windowStage.getMainWindowSync().setWindowBackgroundColor('#008000');\n    });\n  }\n} 界面状态栏和导航条颜色相同场景。 // xxx.ets\n@Entry\n@Component\nstruct Example {\n  build() {\n    Column() {\n      Row() {\n        Text('ROW1').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW2').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW3').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW4').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW5').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW6').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n    }\n    .width('100%')\n    .height('100%')\n    .alignItems(HorizontalAlign.Center)\n    .justifyContent(FlexAlign.SpaceBetween)\n    .backgroundColor('#008000')\n  }\n}  状态栏和导航条颜色不同时，可以使用expandSafeArea属性扩展安全区域属性进行调整。// xxx.ets\n@Entry\n@Component\nstruct Example {\n  build() {\n    Column() {\n      Row() {\n        Text('Top Row').fontSize(40).textAlign(TextAlign.Center).width('100%')\n      }\n      .backgroundColor('#F08080')\n      // 设置顶部绘制延伸到状态栏\n      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])\n\n      Row() {\n        Text('ROW2').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW3').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW4').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW5').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('Bottom Row').fontSize(40).textAlign(TextAlign.Center).width('100%')\n      }\n      .backgroundColor(Color.Orange)\n      // 设置底部绘制延伸到导航条\n      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])\n    }\n    .width('100%').height('100%').alignItems(HorizontalAlign.Center)\n    .backgroundColor('#008000')\n    .justifyContent(FlexAlign.SpaceBetween)\n  }\n}  
[h2]扩展安全区域属性原理
布局阶段按照安全区范围大小进行UI元素布局。布局完成后查看设置了expandSafeArea的组件边界（不包括margin）是否和安全区边界相交。如果设置了expandSafeArea的组件和安全区边界相交，根据expandSafeArea传递的属性则进一步扩大组件绘制区域大小覆盖状态栏、导航条这些非安全区域。上述过程仅改变组件自身绘制大小，不进行二次布局，不影响子节点和兄弟节点的大小和位置。子节点可以单独设置该属性，只需要自身边界和安全区域重合就可以延伸自身大小至非安全区域内，需要确保父组件未设置clip等裁切属性。配置expandSafeArea属性组件进行绘制扩展时，需要关注组件不能配置固定宽高尺寸，百分比除外。
[h2]背景图和视频场景
设置背景图、视频控件大小为安全区域大小并配置expandSafeArea属性。
// xxx.ets\n@Entry\n@Component\nstruct SafeAreaExample1 {\n  build() {\n    Stack() {\n      Image($r('app.media.bg'))\n        .height('100%').width('100%')\n        .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM]) // 图片组件的绘制区域扩展至状态栏和导航条。\n    }.height('100%').width('100%')\n  }\n}
[h2]滚动类场景
要求需要List滚动类组件滚动过程中元素可以和导航条重合，滚动至底部时，元素在导航条上面需要避让。
由于expandSafeArea不改变子节点布局，因此，List等滚动类组件可以调用expandSafeArea，延伸List组件视图窗口大小而不改变ListItem内在布局。实现ListItem在滑动过程中显示在导航条下，但滚动至最后一个时显示在导航条上，示意图如下：
仅扩展底部导航条。
配置窗口整体底色。import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\n\nexport default class EntryAbility extends UIAbility {\n  // ...\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    windowStage.loadContent('pages/Index', (err, data) => {\n      if (err.code) {\n        return;\n      }\n\n      windowStage.getMainWindowSync().setWindowBackgroundColor('#DCDCDC'); // 配置窗口整体底色\n    });\n  }\n} 界面代码展示。// xxx.ets\n@Entry\n@Component\nstruct ListExample {\n  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n  build() {\n    Column() {\n      List({ space: 20, initialIndex: 0 }) {\n        ForEach(this.arr, (item: number) => {\n          ListItem() {\n            Text('' + item)\n              .width('100%')\n              .height(100)\n              .fontSize(16)\n              .textAlign(TextAlign.Center)\n              .borderRadius(10)\n              .backgroundColor(0xFFFFFF)\n          }\n        }, (item:number) => item.toString())\n      }\n      .listDirection(Axis.Vertical) // 排列方向\n      .scrollBar(BarState.Off)\n      .friction(0.6)\n      .divider({ strokeWidth: 2, color: 0xFFFFFF, startMargin: 20, endMargin: 20 }) // 每行之间的分界线\n      .edgeEffect(EdgeEffect.Spring) // 边缘效果设置为Spring\n      .width('90%')\n      // List组件的视窗范围扩展至导航条。\n      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])\n    }\n    .width('100%')\n    .height('100%')\n    .padding({ top: 15 })\n  }\n} 
[h2]底部页签场景
要求页签背景色能够延伸到导航条区域，但页签内部可操作元素需要在导航条之上。
针对底部的页签部分，Navigation组件和Tabs组件默认实现了页签的延伸处理，开发者只需要保证Navigation和Tabs组件的底部边界和底部导航条重合即可。若开发者显式调用expandSafeArea接口，则安全区效果由expandSafeArea参数指定。
如果未使用上述组件而是采用自定义方式实现页签的场景，可以针对底部元素设置expandSafeArea属性实现底部元素的背景扩展。
// xxx.ets\n@Entry\n@Component\nstruct VideoCreateComponent {\n  build() {\n    Column() {\n      Row() {\n        Text('Top Row').fontSize(40).textAlign(TextAlign.Center).width('100%')\n      }\n      .backgroundColor('#F08080')\n      // 设置顶部绘制延伸到状态栏\n      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])\n\n      Row() {\n        Text('ROW2').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW3').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW4').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('ROW5').fontSize(40)\n      }.backgroundColor(Color.Orange).padding(20)\n\n      Row() {\n        Text('Bottom Row').fontSize(40).textAlign(TextAlign.Center).width('100%')\n      }\n      .backgroundColor(Color.Orange)\n      // 设置底部绘制延伸到导航条\n      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])\n    }\n    .width('100%').height('100%').alignItems(HorizontalAlign.Center)\n    .justifyContent(FlexAlign.SpaceBetween)\n    .backgroundColor(Color.Green)\n  }\n}
[h2]图文场景
当状态栏元素和底部导航条元素不同时，无法单纯通过窗口背景色或者背景图组件延伸实现，此时需要对顶部元素和底部元素分别配置expandSafeArea属性，顶部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.TOP])，底部元素配置expandSafeArea([SafeAreaType.SYSTEM],[SafeAreaEdge.BOTTOM])。
@Entry\n@Component\nstruct Index {\n  build() {\n    Swiper() {\n      Column() {\n        Image($r('app.media.start'))\n          .height('50%').width('100%')\n          // 设置图片延伸到状态栏\n          .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])\n        Column() {\n          Text('HarmonyOS 第一课')\n            .fontSize(32)\n            .margin(30)\n          Text('通过循序渐进的学习路径，无经验和有经验的开发者都可以掌握ArkTS语言声明式开发范式，体验更简洁、更友好的HarmonyOS应用开发旅程。')\n            .fontSize(20).margin(20)\n        }.height('50%').width('100%')\n        .backgroundColor(Color.White)\n        // 设置文本内容区背景延伸到导航栏\n        .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])\n      }\n    }\n    .width('100%')\n    .height('100%')\n    // 关闭Swiper组件默认的裁切效果以便子节点可以绘制在Swiper外。\n    .clip(false)\n  }\n}

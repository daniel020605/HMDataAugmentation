管理应用窗口（Stage模型）
基本概念
 窗口沉浸式能力：指对状态栏、导航栏等系统窗口进行控制，减少状态栏导航栏等系统界面的突兀感，从而使用户获得最佳体验的能力。 沉浸式能力只在应用主窗口作为全屏窗口时生效。通常情况下，应用子窗口（弹窗、悬浮窗口等辅助窗口）和处于自由窗口下的应用主窗口无法使用沉浸式能力。 悬浮窗：全局悬浮窗口是一种特殊的应用窗口，具备在应用主窗口和对应Ability退至后台后仍然可以在前台显示的能力。 悬浮窗口可以用于应用退至后台后，使用小窗继续播放视频，或者为特定的应用创建悬浮球等快速入口。应用在创建悬浮窗口前，需要申请对应的权限。 
场景介绍
在Stage模型下，管理应用窗口的典型场景有：
 设置应用主窗口属性及目标页面 设置应用子窗口属性及目标页面 体验窗口沉浸式能力 设置悬浮窗 监听窗口不可交互与可交互事件 
以下分别介绍具体开发方式。
接口说明
上述场景涉及的常用接口如下表所示。更多API说明请参见API参考。
获取WindowStage实例下的主窗口。
此接口仅可在Stage模型下使用。
为当前WindowStage的主窗口加载具体页面。
其中path为要加载到窗口中的页面内容的路径，该路径需添加到工程的main_pages.json文件中。
此接口仅可在Stage模型下使用。
创建子窗口。
此接口仅可在Stage模型下使用。
开启WindowStage生命周期变化的监听。
此接口仅可在Stage模型下使用。
创建子窗口或者系统窗口。
-config：创建窗口时的参数。
根据当前工程中某个页面的路径为窗口加载具体的页面内容。
其中path为要加载到窗口中的页面内容的路径，在Stage模型下该路径需添加到工程的main_pages.json文件中。
设置窗口内导航栏、状态栏属性。
systemBarProperties：导航栏、状态栏的属性集合。
设置应用主窗口
在Stage模型下，应用主窗口由UIAbility创建并维护生命周期。在UIAbility的onWindowStageCreate回调中，通过WindowStage获取应用主窗口，即可对其进行属性设置等操作。还可以在应用配置文件中设置应用主窗口的属性，如最大窗口宽度maxWindowWidth等，详见module.json5配置文件中的abilities标签。
[h2]开发步骤
 获取应用主窗口。 通过getMainWindow接口获取应用主窗口。 设置主窗口属性。 可设置主窗口的背景色、亮度值、是否可触等多个属性，开发者可根据需要选择对应的接口。本示例以设置“是否可触”属性为例。 为主窗口加载对应的目标页面。 通过loadContent接口加载主窗口的目标页面。 
import { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport default class EntryAbility extends UIAbility {\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    // 1.获取应用主窗口。\n    let windowClass: window.Window | null = null;\n    windowStage.getMainWindow((err: BusinessError, data) => {\n      let errCode: number = err.code;\n      if (errCode) {\n        console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));\n        return;\n      }\n      windowClass = data;\n      console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));\n      // 2.设置主窗口属性。以设置\"是否可触\"属性为例。\n      let isTouchable: boolean = true;\n      windowClass.setWindowTouchable(isTouchable, (err: BusinessError) => {\n        let errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to set the window to be touchable. Cause:' + JSON.stringify(err));\n          return;\n        }\n        console.info('Succeeded in setting the window to be touchable.');\n      })\n    })\n    // 3.为主窗口加载对应的目标页面。\n    windowStage.loadContent(\"pages/page2\", (err: BusinessError) => {\n      let errCode: number = err.code;\n      if (errCode) {\n        console.error('Failed to load the content. Cause:' + JSON.stringify(err));\n        return;\n      }\n      console.info('Succeeded in loading the content.');\n    });\n  }\n};
设置应用子窗口
开发者可以按需创建应用子窗口，如弹窗等，并对其进行属性设置等操作。
由于以下几种情况，移动设备场景下不推荐使用子窗口，优先推荐使用控件overlay能力实现。
 移动设备场景下子窗不能超出主窗口范围，与控件一致。 分屏窗口与自由窗口模式下，主窗口位置大小发生改变时控件实时跟随变化能力优于子窗。 部分设备平台下根据实际的系统配置限制，子窗只有系统默认的动效和圆角阴影，应用无法设置，自由度低。 
[h2]开发步骤
 创建应用子窗口。 通过createSubWindow接口创建应用子窗口。 设置子窗口属性。 子窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置窗口背景色、亮度等属性。 加载显示子窗口的具体内容。 通过setUIContent和showWindow接口加载显示子窗口的具体内容。 销毁子窗口。 当不再需要某些子窗口时，可根据具体实现逻辑，使用destroyWindow接口销毁子窗口。 
直接在onWindowStageCreate里面创建子窗口的整体示例代码如下：
import { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet windowStage_: window.WindowStage | null = null;\nlet sub_windowClass: window.Window | null = null;\n\nexport default class EntryAbility extends UIAbility {\n  showSubWindow() {\n    // 1.创建应用子窗口。\n    if (windowStage_ == null) {\n      console.error('Failed to create the subwindow. Cause: windowStage_ is null');\n    }\n    else {\n      windowStage_.createSubWindow(\"mySubWindow\", (err: BusinessError, data) => {\n        let errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));\n          return;\n        }\n        sub_windowClass = data;\n        console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));\n        // 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。\n        sub_windowClass.moveWindowTo(300, 300, (err: BusinessError) => {\n          let errCode: number = err.code;\n          if (errCode) {\n            console.error('Failed to move the window. Cause:' + JSON.stringify(err));\n            return;\n          }\n          console.info('Succeeded in moving the window.');\n        });\n        sub_windowClass.resize(500, 500, (err: BusinessError) => {\n          let errCode: number = err.code;\n          if (errCode) {\n            console.error('Failed to change the window size. Cause:' + JSON.stringify(err));\n            return;\n          }\n          console.info('Succeeded in changing the window size.');\n        });\n        // 3.为子窗口加载对应的目标页面。\n        sub_windowClass.setUIContent(\"pages/page3\", (err: BusinessError) => {\n          let errCode: number = err.code;\n          if (errCode) {\n            console.error('Failed to load the content. Cause:' + JSON.stringify(err));\n            return;\n          }\n          console.info('Succeeded in loading the content.');\n          // 3.显示子窗口。\n          (sub_windowClass as window.Window).showWindow((err: BusinessError) => {\n            let errCode: number = err.code;\n            if (errCode) {\n              console.error('Failed to show the window. Cause: ' + JSON.stringify(err));\n              return;\n            }\n            console.info('Succeeded in showing the window.');\n          });\n        });\n      })\n    }\n  }\n\n  destroySubWindow() {\n    // 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。\n    (sub_windowClass as window.Window).destroyWindow((err: BusinessError) => {\n      let errCode: number = err.code;\n      if (errCode) {\n        console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));\n        return;\n      }\n      console.info('Succeeded in destroying the window.');\n    });\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    windowStage_ = windowStage;\n    // 开发者可以在适当的时机，如主窗口上按钮点击事件等，创建子窗口。并不一定需要在onWindowStageCreate调用，这里仅作展示\n    this.showSubWindow();\n  }\n\n  onWindowStageDestroy() {\n    // 开发者可以在适当的时机，如子窗口上点击关闭按钮等，销毁子窗口。并不一定需要在onWindowStageDestroy调用，这里仅作展示\n    this.destroySubWindow();\n  }\n};
另外，也可以在某个page页面通过点击按钮创建子窗口，整体示例代码如下：
// EntryAbility.ets\nonWindowStageCreate(windowStage: window.WindowStage) {\n  windowStage.loadContent('pages/Index', (err) => {\n    if (err.code) {\n      console.error('Failed to load the content. Cause:' + JSON.stringify(err));\n      return;\n    }\n    console.info('Succeeded in loading the content.');\n  })\n\n  // 给Index页面传递windowStage\n  AppStorage.setOrCreate('windowStage', windowStage);\n}
// Index.ets\nimport { window } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet windowStage_: window.WindowStage | undefined = undefined;\nlet sub_windowClass: window.Window | undefined = undefined;\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n  private CreateSubWindow(){\n    // 获取windowStage\n    windowStage_ = AppStorage.get('windowStage');\n    // 1.创建应用子窗口。\n    if (windowStage_ == null) {\n      console.error('Failed to create the subwindow. Cause: windowStage_ is null');\n    }\n    else {\n      windowStage_.createSubWindow(\"mySubWindow\", (err: BusinessError, data) => {\n        let errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));\n          return;\n        }\n        sub_windowClass = data;\n        console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));\n        // 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。\n        sub_windowClass.moveWindowTo(300, 300, (err: BusinessError) => {\n          let errCode: number = err.code;\n          if (errCode) {\n            console.error('Failed to move the window. Cause:' + JSON.stringify(err));\n            return;\n          }\n          console.info('Succeeded in moving the window.');\n        });\n        sub_windowClass.resize(500, 500, (err: BusinessError) => {\n          let errCode: number = err.code;\n          if (errCode) {\n            console.error('Failed to change the window size. Cause:' + JSON.stringify(err));\n            return;\n          }\n          console.info('Succeeded in changing the window size.');\n        });\n        // 3.为子窗口加载对应的目标页面。\n        sub_windowClass.setUIContent(\"pages/subWindow\", (err: BusinessError) => {\n          let errCode: number = err.code;\n          if (errCode) {\n            console.error('Failed to load the content. Cause:' + JSON.stringify(err));\n            return;\n          }\n          console.info('Succeeded in loading the content.');\n          // 3.显示子窗口。\n          (sub_windowClass as window.Window).showWindow((err: BusinessError) => {\n            let errCode: number = err.code;\n            if (errCode) {\n              console.error('Failed to show the window. Cause: ' + JSON.stringify(err));\n              return;\n            }\n            console.info('Succeeded in showing the window.');\n          });\n        });\n      })\n    }\n  }\n  private destroySubWindow(){\n    // 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。\n    (sub_windowClass as window.Window).destroyWindow((err: BusinessError) => {\n      let errCode: number = err.code;\n      if (errCode) {\n        console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));\n        return;\n      }\n      console.info('Succeeded in destroying the window.');\n    });\n  }\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n        Button(){\n          Text('CreateSubWindow')\n          .fontSize(24)\n          .fontWeight(FontWeight.Normal)\n        }.width(220).height(68)\n        .margin({left:10, top:60})\n        .onClick(() => {\n          this.CreateSubWindow()\n        })\n        Button(){\n          Text('destroySubWindow')\n          .fontSize(24)\n          .fontWeight(FontWeight.Normal)\n        }.width(220).height(68)\n        .margin({left:10, top:60})\n        .onClick(() => {\n          this.destroySubWindow()\n        })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
// subWindow.ets\n@Entry\n@Component\nstruct SubWindow {\n  @State message: string = 'Hello subWindow';\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
体验窗口沉浸式能力
在看视频、玩游戏等场景下，用户往往希望隐藏状态栏、导航栏等不必要的系统窗口，从而获得更佳的沉浸式体验。此时可以借助窗口沉浸式能力（窗口沉浸式能力都是针对应用主窗口而言的），达到预期效果。从API version 10开始，沉浸式窗口默认配置为全屏大小并由组件模块控制布局，状态栏、导航栏背景颜色为透明，文字颜色为黑色；应用窗口调用setWindowLayoutFullScreen接口，设置为true表示由组件模块控制忽略状态栏、导航栏的沉浸式全屏布局，设置为false表示由组件模块控制避让状态栏、导航栏的非沉浸式全屏布局。
当前沉浸式界面开发仅支持window级别的配置，暂不支持Page级别的配置。若有Page级别切换的需要，可以在页面生命周期开始，例如onPageShow中设置沉浸模式，然后在页面退出，例如onPageHide中恢复默认设置来实现。
[h2]开发步骤
 获取应用主窗口。 通过getMainWindow接口获取应用主窗口。 实现沉浸式效果。有以下两种方式：  方式一：应用主窗口为全屏窗口时，调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。 方式二：调用setWindowLayoutFullScreen接口，设置应用主窗口为全屏布局；然后调用setWindowSystemBarProperties接口，设置导航栏、状态栏的透明度、背景/文字颜色以及高亮图标等属性，使之保持与主窗口显示协调一致，从而达到沉浸式效果。  加载显示沉浸式窗口的具体内容。 通过loadContent接口加载沉浸式窗口的具体内容。 
import { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport default class EntryAbility extends UIAbility {\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    // 1.获取应用主窗口。\n    let windowClass: window.Window | null = null;\n    windowStage.getMainWindow((err: BusinessError, data) => {\n      let errCode: number = err.code;\n      if (errCode) {\n        console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));\n        return;\n      }\n      windowClass = data;\n      console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));\n\n      // 2.实现沉浸式效果。方式一：设置导航栏、状态栏不显示。\n      let names: Array<'status' | 'navigation'> = [];\n      windowClass.setWindowSystemBarEnable(names)\n        .then(() => {\n          console.info('Succeeded in setting the system bar to be visible.');\n        })\n        .catch((err: BusinessError) => {\n          console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));\n        });\n      // 2.实现沉浸式效果。方式二：设置窗口为全屏布局，配合设置导航栏、状态栏的透明度、背景/文字颜色及高亮图标等属性，与主窗口显示保持协调一致。\n      let isLayoutFullScreen = true;\n      windowClass.setWindowLayoutFullScreen(isLayoutFullScreen)\n        .then(() => {\n          console.info('Succeeded in setting the window layout to full-screen mode.');\n        })\n        .catch((err: BusinessError) => {\n          console.error('Failed to set the window layout to full-screen mode. Cause:' + JSON.stringify(err));\n        });\n      let sysBarProps: window.SystemBarProperties = {\n        statusBarColor: '#ff00ff',\n        navigationBarColor: '#00ff00',\n        // 以下两个属性从API Version 8开始支持\n        statusBarContentColor: '#ffffff',\n        navigationBarContentColor: '#ffffff'\n      };\n      windowClass.setWindowSystemBarProperties(sysBarProps)\n        .then(() => {\n          console.info('Succeeded in setting the system bar properties.');\n        })\n        .catch((err: BusinessError) => {\n          console.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err));\n        });\n    })\n    // 3.为沉浸式窗口加载对应的目标页面。\n    windowStage.loadContent(\"pages/page2\", (err: BusinessError) => {\n      let errCode: number = err.code;\n      if (errCode) {\n        console.error('Failed to load the content. Cause:' + JSON.stringify(err));\n        return;\n      }\n      console.info('Succeeded in loading the content.');\n    });\n  }\n};
设置悬浮窗（受限开放）
悬浮窗可以在已有的任务基础上，创建一个始终在前台显示的窗口。即使创建悬浮窗的任务退至后台，悬浮窗仍然可以在前台显示。通常悬浮窗位于所有应用窗口之上，开发者可以创建悬浮窗，并对悬浮窗进行属性设置等操作。
[h2]开发步骤
前提条件： 创建WindowType.TYPE_FLOAT即悬浮窗类型的窗口，需要申请ohos.permission.SYSTEM_FLOAT_WINDOW权限，该权限为受控开放权限，仅符合指定场景的在2in1设备上的应用可申请该权限。申请方式请参考：申请使用受限权限。
在其他设备或场景下，请使用画中画功能，使用方式参考：画中画开发指导。
如果应用未在应用市场（AGC）申请相应的权限证书，却试图在配置文件中声明此类权限，将会导致应用安装失败。
 创建悬浮窗。 通过window.createWindow接口创建悬浮窗类型的窗口。 对悬浮窗进行属性设置等操作。 悬浮窗窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置悬浮窗背景色、亮度等属性。 加载显示悬浮窗的具体内容。 通过setUIContent和showWindow接口加载显示悬浮窗的具体内容。 销毁悬浮窗。 当不再需要悬浮窗时，可根据具体实现逻辑，使用destroyWindow接口销毁悬浮窗。 
import { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport default class EntryAbility extends UIAbility {\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    // 1.创建悬浮窗。\n    let windowClass: window.Window | null = null;\n    let config: window.Configuration = {\n      name: \"floatWindow\", windowType: window.WindowType.TYPE_FLOAT, ctx: this.context\n    };\n    window.createWindow(config, (err: BusinessError, data) => {\n      let errCode: number = err.code;\n      if (errCode) {\n        console.error('Failed to create the floatWindow. Cause: ' + JSON.stringify(err));\n        return;\n      }\n      console.info('Succeeded in creating the floatWindow. Data: ' + JSON.stringify(data));\n      windowClass = data;\n      // 2.悬浮窗窗口创建成功后，设置悬浮窗的位置、大小及相关属性等。\n      windowClass.moveWindowTo(300, 300, (err: BusinessError) => {\n        let errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to move the window. Cause:' + JSON.stringify(err));\n          return;\n        }\n        console.info('Succeeded in moving the window.');\n      });\n      windowClass.resize(500, 500, (err: BusinessError) => {\n        let errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to change the window size. Cause:' + JSON.stringify(err));\n          return;\n        }\n        console.info('Succeeded in changing the window size.');\n      });\n      // 3.为悬浮窗加载对应的目标页面。\n      windowClass.setUIContent(\"pages/page4\", (err: BusinessError) => {\n        let errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to load the content. Cause:' + JSON.stringify(err));\n          return;\n        }\n        console.info('Succeeded in loading the content.');\n        // 3.显示悬浮窗。\n        (windowClass as window.Window).showWindow((err: BusinessError) => {\n          let errCode: number = err.code;\n          if (errCode) {\n            console.error('Failed to show the window. Cause: ' + JSON.stringify(err));\n            return;\n          }\n          console.info('Succeeded in showing the window.');\n        });\n      });\n      // 4.销毁悬浮窗。当不再需要悬浮窗时，可根据具体实现逻辑，使用destroy对其进行销毁。\n      windowClass.destroyWindow((err: BusinessError) => {\n        let errCode: number = err.code;\n        if (errCode) {\n          console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));\n          return;\n        }\n        console.info('Succeeded in destroying the window.');\n      });\n    });\n  }\n};
监听窗口不可交互与可交互事件
应用在前台显示过程中可能会进入某些不可交互的场景，比较典型的是进入多任务界面。此时，对于一些应用可能需要选择暂停某个与用户正在交互的业务，如视频类应用暂停正在播放的视频或者相机暂停预览流等。而当该应用从多任务又切回前台时，又变成了可交互的状态，此时需要恢复被暂停中断的业务，如恢复视频播放或相机预览流等。
[h2]开发步骤
在创建WindowStage对象后可通过监听'windowStageEvent'事件类型，监听到窗口进入前台、后台、前台可交互、前台不可交互等事件，应用可根据这些上报的事件状态进行相应的业务处理。
import { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\n\nexport default class EntryAbility extends UIAbility {\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    try {\n      windowStage.on('windowStageEvent', (data) => {\n        console.info('Succeeded in enabling the listener for window stage event changes. Data: ' +\n          JSON.stringify(data));\n\n        // 根据事件状态类型选择进行相应的处理\n        if (data == window.WindowStageEventType.SHOWN) {\n          console.info('current window stage event is SHOWN');\n          // 应用进入前台，默认为可交互状态\n          // ...\n        } else if (data == window.WindowStageEventType.HIDDEN) {\n          console.info('current window stage event is HIDDEN');\n          // 应用进入后台，默认为不可交互状态\n          // ...\n        } else if (data == window.WindowStageEventType.PAUSED) {\n          console.info('current window stage event is PAUSED');\n          // 前台应用进入多任务，转为不可交互状态\n          // ...\n        } else if (data == window.WindowStageEventType.RESUMED) {\n          console.info('current window stage event is RESUMED');\n          // 进入多任务后又继续返回前台时，恢复可交互状态\n          // ...\n        }\n\n        // ...\n      });\n    } catch (exception) {\n      console.error('Failed to enable the listener for window stage event changes. Cause:' +\n        JSON.stringify(exception));\n    }\n  }\n}

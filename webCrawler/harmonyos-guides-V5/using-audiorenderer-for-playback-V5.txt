使用AudioRenderer开发音频播放功能
AudioRenderer是音频渲染器，用于播放PCM（Pulse Code Modulation）音频数据，相比AVPlayer而言，可以在输入前添加数据预处理，更适合有音频开发经验的开发者，以实现更灵活的播放功能。
开发指导
使用AudioRenderer播放音频涉及到AudioRenderer实例的创建、音频渲染参数的配置、渲染的开始与停止、资源的释放等。本开发指导将以一次渲染音频数据的过程为例，向开发者讲解如何使用AudioRenderer进行音频渲染，建议搭配AudioRenderer的API说明阅读。
下图展示了AudioRenderer的状态变化，在创建实例后，调用对应的方法可以进入指定的状态实现对应的行为。需要注意的是在确定的状态执行不合适的方法可能导致AudioRenderer发生错误，建议开发者在调用状态转换的方法前进行状态检查，避免程序运行产生预期以外的结果。
为保证UI线程不被阻塞，大部分AudioRenderer调用都是异步的。对于每个API均提供了callback函数和Promise函数，以下示例均采用callback函数。
图1 AudioRenderer状态变化示意图
在进行应用开发的过程中，建议开发者通过on('stateChange')方法订阅AudioRenderer的状态变更。因为针对AudioRenderer的某些操作，仅在音频播放器在固定状态时才能执行。如果应用在音频播放器处于错误状态时执行操作，系统可能会抛出异常或生成其他未定义的行为。
 prepared状态： 通过调用createAudioRenderer()方法进入到该状态。 running状态： 正在进行音频数据播放，可以在prepared状态通过调用start()方法进入此状态，也可以在paused状态和stopped状态通过调用start()方法进入此状态。 paused状态： 在running状态可以通过调用pause()方法暂停音频数据的播放并进入paused状态，暂停播放之后可以通过调用start()方法继续音频数据播放。 stopped状态： 在paused/running状态可以通过stop()方法停止音频数据的播放。 released状态： 在prepared、paused、stopped等状态，用户均可通过release()方法释放掉所有占用的硬件和软件资源，并且不会再进入到其他的任何一种状态了。 
[h2]开发步骤及注意事项
 配置音频渲染参数并创建AudioRenderer实例，音频渲染参数的详细信息可以查看AudioRendererOptions。 import { audio } from '@kit.AudioKit';\n\nlet audioStreamInfo: audio.AudioStreamInfo = {\n  samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_48000, // 采样率\n  channels: audio.AudioChannel.CHANNEL_2, // 通道\n  sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式\n  encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式\n};\n\nlet audioRendererInfo: audio.AudioRendererInfo = {\n  usage: audio.StreamUsage.STREAM_USAGE_MUSIC,\n  rendererFlags: 0\n};\n\nlet audioRendererOptions: audio.AudioRendererOptions = {\n  streamInfo: audioStreamInfo,\n  rendererInfo: audioRendererInfo\n};\n\naudio.createAudioRenderer(audioRendererOptions, (err, data) => {\n  if (err) {\n    console.error(`Invoke createAudioRenderer failed, code is ${err.code}, message is ${err.message}`);\n    return;\n  } else {\n    console.info('Invoke createAudioRenderer succeeded.');\n    let audioRenderer = data;\n  }\n}); 调用on('writeData')方法，订阅监听音频数据写入回调，推荐使用API version 12支持返回回调结果的方式。  API version 12开始该方法支持返回回调结果，系统可以根据开发者返回的值来决定此次回调中的数据是否播放。      能填满回调所需长度数据的情况下，返回audio.AudioDataCallbackResult.VALID，系统会取用完整长度的数据缓冲进行播放。请不要在未填满数据的情况下返回audio.AudioDataCallbackResult.VALID，否则会导致杂音、卡顿等现象。 在无法填满回调所需长度数据的情况下，建议开发者返回audio.AudioDataCallbackResult.INVALID，系统不会处理该段音频数据，然后会再次向应用请求数据，确认数据填满后返回audio.AudioDataCallbackResult.VALID。 回调函数结束后，音频服务会把缓冲中数据放入队列里等待播放，因此请勿在回调外再次更改缓冲中的数据。对于最后一帧，如果数据不够填满缓冲长度，开发者需要使用剩余数据拼接空数据的方式，将缓冲填满，避免缓冲内的历史脏数据对播放效果产生不良的影响。    import { audio } from '@kit.AudioKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\n\nclass Options {\n  offset?: number;\n  length?: number;\n}\n\nlet bufferSize: number = 0;\nlet path = getContext().cacheDir;\n// 确保该沙箱路径下存在该资源\nlet filePath = path + '/StarWars10s-2C-48000-4SW.wav';\nlet file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_ONLY);\n\nlet writeDataCallback = (buffer: ArrayBuffer) => {\n  let options: Options = {\n    offset: bufferSize,\n    length: buffer.byteLength\n  };\n\n  try {\n    fs.readSync(file.fd, buffer, options);\n    bufferSize += buffer.byteLength;\n    // 系统会判定buffer有效，正常播放。\n    return audio.AudioDataCallbackResult.VALID;\n  } catch (error) {\n    console.error('Error reading file:', error);\n    // 系统会判定buffer无效，不播放。\n    return audio.AudioDataCallbackResult.INVALID;\n  }\n};\n\naudioRenderer.on('writeData', writeDataCallback); API version 11该方法不支持返回回调结果，系统默认回调中的数据均为有效数据。      请确保填满回调所需长度数据，否则会导致杂音、卡顿等现象。 在无法填满回调所需长度数据的情况下，建议开发者选择暂时停止写入数据（不暂停音频流），阻塞回调函数，等待数据充足时，再继续写入数据，确保数据填满。在阻塞回调函数后，如需调用AudioRenderer相关接口，需先解阻塞。 开发者如果不希望播放本次回调中的音频数据，可以主动将回调中的数据块置空（置空后，也会被系统统计到已写入的数据，播放静音帧）。 回调函数结束后，音频服务会把缓冲中数据放入队列里等待播放，因此请勿在回调外再次更改缓冲中的数据。对于最后一帧，如果数据不够填满缓冲长度，开发者需要使用剩余数据拼接空数据的方式，将缓冲填满，避免缓冲内的历史脏数据对播放效果产生不良的影响。    import { BusinessError } from '@kit.BasicServicesKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\n\nclass Options {\n  offset?: number;\n  length?: number;\n}\n\nlet bufferSize: number = 0;\nlet path = getContext().cacheDir;\n// 确保该沙箱路径下存在该资源\nlet filePath = path + '/StarWars10s-2C-48000-4SW.wav';\nlet file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_ONLY);\nlet writeDataCallback = (buffer: ArrayBuffer) => {\n  // 如果开发者不希望播放某段buffer，可在此处添加判断并对buffer进行置空处理。\n  let options: Options = {\n    offset: bufferSize,\n    length: buffer.byteLength\n  };\n  fs.readSync(file.fd, buffer, options);\n  bufferSize += buffer.byteLength;\n};\n\naudioRenderer.on('writeData', writeDataCallback);  调用start()方法进入running状态，开始渲染音频。 import { BusinessError } from '@kit.BasicServicesKit';\n\naudioRenderer.start((err: BusinessError) => {\n  if (err) {\n    console.error(`Renderer start failed, code is ${err.code}, message is ${err.message}`);\n  } else {\n    console.info('Renderer start success.');\n  }\n}); 调用stop()方法停止渲染。 import { BusinessError } from '@kit.BasicServicesKit';\n\naudioRenderer.stop((err: BusinessError) => {\n  if (err) {\n    console.error(`Renderer stop failed, code is ${err.code}, message is ${err.message}`);\n  } else {\n    console.info('Renderer stopped.');\n  }\n}); 调用release()方法销毁实例，释放资源。 import { BusinessError } from '@kit.BasicServicesKit';\n\naudioRenderer.release((err: BusinessError) => {\n  if (err) {\n    console.error(`Renderer release failed, code is ${err.code}, message is ${err.message}`);\n  } else {\n    console.info('Renderer released.');\n  } \n}); 
[h2]选择正确的StreamUsage
创建播放器时候，开发者需要根据应用场景指定播放器的StreamUsage，选择正确的StreamUsage可以避免用户遇到不符合预期的行为。
在音频API文档StreamUsage介绍中，列举了每一种类型推荐的应用场景。例如音乐场景推荐使用STREAM_USAGE_MUSIC，电影或者视频场景推荐使用STREAM_USAGE_MOVIE，游戏场景推荐使用STREAM_USAGE_GAME，等等。
如果开发者配置了不正确的StreamUsage，可能带来一些不符合预期的行为。例如以下场景。
 游戏场景错误使用STREAM_USAGE_MUSIC类型，游戏应用将无法和其他音乐应用并发播放，而游戏场景通常可以与其他音乐应用并发播放。 导航场景错误使用STREAM_USAGE_MUSIC类型，导航应用播报时候会导致正在播放的音乐停止播放，而导航场景我们通常期望正在播放的音乐仅仅降低音量播放。 
[h2]完整示例
下面展示了使用AudioRenderer渲染音频文件的示例代码。
import { audio } from '@kit.AudioKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\n\nconst TAG = 'AudioRendererDemo';\n\nclass Options {\n  offset?: number;\n  length?: number;\n}\n\nlet bufferSize: number = 0;\nlet renderModel: audio.AudioRenderer | undefined = undefined;\nlet audioStreamInfo: audio.AudioStreamInfo = {\n  samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_48000, // 采样率\n  channels: audio.AudioChannel.CHANNEL_2, // 通道\n  sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式\n  encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式\n};\nlet audioRendererInfo: audio.AudioRendererInfo = {\n  usage: audio.StreamUsage.STREAM_USAGE_MUSIC, // 音频流使用类型\n  rendererFlags: 0 // 音频渲染器标志\n};\nlet audioRendererOptions: audio.AudioRendererOptions = {\n  streamInfo: audioStreamInfo,\n  rendererInfo: audioRendererInfo\n};\nlet path = getContext().cacheDir;\n// 确保该沙箱路径下存在该资源\nlet filePath = path + '/StarWars10s-2C-48000-4SW.wav';\nlet file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_ONLY);\nlet writeDataCallback = (buffer: ArrayBuffer) => {\n  let options: Options = {\n    offset: bufferSize,\n    length: buffer.byteLength\n  };\n\n  try {\n    fs.readSync(file.fd, buffer, options);\n    bufferSize += buffer.byteLength;\n    // API version 11 不支持返回回调结果，从 API version 12 开始支持返回回调结果\n    return audio.AudioDataCallbackResult.VALID;\n  } catch (error) {\n    console.error('Error reading file:', error);\n    // API version 11 不支持返回回调结果，从 API version 12 开始支持返回回调结果\n    return audio.AudioDataCallbackResult.INVALID;\n  }\n};\n\n// 初始化，创建实例，设置监听事件\nfunction init() {\n  audio.createAudioRenderer(audioRendererOptions, (err, renderer) => { // 创建AudioRenderer实例\n    if (!err) {\n      console.info(`${TAG}: creating AudioRenderer success`);\n      renderModel = renderer;\n      if (renderModel !== undefined) {\n        (renderModel as audio.AudioRenderer).on('writeData', writeDataCallback);\n      }\n    } else {\n      console.info(`${TAG}: creating AudioRenderer failed, error: ${err.message}`);\n    }\n  });\n}\n\n// 开始一次音频渲染\nfunction start() {\n  if (renderModel !== undefined) {\n    let stateGroup = [audio.AudioState.STATE_PREPARED, audio.AudioState.STATE_PAUSED, audio.AudioState.STATE_STOPPED];\n    if (stateGroup.indexOf((renderModel as audio.AudioRenderer).state.valueOf()) === -1) { // 当且仅当状态为prepared、paused和stopped之一时才能启动渲染\n      console.error(TAG + 'start failed');\n      return;\n    }\n    // 启动渲染\n    (renderModel as audio.AudioRenderer).start((err: BusinessError) => {\n      if (err) {\n        console.error('Renderer start failed.');\n      } else {\n        console.info('Renderer start success.');\n      }\n    });\n  }\n}\n\n// 暂停渲染\nfunction pause() {\n  if (renderModel !== undefined) {\n    // 只有渲染器状态为running的时候才能暂停\n    if ((renderModel as audio.AudioRenderer).state.valueOf() !== audio.AudioState.STATE_RUNNING) {\n      console.info('Renderer is not running');\n      return;\n    }\n    // 暂停渲染\n    (renderModel as audio.AudioRenderer).pause((err: BusinessError) => {\n      if (err) {\n        console.error('Renderer pause failed.');\n      } else {\n        console.info('Renderer pause success.');\n      }\n    });\n  }\n}\n\n// 停止渲染\nasync function stop() {\n  if (renderModel !== undefined) {\n    // 只有渲染器状态为running或paused的时候才可以停止\n    if ((renderModel as audio.AudioRenderer).state.valueOf() !== audio.AudioState.STATE_RUNNING && (renderModel as audio.AudioRenderer).state.valueOf() !== audio.AudioState.STATE_PAUSED) {\n      console.info('Renderer is not running or paused.');\n      return;\n    }\n    // 停止渲染\n    (renderModel as audio.AudioRenderer).stop((err: BusinessError) => {\n      if (err) {\n        console.error('Renderer stop failed.');\n      } else {\n        fs.close(file);\n        console.info('Renderer stop success.');\n      }\n    });\n  }\n}\n\n// 销毁实例，释放资源\nasync function release() {\n  if (renderModel !== undefined) {\n    // 渲染器状态不是released状态，才能release\n    if (renderModel.state.valueOf() === audio.AudioState.STATE_RELEASED) {\n      console.info('Renderer already released');\n      return;\n    }\n    // 释放资源\n    (renderModel as audio.AudioRenderer).release((err: BusinessError) => {\n      if (err) {\n        console.error('Renderer release failed.');\n      } else {\n        console.info('Renderer release success.');\n      }\n    });\n  }\n}
当同优先级或高优先级音频流要使用输出设备时，当前音频流会被中断，应用可以自行响应中断事件并做出处理。具体的音频并发处理方式可参考处理音频焦点事件。

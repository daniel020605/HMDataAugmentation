LazyForEach：数据懒加载
API参数说明见：LazyForEach API参数说明。
LazyForEach从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。当在滚动容器中使用了LazyForEach，框架会根据滚动容器可视区域按需创建组件，当组件滑出可视区域外时，框架会进行组件销毁回收以降低内存占用。
使用限制
 LazyForEach必须在容器组件内使用，仅有List、Grid、Swiper以及WaterFlow组件支持数据懒加载（可配置cachedCount属性，即只加载可视部分以及其前后少量数据用于缓冲），其他组件仍然是一次性加载所有的数据。 容器组件内使用LazyForEach的时候，只能包含一个LazyForEach。以List为例，同时包含ListItem、ForEach、LazyForEach的情形是不推荐的；同时包含多个LazyForEach也是不推荐的。 LazyForEach在每次迭代中，必须创建且只允许创建一个子组件；即LazyForEach的子组件生成函数有且只有一个根组件。 生成的子组件必须是允许包含在LazyForEach父容器组件中的子组件。 允许LazyForEach包含在if/else条件渲染语句中，也允许LazyForEach中出现if/else条件渲染语句。 键值生成器必须针对每个数据生成唯一的值，如果键值相同，将导致键值相同的UI组件渲染出现问题。 LazyForEach必须使用DataChangeListener对象进行更新，对第一个参数dataSource重新赋值会异常；dataSource使用状态变量时，状态变量改变不会触发LazyForEach的UI刷新。 为了高性能渲染，通过DataChangeListener对象的onDataChange方法来更新UI时，需要生成不同于原来的键值来触发组件刷新。 LazyForEach必须和@Reusable装饰器一起使用才能触发节点复用。使用方法：将@Reusable装饰在LazyForEach列表的组件上，见使用规则。 
键值生成规则
在LazyForEach循环渲染过程中，系统会为每个item生成一个唯一且持久的键值，用于标识对应的组件。当这个键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并会基于新的键值创建一个新的组件。
LazyForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: Object, index: number) => { return viewId + '-' + index.toString(); }, viewId在编译器转换过程中生成，同一个LazyForEach组件内其viewId是一致的。
组件创建规则
在确定键值生成规则后，LazyForEach的第二个参数itemGenerator函数会根据组件创建规则为数据源的每个数组项创建组件。组件的创建包括两种情况：LazyForEach首次渲染和LazyForEach非首次渲染。
[h2]首次渲染
生成不同键值
在LazyForEach首次渲染时，会根据上述键值生成规则为数据源的每个数组项生成唯一键值，并创建相应的组件。
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n   \n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n      }, (item: string) => item)\n    }.cachedCount(5)\n  }\n}
在上述代码中，键值生成规则是keyGenerator函数的返回值item。在LazyForEach循环渲染时，其为数据源数组项依次生成键值Hello 0、Hello 1 ... Hello 20，并创建对应的ListItem子组件渲染到界面上。
运行效果如下图所示。
图1 LazyForEach正常首次渲染
键值相同时错误渲染
当不同数据项生成的键值相同时，框架的行为是不可预测的。例如，在以下代码中，LazyForEach渲染的数据项键值均相同，在滑动过程中，LazyForEach会对划入划出当前页面的子组件进行预加载，而新建的子组件和销毁的原子组件具有相同的键值，框架可能存在取用缓存错误的情况，导致子组件渲染有问题。
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n      }, (item: string) => 'same key')\n    }.cachedCount(5)\n  }\n}
运行效果如下图所示。
图2 LazyForEach存在相同键值
[h2]非首次渲染
当LazyForEach数据源发生变化，需要再次渲染时，开发者应根据数据源的变化情况调用listener对应的接口，通知LazyForEach做相应的更新，各使用场景如下。
添加数据
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n        .onClick(() => {\n          // 点击追加子组件\n          this.data.pushData(`Hello ${this.data.totalCount()}`);\n        })\n      }, (item: string) => item)\n    }.cachedCount(5)\n  }\n}
当我们点击LazyForEach的子组件时，首先调用数据源data的pushData方法，该方法会在数据源末尾添加数据并调用notifyDataAdd方法。在notifyDataAdd方法内会又调用listener.onDataAdd方法，该方法会通知LazyForEach在该处有数据添加，LazyForEach便会在该索引处新建子组件。
运行效果如下图所示。
图3 LazyForEach添加数据
删除数据
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public getAllData(): string[] {\n    return this.dataArray;\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n  }\n  \n  public deleteData(index: number): void {\n    this.dataArray.splice(index, 1);\n    this.notifyDataDelete(index);\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n        .onClick(() => {\n          // 点击删除子组件\n          this.data.deleteData(this.data.getAllData().indexOf(item));\n        })\n      }, (item: string) => item)\n    }.cachedCount(5)\n  }\n}
当我们点击LazyForEach的子组件时，首先调用数据源data的deleteData方法，该方法会删除数据源对应索引处的数据并调用notifyDataDelete方法。在notifyDataDelete方法内会又调用listener.onDataDelete方法，该方法会通知LazyForEach在该处有数据删除，LazyForEach便会在该索引处删除对应子组件。
运行效果如下图所示。
图4 LazyForEach删除数据
交换数据
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public getAllData(): string[] {\n    return this.dataArray;\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n  }\n  \n  public moveData(from: number, to: number): void {\n    let temp: string = this.dataArray[from];\n    this.dataArray[from] = this.dataArray[to];\n    this.dataArray[to] = temp;\n    this.notifyDataMove(from, to);\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n        .onClick(() => {\n          this.moved.push(this.data.getAllData().indexOf(item));\n          if (this.moved.length === 2) {\n              // 点击交换子组件\n              this.data.moveData(this.moved[0], this.moved[1]);\n            this.moved = [];\n          }\n        })\n      }, (item: string) => item)\n    }.cachedCount(5)\n  }\n}
当我们首次点击LazyForEach的子组件时，在moved成员变量内存入要移动的数据索引，再次点击LazyForEach另一个子组件时，我们将首次点击的子组件移到此处。调用数据源data的moveData方法，该方法会将数据源对应数据移动到预期的位置并调用notifyDataMove方法。在notifyDataMove方法内会又调用listener.onDataMove方法，该方法通知LazyForEach在该处有数据需要移动，LazyForEach便会将from和to索引处的子组件进行位置调换。
运行效果如下图所示。
图5 LazyForEach交换数据
改变单个数据
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n  }\n  \n  public changeData(index: number, data: string): void {\n    this.dataArray.splice(index, 1, data);\n    this.notifyDataChange(index);\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n        .onClick(() => {\n          this.data.changeData(index, item + '00');\n        })\n      }, (item: string) => item)\n    }.cachedCount(5)\n  }\n}
当我们点击LazyForEach的子组件时，首先改变当前数据，然后调用数据源data的changeData方法，在该方法内会调用notifyDataChange方法。在notifyDataChange方法内会又调用listener.onDataChange方法，该方法通知LazyForEach组件该处有数据发生变化，LazyForEach便会在对应索引处重建子组件。
运行效果如下图所示。
图6 LazyForEach改变单个数据
改变多个数据
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n  }\n    \n  public reloadData(): void {\n    this.notifyDataReload();\n  }\n    \n  public modifyAllData(): void {\n    this.dataArray = this.dataArray.map((item: string) => {\n        return item + '0';\n    })\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n        .onClick(() => {\n          this.data.modifyAllData();\n          this.data.reloadData();\n        })\n      }, (item: string) => item)\n    }.cachedCount(5)\n  }\n}
当我们点击LazyForEach的子组件时，首先调用data的modifyAllData方法改变了数据源中的所有数据，然后调用数据源的reloadData方法，在该方法内会调用notifyDataReload方法。在notifyDataReload方法内会又调用listener.onDataReloaded方法，通知LazyForEach需要重建所有子节点。LazyForEach会将原所有数据项和新所有数据项一一做键值比对，若有相同键值则使用缓存，若键值不同则重新构建。
运行效果如下图所示。
图7 LazyForEach改变多个数据
精准批量修改数据
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public operateData(): void {\n    console.info(JSON.stringify(this.dataArray));\n    this.dataArray.splice(4, 0, this.dataArray[1]);\n    this.dataArray.splice(1, 1);\n    let temp = this.dataArray[4];\n    this.dataArray[4] = this.dataArray[6];\n    this.dataArray[6] = temp\n    this.dataArray.splice(8, 0, 'Hello 1', 'Hello 2');\n    this.dataArray.splice(12, 2);\n    console.info(JSON.stringify(this.dataArray));\n    this.notifyDatasetChange([\n      { type: DataOperationType.MOVE, index: { from: 1, to: 3 } },\n      { type: DataOperationType.EXCHANGE, index: { start: 4, end: 6 } },\n      { type: DataOperationType.ADD, index: 8, count: 2 },\n      { type: DataOperationType.DELETE, index: 10, count: 2 }]);\n  }\n\n  public init(): void {\n    this.dataArray.splice(0, 0, 'Hello a', 'Hello b', 'Hello c', 'Hello d', 'Hello e', 'Hello f', 'Hello g', 'Hello h',\n      'Hello i', 'Hello j', 'Hello k', 'Hello l', 'Hello m', 'Hello n', 'Hello o', 'Hello p', 'Hello q', 'Hello r');\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    this.data.init()\n  }\n\n  build() {\n    Column() {\n      Text('change data')\n        .fontSize(10)\n        .backgroundColor(Color.Blue)\n        .fontColor(Color.White)\n        .borderRadius(50)\n        .padding(5)\n        .onClick(() => {\n          this.data.operateData();\n        })\n      List({ space: 3 }) {\n        LazyForEach(this.data, (item: string, index: number) => {\n          ListItem() {\n            Row() {\n              Text(item).fontSize(35)\n                .onAppear(() => {\n                  console.info(\"appear:\" + item)\n                })\n            }.margin({ left: 10, right: 10 })\n          }\n\n        }, (item: string) => item + new Date().getTime())\n      }.cachedCount(5)\n    }\n  }\n}
onDatasetChange接口允许开发者一次性通知LazyForEach进行数据添加、删除、移动和交换等操作。在上述例子中，点击“change data”文本后,第二项数据被移动到第四项位置，第五项与第七项数据交换位置，并且从第九项开始添加了数据\"Hello 1\"和\"Hello 2\"，同时从第十一项开始删除了两项数据。
图8 LazyForEach改变多个数据
第二个例子，直接给数组赋值，不涉及 splice 操作。operations直接从比较原数组和新数组得到。
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public operateData(): void {\n    this.dataArray =\n      ['Hello x', 'Hello 1', 'Hello 2', 'Hello b', 'Hello c', 'Hello e', 'Hello d', 'Hello f', 'Hello g', 'Hello h']\n    this.notifyDatasetChange([\n      { type: DataOperationType.CHANGE, index: 0 },\n      { type: DataOperationType.ADD, index: 1, count: 2 },\n      { type: DataOperationType.EXCHANGE, index: { start: 3, end: 4 } },\n    ]);\n  }\n\n  public init(): void {\n    this.dataArray = ['Hello a', 'Hello b', 'Hello c', 'Hello d', 'Hello e', 'Hello f', 'Hello g', 'Hello h'];\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    this.data.init()\n  }\n\n  build() {\n    Column() {\n      Text('Multi-Data Change')\n        .fontSize(10)\n        .backgroundColor(Color.Blue)\n        .fontColor(Color.White)\n        .borderRadius(50)\n        .padding(5)\n        .onClick(() => {\n          this.data.operateData();\n        })\n      List({ space: 3 }) {\n        LazyForEach(this.data, (item: string, index: number) => {\n          ListItem() {\n            Row() {\n              Text(item).fontSize(35)\n                .onAppear(() => {\n                  console.info(\"appear:\" + item)\n                })\n            }.margin({ left: 10, right: 10 })\n          }\n\n        }, (item: string) => item + new Date().getTime())\n      }.cachedCount(5)\n    }\n  }\n}
图9 LazyForEach改变多个数据
使用该接口时有如下注意事项。
 onDatasetChange与其它操作数据的接口不能混用。 传入onDatasetChange的operations，其中每一项operation的index均从修改前的原数组内寻找。因此，operations中的index跟操作Datasource中的index不总是一一对应的,而且不能是负数。 
第一个例子清楚地显示了这一点:
// 修改之前的数组\n[\"Hello a\",\"Hello b\",\"Hello c\",\"Hello d\",\"Hello e\",\"Hello f\",\"Hello g\",\"Hello h\",\"Hello i\",\"Hello j\",\"Hello k\",\"Hello l\",\"Hello m\",\"Hello n\",\"Hello o\",\"Hello p\",\"Hello q\",\"Hello r\"]\n// 修改之后的数组\n[\"Hello a\",\"Hello c\",\"Hello d\",\"Hello b\",\"Hello g\",\"Hello f\",\"Hello e\",\"Hello h\",\"Hello 1\",\"Hello 2\",\"Hello i\",\"Hello j\",\"Hello m\",\"Hello n\",\"Hello o\",\"Hello p\",\"Hello q\",\"Hello r\"]
\"Hello b\" 从第2项变成第4项，因此第一个 operation 为 { type: DataOperationType.MOVE, index: { from: 1, to: 3 } }。
\"Hello e\" 跟 \"Hello g\" 对调了，而 \"Hello e\" 在修改前的原数组中的 index=4，\"Hello g\" 在修改前的原数组中的 index=6, 因此第二个 operation 为 { type: DataOperationType.EXCHANGE, index: { start: 4, end: 6 } }。
\"Hello 1\",\"Hello 2\" 在 \"Hello h\" 之后插入，而 \"Hello h\" 在修改前的原数组中的 index=7，因此第三个 operation 为 { type: DataOperationType.ADD, index: 8, count: 2 }。
\"Hello k\",\"Hello l\" 被删除了，而 \"Hello k\" 在原数组中的 index=10，因此第四个 operation 为 { type: DataOperationType.DELETE, index: 10, count: 2 }。
 调用一次onDatasetChange，一个index对应的数据只能被操作一次，若被操作多次，LazyForEach仅使第一个操作生效。 部分操作可以由开发者传入键值，LazyForEach不会再去重复调用keygenerator获取键值，需要开发者保证传入的键值的正确性。 若本次操作集合中有RELOAD操作，则其余操作全不生效。 
[h2]改变数据子属性
若仅靠LazyForEach的刷新机制，当item变化时若想更新子组件，需要将原来的子组件全部销毁再重新构建，在子组件结构较为复杂的情况下，靠改变键值去刷新渲染性能较低。因此框架提供了@Observed与@ObjectLink机制进行深度观测，可以做到仅刷新使用了该属性的组件，提高渲染性能。开发者可根据其自身业务特点选择使用哪种刷新方式。
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@Observed\nclass StringData {\n  message: string;\n  constructor(message: string) {\n    this.message = message;\n  }  \n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(new StringData(`Hello ${i}`));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          ChildComponent({data: item})\n        }\n        .onClick(() => {\n          item.message += '0';\n        })\n      }, (item: StringData, index: number) => index.toString())\n    }.cachedCount(5)\n  }\n}\n\n@Component\nstruct ChildComponent {\n  @ObjectLink data: StringData\n  build() {\n    Row() {\n      Text(this.data.message).fontSize(50)\n        .onAppear(() => {\n          console.info(\"appear:\" + this.data.message)\n        })\n    }.margin({ left: 10, right: 10 })\n  }\n}
此时点击LazyForEach子组件改变item.message时，重渲染依赖的是ChildComponent的@ObjectLink成员变量对其子属性的监听，此时框架只会刷新Text(this.data.message)，不会去重建整个ListItem子组件。
图10 LazyForEach改变数据子属性
[h2]使用状态管理V2
状态管理V2提供了@ObservedV2与@Trace装饰器可以实现对属性的深度观测，使用@Local和@Param可以实现对子组件的刷新管理，仅刷新使用了对应属性的组件。
嵌套类属性变化观测
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\nclass StringData {\n  firstLayer: FirstLayer;\n\n  constructor(firstLayer: FirstLayer) {\n    this.firstLayer = firstLayer;\n  }\n}\n\nclass FirstLayer {\n  secondLayer: SecondLayer;\n\n  constructor(secondLayer: SecondLayer) {\n    this.secondLayer = secondLayer;\n  }\n}\n\nclass SecondLayer {\n  thirdLayer: ThirdLayer;\n\n  constructor(thirdLayer: ThirdLayer) {\n    this.thirdLayer = thirdLayer;\n  }\n}\n\n@ObservedV2\nclass ThirdLayer {\n  @Trace forthLayer: String;\n\n  constructor(forthLayer: String) {\n    this.forthLayer = forthLayer;\n  }\n}\n\n@Entry\n@ComponentV2\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(new StringData(new FirstLayer(new SecondLayer(new ThirdLayer('Hello' + i)))));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          Text(item.firstLayer.secondLayer.thirdLayer.forthLayer.toString()).fontSize(50)\n            .onClick(() => {\n              item.firstLayer.secondLayer.thirdLayer.forthLayer += '!';\n            })\n        }\n      }, (item: StringData, index: number) => index.toString())\n    }.cachedCount(5)\n  }\n}
@ObservedV2与@Trace用于装饰类以及类中的属性，配合使用能深度观测被装饰的类和属性。示例中，展示了深度嵌套类结构下，通过@ObservedV2和@Trace实现对多层嵌套属性变化的观测和子组件刷新。当点击子组件Text修改被@Trace修饰的嵌套类最内层的类成员属性时，仅重新渲染依赖了该属性的组件。
组件内部状态
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@ObservedV2\nclass StringData {\n  @Trace message: string;\n\n  constructor(message: string) {\n    this.message = message;\n  }\n}\n\n@Entry\n@ComponentV2\nstruct MyComponent {\n  data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(new StringData('Hello' + i));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          Row() {\n\n            Text(item.message).fontSize(50)\n              .onClick(() => {\n                // 修改@ObservedV2装饰类中@Trace装饰的变量，触发刷新此处Text组件\n                item.message += '!';\n              })\n            ChildComponent()\n          }\n        }\n      }, (item: StringData, index: number) => index.toString())\n    }.cachedCount(5)\n  }\n}\n\n@ComponentV2\nstruct ChildComponent {\n  @Local message: string = '?';\n\n  build() {\n    Row() {\n      Text(this.message).fontSize(50)\n        .onClick(() => {\n          // 修改@Local装饰的变量，触发刷新此处Text组件\n          this.message += '?';\n        })\n    }\n  }\n}
@Local使得自定义组件内被修饰的变量具有观测其变化的能力，该变量必须在组件内部进行初始化。示例中，点击Text组件修改item.message会触发变量更新并刷新使用该变量的组件，ChildComponent中@Local装饰的变量message变化时也能刷新子组件。
组件外部输入
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@ObservedV2\nclass StringData {\n  @Trace message: string;\n\n  constructor(message: string) {\n    this.message = message;\n  }\n}\n\n@Entry\n@ComponentV2\nstruct MyComponent {\n  data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(new StringData('Hello' + i));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          ChildComponent({ data: item.message })\n            .onClick(() => {\n              item.message += '!';\n            })\n        }\n      }, (item: StringData, index: number) => index.toString())\n    }.cachedCount(5)\n  }\n}\n\n@ComponentV2\nstruct ChildComponent {\n  @Param @Require data: string = '';\n\n  build() {\n    Row() {\n      Text(this.data).fontSize(50)\n    }\n  }\n}
使用@Param装饰器可以让子组件接受外部输入的参数，实现父子组件之间的数据同步。在MyComponent中创建子组件时，将变量item.message传递，使用@Param修饰的变量data与之关联。点击ListItem中的组件修改item.message，数据变化会从父组件传递到子组件，并且触发子组件的刷新。
拖拽排序
当LazyForEach在List组件下使用，并且设置了onMove事件，可以使能拖拽排序。拖拽排序离手后，如果数据位置发生变化，则会触发onMove事件，上报数据移动原始索引号和目标索引号。在onMove事件中，需要根据上报的起始索引号和目标索引号修改数据源。onMove中修改数据源不需要调用DataChangeListener中接口通知数据源变化。
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public moveDataWithoutNotify(from: number, to: number): void {\n    let tmp = this.dataArray.splice(from, 1);\n    this.dataArray.splice(to, 0, tmp[0])\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear(): void {\n    for (let i = 0; i < 100; i++) {\n      this.data.pushData(i.toString())\n    }\n  }\n\n  build() {\n    Row() {\n      List() {\n        LazyForEach(this.data, (item: string) => {\n            ListItem() {\n              Text(item.toString())\n                .fontSize(16)\n                .textAlign(TextAlign.Center)\n                .size({height: 100, width: \"100%\"})\n            }.margin(10)\n            .borderRadius(10)\n            .backgroundColor(\"#FFFFFFFF\")\n          }, (item: string) => item)\n          .onMove((from:number, to:number)=>{\n            this.data.moveDataWithoutNotify(from, to)\n          })\n      }\n      .width('100%')\n      .height('100%')\n      .backgroundColor(\"#FFDCDCDC\")\n    }\n  }\n}
图11 LazyForEach拖拽排序效果图
常见使用问题
[h2]渲染结果非预期
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n  \n  public deleteData(index: number): void {\n    this.dataArray.splice(index, 1);\n    this.notifyDataDelete(index);\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n        .onClick(() => {\n          // 点击删除子组件\n          this.data.deleteData(index);\n        })\n      }, (item: string) => item)\n    }.cachedCount(5)\n  }\n}
图12 LazyForEach删除数据非预期
当我们多次点击子组件时，会发现删除的并不一定是我们点击的那个子组件。原因是当我们删除了某一个子组件后，位于该子组件对应的数据项之后的各数据项，其index均应减1，但实际上后续的数据项对应的子组件仍然使用的是最初分配的index，其itemGenerator中的index并没有发生变化，所以删除结果和预期不符。
修复代码如下所示。
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n  \n  public deleteData(index: number): void {\n    this.dataArray.splice(index, 1);\n    this.notifyDataDelete(index);\n  }\n    \n  public reloadData(): void {\n    this.notifyDataReload();\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          Row() {\n            Text(item).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n        .onClick(() => {\n          // 点击删除子组件\n          this.data.deleteData(index);\n          // 重置所有子组件的index索引\n          this.data.reloadData();\n        })\n      }, (item: string, index: number) => item + index.toString())\n    }.cachedCount(5)\n  }\n}
在删除一个数据项后调用reloadData方法，重建后面的数据项，以达到更新index索引的目的。要保证reloadData方法重建数据项，必须保证数据项能生成新的key。这里用了item + index.toString()保证被删除数据项后面的数据项都被重建。如果用item + Date.now().toString()替代，那么所有数据项都生成新的key，导致所有数据项都被重建。这种方法，效果是一样的，只是性能略差。
图13 修复LazyForEach删除数据非预期
[h2]重渲染时图片闪烁
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n    \n  public reloadData(): void {\n    this.notifyDataReload();\n  }\n}\n\nclass StringData {\n  message: string;\n  imgSrc: Resource;\n  constructor(message: string, imgSrc: Resource) {\n      this.message = message;\n      this.imgSrc = imgSrc;\n  }  \n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      // 此处'app.media.img'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。\n      this.data.pushData(new StringData(`Hello ${i}`, $r('app.media.img')));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          Column() {\n            Text(item.message).fontSize(50)\n              .onAppear(() => {\n                console.info(\"appear:\" + item.message)\n              })\n            Image(item.imgSrc)\n              .width(500)\n              .height(200)\n          }.margin({ left: 10, right: 10 })\n        }\n        .onClick(() => {\n          item.message += '00';\n          this.data.reloadData();\n        })\n      }, (item: StringData, index: number) => JSON.stringify(item))\n    }.cachedCount(5)\n  }\n}
图14 LazyForEach仅改变文字但是图片闪烁问题
在我们点击ListItem子组件时，我们只改变了数据项的message属性，但是LazyForEach的刷新机制会导致整个ListItem被重建。由于Image组件是异步刷新，所以视觉上图片会发生闪烁。为了解决这种情况我们应该使用@ObjectLink和@Observed去单独刷新使用了item.message的Text组件。
修复代码如下所示。
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n// @Observed类装饰器 和 @ObjectLink 用于在涉及嵌套对象或数组的场景中进行双向数据同步\n@Observed\nclass StringData {\n  message: string;\n  imgSrc: Resource;\n  constructor(message: string, imgSrc: Resource) {\n      this.message = message;\n      this.imgSrc = imgSrc;\n  }  \n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(new StringData(`Hello ${i}`, $r('app.media.img')));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          ChildComponent({data: item})\n        }\n        .onClick(() => {\n          item.message += '0';\n        })\n      }, (item: StringData, index: number) => index.toString())\n    }.cachedCount(5)\n  }\n}\n\n@Component\nstruct ChildComponent {\n  // 用状态变量来驱动UI刷新，而不是通过Lazyforeach的api来驱动UI刷新\n  @ObjectLink data: StringData\n  build() {\n    Column() {\n      Text(this.data.message).fontSize(50)\n        .onAppear(() => {\n          console.info(\"appear:\" + this.data.message)\n        })\n      Image(this.data.imgSrc)\n        .width(500)\n        .height(200)\n    }.margin({ left: 10, right: 10 })\n  }\n}
图15 修复LazyForEach仅改变文字但是图片闪烁问题
[h2]@ObjectLink属性变化UI未更新
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@Observed\nclass StringData {\n  message: NestedString;\n  constructor(message: NestedString) {\n    this.message = message;\n  }  \n}\n\n@Observed\nclass NestedString {\n  message: string;\n  constructor(message: string) {\n    this.message = message;\n  }  \n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(new StringData(new NestedString(`Hello ${i}`)));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          ChildComponent({data: item})\n        }\n        .onClick(() => {\n          item.message.message += '0';\n        })\n      }, (item: StringData, index: number) => JSON.stringify(item) + index.toString())\n    }.cachedCount(5)\n  }\n}\n\n@Component\nstruct ChildComponent {\n  @ObjectLink data: StringData\n  build() {\n    Row() {\n      Text(this.data.message.message).fontSize(50)\n        .onAppear(() => {\n          console.info(\"appear:\" + this.data.message.message)\n        })\n    }.margin({ left: 10, right: 10 })\n  }\n}
图16 ObjectLink属性变化后UI未更新
@ObjectLink装饰的成员变量仅能监听到其子属性的变化，再深入嵌套的属性便无法观测到了，因此我们只能改变它的子属性去通知对应组件重新渲染，具体请查看@ObjectLink与@Observed的详细使用方法和限制条件。
修复代码如下所示。
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@Observed\nclass StringData {\n  message: NestedString;\n  constructor(message: NestedString) {\n    this.message = message;\n  }  \n}\n\n@Observed\nclass NestedString {\n  message: string;\n  constructor(message: string) {\n    this.message = message;\n  }  \n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 20; i++) {\n      this.data.pushData(new StringData(new NestedString(`Hello ${i}`)));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          ChildComponent({data: item})\n        }\n        .onClick(() => {\n          // @ObjectLink装饰的成员变量仅能监听到其子属性的变化，再深入嵌套的属性便无法观测到\n          item.message = new NestedString(item.message.message + '0');\n        })\n      }, (item: StringData, index: number) => JSON.stringify(item) + index.toString())\n    }.cachedCount(5)\n  }\n}\n\n@Component\nstruct ChildComponent {\n  @ObjectLink data: StringData\n  build() {\n    Row() {\n      Text(this.data.message.message).fontSize(50)\n        .onAppear(() => {\n          console.info(\"appear:\" + this.data.message.message)\n        })\n    }.margin({ left: 10, right: 10 })\n  }\n}
图17 修复ObjectLink属性变化后UI更新
[h2]在List内使用屏幕闪烁
在List的onScrollIndex方法中调用onDataReloaded有产生屏幕闪烁的风险。
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n\n  operateData():void {\n    const totalCount = this.dataArray.length;\n    const batch=5;\n    for (let i = totalCount; i < totalCount + batch; i++) {\n      this.dataArray.push(`Hello ${i}`)\n    }\n    this.notifyDataReload();\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 10; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          Row() {\n            Text(item)\n              .width('100%')\n              .height(80)\n              .backgroundColor(Color.Gray)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n      }, (item: string) => item)\n    }.cachedCount(10)\n    .onScrollIndex((start, end, center) => {\n      if (end === this.data.totalCount() - 1) {\n        console.log('scroll to end')\n        this.data.operateData();\n      }\n    })\n  }\n}
当List下拉到底的时候，屏闪效果如下图
用onDatasetChange代替onDataReloaded，不仅可以修复闪屏的问题，还能提升加载性能。
/** BasicDataSource代码见文档末尾附件: string类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n\n  operateData():void {\n    const totalCount = this.dataArray.length;\n    const batch=5;\n    for (let i = totalCount; i < totalCount + batch; i++) {\n      this.dataArray.push(`Hello ${i}`)\n    }\n    // 替换 notifyDataReload\n    this.notifyDatasetChange([{type:DataOperationType.ADD, index: totalCount-1, count:batch}])\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private moved: number[] = [];\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 10; i++) {\n      this.data.pushData(`Hello ${i}`)\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          Row() {\n            Text(item)\n              .width('100%')\n              .height(80)\n              .backgroundColor(Color.Gray)\n              .onAppear(() => {\n                console.info(\"appear:\" + item)\n              })\n          }.margin({ left: 10, right: 10 })\n        }\n      }, (item: string) => item)\n    }.cachedCount(10)\n    .onScrollIndex((start, end, center) => {\n      if (end === this.data.totalCount() - 1) {\n        console.log('scroll to end')\n        this.data.operateData();\n      }\n    })\n  }\n}
修复后的效果如下图
[h2]组件复用渲染异常
@Reusable与@ComponentV2混用会导致组件渲染异常。
/** BasicDataSource代码见文档末尾附件: StringData类型数组的BasicDataSource代码 **/\n\nclass MyDataSource extends BasicDataSource {\n  private dataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): StringData {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: StringData): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n\nclass StringData {\n  message: string;\n\n  constructor(message: string) {\n    this.message = message;\n  }\n}\n\n@Entry\n@ComponentV2\nstruct MyComponent {\n  data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i <= 30; i++) {\n      this.data.pushData(new StringData('Hello' + i));\n    }\n  }\n\n  build() {\n    List({ space: 3 }) {\n      LazyForEach(this.data, (item: StringData, index: number) => {\n        ListItem() {\n          ChildComponent({ data: item })\n            .onAppear(() => {\n              console.log('onAppear: ' + item.message)\n            })\n        }\n      }, (item: StringData, index: number) => index.toString())\n    }.cachedCount(5)\n  }\n}\n\n@Reusable\n@Component\nstruct ChildComponent {\n  @State data: StringData = new StringData('');\n\n  aboutToAppear(): void {\n    console.log('aboutToAppear: ' + this.data.message);\n  }\n\n  aboutToRecycle(): void {\n    console.log('aboutToRecycle: ' + this.data.message);\n  }\n\n  // 对复用的组件进行数据更新\n  aboutToReuse(params: Record<string, ESObject>): void {\n    this.data = params.data as StringData;\n    console.log('aboutToReuse: ' + this.data.message);\n  }\n\n  build() {\n    Row() {\n      Text(this.data.message).fontSize(50)\n    }\n  }\n}
反例中，在@ComponentV2装饰的组件MyComponent中，LazyForEach列表中使用了@Reusable装饰的组件ChildComponent，导致组件渲染失败，观察日志可以看到组件触发了onAppear，但是没有触发aboutToAppear。
将@ComponentV2修改为@Component可以修复渲染异常。修复后，当滑动事件触发组件节点下树时，对应的可复用组件ChildComponent从组件树上被加入到复用缓存中而不是被销毁，并触发aboutToRecycle事件，打印日志信息。当滑动需要显示新的节点时，会将可复用的组件从复用缓存中重新加入到节点树，并触发aboutToReuse刷新组件数据，并打印日志信息。
附件
[h2]string类型数组的BasicDataSource代码
// BasicDataSource实现了IDataSource接口，用于管理listener监听，以及通知LazyForEach数据更新\nclass BasicDataSource implements IDataSource {\n  private listeners: DataChangeListener[] = [];\n  private originDataArray: string[] = [];\n\n  public totalCount(): number {\n    return 0;\n  }\n\n  public getData(index: number): string {\n    return this.originDataArray[index];\n  }\n\n  // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      console.info('add listener');\n      this.listeners.push(listener);\n    }\n  }\n\n  // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      console.info('remove listener');\n      this.listeners.splice(pos, 1);\n    }\n  }\n\n  // 通知LazyForEach组件需要重载所有子组件\n  notifyDataReload(): void {\n    this.listeners.forEach(listener => {\n      listener.onDataReloaded();\n    })\n  }\n\n  // 通知LazyForEach组件需要在index对应索引处添加子组件\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index);\n      // 写法2：listener.onDatasetChange([{type: DataOperationType.ADD, index: index}]);\n    })\n  }\n\n  // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件\n  notifyDataChange(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataChange(index);\n      // 写法2：listener.onDatasetChange([{type: DataOperationType.CHANGE, index: index}]);\n    })\n  }\n\n  // 通知LazyForEach组件需要在index对应索引处删除该子组件\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataDelete(index);\n      // 写法2：listener.onDatasetChange([{type: DataOperationType.DELETE, index: index}]);\n    })\n  }\n\n  // 通知LazyForEach组件将from索引和to索引处的子组件进行交换\n  notifyDataMove(from: number, to: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataMove(from, to);\n      // 写法2：listener.onDatasetChange(\n      //         [{type: DataOperationType.EXCHANGE, index: {start: from, end: to}}]);\n    })\n  }\n\n  notifyDatasetChange(operations: DataOperation[]): void {\n    this.listeners.forEach(listener => {\n      listener.onDatasetChange(operations);\n    })\n  }\n}
[h2]StringData类型数组的BasicDataSource代码
class BasicDataSource implements IDataSource {\n  private listeners: DataChangeListener[] = [];\n  private originDataArray: StringData[] = [];\n\n  public totalCount(): number {\n    return 0;\n  }\n\n  public getData(index: number): StringData {\n    return this.originDataArray[index];\n  }\n\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      console.info('add listener');\n      this.listeners.push(listener);\n    }\n  }\n\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      console.info('remove listener');\n      this.listeners.splice(pos, 1);\n    }\n  }\n\n  notifyDataReload(): void {\n    this.listeners.forEach(listener => {\n      listener.onDataReloaded();\n    })\n  }\n\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index);\n    })\n  }\n\n  notifyDataChange(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataChange(index);\n    })\n  }\n\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataDelete(index);\n    })\n  }\n\n  notifyDataMove(from: number, to: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataMove(from, to);\n    })\n  }\n\n  notifyDatasetChange(operations: DataOperation[]): void {\n    this.listeners.forEach(listener => {\n      listener.onDatasetChange(operations);\n    })\n  }\n}

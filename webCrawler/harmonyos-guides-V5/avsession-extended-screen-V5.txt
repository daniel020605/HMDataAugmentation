扩展屏投播开发指导
通过本节开发指导，可在系统镜像投屏后，获取投屏设备信息，实现扩展屏模式的投播，实现双屏协作的能力。
运作机制
虚拟扩展屏是在系统投屏启动过程中建立的，依据双端协商的投屏视频流的分辨率创建，支持1080P 及以上分辨率。默认镜像主屏内容，当虚拟扩展屏上有UIAbility绘制时，会投屏该屏内容。 UIAbility A（本机内容）在本端主屏上显示的内容。假定UIAbility A 与 UIAbility B 属于同一应用，UIAbility A可以控制UIAbility B，实现双屏联动。 UIAbility B（投屏内容）在虚拟扩展屏上绘制的内容，考虑到远端投屏用户体验，UIAbility B 应铺满全屏。从安全角度考虑，在启动UIAbility B 时，系统会校验主屏前台UIAbility是否归属同一应用，如果校验失败会禁止其在虚拟扩展屏启动。 
约束与限制
需同时满足以下条件，才能使用该功能：
设备限制本端设备：HarmonyOS NEXT Developer Beta1及以上版本的手机设备。 远端设备：支持Cast+或Miracast标准协议的设备，推荐使用华为智慧屏HarmonyOS2.0及以上版本。 使用限制需要系统发起无线/有线投屏后才可通过接口获取有效的扩展投屏设备。 
接口说明
接口
说明
getAllCastDisplays(): Promise<Array<CastDisplayInfo>>;
获取当前系统中所有支持扩展屏投播的显示设备。
on(type: 'castDisplayChange', callback: Callback<CastDisplayInfo>): void;
设置扩展屏投播显示设备变化的监听事件。
off(type: 'castDisplayChange', callback?: Callback<CastDisplayInfo>): void;
取消扩展屏投播显示设备变化事件监听，关闭后，不再进行该事件回调。
开发步骤
UIAibility A创建AVSession, 获取可用扩展屏投播设备并注册监听。 获取的屏幕信息CastDisplayInfo中包含屏幕ID，屏幕名称、状态以及分辨率宽度、高度基础属性，其中屏幕id 值同于Display的id，如需要获取更详细的信息可参考Display获取设备信息说明。  import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport  { avSession }  from '@kit.AVSessionKit'; // 导入AVSession模块\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport default class AbilityA extends UIAbility{\n  private session: avSession.AVSession | undefined = undefined;\n  private extCastDisplayInfo: avSession.CastDisplayInfo | undefined = undefined;\n  // 注册监听可投屏设备变化事件\n  private onCastDisplayChangedCallback = (castDisplayInfo: avSession.CastDisplayInfo) => {\n    // 新增扩展屏,进入扩展屏显示\n    if (this.extCastDisplayInfo === undefined && castDisplayInfo.state === avSession.CastDisplayState.STATE_ON) {\n      console.info('Succeeded in opening the cast display');\n      this.extCastDisplayInfo = castDisplayInfo;\n      this.startExternalDisplay();\n    } else if (this.extCastDisplayInfo?.id == castDisplayInfo.id) {\n      this.extCastDisplayInfo = castDisplayInfo;\n      // 扩展屏不可用，退出扩展屏显示\n      if (castDisplayInfo.state === avSession.CastDisplayState.STATE_OFF){\n        console.info('Succeeded in closing the cast display');\n        this.stopExternalDisplay();\n        this.extCastDisplayInfo = undefined;\n      }\n    }\n  };\n\n  // 创建AVSession, 获取可用扩展屏投播设备并注册监听\n  initAVSession(context: Context) {\n    avSession.createAVSession(context, 'CastDisplay', 'video').then((session: avSession.AVSession) => {\n      this.session = session;\n      this.session?.on('castDisplayChange', this.onCastDisplayChangedCallback);\n\n      // 获取当前系统可用的扩展屏显示设备\n      session.getAllCastDisplays().then((infoArr: avSession.CastDisplayInfo[]) => {\n        // 有多个扩展屏时可以提供用户选择，也可使用其中任一个作为扩展屏使用。\n        if (infoArr.length > 0) {\n          this.extCastDisplayInfo = infoArr[0];\n          this.startExternalDisplay();\n        }\n      }).catch((err: BusinessError<void>) => {\n        console.error(`Failed to get all CastDisplay. Code: ${err.code}, message: ${err.message}`);\n      });\n    });\n  }\n\n  async onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): Promise<void> {\n    super.onCreate(want, launchParam);\n    this.initAVSession(this.context);\n  }\n\n  onDestroy() {\n    this.stopExternalDisplay();\n    // 去注册监听\n    this.session?.off('castDisplayChange');\n  }\n} 在UIAblityA中构建扩展屏启动和退出能力。// 扩展屏启动UIAbilityB\n  startExternalDisplay() {\n    if (this.extCastDisplayInfo !== undefined &&\n      this.extCastDisplayInfo.id !== 0 &&\n      this.extCastDisplayInfo.state === avSession.CastDisplayState.STATE_ON) {\n      let id = this.extCastDisplayInfo?.id;\n      console.info(`Succeeded in starting ability and the id of display is ${id}`);\n      this.context.startAbility({\n        bundleName: 'com.example.myapplication', // 应用自有包名\n        abilityName: 'AbilityB'\n      }, {\n        displayId: id // 扩展屏ID\n      });\n      AppStorage.setOrCreate('CastDisplayState', 1);\n    }\n  }\n\n  // 停止使用扩展屏\n  stopExternalDisplay() {\n    AppStorage.setOrCreate('CastDisplayState', 0);\n    // 更新本页面显示。\n  } UIAbility B 扩展屏显示内容绘制，需响应退出处理。import { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport default class AbilityB extends UIAbility {\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    windowStage.getMainWindowSync().setWindowLayoutFullScreen(true); // 设置为全屏\n    windowStage.loadContent('pages/CastPage', (err: BusinessError) => {\n      if (err.code) {\n        console.error(`Failed to load the content. Code: ${err.code}, message: ${err.message}`);\n        return;\n      }\n      console.info('Succeeded in loading the content. ');\n    });\n  }\n} import { BusinessError } from '@kit.BasicServicesKit';\nimport { common } from '@kit.AbilityKit';\n\n@Entry\n@Component\nstruct CastPage {\n  // 监测到CastDisplayState变化后，当设备断开时，销毁本页内容。\n  @StorageLink('CastDisplayState') @Watch('onDestroyExtend') private displayState: number = 1;\n\n  private onDestroyExtend() {\n    if (this.displayState === 1) return;\n    let context = (getContext(this) as common.UIAbilityContext)\n    context.terminateSelf().then(() => {\n      console.info('CastPage finished');\n    }).catch((err: BusinessError) => {\n      console.error(`Failed to destroying CastPage. Code: ${err.code}, message: ${err.message}`);\n    });\n  }\n  //...\n} 

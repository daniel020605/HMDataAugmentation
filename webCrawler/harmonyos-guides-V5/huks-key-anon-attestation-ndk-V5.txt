匿名密钥证明(C/C++)
在使用本功能时，需确保网络通畅。
在CMake脚本中链接相关动态库
target_link_libraries(entry PUBLIC libhuks_ndk.z.so)
开发步骤
 确定密钥别名keyAlias，密钥别名最大长度为64字节。 初始化参数集：通过OH_Huks_InitParamSet、OH_Huks_AddParams、OH_Huks_BuildParamSet构造参数集paramSet，参数集中必须包含OH_Huks_KeyAlg，OH_Huks_KeySize，OH_Huks_KeyPurpose属性。 将密钥别名与参数集作为参数传入OH_Huks_AnonAttestKeyItem方法中，即可证明密钥。 
#include \"huks/native_huks_api.h\"\n#include \"huks/native_huks_param.h\"\n#include \"napi/native_api.h\"\n#include <string.h>\nOH_Huks_Result InitParamSet(\n    struct OH_Huks_ParamSet **paramSet,\n    const struct OH_Huks_Param *params,\n    uint32_t paramCount)\n{\n    OH_Huks_Result ret = OH_Huks_InitParamSet(paramSet);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    ret = OH_Huks_AddParams(*paramSet, params, paramCount);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        OH_Huks_FreeParamSet(paramSet);\n        return ret;\n    }\n    ret = OH_Huks_BuildParamSet(paramSet);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        OH_Huks_FreeParamSet(paramSet);\n        return ret;\n    }\n    return ret;\n}\nstatic uint32_t g_size = 4096;\nstatic uint32_t CERT_COUNT = 4;\nvoid FreeCertChain(struct OH_Huks_CertChain *certChain, const uint32_t pos)\n{\n    if (certChain == nullptr || certChain->certs == nullptr) {\n        return;\n    }\n    for (uint32_t j = 0; j < pos; j++) {\n        if (certChain->certs[j].data != nullptr) {\n            free(certChain->certs[j].data);\n            certChain->certs[j].data = nullptr;\n        }\n    }\n    if (certChain->certs != nullptr) {\n        free(certChain->certs);\n        certChain->certs = nullptr;\n    }\n}\nint32_t ConstructDataToCertChain(struct OH_Huks_CertChain *certChain)\n{\n    if (certChain == nullptr) {\n        return OH_HUKS_ERR_CODE_ILLEGAL_ARGUMENT;\n    }\n    certChain->certsCount = CERT_COUNT;\n  \n    certChain->certs = (struct OH_Huks_Blob *)malloc(sizeof(struct OH_Huks_Blob) * (certChain->certsCount));\n    if (certChain->certs == nullptr) {\n        return OH_HUKS_ERR_CODE_INTERNAL_ERROR;\n    }\n    for (uint32_t i = 0; i < certChain->certsCount; i++) {\n        certChain->certs[i].size = g_size;\n        certChain->certs[i].data = (uint8_t *)malloc(certChain->certs[i].size);\n        if (certChain->certs[i].data == nullptr) {\n            FreeCertChain(certChain, i);\n            return OH_HUKS_ERR_CODE_ILLEGAL_ARGUMENT;\n        }\n    }\n    return 0;\n}\nstatic struct OH_Huks_Param g_genAnonAttestParams[] = {\n    { .tag = OH_HUKS_TAG_ALGORITHM, .uint32Param = OH_HUKS_ALG_RSA },\n    { .tag = OH_HUKS_TAG_KEY_SIZE, .uint32Param = OH_HUKS_RSA_KEY_SIZE_2048 },\n    { .tag = OH_HUKS_TAG_PURPOSE, .uint32Param = OH_HUKS_KEY_PURPOSE_VERIFY },\n    { .tag = OH_HUKS_TAG_DIGEST, .uint32Param = OH_HUKS_DIGEST_SHA256 },\n    { .tag = OH_HUKS_TAG_PADDING, .uint32Param = OH_HUKS_PADDING_PSS },\n    { .tag = OH_HUKS_TAG_BLOCK_MODE, .uint32Param = OH_HUKS_MODE_ECB },\n};\n#define CHALLENGE_DATA \"hi_challenge_data\"\nstatic struct OH_Huks_Blob g_challenge = { sizeof(CHALLENGE_DATA), (uint8_t *)CHALLENGE_DATA };\nstatic napi_value AnonAttestKey(napi_env env, napi_callback_info info) \n{\n    /* 1.确定密钥别名 */\n    struct OH_Huks_Blob genAlias = {\n        (uint32_t)strlen(\"test_anon_attest\"),\n        (uint8_t *)\"test_anon_attest\"\n    };\n    static struct OH_Huks_Param g_anonAttestParams[] = {\n        { .tag = OH_HUKS_TAG_ATTESTATION_CHALLENGE, .blob = g_challenge },\n        { .tag = OH_HUKS_TAG_ATTESTATION_ID_ALIAS, .blob = genAlias },\n    };\n    struct OH_Huks_ParamSet *genParamSet = nullptr;\n    struct OH_Huks_ParamSet *anonAttestParamSet = nullptr;\n    OH_Huks_Result ohResult;\n    OH_Huks_Blob certs = { 0 };\n    OH_Huks_CertChain certChain = { &certs, 0 };\n    do {\n        /* 2.初始化密钥参数集 */\n        ohResult = InitParamSet(&genParamSet, g_genAnonAttestParams, sizeof(g_genAnonAttestParams) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = InitParamSet(&anonAttestParamSet, g_anonAttestParams, sizeof(g_anonAttestParams) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        ohResult = OH_Huks_GenerateKeyItem(&genAlias, genParamSet, nullptr);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        \n        (void)ConstructDataToCertChain(&certChain);\n        /* 3.证明密钥 */\n        ohResult = OH_Huks_AnonAttestKeyItem(&genAlias, anonAttestParamSet, &certChain);\n    } while (0);\n    FreeCertChain(&certChain, CERT_COUNT);\n    OH_Huks_FreeParamSet(&genParamSet);\n    OH_Huks_FreeParamSet(&anonAttestParamSet);\n    (void)OH_Huks_DeleteKeyItem(&genAlias, NULL);\n    \n    napi_value ret;\n    napi_create_int32(env, ohResult.errorCode, &ret);\n    return ret;\n}

@Prop装饰器：父子单向同步
@Prop装饰的变量可以和父组件建立单向的同步关系。@Prop装饰的变量是可变的，但是变化不会同步回其父组件。
在阅读@Prop文档前，建议开发者首先了解@State的基本用法。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 11开始，该装饰器支持在元服务中使用。
概述
@Prop装饰的变量和父组件建立单向的同步关系：
 @Prop变量允许在本地修改，但修改后的变化不会同步回父组件。 当数据源更改时，@Prop装饰的变量都会更新，并且会覆盖本地所有更改。因此，数值的同步是父组件到子组件（所属组件)，子组件数值的变化不会同步到父组件。 
限制条件
 @Prop装饰变量时会进行深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型。例如PixelMap等通过NAPI提供的复杂类型，由于有部分实现在Native侧，因此无法在ArkTS侧通过深拷贝获得完整的数据。 
装饰器使用规则说明
Object、class、string、number、boolean、enum类型，以及这些类型的数组。
不支持any，支持undefined和null。
支持Date类型。
API11及以上支持Map、Set类型。
支持ArkUI框架定义的联合类型Length、ResourceStr、ResourceColor类型。
必须指定类型。
@Prop和数据源类型需要相同，有以下三种情况：
- @Prop装饰的变量和@State以及其他装饰器同步时双方的类型必须相同，示例请参考父组件@State到子组件@Prop简单数据类型同步。
- @Prop装饰的变量和@State以及其他装饰器装饰的数组的项同步时 ，@Prop的类型需要和@State装饰的数组的数组项相同，比如@Prop : T和@State : Array<T>，示例请参考父组件@State数组中的项到子组件@Prop简单数据类型同步。
- 当父组件状态变量为Object或者class时，@Prop装饰的变量和父组件状态变量的属性类型相同，示例请参考从父组件中的@State类对象属性到@Prop简单类型的同步。
支持类型的场景请参考观察变化。
API11及以上支持上述支持类型的联合类型，比如string | number, string | undefined 或者 ClassA | null，示例见Prop支持联合类型实例。
注意
当使用undefined和null的时候，建议显式指定类型，遵循TypeScript类型校验，比如：@Prop a : string | undefined = undefined是推荐的，不推荐@Prop a: string = undefined。
变量的传递/访问规则说明
图1 初始化规则图示
观察变化和行为表现
[h2]观察变化
@Prop装饰的数据可以观察到以下变化。
 当装饰的类型是允许的类型，即Object、class、string、number、boolean、enum类型都可以观察到赋值的变化。 // 简单类型\n@Prop count: number;\n// 赋值的变化可以被观察到\nthis.count = 1;\n// 复杂类型\n@Prop title: Model;\n// 可以观察到赋值的变化\nthis.title = new Model('Hi'); 当装饰的类型是Object或者class复杂类型时，可以观察到第一层的属性的变化，属性即Object.keys(observedObject)返回的所有属性。 
class Info {\n  public value: string;\n  constructor(value: string) {\n    this.value = value;\n  }\n}\nclass Model {\n  public value: string;\n  public info: Info;\n  constructor(value: string, info: Info) {\n    this.value = value;\n    this.info = info;\n  }\n}\n\n@Prop title: Model;\n// 可以观察到第一层的变化\nthis.title.value = 'Hi';\n// 观察不到第二层的变化\nthis.title.info.value = 'ArkUI';
对于嵌套场景，如果class是被@Observed装饰的，可以观察到class属性的变化，示例请参考@Prop嵌套场景。
 当装饰的类型是数组的时候，可以观察到数组本身的赋值和数组项的添加、删除和更新。 
// @State装饰的对象为数组时\n@Prop title: string[];\n// 数组自身的赋值可以观察到\nthis.title = ['1'];\n// 数组项的赋值可以观察到\nthis.title[0] = '2';\n// 删除数组项可以观察到\nthis.title.pop();\n// 新增数组项可以观察到\nthis.title.push('3');
对于@State和@Prop的同步场景：
 使用父组件中@State变量的值初始化子组件中的@Prop变量。当@State变量变化时，该变量值也会同步更新至@Prop变量。 @Prop装饰的变量的修改不会影响其数据源@State装饰变量的值。 除了@State，数据源也可以用@Link或@Prop装饰，对@Prop的同步机制是相同的。 数据源和@Prop变量的类型需要相同，@Prop允许简单类型和class类型。 当装饰的对象是Date时，可以观察到Date整体的赋值，同时可通过调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 更新Date的属性。 
@Component\nstruct DateComponent {\n  @Prop selectedDate: Date = new Date('');\n\n  build() {\n    Column() {\n      Button('child update the new date')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate = new Date('2023-09-09');\n        })\n      Button(`child increase the year by 1`).onClick(() => {\n        this.selectedDate.setFullYear(this.selectedDate.getFullYear() + 1);\n      })\n      DatePicker({\n        start: new Date('1970-1-1'),\n        end: new Date('2100-1-1'),\n        selected: this.selectedDate\n      })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct ParentComponent {\n  @State parentSelectedDate: Date = new Date('2021-08-08');\n\n  build() {\n    Column() {\n      Button('parent update the new date')\n        .margin(10)\n        .onClick(() => {\n          this.parentSelectedDate = new Date('2023-07-07');\n        })\n      Button('parent increase the day by 1')\n        .margin(10)\n        .onClick(() => {\n          this.parentSelectedDate.setDate(this.parentSelectedDate.getDate() + 1);\n        })\n      DatePicker({\n        start: new Date('1970-1-1'),\n        end: new Date('2100-1-1'),\n        selected: this.parentSelectedDate\n      })\n\n      DateComponent({ selectedDate: this.parentSelectedDate })\n    }\n\n  }\n}
 当装饰的变量是Map时，可以观察到Map整体的赋值，同时可通过调用Map的接口set, clear, delete 更新Map的值。详见装饰Map类型变量。 当装饰的变量是Set时，可以观察到Set整体的赋值，同时可通过调用Set的接口add, clear, delete 更新Set的值。详见装饰Set类型变量。 
[h2]框架行为
要理解@Prop变量值初始化和更新机制，有必要了解父组件和拥有@Prop变量的子组件初始渲染和更新流程。
 初始渲染：  执行父组件的build()函数将创建子组件的新实例，将数据源传递给子组件。 初始化子组件@Prop装饰的变量。  更新：  子组件@Prop更新时，更新仅停留在当前子组件，不会同步回父组件。 当父组件的数据源更新时，子组件的@Prop装饰的变量将被来自父组件的数据源重置，所有@Prop装饰的本地的修改将被父组件的更新覆盖。  
@Prop装饰的数据更新依赖其所属自定义组件的重新渲染，所以在应用进入后台后，@Prop无法刷新，推荐使用@Link代替。
使用场景
[h2]父组件@State到子组件@Prop简单数据类型同步
以下示例是@State到子组件@Prop简单数据同步，父组件ParentComponent的状态变量countDownStartValue初始化子组件CountDownComponent中@Prop装饰的count，点击“Try again”，count的修改仅保留在CountDownComponent 不会同步给父组件ParentComponent。
ParentComponent的状态变量countDownStartValue的变化将重置CountDownComponent的count。
@Component\nstruct CountDownComponent {\n  @Prop count: number = 0;\n  costOfOneAttempt: number = 1;\n\n  build() {\n    Column() {\n      if (this.count > 0) {\n        Text(`You have ${this.count} Nuggets left`)\n      } else {\n        Text('Game over!')\n      }\n      // @Prop装饰的变量不会同步给父组件\n      Button(`Try again`).onClick(() => {\n        this.count -= this.costOfOneAttempt;\n      })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct ParentComponent {\n  @State countDownStartValue: number = 10;\n\n  build() {\n    Column() {\n      Text(`Grant ${this.countDownStartValue} nuggets to play.`)\n      // 父组件的数据源的修改会同步给子组件\n      Button(`+1 - Nuggets in New Game`).onClick(() => {\n        this.countDownStartValue += 1;\n      })\n      // 父组件的修改会同步给子组件\n      Button(`-1  - Nuggets in New Game`).onClick(() => {\n        this.countDownStartValue -= 1;\n      })\n\n      CountDownComponent({ count: this.countDownStartValue, costOfOneAttempt: 2 })\n    }\n  }\n}
在上面的示例中：
 CountDownComponent子组件首次创建时其@Prop装饰的count变量将从父组件@State装饰的countDownStartValue变量初始化。 按“+1”或“-1”按钮时，父组件的@State装饰的countDownStartValue值会变化，这将触发父组件重新渲染，在父组件重新渲染过程中会刷新使用countDownStartValue状态变量的UI组件并单向同步更新CountDownComponent子组件中的count值。 更新count状态变量值也会触发CountDownComponent的重新渲染，在重新渲染过程中，评估使用count状态变量的if语句条件（this.count > 0），并执行true分支中的使用count状态变量的UI组件相关描述来更新Text组件的UI显示。 当按下子组件CountDownComponent的“Try again”按钮时，其@Prop变量count将被更改，但是count值的更改不会影响父组件的countDownStartValue值。 父组件的countDownStartValue值会变化时，父组件的修改将覆盖掉子组件CountDownComponent中count本地的修改。 
[h2]父组件@State数组项到子组件@Prop简单数据类型同步
父组件中@State如果装饰的数组，其数组项也可以初始化@Prop。以下示例中父组件Index中@State装饰的数组arr，将其数组项初始化子组件Child中@Prop装饰的value。
@Component\nstruct Child {\n  @Prop value: number = 0;\n\n  build() {\n    Text(`${this.value}`)\n      .fontSize(50)\n      .onClick(() => {\n        this.value++;\n      })\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State arr: number[] = [1, 2, 3];\n\n  build() {\n    Row() {\n      Column() {\n        Child({ value: this.arr[0] })\n        Child({ value: this.arr[1] })\n        Child({ value: this.arr[2] })\n\n        Divider().height(5)\n\n        ForEach(this.arr,\n          (item: number) => {\n            Child({ value: item })\n          },\n          (item: number) => item.toString()\n        )\n        Text('replace entire arr')\n          .fontSize(50)\n          .onClick(() => {\n            // 两个数组都包含项“3”。\n            this.arr = this.arr[0] == 1 ? [3, 4, 5] : [1, 2, 3];\n          })\n      }\n    }\n  }\n}
初始渲染创建6个子组件实例，每个@Prop装饰的变量初始化都在本地拷贝了一份数组项。子组件onclick事件处理程序会更改局部变量值。
如果点击界面上的“1”六下，“2”五下、“3”四下，将所有变量的本地取值都变为“7”。
7\n7\n7\n----\n7\n7\n7
单击replace entire arr后，屏幕将显示以下信息。
3\n4\n5\n----\n7\n4\n5
 在子组件Child中做的所有的修改都不会同步回父组件Index组件，所以即使6个组件显示都为7，但在父组件Index中，this.arr保存的值依旧是[1,2,3]。 点击replace entire arr，this.arr[0] == 1成立，将this.arr赋值为[3, 4, 5]。 因为this.arr[0]已更改，Child({value: this.arr[0]})组件将this.arr[0]更新同步到实例@Prop装饰的变量。Child({value: this.arr[1]})和Child({value: this.arr[2]})的情况也类似。 this.arr的更改触发ForEach更新，this.arr更新的前后都有数值为3的数组项：[3, 4, 5] 和[1, 2, 3]。根据diff算法，数组项“3”将被保留，删除“1”和“2”的数组项，添加为“4”和“5”的数组项。这就意味着，数组项“3”的组件不会重新生成，而是将其移动到第一位。所以“3”对应的组件不会更新，此时“3”对应的组件数值为“7”，ForEach最终的渲染结果是“7”，“4”，“5”。 
[h2]从父组件中的@State类对象属性到@Prop简单类型的同步
如果图书馆有一本图书和两位用户，每位用户都可以将图书标记为已读，此标记行为不会影响其它读者用户。从代码角度讲，对@Prop图书对象的本地更改不会同步给图书馆组件中的@State图书对象。
在此示例中，图书类可以使用@Observed装饰器，但不是必须的，只有在嵌套结构时需要此装饰器。这一点我们会在从父组件中的@State数组项到@Prop class类型的同步说明。
class Book {\n  public title: string;\n  public pages: number;\n  public readIt: boolean = false;\n\n  constructor(title: string, pages: number) {\n    this.title = title;\n    this.pages = pages;\n  }\n}\n\n@Component\nstruct ReaderComp {\n  @Prop book: Book = new Book(\"\", 0);\n\n  build() {\n    Row() {\n      Text(this.book.title)\n      Text(`...has${this.book.pages} pages!`)\n      Text(`...${this.book.readIt ? \"I have read\" : 'I have not read it'}`)\n        .onClick(() => this.book.readIt = true)\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Library {\n  @State book: Book = new Book('100 secrets of C++', 765);\n\n  build() {\n    Column() {\n      ReaderComp({ book: this.book })\n      ReaderComp({ book: this.book })\n    }\n  }\n}
[h2]从父组件中的@State数组项到@Prop class类型的同步
在下面的示例中，更改了@State 装饰的allBooks数组中Book对象上的属性，但点击“Mark read for everyone”无反应。这是因为该属性是第二层的嵌套属性，@State装饰器只能观察到第一层属性，不会观察到此属性更改，所以框架不会更新ReaderComp。
let nextId: number = 1;\n\n// @Observed\nclass Book {\n  public id: number;\n  public title: string;\n  public pages: number;\n  public readIt: boolean = false;\n\n  constructor(title: string, pages: number) {\n    this.id = nextId++;\n    this.title = title;\n    this.pages = pages;\n  }\n}\n\n@Component\nstruct ReaderComp {\n  @Prop book: Book = new Book(\"\", 1);\n\n  build() {\n    Row() {\n      Text(` ${this.book ? this.book.title : \"Book is undefined\"}`).fontColor('#e6000000')\n      Text(` has ${this.book ? this.book.pages : \"Book is undefined\"} pages!`).fontColor('#e6000000')\n      Text(` ${this.book ? this.book.readIt ? \"I have read\" : 'I have not read it' : \"Book is undefined\"}`).fontColor('#e6000000')\n        .onClick(() => this.book.readIt = true)\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Library {\n  @State allBooks: Book[] = [new Book(\"C#\", 765), new Book(\"JS\", 652), new Book(\"TS\", 765)];\n\n  build() {\n    Column() {\n      Text('library`s all time favorite')\n        .width(312)\n        .height(40)\n        .backgroundColor('#0d000000')\n        .borderRadius(20)\n        .margin(12)\n        .padding({ left: 20 })\n        .fontColor('#e6000000')\n      ReaderComp({ book: this.allBooks[2] })\n        .backgroundColor('#0d000000')\n        .width(312)\n        .height(40)\n        .padding({ left: 20, top: 10 })\n        .borderRadius(20)\n        .colorBlend('#e6000000')\n      Divider()\n      Text('Books on loan to a reader')\n        .width(312)\n        .height(40)\n        .backgroundColor('#0d000000')\n        .borderRadius(20)\n        .margin(12)\n        .padding({ left: 20 })\n        .fontColor('#e6000000')\n      ForEach(this.allBooks, (book: Book) => {\n        ReaderComp({ book: book })\n          .margin(12)\n          .width(312)\n          .height(40)\n          .padding({ left: 20, top: 10 })\n          .backgroundColor('#0d000000')\n          .borderRadius(20)\n      },\n        (book: Book) => book.id.toString())\n      Button('Add new')\n        .width(312)\n        .height(40)\n        .margin(12)\n        .fontColor('#FFFFFF 90%')\n        .onClick(() => {\n          this.allBooks.push(new Book(\"JA\", 512));\n        })\n      Button('Remove first book')\n        .width(312)\n        .height(40)\n        .margin(12)\n        .fontColor('#FFFFFF 90%')\n        .onClick(() => {\n          if (this.allBooks.length > 0){\n            this.allBooks.shift();\n          } else {\n            console.log(\"length <= 0\");\n          }\n        })\n      Button(\"Mark read for everyone\")\n        .width(312)\n        .height(40)\n        .margin(12)\n        .fontColor('#FFFFFF 90%')\n        .onClick(() => {\n          this.allBooks.forEach((book) => book.readIt = true)\n        })\n    }\n  }\n}
需要使用@Observed装饰class Book，Book的属性将被观察。 需要注意的是，@Prop在子组件装饰的状态变量和父组件的数据源是单向同步关系，即ReaderComp中的@Prop book的修改不会同步给父组件Library。而父组件只会在数值有更新的时候（和上一次状态的对比），才会触发UI的重新渲染。
@Observed\nclass Book {\n  public id: number;\n  public title: string;\n  public pages: number;\n  public readIt: boolean = false;\n\n  constructor(title: string, pages: number) {\n    this.id = nextId++;\n    this.title = title;\n    this.pages = pages;\n  }\n}
@Observed装饰的类的实例会被不透明的代理对象包装，此代理可以检测到包装对象内的所有属性更改。如果发生这种情况，此时，代理通知@Prop，@Prop对象值被更新。
[h2]@Prop本地初始化不和父组件同步
为了支持@Component装饰的组件复用场景，@Prop支持本地初始化，这样可以让@Prop是否与父组件建立同步关系变得可选。当且仅当@Prop有本地初始化时，从父组件向子组件传递@Prop的数据源才是可选的。
下面的示例中，子组件包含两个@Prop变量：
 @Prop customCounter没有本地初始化，所以需要父组件提供数据源去初始化@Prop，并当父组件的数据源变化时，@Prop也将被更新。 @Prop customCounter2有本地初始化，在这种情况下，@Prop依旧允许但非强制父组件同步数据源给@Prop。 
@Component\nstruct MyComponent {\n  @Prop customCounter: number;\n  @Prop customCounter2: number = 5;\n\n  build() {\n    Column() {\n      Row() {\n        Text(`From Main: ${this.customCounter}`).fontColor('#ff6b6565').margin({ left: -110, top: 12 })\n      }\n\n      Row() {\n        Button('Click to change locally !')\n          .width(288)\n          .height(40)\n          .margin({ left: 30, top: 12 })\n          .fontColor('#FFFFFF，90%')\n          .onClick(() => {\n            this.customCounter2++;\n          })\n      }\n\n      Row() {\n        Text(`Custom Local: ${this.customCounter2}`).fontColor('#ff6b6565').margin({ left: -110, top: 12 })\n      }\n    }\n  }\n}\n\n@Entry\n@Component\nstruct MainProgram {\n  @State mainCounter: number = 10;\n\n  build() {\n    Column() {\n      Row() {\n        Column() {\n          // customCounter必须从父组件初始化，因为MyComponent的customCounter成员变量缺少本地初始化；此处，customCounter2可以不做初始化。\n          MyComponent({ customCounter: this.mainCounter })\n          // customCounter2也可以从父组件初始化，父组件初始化的值会覆盖子组件customCounter2的本地初始化的值\n          MyComponent({ customCounter: this.mainCounter, customCounter2: this.mainCounter })\n        }\n      }\n\n      Row() {\n        Column() {\n          Button('Click to change number')\n            .width(288)\n            .height(40)\n            .margin({ left: 30, top: 12 })\n            .fontColor('#FFFFFF，90%')\n            .onClick(() => {\n              this.mainCounter++;\n            })\n        }\n      }\n    }\n  }\n}
[h2]@Prop嵌套场景
在嵌套场景下，每一层都要用@Observed装饰，且每一层都要被@Prop接收，这样才能观察到嵌套场景。
// 以下是嵌套类对象的数据结构。\n@Observed\nclass Son {\n  public title: string;\n\n  constructor(title: string) {\n    this.title = title;\n  }\n}\n\n@Observed\nclass Father {\n  public name: string;\n  public son: Son;\n\n  constructor(name: string, son: Son) {\n    this.name = name;\n    this.son = son;\n  }\n}
以下组件层次结构呈现的是@Prop嵌套场景的数据结构。
@Entry\n@Component\nstruct Person {\n  @State person: Father = new Father('Hello', new Son('world'));\n\n  build() {\n    Column() {\n      Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center }) {\n        Button('change Father name')\n          .width(312)\n          .height(40)\n          .margin(12)\n          .fontColor('#FFFFFF，90%')\n          .onClick(() => {\n            this.person.name = \"Hi\";\n          })\n        Button('change Son title')\n          .width(312)\n          .height(40)\n          .margin(12)\n          .fontColor('#FFFFFF，90%')\n          .onClick(() => {\n            this.person.son.title = \"ArkUI\";\n          })\n        Text(this.person.name)\n          .fontSize(16)\n          .margin(12)\n          .width(312)\n          .height(40)\n          .backgroundColor('#ededed')\n          .borderRadius(20)\n          .textAlign(TextAlign.Center)\n          .fontColor('#e6000000')\n          .onClick(() => {\n            this.person.name = 'Bye';\n          })\n        Text(this.person.son.title)\n          .fontSize(16)\n          .margin(12)\n          .width(312)\n          .height(40)\n          .backgroundColor('#ededed')\n          .borderRadius(20)\n          .textAlign(TextAlign.Center)\n          .onClick(() => {\n            this.person.son.title = \"openHarmony\";\n          })\n        Child({ child: this.person.son })\n      }\n\n    }\n\n  }\n}\n\n\n@Component\nstruct Child {\n  @Prop child: Son = new Son('');\n\n  build() {\n    Column() {\n      Text(this.child.title)\n        .fontSize(16)\n        .margin(12)\n        .width(312)\n        .height(40)\n        .backgroundColor('#ededed')\n        .borderRadius(20)\n        .textAlign(TextAlign.Center)\n        .onClick(() => {\n          this.child.title = 'Bye Bye';\n        })\n    }\n  }\n}
[h2]装饰Map类型变量
从API version 11开始，@Prop支持Map类型。
在下面的示例中，value类型为Map<number, string>，点击Button改变message的值，视图会随之刷新。
@Component\nstruct Child {\n  @Prop value: Map<number, string> = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n\n  build() {\n    Column() {\n      ForEach(Array.from(this.value.entries()), (item: [number, string]) => {\n        Text(`${item[0]}`).fontSize(30)\n        Text(`${item[1]}`).fontSize(30)\n        Divider()\n      })\n      Button('child init map').onClick(() => {\n        this.value = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n      })\n      Button('child set new one').onClick(() => {\n        this.value.set(4, \"d\");\n      })\n      Button('child clear').onClick(() => {\n        this.value.clear();\n      })\n      Button('child replace the first one').onClick(() => {\n        this.value.set(0, \"aa\");\n      })\n      Button('child delete the first one').onClick(() => {\n        this.value.delete(0);\n      })\n    }\n  }\n}\n\n\n@Entry\n@Component\nstruct MapSample {\n  @State message: Map<number, string> = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n\n  build() {\n    Row() {\n      Column() {\n        Child({ value: this.message })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]装饰Set类型变量
从API version 11开始，@Prop支持Set类型。
在下面的示例中，message类型为Set<number>，点击Button改变message的值，视图会随之刷新。
@Component\nstruct Child {\n  @Prop message: Set<number> = new Set([0, 1, 2, 3, 4]);\n\n  build() {\n    Column() {\n      ForEach(Array.from(this.message.entries()), (item: [number, string]) => {\n        Text(`${item[0]}`).fontSize(30)\n        Divider()\n      })\n      Button('init set').onClick(() => {\n        this.message = new Set([0, 1, 2, 3, 4]);\n      })\n      Button('set new one').onClick(() => {\n        this.message.add(5);\n      })\n      Button('clear').onClick(() => {\n        this.message.clear();\n      })\n      Button('delete the first one').onClick(() => {\n        this.message.delete(0);\n      })\n    }\n    .width('100%')\n  }\n}\n\n\n@Entry\n@Component\nstruct SetSample {\n  @State message: Set<number> = new Set([0, 1, 2, 3, 4]);\n\n  build() {\n    Row() {\n      Column() {\n        Child({ message: this.message })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
Prop支持联合类型实例
@Prop支持联合类型和undefined和null，在下面的示例中，animal类型为Animals | undefined，点击父组件Zoo中的Button改变animal的属性或者类型，Child中也会对应刷新。
class Animals {\n  public name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n@Component\nstruct Child {\n  @Prop animal: Animals | undefined;\n\n  build() {\n    Column() {\n      Text(`Child's animal is  ${this.animal instanceof Animals ? this.animal.name : 'undefined'}`).fontSize(30)\n\n      Button('Child change animals into tigers')\n        .onClick(() => {\n          // 赋值为Animals的实例\n          this.animal = new Animals(\"Tiger\");\n        })\n\n      Button('Child change animal to undefined')\n        .onClick(() => {\n          // 赋值为undefined\n          this.animal = undefined;\n        })\n\n    }.width('100%')\n  }\n}\n\n@Entry\n@Component\nstruct Zoo {\n  @State animal: Animals | undefined = new Animals(\"lion\");\n\n  build() {\n    Column() {\n      Text(`Parents' animals are  ${this.animal instanceof Animals ? this.animal.name : 'undefined'}`).fontSize(30)\n\n      Child({animal: this.animal})\n\n      Button('Parents change animals into dogs')\n        .onClick(() => {\n          // 判断animal的类型，做属性的更新\n          if (this.animal instanceof Animals) {\n            this.animal.name = \"Dog\";\n          } else {\n            console.info('num is undefined, cannot change property');\n          }\n        })\n\n      Button('Parents change animal to undefined')\n        .onClick(() => {\n          // 赋值为undefined\n          this.animal = undefined;\n        })\n    }\n  }\n}
常见问题
[h2]@Prop装饰状态变量未初始化错误
@Prop需要被初始化，如果没有进行本地初始化的，则必须通过父组件进行初始化。如果进行了本地初始化，那么是可以不通过父组件进行初始化的。
【反例】
@Observed\nclass Commodity {\n  public price: number = 0;\n\n  constructor(price: number) {\n    this.price = price;\n  }\n}\n\n@Component\nstruct PropChild {\n  @Prop fruit: Commodity; // 未进行本地初始化\n\n  build() {\n    Text(`PropChild fruit ${this.fruit.price}`)\n      .onClick(() => {\n        this.fruit.price += 1;\n      })\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State fruit: Commodity[] = [new Commodity(1)];\n\n  build() {\n    Column() {\n      Text(`Parent fruit ${this.fruit[0].price}`)\n        .onClick(() => {\n          this.fruit[0].price += 1;\n        })\n\n      // @Prop本地没有初始化，也没有从父组件初始化\n      PropChild()\n    }\n  }\n}
【正例】
@Observed\nclass Commodity {\n  public price: number = 0;\n\n  constructor(price: number) {\n    this.price = price;\n  }\n}\n\n@Component\nstruct PropChild1 {\n  @Prop fruit: Commodity; // 未进行本地初始化\n\n  build() {\n    Text(`PropChild1 fruit ${this.fruit.price}`)\n      .onClick(() => {\n        this.fruit.price += 1;\n      })\n  }\n}\n\n@Component\nstruct PropChild2 {\n  @Prop fruit: Commodity = new Commodity(1); // 进行本地初始化\n\n  build() {\n    Text(`PropChild2 fruit ${this.fruit.price}`)\n      .onClick(() => {\n        this.fruit.price += 1;\n      })\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State fruit: Commodity[] = [new Commodity(1)];\n\n  build() {\n    Column() {\n      Text(`Parent fruit ${this.fruit[0].price}`)\n        .onClick(() => {\n          this.fruit[0].price += 1;\n        })\n\n      // @PropChild1本地没有初始化，必须从父组件初始化\n      PropChild1({ fruit: this.fruit[0] })\n      // @PropChild2本地进行了初始化，可以不从父组件初始化，也可以从父组件初始化\n      PropChild2()\n      PropChild2({ fruit: this.fruit[0] })\n    }\n  }\n}
[h2]使用a.b(this.object)形式调用，不会触发UI刷新
在build方法内，当@Prop装饰的变量是Object类型、且通过a.b(this.object)形式调用时，b方法内传入的是this.object的原生对象，修改其属性，无法触发UI刷新。如下例中，通过静态方法Score.changeScore1或者this.changeScore2修改自定义组件Child中的this.score.value时，UI不会刷新。
【反例】
class Score {\n  value: number;\n  constructor(value: number) {\n    this.value = value;\n  }\n\n  static changeScore1(param1:Score) {\n    param1.value += 1;\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State score: Score = new Score(1);\n\n  build() {\n    Column({space:8}) {\n      Text(`The value in Parent is ${this.score.value}.`)\n        .fontSize(30)\n        .fontColor(Color.Red)\n      Child({ score: this.score })\n    }\n    .width('100%')\n    .height('100%')\n  }\n}\n\n@Component\nstruct Child {\n  @Prop score: Score;\n\n  changeScore2(param2:Score) {\n    param2.value += 2;\n  }\n\n  build() {\n    Column({space:8}) {\n      Text(`The value in Child is ${this.score.value}.`)\n        .fontSize(30)\n      Button(`changeScore1`)\n        .onClick(()=>{\n          // 通过静态方法调用，无法触发UI刷新\n          Score.changeScore1(this.score);\n        })\n      Button(`changeScore2`)\n        .onClick(()=>{\n          // 使用this通过自定义组件内部方法调用，无法触发UI刷新\n          this.changeScore2(this.score);\n        })\n    }\n  }\n}
可以通过如下先赋值、再调用新赋值的变量的方式为this.score加上Proxy代理，实现UI刷新。
【正例】
class Score {\n  value: number;\n  constructor(value: number) {\n    this.value = value;\n  }\n\n  static changeScore1(score:Score) {\n    score.value += 1;\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State score: Score = new Score(1);\n\n  build() {\n    Column({space:8}) {\n      Text(`The value in Parent is ${this.score.value}.`)\n        .fontSize(30)\n        .fontColor(Color.Red)\n      Child({ score: this.score })\n    }\n    .width('100%')\n    .height('100%')\n  }\n}\n\n@Component\nstruct Child {\n  @Prop score: Score;\n\n  changeScore2(score:Score) {\n    score.value += 2;\n  }\n\n  build() {\n    Column({space:8}) {\n      Text(`The value in Child is ${this.score.value}.`)\n        .fontSize(30)\n      Button(`changeScore1`)\n        .onClick(()=>{\n          // 通过赋值添加 Proxy 代理\n          let score1 = this.score;\n          Score.changeScore1(score1);\n        })\n      Button(`changeScore2`)\n        .onClick(()=>{\n          // 通过赋值添加 Proxy 代理\n          let score2 = this.score;\n          this.changeScore2(score2);\n        })\n    }\n  }\n}

显式Want跳转切换应用链接跳转适配指导
从API 12开始，已不再推荐三方应用使用指定Ability方式（即显式Want）拉起其他应用，推荐通过指定应用链接的方式来实现。
本章节介绍如何从显式Want跳转切换到应用链接跳转。
启动其他应用的UIAbility
 将待跳转的应用安装到设备，在其对应UIAbility的module.json5配置文件中配置skills标签的entities字段、actions字段和uri字段：  \"actions\"列表中包含\"ohos.want.action.viewData\"。 \"entities\"列表中包含\"entity.system.browsable\"。 \"uris\"列表中包含\"scheme\"为\"https\"且\"domainVerify\"为true的元素。uri的匹配规则参考uri匹配, domainVerify为true代表开启域名检查，通过applinking匹配该应用时需经过配置的域名校验后才能匹配到。applinking域名配置具体可参考AppLinking。  {\n  \"module\": {\n    // ...\n    \"abilities\": [\n      {\n        // ...\n        \"skills\": [\n          {\n            \"entities\": [\n              \"entity.system.browsable\"\n            ],\n            \"actions\": [\n              \"ohos.want.action.viewData\"\n            ],\n            \"uris\": [\n              {\n                \"scheme\": \"https\",\n                \"host\": \"www.example.com\",\n              }\n            ],\n          \"domainVerify\": true\n          }\n        ]\n      }\n    ]\n  }\n} 调用方通过openLink接口执行跳转，在接口入参需要传入转换后的link和配置options, 不再传入bundleName、moduleName和abilityName。系统会根据传入的link匹配到符合skill配置的应用。  当options中的appLinkingOnly为true时，匹配到的应用会经过应用市场域名检查（需联网）返回域名校验检查的唯一匹配项或未匹配结果。 当options中的appLinkingOnly为false时，会优先尝试以AppLinking的方式拉起，如果没有匹配的应用则改为使用DeepLinking的方式拉起目标应用。  import { common } from '@kit.AbilityKit';\nimport OpenLinkOptions from '@ohos.app.ability.OpenLinkOptions';\nimport { BusinessError } from '@ohos.base';\nimport hilog from '@ohos.hilog';\n\nconst TAG: string = '[UIAbilityComponentsOpenLink]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Button('start link', { type: ButtonType.Capsule, stateEffect: true })\n      .width('87%')\n      .height('5%')\n      .margin({ bottom: '12vp' })\n      .onClick(() => {\n        let context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;\n        // 通过startAbility接口显式启动其他UIAbility，推荐使用openLink接口。\n        // let want: Want = {\n        //   bundleName: \"com.test.example\",\n        //   moduleName: \"entry\",\n        //   abilityName: \"EntryAbility\"\n        // };\n        // try {\n        //   context.startAbility(want)\n        //     .then(() => {\n        //       hilog.info(DOMAIN_NUMBER, TAG, 'startAbility success.');\n        //     }).catch((err: BusinessError) => {\n        //       hilog.error(DOMAIN_NUMBER, TAG, `startAbility failed. Code is ${err.code}, message is ${err.message}`);\n        //     })\n        // } catch (paramError) {\n        //   hilog.error(DOMAIN_NUMBER, TAG, `Failed to startAbility. Code is ${paramError.code}, message is ${paramError.message}`);\n        // }\n        let link: string = \"https://www.example.com\";\n        let openLinkOptions: OpenLinkOptions = {\n          // 匹配的abilities选项是否需要通过AppLinking域名校验，匹配到唯一配置过的应用ability\n          appLinkingOnly: true,\n          // 同want中的parameter，用于传递的参数\n          parameters: {demo_key: \"demo_value\"}\n        };\n\n        try {\n          context.openLink(link, openLinkOptions)\n            .then(() => {\n              hilog.info(DOMAIN_NUMBER, TAG, 'open link success.');\n            }).catch((err: BusinessError) => {\n              hilog.error(DOMAIN_NUMBER, TAG, `open link failed. Code is ${err.code}, message is ${err.message}`);\n            })\n        } catch (paramError) {\n          hilog.error(DOMAIN_NUMBER, TAG, `Failed to start link. Code is ${paramError.code}, message is ${paramError.message}`);\n        }\n      })\n  }\n} 
启动其他应用的UIAbility并获取返回结果
 将待跳转的应用安装到设备，在其对应UIAbility的module.json5配置文件中配置skills标签的entities字段、actions字段和uri字段：  \"actions\"列表中包含\"ohos.want.action.viewData\"。 \"entities\"列表中包含\"entity.system.browsable\"。 \"uris\"列表中包含\"scheme\"为\"https\"且\"domainVerify\"为true的元素。uri的匹配规则参考uri匹配, domainVerify为true代表开启域名检查，通过applinking匹配该应用时需经过配置的域名校验后才能匹配到。applinking域名配置具体可参考App Linking。  {\n  \"module\": {\n    // ...\n    \"abilities\": [\n      {\n        // ...\n        \"skills\": [\n          {\n            \"entities\": [\n              \"entity.system.browsable\"\n            ],\n            \"actions\": [\n              \"ohos.want.action.viewData\"\n            ],\n            \"uris\": [\n              {\n                \"scheme\": \"https\",\n                \"host\": \"www.example.com\",\n              }\n            ],\n          \"domainVerify\": true\n          }\n        ]\n      }\n    ]\n  }\n} 调用方通过openLink接口执行跳转，在接口入参需要传入转换后的link和配置options, 不再传入bundleName、moduleName和abilityName。系统会根据传入的link匹配到符合skills配置的应用。AbilityResult回调结果返回通过入参传入回调函数，在启动ability停止自身后返回给调用方的信息。启动成功和失败结果仍通过Promise返回。  当options中的appLinkingOnly为true时，匹配到的应用会经过应用市场域名检查（需联网）返回域名校验检查的唯一匹配项或未匹配结果。 当options中的appLinkingOnly为false时，会优先尝试以AppLinking的方式拉起，如果没有匹配的应用则改为使用DeepLinking的方式拉起目标应用。  import { common } from '@kit.AbilityKit';\nimport OpenLinkOptions from '@ohos.app.ability.OpenLinkOptions';\nimport { BusinessError } from '@ohos.base';\nimport hilog from '@ohos.hilog';\n\nconst TAG: string = '[UIAbilityComponentsOpenLink]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Button('start link', { type: ButtonType.Capsule, stateEffect: true })\n      .width('87%')\n      .height('5%')\n      .margin({ bottom: '12vp' })\n      .onClick(() => {\n        let context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;\n        // 通过startAbility接口显式启动其他UIAbility，推荐使用openLink接口。\n        // let want: Want = {\n        //   bundleName: \"com.test.example\",\n        //   moduleName: \"entry\",\n        //   abilityName: \"EntryAbility\"\n        // };\n        // try {\n        //   context.startAbilityForResult(want)\n        //     .then((data) => {\n        //       hilog.info(DOMAIN_NUMBER, TAG, 'startAbility success. data:' + JSON.stringify(data));\n        //     }).catch((err: BusinessError) => {\n        //       hilog.error(DOMAIN_NUMBER, TAG, `startAbility failed. Code is ${err.code}, message is ${err.message}`);\n        //     })\n        // } catch (paramError) {\n        //   hilog.error(DOMAIN_NUMBER, TAG, `Failed to startAbility. Code is ${paramError.code}, message is ${paramError.message}`);\n        // }\n        let link: string = \"https://www.example.com\";\n        let openLinkOptions: OpenLinkOptions = {\n          // 匹配的abilities选项是否需要通过AppLinking域名校验，匹配到唯一配置过的应用ability\n          appLinkingOnly: true,\n          // 同want中的parameter，用于传递的参数\n          parameters: {demo_key: \"demo_value\"}\n        };\n\n        try {\n          context.openLink(link, openLinkOptions, (err, data) => {\n            // AbilityResult callback回调，仅在被拉起ability死亡时触发\n            hilog.info(DOMAIN_NUMBER, TAG, 'open link success. Callback result:' + JSON.stringify(data));\n          }).then(() => {\n            hilog.info(DOMAIN_NUMBER, TAG, 'open link success.');\n          }).catch((err: BusinessError) => {\n            hilog.error(DOMAIN_NUMBER, TAG, `open link failed. Code is ${err.code}, message is ${err.message}`);\n          })\n        } catch (paramError) {\n          hilog.error(DOMAIN_NUMBER, TAG, `Failed to start link. Code is ${paramError.code}, message is ${paramError.message}`);\n        }\n      })\n  }\n} 

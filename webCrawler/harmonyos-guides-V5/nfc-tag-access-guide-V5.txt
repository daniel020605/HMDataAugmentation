NFC标签读写开发指南
简介
近场通信(Near Field Communication，NFC)是一种短距高频的无线电技术，在13.56MHz频率运行，通信距离一般在10厘米距离内。电子设备可以通过NFC通信技术和NFC标签通信，从标签中读取数据，或写入数据到标签。
NFC标签可能会支持一种或多种通信技术，具体技术如下：
 NfcA (也称为 ISO 14443-3A) NfcB (也称为 ISO 14443-3B) NfcF (也称为 JIS 6319-4) NfcV (也称为 ISO 15693) IsoDep NDEF MifareClassic MifareUltralight 
场景介绍
电子设备通过NFC天线位置触碰NFC标签卡片，完成NFC标签卡片的读取或写入。从使用场景上，可以分成NFC标签前台读写，和NFC标签后台读写。
 NFC标签前台读写 前台读写是指在触碰NFC标签之前，用户先在电子设备上打开特定的应用程序，用户明确想使用所打开的应用程序和NFC标签进行读写操作。用户打开应用程序在前台，并且进入应用的刷卡页面之后，电子设备触碰NFC标签，只会把读取到的卡片分发给前台应用。 NFC标签后台读写 后台读写是指不打开特定的NFC标签应用程序，电子设备触碰发现NFC标签后，根据NFC标签的技术类型，分发给能够处理的应用程序。如果能匹配到多个应用程序，则弹出应用选择器列举出应用列表给用户手动选择。用户选择指定的应用后，自动跳转到应用程序的NFC标签读写卡页面。 标签读写约束条件 不管是前台读写，还是后台读写，电子设备能够发现NFC标签的前提条件是设备必须是亮屏和解锁状态。 
接口说明
NFC标签读写完整的JS API说明以及实例代码请参考：NFC标签接口。
获取不同技术类型标签对象的接口说明如下表，根据不同技术的标签对象来执行NFC标签的读写。
开发步骤
[h2]前台读取标签
 在module.json5文件中声明NFC标签读取的权限，以及声明NFC标签特定的action。 import需要的tag模块和其他相关的模块。 判断设备是否支持NFC能力。 调用tag模块中前台优先的接口，使能前台应用程序优先处理所发现的NFC标签功能。 获取特定技术类型的NFC标签对象。 执行读写接口完成标签数据的读取或写入数据到标签。 退出应用程序NFC标签页面时，调用tag模块退出前台优先功能。 
    \"abilities\": [\n      {\n        \"name\": \"EntryAbility\",\n        \"srcEntry\": \"./ets/entryability/EntryAbility.ts\",\n        \"description\": \"$string:EntryAbility_desc\",\n        \"icon\": \"$media:icon\",\n        \"label\": \"$string:EntryAbility_label\",\n        \"startWindowIcon\": \"$media:icon\",\n        \"startWindowBackground\": \"$color:start_window_background\",\n        \"exported\": true,\n        \"skills\": [\n          {\n            \"entities\": [\n              \"entity.system.home\"\n            ],\n            \"actions\": [\n              \"action.system.home\",\n\n              // Add the nfc tag action to filter out for this application.\n              \"ohos.nfc.tag.action.TAG_FOUND\"\n            ]\n          }\n        ]\n      }\n    ],\n    \"requestPermissions\": [\n      {\n        // Add the permission for nfc tag operations.\n        \"name\": \"ohos.permission.NFC_TAG\",\n        \"reason\": \"$string:app_name\",\n      }\n    ]
import { tag } from '@kit.ConnectivityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { AbilityConstant, UIAbility, Want, bundleManager } from '@kit.AbilityKit';\n\nlet nfcTagElementName: bundleManager.ElementName;\nlet foregroundRegister: boolean;\n\nasync function readerModeCb(error : BusinessError, tagInfo : tag.TagInfo) {\n  if (!error) {\n    // 获取特定技术类型的NFC标签对象\n    if (tagInfo == null || tagInfo == undefined) {\n      hilog.error(0x0000, 'testTag', 'readerModeCb tagInfo is invalid');\n      return;\n    }\n    if (tagInfo.uid == null || tagInfo.uid == undefined) {\n      hilog.error(0x0000, 'testTag', 'readerModeCb uid is invalid');\n      return;\n    }\n    if (tagInfo.technology == null || tagInfo.technology == undefined || tagInfo.technology.length == 0) {\n      hilog.error(0x0000, 'testTag', 'readerModeCb technology is invalid');\n      return;\n    }\n\n    // 执行读写接口完成标签数据的读取或写入数据到标签\n    // use the IsoDep technology to access this nfc tag.\n    let isoDep : tag.IsoDepTag | null = null;\n    for (let i = 0; i < tagInfo.technology.length; i++) {\n      if (tagInfo.technology[i] == tag.ISO_DEP) {\n        try {\n          isoDep = tag.getIsoDep(tagInfo);\n        } catch (error) {\n          hilog.error(0x0000, 'testTag', 'readerModeCb getIsoDep error = %{public}s', JSON.stringify(error));\n          return;\n        }\n      }\n      // use other technology to access this nfc tag if necessary.\n    }\n    if (isoDep == undefined) {\n      hilog.error(0x0000, 'testTag', 'readerModeCb getIsoDep is invalid');\n      return;\n    }\n\n    // connect to this nfc tag using IsoDep technology.\n    try {\n        isoDep.connect(); \n    } catch (error) {\n        hilog.error(0x0000, 'testTag', 'readerModeCb isoDep.connect() error = %{public}s', JSON.stringify(error));\n        return;\n    }\n    if (!isoDep.isConnected()) {\n      hilog.error(0x0000, 'testTag', 'readerModeCb isoDep.isConnected() false.');\n      return;\n    }\n\n    // transmit data to the connected tag.\n    let cmdData = [0x01, 0x02, 0x03, 0x04]; // please change the raw data to be correct.\n    try {\n      isoDep.transmit(cmdData).then((response : number[]) => {\n        hilog.info(0x0000, 'testTag', 'readerModeCb isoDep.transmit() response = %{public}s.', JSON.stringify(response));\n      }).catch((err : BusinessError)=> {\n        hilog.error(0x0000, 'testTag', 'readerModeCb isoDep.transmit() err = %{public}s.', JSON.stringify(err));\n        return;\n      });\n    } catch (businessError) {\n      hilog.error(0x0000, 'testTag', 'readerModeCb isoDep.transmit() businessError = %{public}s.', JSON.stringify(businessError));\n      return;\n    }\n  } else {\n    hilog.info(0x0000, 'testTag', 'readerModeCb readerModeCb error %{public}s', JSON.stringify(error));\n  }\n}\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\n\n    // 判断设备是否支持NFC能力\n    if (!canIUse(\"SystemCapability.Communication.NFC.Core\")) {\n      hilog.error(0x0000, 'testTag', 'nfc unavailable.');\n      return;\n    }\n\n    nfcTagElementName = {\n      bundleName: want.bundleName ?? '',\n      abilityName: want.abilityName ?? '',\n      moduleName: want.moduleName,\n    }\n  }\n\n  onForeground() {\n    // Ability has brought to foreground\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');\n    if (nfcTagElementName != undefined) {\n      // 调用tag模块中前台优先的接口，使能前台应用程序优先处理所发现的NFC标签功能\n      let techList : number[] = [tag.NFC_A, tag.NFC_B, tag.NFC_F, tag.NFC_V];\n      try {\n        tag.on('readerMode', nfcTagElementName, techList, readerModeCb);\n        foregroundRegister = true;\n      } catch (error) {\n        hilog.error(0x0000, 'testTag', 'on readerMode error = %{public}s', JSON.stringify(error));\n      }\n    }\n  }\n\n  onBackground() {\n    // Ability has back to background\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');\n    // 退出应用程序NFC标签页面时，调用tag模块退出前台优先功能\n    if (foregroundRegister) {\n      foregroundRegister = false;\n      try {\n        tag.off('readerMode', nfcTagElementName);\n      } catch (error) {\n        hilog.error(0x0000, 'testTag', 'off readerMode error = %{public}s', JSON.stringify(error));\n      }\n    }\n  }\n}
[h2]后台读取标签
 在module.json5文件中声明NFC标签读取的权限，声明NFC标签特定的action，以及声明本应用程序的能够处理的NFC标签技术类型。 import需要的tag模块和其他相关的模块。 获取特定技术类型的NFC标签对象。 执行读写接口完成标签数据的读取或写入数据到标签。 
    \"abilities\": [\n      {\n        \"name\": \"EntryAbility\",\n        \"srcEntry\": \"./ets/entryability/EntryAbility.ts\",\n        \"description\": \"$string:EntryAbility_desc\",\n        \"icon\": \"$media:icon\",\n        \"label\": \"$string:EntryAbility_label\",\n        \"startWindowIcon\": \"$media:icon\",\n        \"startWindowBackground\": \"$color:start_window_background\",\n        \"exported\": true,\n        \"skills\": [\n          {\n            \"entities\": [\n              \"entity.system.home\"\n            ],\n            \"actions\": [\n              \"action.system.home\",\n\n              // Add the nfc tag action to filter out for this application.\n              \"ohos.nfc.tag.action.TAG_FOUND\"\n            ],\n            \"uris\": [\n              {\n                  \"type\":\"tag-tech/NfcA\"\n              },\n              {\n                  \"type\":\"tag-tech/IsoDep\"\n              }\n              // Add other technologies if necessary,\n              // such as: NfcB/NfcF/NfcV/Ndef/MifareClassic/MifareUL/NdefFormatable\n            ]\n          }\n        ]\n      }\n    ],\n    \"requestPermissions\": [\n      {\n        // Add the permission for nfc tag operations.\n        \"name\": \"ohos.permission.NFC_TAG\",\n        \"reason\": \"$string:app_name\",\n      }\n    ]
import { tag } from '@kit.ConnectivityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\n\n    // 获取特定技术类型的NFC标签对象\n    let tagInfo : tag.TagInfo;\n    try {\n      tagInfo = tag.getTagInfo(want);\n    } catch (error) {\n      hilog.error(0x0000, 'testTag', 'getTagInfo error = %{public}s', JSON.stringify(error));\n      return;\n    }\n\n    if (tagInfo == null || tagInfo == undefined) {\n      hilog.error(0x0000, 'testTag', 'tagInfo is invalid');\n      return;\n    }\n    if (tagInfo.uid == null || tagInfo.uid == undefined) {\n      hilog.error(0x0000, 'testTag', 'uid is invalid');\n      return;\n    }\n    if (tagInfo.technology == null || tagInfo.technology == undefined || tagInfo.technology.length == 0) {\n      hilog.error(0x0000, 'testTag', 'technology is invalid');\n      return;\n    }\n\n    // 执行读写接口完成标签数据的读取或写入数据到标签\n    // use the IsoDep technology to access this nfc tag.\n    let isoDep : tag.IsoDepTag | null = null;\n    for (let i = 0; i < tagInfo.technology.length; i++) {\n      if (tagInfo.technology[i] == tag.ISO_DEP) {\n        try {\n          isoDep = tag.getIsoDep(tagInfo);\n        } catch (error) {\n          hilog.error(0x0000, 'testTag', 'getIsoDep error = %{public}s', JSON.stringify(error));\n          return;\n        }\n      }\n      // use other technology to access this nfc tag if necessary.\n    }\n    if (isoDep == undefined) {\n      hilog.error(0x0000, 'testTag', 'getIsoDep is invalid');\n      return;\n    }\n\n    // connect to this nfc tag using IsoDep technology.\n    try {\n        isoDep.connect(); \n    } catch (error) {\n        hilog.error(0x0000, 'testTag', 'isoDep.connect() error = %{public}s', JSON.stringify(error));\n        return;\n    }\n    if (!isoDep.isConnected()) {\n      hilog.error(0x0000, 'testTag', 'isoDep.isConnected() false.');\n      return;\n    }\n\n    // transmit data to the connected tag.\n    let cmdData = [0x01, 0x02, 0x03, 0x04]; // please change the raw data to be correct.\n    try {\n      isoDep.transmit(cmdData).then((response : number[]) => {\n        hilog.info(0x0000, 'testTag', 'isoDep.transmit() response = %{public}s.', JSON.stringify(response));\n      }).catch((err : BusinessError)=> {\n        hilog.error(0x0000, 'testTag', 'isoDep.transmit() err = %{public}s.', JSON.stringify(err));\n        return;\n      });\n    } catch (businessError) {\n      hilog.error(0x0000, 'testTag', 'isoDep.transmit() businessError = %{public}s.', JSON.stringify(businessError));\n      return;\n    }\n  }\n}

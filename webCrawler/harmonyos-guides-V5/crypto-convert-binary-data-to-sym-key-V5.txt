指定二进制数据转换对称密钥(ArkTS)
以3DES和HMAC为例，根据指定的对称密钥二进制数据，生成密钥（SymKey），即将外部或存储的二进制数据转换为算法库的密钥对象，该对象可用于后续的加解密等操作。
指定二进制数据转换3DES密钥
对应的算法规格请查看对称密钥生成和转换规格：3DES。
 获取3DES二进制密钥数据，封装成DataBlob对象。 调用cryptoFramework.createSymKeyGenerator，指定字符串参数'3DES192'，创建密钥算法为3DES、密钥长度为192位的对称密钥生成器（SymKeyGenerator）。 调用SymKeyGenerator.convertKey，根据指定的对称密钥二进制数据，生成对称密钥对象（SymKey）。 调用SymKey.getEncoded，获取密钥对象的二进制数据。 
 以使用callback方式生成3DES密钥为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nfunction genKeyMaterialBlob(): cryptoFramework.DataBlob {\n  let arr = [\n    0xba, 0x3d, 0xc2, 0x71, 0x21, 0x1e, 0x30, 0x56,\n    0xad, 0x47, 0xfc, 0x5a, 0x46, 0x39, 0xee, 0x7c,\n    0xba, 0x3b, 0xc2, 0x71, 0xab, 0xa0, 0x30, 0x72]; // 密钥长度为192位，即24字节。\n  let keyMaterial = new Uint8Array(arr);\n  return { data: keyMaterial };\n}\n\nfunction testConvertSymKey() {\n  // 创建SymKeyGenerator实例\n  let symKeyGenerator = cryptoFramework.createSymKeyGenerator('3DES192');\n  // 根据指定的数据生成对称密钥\n  let keyMaterialBlob = genKeyMaterialBlob();\n  try {\n    symKeyGenerator.convertKey(keyMaterialBlob, (error, key) => {\n      if (error) { // 如果业务逻辑执行失败，则callback的第一个参数返回错误信息，即异步抛出异常\n        let e: BusinessError = error as BusinessError;\n        console.error(`convertKey error, ${e.code}, ${e.message}`);\n        return;\n      }\n      console.info('key algName：' + key.algName);\n      console.info('key format：' + key.format);\n      let encodedKey = key.getEncoded(); // 获取对称密钥的二进制数据，并以字节数组形式输出。长度为24字节\n      console.info('key getEncoded hex: ' + encodedKey.data);\n    })\n  } catch (error) { // 参数检查发现错误立即抛出异常\n    let e: BusinessError = error as BusinessError;\n    console.error(`convertKey failed, ${e.code}, ${e.message}`);\n  }\n} 同步方法（调用方法convertKeySync）： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\n\nfunction genKeyMaterialBlob(): cryptoFramework.DataBlob {\n  let arr = [\n    0xba, 0x3d, 0xc2, 0x71, 0x21, 0x1e, 0x30, 0x56,\n    0xad, 0x47, 0xfc, 0x5a, 0x46, 0x39, 0xee, 0x7c,\n    0xba, 0x3b, 0xc2, 0x71, 0xab, 0xa0, 0x30, 0x72]; // 密钥长度为192位，即24字节。\n  let keyMaterial = new Uint8Array(arr);\n  return { data: keyMaterial };\n}\n\nfunction testConvertSymKey() {\n  // 创建SymKeyGenerator实例\n  let symKeyGenerator = cryptoFramework.createSymKeyGenerator('3DES192');\n  // 根据指定的数据生成对称密钥\n  let keyMaterialBlob = genKeyMaterialBlob();\n  let key = symKeyGenerator.convertKeySync(keyMaterialBlob);\n  let encodedKey = key.getEncoded(); // 获取对称密钥的二进制数据，并以字节数组形式输出。长度为24字节\n  console.info('key getEncoded hex' + encodedKey.data);\n} 
指定二进制数据转换HMAC密钥
对应的算法规格请查看对称密钥生成和转换规格：HMAC。
 获取HMAC二进制密钥，封装成DataBlob对象。 调用cryptoFramework.createSymKeyGenerator，指定字符串参数'HMAC'，创建密钥算法为HMAC、密钥长度为[1, 32768]位的对称密钥生成器（SymKeyGenerator）。 调用SymKeyGenerator.convertKey，根据指定的对称密钥二进制数据，生成对称密钥对象（SymKey）。 调用SymKey.getEncoded，获取密钥对象的二进制数据。 
 以使用await方式生成HMAC密钥为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nasync function testConvertHmacKey() {\n  // 对称密钥长度为64字节，512比特\n  let keyMessage = '12345678abcdefgh12345678abcdefgh12345678abcdefgh12345678abcdefgh';\n  let keyBlob: cryptoFramework.DataBlob = {\n    data : new Uint8Array(buffer.from(keyMessage, 'utf-8').buffer)\n  }\n  let symKeyGenerator = cryptoFramework.createSymKeyGenerator('HMAC');\n  let key = await symKeyGenerator.convertKey(keyBlob);\n  let encodedKey = key.getEncoded();\n  console.info('key encoded data：' + encodedKey.data);\n} 同步方法（调用方法convertKeySync）： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nfunction testConvertKeySync() {\n  // 对称密钥长度为64字节，512比特\n  let keyMessage = '12345678abcdefgh12345678abcdefgh12345678abcdefgh12345678abcdefgh';\n  let keyBlob: cryptoFramework.DataBlob = {\n    data : new Uint8Array(buffer.from(keyMessage, 'utf-8').buffer)\n  }\n  let symKeyGenerator = cryptoFramework.createSymKeyGenerator('HMAC');\n  let key = symKeyGenerator.convertKeySync(keyBlob);\n  let encodedKey = key.getEncoded();\n  console.info('key encoded data：' + encodedKey.data);\n} 

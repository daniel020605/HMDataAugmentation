使用RSA密钥对（PKCS1模式）签名及签名恢复(ArkTS)
对应的算法规格请查看签名验签算法规格：RSA。
签名
 调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成密钥算法为RSA、密钥长度为1024位、素数个数为2的非对称密钥对象（KeyPair），包括公钥（PubKey）和私钥（PriKey）。 如何生成RSA非对称密钥，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。 调用cryptoFramework.createSign，指定字符串参数'RSA1024|PKCS1|SHA256|SignOnly'，创建非对称密钥类型为RSA1024、填充模式为PKCS1、摘要算法为SHA256的Sign实例，用于完成仅签名操作。 调用Sign.init，使用私钥（PriKey）初始化Sign实例。 调用Sign.sign，生成数据签名。 
验签
 调用cryptoFramework.createVerify，指定字符串参数'RSA1024|PKCS1|SHA256|Recover'，与签名的Sign实例保持一致。创建Verify实例，用于完成验签操作。 调用Verify.init，使用公钥（PubKey）初始化Verify实例。 调用Verify.recover，对数据进行签名恢复。 
 异步方法示例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n// 完整的明文被拆分为input1和input2\nlet input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(\"This is Sign test plan1\", 'utf-8').buffer) };\nasync function signMessagePromise(priKey: cryptoFramework.PriKey) {\n  let signAlg = \"RSA1024|PKCS1|NoHash|OnlySign\";\n  let signer = cryptoFramework.createSign(signAlg);\n  await signer.init(priKey);\n  let signData = await signer.sign(input1);\n  return signData;\n}\nasync function verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {\n  let verifyAlg = \"RSA1024|PKCS1|NoHash|Recover\";\n  let verifier = cryptoFramework.createVerify(verifyAlg);\n  await verifier.init(pubKey);\n  let rawSignData = await verifier.recover(signMessageBlob);\n  return rawSignData;\n}\nasync function main() {\n  let keyGenAlg = \"RSA1024\";\n  let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);\n  let keyPair = await generator.generateKeyPair();\n  let signData = await signMessagePromise(keyPair.priKey);\n  let rawSignData = await verifyMessagePromise(signData, keyPair.pubKey);\n  if (rawSignData != null) {\n    console.info('recover result: ' + rawSignData.data);\n  } else {\n    console.error(\"get verify recover result fail!\");\n  }\n} 同步方法示例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n// 完整的明文被拆分为input1和input2\nlet input1: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(\"This is Sign test plan1\", 'utf-8').buffer) };\nfunction signMessagePromise(priKey: cryptoFramework.PriKey) {\n  let signAlg = \"RSA1024|PKCS1|NoHash|OnlySign\";\n  let signer = cryptoFramework.createSign(signAlg);\n  signer.initSync(priKey);\n  let signData = signer.signSync(input1);\n  return signData;\n}\nfunction verifyMessagePromise(signMessageBlob: cryptoFramework.DataBlob, pubKey: cryptoFramework.PubKey) {\n  let verifyAlg = \"RSA1024|PKCS1|NoHash|Recover\";\n  let verifier = cryptoFramework.createVerify(verifyAlg);\n  verifier.initSync(pubKey);\n  let rawSignData = verifier.recoverSync(signMessageBlob);\n  return rawSignData;\n}\nfunction main() {\n  let keyGenAlg = \"RSA1024\";\n  let generator = cryptoFramework.createAsyKeyGenerator(keyGenAlg);\n  let keyPair = generator.generateKeyPairSync();\n  let signData = signMessagePromise(keyPair.priKey);\n  let rawSignData = verifyMessagePromise(signData, keyPair.pubKey);\n  if (rawSignData != null) {\n    console.info('recover result: ' + rawSignData.data);\n  } else {\n    console.error(\"get verify recover result fail!\");\n  }\n} 

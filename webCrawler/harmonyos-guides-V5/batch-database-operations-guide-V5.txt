批量数据写数据库场景
使用TaskPool进行频繁数据库操作
对于需要频繁数据库操作的场景，由于读写数据库存在耗时，因此推荐在子线程中操作，避免阻塞UI线程。
通过ArkTS提供的TaskPool能力，可以将数据库操作任务移到子线程中，实现如下。
创建多个子任务，支持数据库创建、插入、查询、清除等操作。 UI主线程调用子任务完成增删改查等数据库操作。 
// Index.ets\nimport { relationalStore, ValuesBucket } from '@kit.ArkData';\nimport { taskpool } from '@kit.ArkTS';\n\n@Concurrent\nasync function create(context: Context) {\n  const CONFIG: relationalStore.StoreConfig = {\n    name: \"Store.db\",\n    securityLevel: relationalStore.SecurityLevel.S1,\n  };\n\n  // 默认数据库文件路径为 context.databaseDir + rdb + StoreConfig.name\n  let store: relationalStore.RdbStore = await relationalStore.getRdbStore(context, CONFIG);\n  console.info(`Create Store.db successfully!`);\n\n  // 创建表\n  const CREATE_TABLE_SQL = \"CREATE TABLE IF NOT EXISTS test (\" +\n    \"id INTEGER PRIMARY KEY AUTOINCREMENT, \" +\n    \"name TEXT NOT NULL, \" +\n    \"age INTEGER, \" +\n    \"salary REAL, \" +\n    \"blobType BLOB)\";\n  await store.executeSql(CREATE_TABLE_SQL);\n  console.info(`Create table test successfully!`);\n}\n\n@Concurrent\nasync function insert(context: Context, valueBucketArray: Array<relationalStore.ValuesBucket>) {\n  const CONFIG: relationalStore.StoreConfig = {\n    name: \"Store.db\",\n    securityLevel: relationalStore.SecurityLevel.S1,\n  };\n\n  // 默认数据库文件路径为 context.databaseDir + rdb + StoreConfig.name\n  let store: relationalStore.RdbStore = await relationalStore.getRdbStore(context, CONFIG);\n  console.info(`Create Store.db successfully!`);\n\n  // 数据插入\n  await store.batchInsert(\"test\", valueBucketArray as Object as Array<relationalStore.ValuesBucket>);\n}\n\n@Concurrent\nasync function query(context: Context): Promise<Array<relationalStore.ValuesBucket>> {\n  const CONFIG: relationalStore.StoreConfig = {\n    name: \"Store.db\",\n    securityLevel: relationalStore.SecurityLevel.S1,\n  };\n\n  // 默认数据库文件路径为 context.databaseDir + rdb + StoreConfig.name\n  let store: relationalStore.RdbStore = await relationalStore.getRdbStore(context, CONFIG);\n  console.info(`Create Store.db successfully!`);\n\n  // 获取结果集\n  let predicates: relationalStore.RdbPredicates = new relationalStore.RdbPredicates(\"test\");\n  let resultSet = await store.query(predicates);  // 查询所有数据\n  console.info(`Query data successfully! row count:${resultSet.rowCount}`);\n  let index = 0;\n  let result = new Array<relationalStore.ValuesBucket>(resultSet.rowCount)\n  resultSet.goToFirstRow()\n  do {\n    result[index++] = resultSet.getRow()\n  } while (resultSet.goToNextRow());\n  resultSet.close();\n  return result\n}\n\n@Concurrent\nasync function clear(context: Context) {\n  const CONFIG: relationalStore.StoreConfig = {\n    name: \"Store.db\",\n    securityLevel: relationalStore.SecurityLevel.S1,\n  };\n\n  // 默认数据库文件路径为 context.databaseDir + rdb + StoreConfig.name\n  await relationalStore.deleteRdbStore(context, CONFIG);\n  console.info(`Delete Store.db successfully!`);\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    RelativeContainer() {\n      Text(this.message)\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .alignRules({\n          center: { anchor: '__container__', align: VerticalAlign.Center },\n          middle: { anchor: '__container__', align: HorizontalAlign.Center }\n        })\n        .onClick(async () => {\n          let context = getContext(this);\n\n          // 数据准备\n          const count = 5\n          let valueBucketArray = new Array<relationalStore.ValuesBucket>(count);\n          for (let i = 0; i < count; i++) {\n            let v : relationalStore.ValuesBucket = {\n              id: i,\n              name: \"zhangsan\" + i,\n              age: 20,\n              salary: 5000 + 50 * i\n            };\n            valueBucketArray[i] = v;\n          }\n          await taskpool.execute(create, context)\n          await taskpool.execute(insert, context, valueBucketArray)\n          let index = 0\n          let ret = await taskpool.execute(query, context) as Array<relationalStore.ValuesBucket>\n          for (let v of ret) {\n            console.info(`Row[${index}].id = ${v.id}`)\n            console.info(`Row[${index}].name = ${v.name}`)\n            console.info(`Row[${index}].age = ${v.age}`)\n            console.info(`Row[${index}].salary = ${v.salary}`)\n            index++\n          }\n          await taskpool.execute(clear, context)\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
使用Sendable进行大容量数据库操作
由于数据库数据跨线程传递存在耗时，当数据量较大时，仍然会占用UI主线程，推荐采用Sendable封装数据库数据，降低跨线程开销。
定义数据库中的数据格式，可采用Sendable，减少跨线程耗时。 // SharedValuesBucket.ets\nexport interface IValueBucket {\n  id: number\n  name: string\n  age: number\n  salary: number\n}\n\n@Sendable\nexport class SharedValuesBucket implements IValueBucket {\n  id: number = 0\n  name: string = \"\"\n  age: number = 0\n  salary: number = 0\n\n  constructor(v: IValueBucket) {\n    this.id = v.id;\n    this.name = v.name;\n    this.age = v.age;\n    this.salary = v.salary\n  }\n} UI主线程发起，在子线程进行数据的增删改查等操作。 // Index.ets\nimport { relationalStore, ValuesBucket } from '@kit.ArkData';\nimport { collections, taskpool } from '@kit.ArkTS';\nimport { IValueBucket, SharedValuesBucket } from './SharedValuesBucket';\n\n@Concurrent\nasync function create(context: Context) {\n  const CONFIG: relationalStore.StoreConfig = {\n    name: \"Store.db\",\n    securityLevel: relationalStore.SecurityLevel.S1,\n  };\n\n  // 默认数据库文件路径为 context.databaseDir + rdb + StoreConfig.name\n  let store: relationalStore.RdbStore = await relationalStore.getRdbStore(context, CONFIG);\n  console.info(`Create Store.db successfully!`);\n\n  // 创建表\n  const CREATE_TABLE_SQL = \"CREATE TABLE IF NOT EXISTS test (\" +\n    \"id INTEGER PRIMARY KEY AUTOINCREMENT, \" +\n    \"name TEXT NOT NULL, \" +\n    \"age INTEGER, \" +\n    \"salary REAL, \" +\n    \"blobType BLOB)\";\n  await store.executeSql(CREATE_TABLE_SQL);\n  console.info(`Create table test successfully!`);\n}\n\n@Concurrent\nasync function insert(context: Context, valueBucketArray: collections.Array<SharedValuesBucket | undefined>) {\n  const CONFIG: relationalStore.StoreConfig = {\n    name: \"Store.db\",\n    securityLevel: relationalStore.SecurityLevel.S1,\n  };\n\n  // 默认数据库文件路径为 context.databaseDir + rdb + StoreConfig.name\n  let store: relationalStore.RdbStore = await relationalStore.getRdbStore(context, CONFIG);\n  console.info(`Create Store.db successfully!`);\n\n  // 数据插入\n  await store.batchInsert(\"test\", valueBucketArray as Object as Array<ValuesBucket>);\n}\n\n@Concurrent\nasync function query(context: Context): Promise<collections.Array<SharedValuesBucket | undefined>> {\n  const CONFIG: relationalStore.StoreConfig = {\n    name: \"Store.db\",\n    securityLevel: relationalStore.SecurityLevel.S1,\n  };\n\n  // 默认数据库文件路径为 context.databaseDir + rdb + StoreConfig.name\n  let store: relationalStore.RdbStore = await relationalStore.getRdbStore(context, CONFIG);\n  console.info(`Create Store.db successfully!`);\n\n  // 获取结果集\n  let predicates: relationalStore.RdbPredicates = new relationalStore.RdbPredicates(\"test\");\n  let resultSet = await store.query(predicates); // 查询所有数据\n  console.info(`Query data successfully! row count:${resultSet.rowCount}`);\n  let index = 0;\n  let result = collections.Array.create<SharedValuesBucket | undefined>(resultSet.rowCount, undefined)\n  resultSet.goToFirstRow()\n  do {\n    let v: IValueBucket = {\n      id: resultSet.getLong(resultSet.getColumnIndex(\"id\")),\n      name: resultSet.getString(resultSet.getColumnIndex(\"name\")),\n      age: resultSet.getLong(resultSet.getColumnIndex(\"age\")),\n      salary: resultSet.getLong(resultSet.getColumnIndex(\"salary\"))\n    };\n    result[index++] = new SharedValuesBucket(v)\n  } while (resultSet.goToNextRow());\n  resultSet.close();\n  return result\n}\n\n@Concurrent\nasync function clear(context: Context) {\n  const CONFIG: relationalStore.StoreConfig = {\n    name: \"Store.db\",\n    securityLevel: relationalStore.SecurityLevel.S1,\n  };\n\n  // 默认数据库文件路径为 context.databaseDir + rdb + StoreConfig.name\n  await relationalStore.deleteRdbStore(context, CONFIG);\n  console.info(`Delete Store.db successfully!`);\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    RelativeContainer() {\n      Text(this.message)\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .alignRules({\n          center: { anchor: '__container__', align: VerticalAlign.Center },\n          middle: { anchor: '__container__', align: HorizontalAlign.Center }\n        })\n        .onClick(async () => {\n          let context = getContext(this);\n\n          // 数据准备\n          const count = 5\n          let valueBucketArray = collections.Array.create<SharedValuesBucket | undefined>(count, undefined);\n          for (let i = 0; i < count; i++) {\n            let v: IValueBucket = {\n              id: i,\n              name: \"zhangsan\" + i,\n              age: 20,\n              salary: 5000 + 50 * i\n            };\n            valueBucketArray[i] = new SharedValuesBucket(v);\n          }\n          await taskpool.execute(create, context)\n          await taskpool.execute(insert, context, valueBucketArray)\n          let index = 0\n          let ret: collections.Array<SharedValuesBucket> =\n            await taskpool.execute(query, context) as collections.Array<SharedValuesBucket>\n          for (let v of ret.values()) {\n            console.info(`Row[${index}].id = ${v.id}`)\n            console.info(`Row[${index}].name = ${v.name}`)\n            console.info(`Row[${index}].age = ${v.age}`)\n            console.info(`Row[${index}].salary = ${v.salary}`)\n            index++\n          }\n          await taskpool.execute(clear, context)\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n} 

自定义组件冻结功能
当@ComponentV2装饰的自定义组件处于非激活状态时，状态变量将不响应更新，即@Monitor不会调用，状态变量关联的节点不会刷新。通过freezeWhenInactive属性来决定是否使用冻结功能，不传参数时默认不使用。支持的场景有：页面路由，TabContent，Navigation。
在阅读本文档前，开发者需要了解@ComponentV2基本语法。建议提前阅读：@ComponentV2。
从API version 12开始，支持@ComponentV2装饰的自定义组件冻结功能。
和@Component的组件冻结不同， @ComponentV2装饰的自定义组件不支持LazyForEach场景下的缓存节点组件冻结。
当前支持的场景
[h2]页面路由
本示例使用了router进行页面跳转，建议开发者使用组件导航(Navigation)代替页面路由(router)来实现页面切换。Navigation提供了更多的功能和更灵活的自定义能力。请参考使用Navigation的组件冻结用例。
 当页面1调用router.pushUrl接口跳转到页面2时，页面1为隐藏不可见状态，此时如果更新页面1中的状态变量，不会触发页面1刷新。 图示如下： 
页面1：
import { router } from '@kit.ArkUI';\n\n@ObservedV2\nexport class Book {\n  @Trace name: string = \"100\";\n\n  constructor(page: string) {\n    this.name = page;\n  }\n}\n\n@Entry\n@ComponentV2({ freezeWhenInactive: true })\nexport struct Page1 {\n  @Local bookTest: Book = new Book(\"A Midsummer Night’s Dream\");\n\n  @Monitor(\"bookTest.name\")\n  onMessageChange(monitor: IMonitor) {\n    console.log(`The book name change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n\n  build() {\n    Column() {\n      Text(`Book name is  ${this.bookTest.name}`).fontSize(25)\n      Button('changeBookName').fontSize(25)\n        .onClick(() => {\n          this.bookTest.name = \"The Old Man and the Sea\";\n        })\n      Button('go to next page').fontSize(25)\n        .onClick(() => {\n          router.pushUrl({ url: 'pages/Page2' });\n          setTimeout(() => {\n            this.bookTest = new Book(\"Jane Austen oPride and Prejudice\");\n          }, 1000)\n        })\n    }\n  }\n}
页面2：
import { router } from '@kit.ArkUI';\n\n@Entry\n@ComponentV2\nstruct Page2 {\n  build() {\n    Column() {\n      Text(`This is the page2`).fontSize(25)\n      Button('Back')\n        .onClick(() => {\n          router.back();\n        })\n    }\n  }\n}
在上面的示例中：
1.点击页面1中的Button “changeBookName”，bookTest变量的name属性改变，@Monitor中注册的方法onMessageChange会被调用。
2.点击页面1中的Button “go to next page”，跳转到页面2，然后延迟1s更新状态变量“bookTest”。在更新“bookTest”的时候，已经跳转到页面2，页面1处于inactive状态，状态变量@Local bookTest将不响应更新，其@Monitor不会调用，状态变量关联的节点不会刷新。
trace如下：
3.点击“back”，页面2被销毁，页面1的状态由inactive变为active。状态变量“bookTest”的更新被观察到，@Monitor中注册的方法onMessageChange被调用，对应的Text显示内容改变。
[h2]TabContent
 对Tabs中当前不可见的TabContent进行冻结，不会触发组件的更新。 需要注意的是：在首次渲染的时候，Tab只会创建当前正在显示的TabContent，当切换全部的TabContent后，TabContent才会被全部创建。 
图示如下：
@Entry\n@ComponentV2\nstruct TabContentTest {\n  @Local message: number = 0;\n  @Local data: number[] = [0, 1];\n\n  build() {\n    Row() {\n      Column() {\n        Button('change message').onClick(() => {\n          this.message++;\n        })\n\n        Tabs() {\n          ForEach(this.data, (item: number) => {\n            TabContent() {\n              FreezeChild({ message: this.message, index: item })\n            }.tabBar(`tab${item}`)\n          }, (item: number) => item.toString())\n        }\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}\n\n@ComponentV2({ freezeWhenInactive: true })\nstruct FreezeChild {\n  @Param message: number = 0;\n  @Param index: number = 0;\n\n  @Monitor('message') onMessageUpdated(mon: IMonitor) {\n    console.info(`FreezeChild message callback func ${this.message}, index: ${this.index}`);\n  }\n\n  build() {\n    Text(\"message\" + `${this.message}, index: ${this.index}`)\n      .fontSize(50)\n      .fontWeight(FontWeight.Bold)\n  }\n}
在上面的示例中：
1.点击“change message”更改message的值，当前正在显示的TabContent组件中的@Monitor中注册的方法onMessageUpdated被触发。
2.点击TabBar“tab1”切换到另外的TabContent，TabContent状态由inactive变为active，对应的@Monitor中注册的方法onMessageUpdated被触发。
3.再次点击“change message”更改message的值，仅当前显示的TabContent子组件中的@Monitor中注册的方法onMessageUpdated被触发。其他inactive的TabContent组件不会触发@Monitor。
[h2]Navigation
 当NavDestination不可见时，会将其子自定义组件设置成非激活态，不会触发组件的刷新。当返回该页面时，其子自定义组件重新恢复成激活态，触发@Monitor回调进行刷新。 
@Entry\n@ComponentV2\nstruct MyNavigationTestStack {\n  @Provider('pageInfo') pageInfo: NavPathStack = new NavPathStack();\n  @Local message: number = 0;\n\n  @Monitor('message') info() {\n    console.info(`freeze-test MyNavigation message callback ${this.message}`);\n  }\n\n  @Builder\n  PageMap(name: string) {\n    if (name === 'pageOne') {\n      pageOneStack({ message: this.message })\n    } else if (name === 'pageTwo') {\n      pageTwoStack({ message: this.message })\n    } else if (name === 'pageThree') {\n      pageThreeStack({ message: this.message })\n    }\n  }\n\n  build() {\n    Column() {\n      Button('change message')\n        .onClick(() => {\n          this.message++;\n        })\n      Navigation(this.pageInfo) {\n        Column() {\n          Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n            .onClick(() => {\n              this.pageInfo.pushPath({ name: 'pageOne' }); //将name指定的NavDestination页面信息入栈\n            })\n        }\n      }.title('NavIndex')\n      .navDestination(this.PageMap)\n      .mode(NavigationMode.Stack)\n    }\n  }\n}\n\n@ComponentV2\nstruct pageOneStack {\n  @Consumer('pageInfo') pageInfo: NavPathStack = new NavPathStack();\n  @Local index: number = 1;\n  @Param message: number = 0;\n\n  build() {\n    NavDestination() {\n      Column() {\n        NavigationContentMsgStack({ message: this.message, index: this.index })\n        Text(\"cur stack size:\" + `${this.pageInfo.size()}`)\n          .fontSize(30)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageTwo', null);\n          })\n        Button('Back Page', { stateEffect: true, type: ButtonType.Capsule })\n          .onClick(() => {\n            this.pageInfo.pop();\n          })\n      }.width('100%').height('100%')\n    }.title('pageOne')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@ComponentV2\nstruct pageTwoStack {\n  @Consumer('pageInfo') pageInfo: NavPathStack = new NavPathStack();\n  @Local index: number = 2;\n  @Param message: number = 0;\n\n  build() {\n    NavDestination() {\n      Column() {\n        NavigationContentMsgStack({ message: this.message, index: this.index })\n        Text(\"cur stack size:\" + `${this.pageInfo.size()}`)\n          .fontSize(30)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageThree', null);\n          })\n        Button('Back Page', { stateEffect: true, type: ButtonType.Capsule })\n          .onClick(() => {\n            this.pageInfo.pop();\n          })\n      }\n    }.title('pageTwo')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@ComponentV2\nstruct pageThreeStack {\n  @Consumer('pageInfo') pageInfo: NavPathStack = new NavPathStack();\n  @Local index: number = 3;\n  @Param message: number = 0;\n\n  build() {\n    NavDestination() {\n      Column() {\n        NavigationContentMsgStack({ message: this.message, index: this.index })\n        Text(\"cur stack size:\" + `${this.pageInfo.size()}`)\n          .fontSize(30)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .height(40)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageOne', null);\n          })\n        Button('Back Page', { stateEffect: true, type: ButtonType.Capsule })\n          .height(40)\n          .onClick(() => {\n            this.pageInfo.pop();\n          })\n      }\n    }.title('pageThree')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@ComponentV2({ freezeWhenInactive: true })\nstruct NavigationContentMsgStack {\n  @Param message: number = 0;\n  @Param index: number = 0;\n\n  @Monitor('message') info() {\n    console.info(`freeze-test NavigationContent message callback ${this.message}`);\n    console.info(`freeze-test ---- called by content ${this.index}`);\n  }\n\n  build() {\n    Column() {\n      Text(\"msg:\" + `${this.message}`)\n        .fontSize(30)\n    }\n  }\n}
在上面的示例中：
1.点击“change message”更改message的值，当前正在显示的MyNavigationTestStack组件中的@Monitor中注册的方法info被触发。
2.点击“Next Page”切换到PageOne，创建pageOneStack节点。
3.再次点击“change message”更改message的值，仅pageOneStack中的NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。
4.再次点击“Next Page”切换到PageTwo，创建pageTwoStack节点。pageOneStack节点状态由active变为inactive。
5.再次点击“change message”更改message的值，仅pageTwoStack中的NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。Navigation路由栈中非栈顶的NavDestination中的子自定义组件，将是inactive状态。@Monitor方法不会触发。
6.再次点击“Next Page”切换到PageThree，创建pageThreeStack节点。pageTwoStack节点状态由active变为inactive。
7.再次点击“change message”更改message的值，仅pageThreeStack中的NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。Navigation路由栈中非栈顶的NavDestination中的子自定义组件，将是inactive状态。@Monitor方法不会触发。
8.点击“Back Page”回到PageTwo，此时，pageTwoStack节点状态由inactive变为active，其NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。
9.再次点击“Back Page”回到PageOne，此时，pageOneStack节点状态由inactive变为active，其NavigationContentMsgStack子组件中的@Monitor中注册的方法info被触发。
10.再次点击“Back Page”回到初始页。
限制条件
如下面的例子所示，FreezeBuildNode中使用了自定义节点BuilderNode。BuilderNode可以通过命令式动态挂载组件，而组件冻结又是强依赖父子关系来通知是否开启组件冻结。如果父组件使用组件冻结，且组件树的中间层级上又启用了BuilderNode，则BuilderNode的子组件将无法被冻结。
import { BuilderNode, FrameNode, NodeController, UIContext } from '@kit.ArkUI';\n\n// 定义一个Params类，用于传递参数\n@ObservedV2\nclass Params {\n  // 单例模式，确保只有一个Params实例\n  static singleton_: Params;\n\n  // 获取Params实例的方法\n  static instance() {\n    if (!Params.singleton_) {\n      Params.singleton_ = new Params(0);\n    }\n    return Params.singleton_;\n  }\n\n  // 使用@Trace装饰器装饰message属性，以便跟踪其变化\n  @Trace message: string = \"Hello\";\n  index: number = 0;\n\n  constructor(index: number) {\n    this.index = index;\n  }\n}\n\n// 定义一个buildNodeChild组件，它包含一个message属性和一个index属性\n@ComponentV2\nstruct buildNodeChild {\n  // 使用Params实例作为storage属性\n  storage: Params = Params.instance();\n  @Param index: number = 0;\n\n  // 使用@Monitor装饰器监听storage.message的变化\n  @Monitor(\"storage.message\")\n  onMessageChange(monitor: IMonitor) {\n    console.log(`FreezeBuildNode buildNodeChild message callback func ${this.storage.message}, index:${this.index}`);\n  }\n\n  build() {\n    Text(`buildNode Child message: ${this.storage.message}`).fontSize(30)\n  }\n}\n\n// 定义一个buildText函数，它接收一个Params参数并构建一个Column组件\n@Builder\nfunction buildText(params: Params) {\n  Column() {\n    buildNodeChild({ index: params.index })\n  }\n}\n\nclass TextNodeController extends NodeController {\n  private textNode: BuilderNode<[Params]> | null = null;\n  private index: number = 0;\n  \n  // 构造函数接收一个index参数\n  constructor(index: number) {\n    super();\n    this.index = index;\n  }\n\n  // 创建并返回一个FrameNode\n  makeNode(context: UIContext): FrameNode | null {\n    this.textNode = new BuilderNode(context);\n    this.textNode.build(wrapBuilder<[Params]>(buildText), new Params(this.index));\n    return this.textNode.getFrameNode();\n  }\n}\n\n// 定义一个Index组件，它包含一个message属性和一个data数组\n@Entry\n@ComponentV2\nstruct Index {\n  // 使用Params实例作为storage属性\n  storage: Params = Params.instance();\n  private data: number[] = [0, 1];\n\n  build() {\n    Row() {\n      Column() {\n        Button(\"change\").fontSize(30)\n          .onClick(() => {\n            this.storage.message += 'a';\n          })\n\n        Tabs() {\n          // 使用Repeat重复渲染TabContent组件\n          Repeat<number>(this.data)\n            .each((obj: RepeatItem<number>) => {\n              TabContent() {\n                FreezeBuildNode({ index: obj.item })\n                  .margin({ top: 20 })\n              }.tabBar(`tab${obj.item}`)\n            })\n            .key((item: number) => item.toString())\n        }\n      }\n    }\n    .width('100%')\n    .height('100%')\n  }\n}\n\n// 定义一个FreezeBuildNode组件，它包含一个message属性和一个index属性\n@ComponentV2({ freezeWhenInactive: true })\nstruct FreezeBuildNode {\n  // 使用Params实例作为storage属性\n  storage: Params = Params.instance();\n  @Param index: number = 0;\n\n  // 使用@Monitor装饰器监听storage.message的变化\n  @Monitor(\"storage.message\")\n  onMessageChange(monitor: IMonitor) {\n    console.log(`FreezeBuildNode message callback func ${this.storage.message}, index: ${this.index}`);\n  }\n\n  build() {\n    NodeContainer(new TextNodeController(this.index))\n      .width('100%')\n      .height('100%')\n      .backgroundColor('#FFF0F0F0')\n  }\n}
点击Button(\"change\")。改变message的值，当前正在显示的TabContent组件中的@Watch中注册的方法onMessageUpdated被触发。未显示的TabContent中的BuilderNode节点下组件的@Watch方法onMessageUpdated也被触发，并没有被冻结。

证书管理开发指导
本开发指导需使用API version 11及以上版本SDK。
场景说明
 典型场景：  安装应用证书和私有凭据。 获取应用证书和私有凭据。 使用应用证书和私有凭据对数据进行签名、验签。 卸载指定的应用证书和私有凭据。  支持安装的私有凭据算法类型&签名验签支持的参数组合。 证书管理安装凭据及使用凭据中的密钥进行签名、验签，依赖通用密钥库（HUKS）能力，证书管理支持的算法为其子集，当前仅支持RSA及ECC算法类型的私有凭据安装及使用。签名、验签支持的参数组合，详见HUKS声明的签名/验签介绍及算法规格中RSA及ECC的描述。 
接口说明
详细接口说明可参考API参考。
以上场景涉及的常用接口如下表所示：
开发步骤
 申请权限。调用证书管理相关接口，需要在module.json5文件的requestPermissions对象中配置ohos.permission.ACCESS_CERT_MANAGER权限。更多配置信息请参考Stage模型应用程序包结构。 导入相关模块。 import { certificateManager } from '@kit.DeviceCertificateKit';\nimport { BusinessError } from '@kit.BasicServicesKit'; 安装应用私有凭据，获取应用私有凭据，并使用应用私有凭据进行签名、验签，最后删除应用私有凭据。 async function certificateManagerSample() {\n  /* 安装的凭据数据需要业务赋值，本例数据非凭据数据 */\n  let keystore: Uint8Array = new Uint8Array([\n    0x30, 0x82, 0x04, 0x6a, 0x02, 0x01,\n  ]);\n\n  /* 安装凭据对应的密码，业务赋值 */\n  let keystorePwd: string = '123456';\n  let appKeyUri: string = '';\n  try {\n    /* 安装私有凭据 */\n    const res: certificateManager.CMResult = await certificateManager.installPrivateCertificate(keystore, keystorePwd, \"testPriCredential\");\n    appKeyUri = (res.uri != undefined) ? res.uri : '';\n  } catch (err) {\n    let e: BusinessError = err as BusinessError;\n    console.error(`Failed to install private certificate. Code: ${e.code}, message: ${e.message}`);\n  }\n\n  try {\n    /* srcData为待签名、验签的数据，业务自行赋值 */\n    let srcData: Uint8Array = new Uint8Array([\n      0x86, 0xf7, 0x0d, 0x01, 0x07, 0x01,\n  ]);\n\n    /* 构造签名的属性参数 */\n    const signSpec: certificateManager.CMSignatureSpec = {\n      purpose: certificateManager.CmKeyPurpose.CM_KEY_PURPOSE_SIGN,\n      padding: certificateManager.CmKeyPadding.CM_PADDING_PSS,\n      digest: certificateManager.CmKeyDigest.CM_DIGEST_SHA256\n    };\n\n    /* 签名 */\n    const signHandle: certificateManager.CMHandle = await certificateManager.init(appKeyUri, signSpec);\n    await certificateManager.update(signHandle.handle, srcData);\n    const signResult: certificateManager.CMResult = await certificateManager.finish(signHandle.handle);\n\n    /* 构造验签的的属性参数 */\n    const verifySpec: certificateManager.CMSignatureSpec = {\n      purpose: certificateManager.CmKeyPurpose.CM_KEY_PURPOSE_VERIFY,\n      padding: certificateManager.CmKeyPadding.CM_PADDING_PSS,\n      digest: certificateManager.CmKeyDigest.CM_DIGEST_SHA256\n    };\n\n    /* 验签 */\n    const verifyHandle: certificateManager.CMHandle = await certificateManager.init(appKeyUri, verifySpec);\n    await certificateManager.update(verifyHandle.handle, srcData);\n    const verifyResult = await certificateManager.finish(verifyHandle.handle, signResult.outData);\n    console.info('Succeeded in signing and verifying.');\n  } catch (err) {\n    let e: BusinessError = err as BusinessError;\n    console.error(`Failed to sign or verify. Code: ${e.code}, message: ${e.message}`);\n  }\n\n  try {\n    /* 卸载私有凭据 */\n    await certificateManager.uninstallPrivateCertificate(appKeyUri);\n  } catch (err) {\n    let e: BusinessError = err as BusinessError;\n    console.error(`Failed to uninstall private certificate. Code: ${e.code}, message: ${e.message}`);\n  }\n} 

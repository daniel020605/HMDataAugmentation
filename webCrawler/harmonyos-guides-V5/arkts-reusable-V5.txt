@Reusable装饰器：组件复用
@Reusable装饰器装饰任意自定义组件时，表示该自定义组件可以复用。
从API version 10开始，对@Reusable进行支持，支持在ArkTS中使用。
概述
@Reusable适用自定义组件，与@Component结合使用，标记为@Reusable的自定义组件从组件树上被移除时，组件和其对应的JSView对象都会被放入复用缓存中，后续创建新自定义组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。
限制条件
@Reusable装饰器仅用于自定义组件。
import { ComponentContent } from \"@kit.ArkUI\";\n\n// @Builder加上@Reusable编译报错,不适用于builder\n// @Reusable\n@Builder\nfunction buildCreativeLoadingDialog(closedClick: () => void) {\n  Crash()\n}\n\n@Component\nexport struct Crash {\n  build() {\n    Column() {\n      Text(\"Crash\")\n        .fontSize(12)\n        .lineHeight(18)\n        .fontColor(Color.Blue)\n        .margin({\n          left: 6\n        })\n    }.width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n  private uicontext = this.getUIContext()\n\n  build() {\n    RelativeContainer() {\n      Text(this.message)\n        .id('Index')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .alignRules({\n          center: { anchor: '__container__', align: VerticalAlign.Center },\n          middle: { anchor: '__container__', align: HorizontalAlign.Center }\n        })\n        .onClick(() => {\n          let contentNode = new ComponentContent(this.uicontext, wrapBuilder(buildCreativeLoadingDialog), () => {\n          });\n          this.uicontext.getPromptAction().openCustomDialog(contentNode);\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
ComponentContent不支持传入@Reusable装饰器装饰的自定义组件。
import { ComponentContent } from \"@kit.ArkUI\";\n@Builder\nfunction buildCreativeLoadingDialog(closedClick: () => void) {\n  Crash()\n}\n\n// 如果注释掉就可以正常弹出弹窗，如果加上@Reusable就直接crash\n@Reusable\n@Component\nexport struct Crash {\n  build() {\n    Column() {\n      Text(\"Crash\")\n        .fontSize(12)\n        .lineHeight(18)\n        .fontColor(Color.Blue)\n        .margin({\n          left: 6\n        })\n    }.width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n  private uicontext = this.getUIContext()\n\n  build() {\n    RelativeContainer() {\n      Text(this.message)\n        .id('Index')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .alignRules({\n          center: { anchor: '__container__', align: VerticalAlign.Center },\n          middle: { anchor: '__container__', align: HorizontalAlign.Center }\n        })\n        .onClick(() => {\n          // ComponentContent底层是buildNode，buildNode不支持传入@Reusable注解的自定义组件\n          let contentNode = new ComponentContent(this.uicontext, wrapBuilder(buildCreativeLoadingDialog), () => {\n          });\n          this.uicontext.getPromptAction().openCustomDialog(contentNode);\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
@Reusable装饰器不支持嵌套使用，存在增加内存和不方便维护的问题；
不支持嵌套使用，只是标记，会多增加一个缓存池，各自的复用缓存池存在相同树状结构，复用效率低，引发复用内存增加;
嵌套使用形成各自独立的复用缓存池之后，生命周期的传递存在问题，资源和变量管理无法共享，并不方便维护，容易引发问题;
示例中PlayButton形成的复用缓存池，并不能在PlayButton02的复用缓存池使用，但PlayButton02自己形成复用缓存相互可以使用;
在PlayButton隐藏时已经触发PlayButton02的aboutToRecycle，但是在PlayButton02单独显示时却无法执行aboutToReuse，组件复用的生命周期方法存在无法成对调用问题;
综上，不建议嵌套使用。
@Entry\n@Component\nstruct Index {\n  @State isPlaying: boolean = false;\n  @State isPlaying02: boolean = true;\n  @State isPlaying01: boolean = false;\n\n  build() {\n    Column() {\n      if (this.isPlaying02) {\n\n        // 初始态是显示的按钮\n        Text(\"Default shown childbutton\")\n          .fontSize(14)\n        PlayButton02({ isPlaying02: $isPlaying02 })\n      }\n      Text(`==================`).fontSize(14);\n\n      // 初始态是隐藏的按钮\n      if (this.isPlaying01) {\n        Text(\"Default hidden childbutton\")\n          .fontSize(14)\n        PlayButton02({ isPlaying02: $isPlaying01 })\n      }\n      Text(`==================`).fontSize(14);\n\n      // 父子嵌套\n      if (this.isPlaying) {\n        Text(\"parent child 嵌套\")\n          .fontSize(14)\n        PlayButton({ buttonPlaying: $isPlaying })\n      }\n      Text(`==================`).fontSize(14);\n\n      // 父子嵌套控制\n      Text(`Parent=child==is ${this.isPlaying ? '' : 'not'} playing`).fontSize(14)\n      Button('Parent=child===controll=' + this.isPlaying)\n        .margin(14)\n        .onClick(() => {\n          this.isPlaying = !this.isPlaying;\n        })\n\n      Text(`==================`).fontSize(14);\n\n      //  默认隐藏按钮控制\n      Text(`Hiddenchild==is ${this.isPlaying01 ? '' : 'not'} playing`).fontSize(14)\n      Button('Button===hiddenchild==control==' + this.isPlaying01)\n        .margin(14)\n        .onClick(() => {\n          this.isPlaying01 = !this.isPlaying01;\n        })\n      Text(`==================`).fontSize(14);\n\n      // 默认显示按钮控制\n      Text(`shownchid==is ${this.isPlaying02 ? '' : 'not'} playing`).fontSize(14)\n      Button('Button===shownchid==control==:' + this.isPlaying02)\n        .margin(15)\n        .onClick(() => {\n          this.isPlaying02 = !this.isPlaying02;\n        })\n    }\n  }\n}\n\n// 复用1\n@Reusable\n@Component\nstruct PlayButton {\n  @Link buttonPlaying: boolean;\n\n  build() {\n    Column() {\n\n      // 复用\n      PlayButton02({ isPlaying02: $buttonPlaying })\n      Button(this.buttonPlaying ? 'parent_pause' : 'parent_play')\n        .margin(12)\n        .onClick(() => {\n          this.buttonPlaying = !this.buttonPlaying;\n        })\n    }\n  }\n}\n\n//  复用2 不建议嵌套使用\n@Reusable\n@Component\nstruct PlayButton02 {\n  @Link isPlaying02: boolean;\n\n  aboutToRecycle(): void {\n    console.log(\"=====aboutToRecycle====PlayButton02====\");\n  }\n\n  aboutToReuse(params: ESObject): void {\n    console.log(\"=====aboutToReuse====PlayButton02====\");\n  }\n\n  build() {\n    Column() {\n      Button('===commonbutton=====')\n        .margin(12)\n    }\n  }\n}
使用场景
列表滚动：当应用需要展示大量数据的列表，并且用户进行滚动操作时，频繁创建和销毁列表项的视图可能导致卡顿和性能问题。在这种情况下，使用列表组件的组件复用机制可以重用已经创建的列表项视图，提高滚动的流畅度。 动态布局更新：如果应用中的界面需要频繁地进行布局更新，例如根据用户的操作或数据变化动态改变视图结构和样式，重复创建和销毁视图可能导致频繁的布局计算，影响帧率。在这种情况下，使用组件复用可以避免不必要的视图创建和布局计算，提高性能。 频繁创建和销毁数据项的视图场景下。使用组件复用可以重用已创建的视图，只更新数据的内容，减少视图的创建和销毁，能有效提高性能。 
使用场景举例
[h2]动态布局更新
示例代码将Child自定义组件标记为复用组件，通过Button点击更新Child，触发Child复用;@Reusable：自定义组件被@Reusable装饰器修饰，即表示其具备组件复用的能力;aboutToReuse：当一个可复用的自定义组件从复用缓存中重新加入到节点树时，触发aboutToReuse生命周期回调，并将组件的构造参数传递给aboutToReuse。
// xxx.ets\nexport class Message {\n  value: string | undefined;\n\n  constructor(value: string) {\n    this.value = value;\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State switch: boolean = true;\n  build() {\n    Column() {\n      Button('Hello')\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold)\n        .onClick(() => {\n          this.switch = !this.switch;\n        })\n      if (this.switch) {\n        Child({ message: new Message('Child') })\n          // 如果只有一个复用的组件，可以不用设置reuseId\n          .reuseId('Child')\n      }\n    }\n    .height(\"100%\")\n    .width('100%')\n  }\n}\n\n@Reusable\n@Component\nstruct Child {\n  @State message: Message = new Message('AboutToReuse');\n\n  aboutToReuse(params: Record<string, ESObject>) {\n    console.info(\"Recycle ====Child==\");\n    this.message = params.message as Message;\n  }\n\n  build() {\n    Column() {\n      Text(this.message.value)\n        .fontSize(30)\n    }\n    .borderWidth(1)\n    .height(100)\n  }\n}
[h2]列表滚动配合LazyForEach使用
示例代码将CardView自定义组件标记为复用组件，List上下滑动，触发CardView复用;@Reusable：自定义组件被@Reusable装饰器修饰，即表示其具备组件复用的能力;变量item的被@State修饰，才能更新，非@State修饰变量存在无法更新问题。
class MyDataSource implements IDataSource {\n  private dataArray: string[] = [];\n  private listener: DataChangeListener | undefined;\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n  }\n\n  public reloadListener(): void {\n    this.listener?.onDataReloaded();\n  }\n\n  public registerDataChangeListener(listener: DataChangeListener): void {\n    this.listener = listener;\n  }\n\n  public unregisterDataChangeListener(listener: DataChangeListener): void {\n    this.listener = undefined;\n  }\n}\n\n@Entry\n@Component\nstruct ReuseDemo {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 1; i < 1000; i++) {\n      this.data.pushData(i+\"\");\n    }\n  }\n\n  // ...\n  build() {\n    Column() {\n      List() {\n        LazyForEach(this.data, (item: string) => {\n          ListItem() {\n            CardView({ item: item })\n          }\n        }, (item: string) => item)\n      }\n    }\n  }\n}\n\n// 复用组件\n@Reusable\n@Component\nexport struct CardView {\n  @State item: string = '';\n\n  aboutToReuse(params: Record<string, Object>): void {\n    this.item = params.item as string;\n  }\n\n  build() {\n    Column() {\n      Text(this.item)\n        .fontSize(30)\n    }\n    .borderWidth(1)\n    .height(100)\n  }\n}
[h2]if使用场景
示例代码将OneMoment自定义组件标记为复用组件，List上下滑动，触发OneMoment复用;可以使用reuseId为复用组件分配复用组，相同reuseId的组件会在同一个复用组中复用，如果只有一个复用的组件，可以不用设置reuseId;通过reuseId来标识需要复用的组件，省去重复执行if的删除重创逻辑，提高组件复用的效率和性能。
@Entry\n@Component\nstruct Index {\n  private dataSource = new MyDataSource<FriendMoment>();\n\n  aboutToAppear(): void {\n    for (let i = 0; i < 20; i++) {\n      let title = i + 1 + \"test_if\";\n      this.dataSource.pushData(new FriendMoment(i.toString(), title, 'app.media.app_icon'))\n    }\n\n    for (let i = 0; i < 50; i++) {\n      let title = i + 1 + \"test_if\";\n      this.dataSource.pushData(new FriendMoment(i.toString(), title, ''))\n    }\n  }\n\n  build() {\n    Column() {\n      // TopBar()\n      List({ space: 3 }) {\n        LazyForEach(this.dataSource, (moment: FriendMoment) => {\n          ListItem() {\n            OneMoment({ moment: moment })// 使用reuseId进行组件复用的控制\n              .reuseId((moment.image !== '') ? 'withImage' : 'noImage')\n          }\n        }, (moment: FriendMoment) => moment.id)\n      }\n      .cachedCount(0)\n    }\n  }\n}\n\nclass FriendMoment {\n  id: string = '';\n  text: string = '';\n  title: string = '';\n  image: string = '';\n  answers: Array<ResourceStr> = [];\n\n  constructor(id: string, title: string, image: string) {\n    this.text = id;\n    this.title = title;\n    this.image = image;\n  }\n}\n\n@Reusable\n@Component\nexport struct OneMoment {\n  @Prop moment: FriendMoment;\n\n  // 复用id相同的同才能触发复用\n  aboutToReuse(params: ESObject): void {\n    console.log(\"=====aboutToReuse====OneMoment==复用了==\" + this.moment.text);\n  }\n\n  build() {\n    Column() {\n      Text(this.moment.text)\n      // if分支判断\n      if (this.moment.image !== '') {\n        Flex({ wrap: FlexWrap.Wrap }) {\n          Image($r(this.moment.image)).height(50).width(50);\n          Image($r(this.moment.image)).height(50).width(50);\n          Image($r(this.moment.image)).height(50).width(50);\n          Image($r(this.moment.image)).height(50).width(50);\n        }\n      }\n    }\n  }\n}\n\nclass BasicDataSource<T> implements IDataSource {\n  private listeners: DataChangeListener[] = [];\n  private originDataArray: T[] = [];\n\n  public totalCount(): number {\n    return 0;\n  }\n\n  public getData(index: number): T {\n    return this.originDataArray[index];\n  }\n\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener);\n    }\n  }\n\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1);\n    }\n  }\n\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index);\n    })\n  }\n}\n\nexport class MyDataSource<T> extends BasicDataSource<T> {\n  private dataArray: T[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): T {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: T): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}
[h2]Foreach使用场景
使用Foreach创建可复用的自定义组件，由于Foreach渲染控制语法的全展开属性，导致复用组件无法复用；如下示例点击update，数据刷新成功，但是滑动列表，ListItemView无法复用;点击clear，再次点击update，ListItemView复用成功，因为一帧内重复创建多个已被销毁的自定义组件。
// xxx.ets\nclass MyDataSource implements IDataSource {\n  private dataArray: string[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n  }\n\n  public registerDataChangeListener(listener: DataChangeListener): void {\n  }\n\n  public unregisterDataChangeListener(listener: DataChangeListener): void {\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  private data: MyDataSource = new MyDataSource();\n  private data02: MyDataSource = new MyDataSource();\n  @State isShow: boolean = true;\n  @State dataSource: ListItemObject[] = [];\n\n  aboutToAppear() {\n    for (let i = 0; i < 100; i++) {\n      this.data.pushData(i.toString());\n    }\n\n    for (let i = 30; i < 80; i++) {\n      this.data02.pushData(i.toString());\n    }\n  }\n\n  build() {\n    Column() {\n      Row() {\n        Button('clear').onClick(() => {\n          for (let i = 1; i < 50; i++) {\n            let obj = new ListItemObject();\n            obj.id = i;\n            obj.uuid = Math.random().toString();\n            obj.isExpand = false;\n            this.dataSource.pop();\n          }\n        }).height(40)\n\n        Button('update').onClick(() => {\n          for (let i = 1; i < 50; i++) {\n            let obj = new ListItemObject();\n            obj.id = i;\n            obj.uuid = Math.random().toString();\n            obj.isExpand = false\n            this.dataSource.push(obj);\n          }\n        }).height(40)\n      }\n\n      List({ space: 10 }) {\n        ForEach(this.dataSource, (item: ListItemObject) => {\n          ListItem() {\n            ListItemView({\n              obj: item\n            })\n          }\n        }, (item: ListItemObject) => {\n          return item.uuid.toString()\n        })\n\n      }.cachedCount(0)\n      .width('100%')\n      .height('100%')\n    }\n  }\n}\n\n@Reusable\n@Component\nstruct ListItemView {\n  @ObjectLink obj: ListItemObject;\n  @State item: string = '';\n\n  aboutToAppear(): void {\n    // 点击 update，首次进入，上下滑动，由于Foreach折叠展开属性，无法复用\n    console.log(\"=====aboutToAppear=====ListItemView==创建了==\" + this.item);\n  }\n\n  aboutToReuse(params: ESObject) {\n    this.item = params.item;\n    // 点击 clear，再次update，复用成功\n    // 符合一帧内重复创建多个已被销毁的自定义组件\n    console.log(\"=====aboutToReuse====ListItemView==复用了==\" + this.item);\n  }\n\n  build() {\n    Column({ space: 10 }) {\n      Text(`${this.obj.id}.标题`)\n        .fontSize(16)\n        .fontColor('#000000')\n        .padding({\n          top: 20,\n          bottom: 20,\n        })\n\n      if (this.obj.isExpand) {\n        Text('')\n          .fontSize(14)\n          .fontColor('#999999')\n      }\n    }\n    .width('100%')\n    .borderRadius(10)\n    .backgroundColor(Color.White)\n    .padding(15)\n    .onClick(() => {\n      this.obj.isExpand = !this.obj.isExpand;\n    })\n  }\n}\n\n@Observed\nclass ListItemObject {\n  uuid: string = \"\";\n  id: number = 0;\n  isExpand: boolean = false;\n}
[h2]Grid使用场景
示例中使用@Reusable装饰器修饰GridItem中的自定义组件ReusableChildComponent，即表示其具备组件复用的能力;使用aboutToReuse是为了让Grid在滑动时从复用缓存中加入到组件树之前触发，用于更新组件的状态变量以展示正确的内容;需要注意的是无需在aboutToReuse中对@Link、@StorageLink、@ObjectLink、@Consume等自动更新值的状态变量进行更新，可能触发不必要的组件刷新。
// MyDataSource类实现IDataSource接口\nclass MyDataSource implements IDataSource {\n  private dataArray: number[] = [];\n\n  public pushData(data: number): void {\n    this.dataArray.push(data);\n  }\n\n  // 数据源的数据总量\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  // 返回指定索引位置的数据\n  public getData(index: number): number {\n    return this.dataArray[index];\n  }\n\n  registerDataChangeListener(listener: DataChangeListener): void {\n  }\n\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  // 数据源\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 1; i < 1000; i++) {\n      this.data.pushData(i);\n    }\n  }\n\n  build() {\n    Column({ space: 5 }) {\n      Grid() {\n        LazyForEach(this.data, (item: number) => {\n          GridItem() {\n            // 使用可复用自定义组件\n            ReusableChildComponent({ item: item })\n          }\n        }, (item: string) => item)\n      }\n      .cachedCount(2) // 设置GridItem的缓存数量\n      .columnsTemplate('1fr 1fr 1fr')\n      .columnsGap(10)\n      .rowsGap(10)\n      .margin(10)\n      .height(500)\n      .backgroundColor(0xFAEEE0)\n    }\n  }\n}\n\n// 自定义组件被@Reusable装饰器修饰，即标志其具备组件复用的能力\n@Reusable\n@Component\nstruct ReusableChildComponent {\n  @State item: number = 0;\n\n  // aboutToReuse从复用缓存中加入到组件树之前调用，可在此处更新组件的状态变量以展示正确的内容\n  // aboutToReuse参数类型已不支持any，这里使用Record指定明确的数据类型。Record用于构造一个对象类型，其属性键为Keys，属性值为Type\n  aboutToReuse(params: Record<string, number>) {\n    this.item = params.item;\n  }\n\n  build() {\n    Column() {\n      // 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错\n      Image($r('app.media.app_icon'))\n        .objectFit(ImageFit.Fill)\n        .layoutWeight(1)\n      Text(`图片${this.item}`)\n        .fontSize(16)\n        .textAlign(TextAlign.Center)\n    }\n    .width('100%')\n    .height(120)\n    .backgroundColor(0xF9CF93)\n  }\n}
[h2]WaterFlow使用场景
WaterFlow滑动场景存在FlowItem及其子组件的频繁创建和销毁，可以将FlowItem中的组件封装成自定义组件，并使用@Reusable装饰器修饰，使其具备组件复用能力。
class WaterFlowDataSource implements IDataSource {\n  private dataArray: number[] = [];\n  private listeners: DataChangeListener[] = [];\n\n  constructor() {\n    for (let i = 0; i <= 60; i++) {\n      this.dataArray.push(i);\n    }\n  }\n\n  // 获取索引对应的数据\n  public getData(index: number): number {\n    return this.dataArray[index];\n  }\n\n  // 通知控制器增加数据\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index);\n    })\n  }\n\n  // 获取数据总数\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  // 注册改变数据的控制器\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener);\n    }\n  }\n\n  // 注销改变数据的控制器\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1);\n    }\n  }\n\n  // 在数据尾部增加一个元素\n  public addLastItem(): void {\n    this.dataArray.splice(this.dataArray.length, 0, this.dataArray.length);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}\n\n@Reusable\n@Component\nstruct ReusableFlowItem {\n  @State item: number = 0;\n\n  // 从复用缓存中加入到组件树之前调用，可在此处更新组件的状态变量以展示正确的内容\n  aboutToReuse(params: ESObject) {\n    this.item = params.item;\n    console.log(\"=====aboutToReuse====FlowItem==复用了==\" + this.item);\n  }\n\n  aboutToRecycle(): void {\n    console.log(\"=====aboutToRecycle====FlowItem==回收了==\" + this.item);\n  }\n\n  build() {\n    // 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错\n    Column() {\n      Text(\"N\" + this.item).fontSize(24).height('26').margin(10)\n      Image($r('app.media.app_icon'))\n        .objectFit(ImageFit.Cover)\n        .width(50)\n        .height(50)\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State minSize: number = 50;\n  @State maxSize: number = 80;\n  @State fontSize: number = 24;\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F];\n  scroller: Scroller = new Scroller();\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource();\n  private itemWidthArray: number[] = [];\n  private itemHeightArray: number[] = [];\n\n  // 计算flow item宽/高\n  getSize() {\n    let ret = Math.floor(Math.random() * this.maxSize);\n    return (ret > this.minSize ? ret : this.minSize);\n  }\n\n  // 保存flow item宽/高\n  getItemSizeArray() {\n    for (let i = 0; i < 100; i++) {\n      this.itemWidthArray.push(this.getSize());\n      this.itemHeightArray.push(this.getSize());\n    }\n  }\n\n  aboutToAppear() {\n    this.getItemSizeArray();\n  }\n\n  build() {\n    Stack({ alignContent: Alignment.TopStart }) {\n      Column({ space: 2 }) {\n        Button('back top')\n          .height('5%')\n          .onClick(() => { // 点击后回到顶部\n            this.scroller.scrollEdge(Edge.Top);\n          })\n        WaterFlow({ scroller: this.scroller }) {\n          LazyForEach(this.dataSource, (item: number) => {\n            FlowItem() {\n              ReusableFlowItem({ item: item })\n            }.onAppear(() => {\n              if (item + 20 == this.dataSource.totalCount()) {\n                for (let i = 0; i < 50; i++) {\n                  this.dataSource.addLastItem();\n                }\n              }\n            })\n\n          })\n        }\n      }\n    }\n  }\n\n  @Builder\n  itemFoot() {\n    Column() {\n      Text(`Footer`)\n        .fontSize(10)\n        .backgroundColor(Color.Red)\n        .width(50)\n        .height(50)\n        .align(Alignment.Center)\n        .margin({ top: 2 })\n    }\n  }\n}
[h2]Swiper使用场景
Swiper滑动场景，条目中存在子组件的频繁创建和销毁，可以将条目中的子组件封装成自定义组件，并使用@Reusable装饰器修饰，使其具备组件复用能力。
@Entry\n@Component\nstruct Index {\n  private dataSource = new MyDataSource<Question>();\n\n  aboutToAppear(): void {\n    for (let i = 0; i < 1000; i++) {\n      let title = i + 1 + \"test_swiper\";\n      let answers = [\"test1\", \"test2\", \"test3\",\n        \"test4\"];\n      // 请开发者自行在src/main/resources/base/media路径下添加app.media.app_icon图片，否则运行时会因资源缺失而报错\n      this.dataSource.pushData(new Question(i.toString(), title, $r('app.media.app_icon'), answers));\n    }\n  }\n\n  build() {\n    Column({ space: 5 }) {\n      Swiper() {\n        LazyForEach(this.dataSource, (item: Question) => {\n          QuestionSwiperItem({ itemData: item })\n        }, (item: Question) => item.id)\n      }\n    }\n    .width('100%')\n    .margin({ top: 5 })\n  }\n}\n\nclass Question {\n  id: string = '';\n  title: ResourceStr = '';\n  image: ResourceStr = '';\n  answers: Array<ResourceStr> = [];\n\n  constructor(id: string, title: ResourceStr, image: ResourceStr, answers: Array<ResourceStr>) {\n    this.id = id;\n    this.title = title;\n    this.image = image;\n    this.answers = answers;\n  }\n}\n\n@Reusable\n@Component\nstruct QuestionSwiperItem {\n  @State itemData: Question | null = null;\n\n  aboutToReuse(params: Record<string, Object>): void {\n    this.itemData = params.itemData as Question;\n    console.info(\"===test===aboutToReuse====QuestionSwiperItem==\");\n  }\n\n  build() {\n    Column() {\n      Text(this.itemData?.title)\n        .fontSize(18)\n        .fontColor($r('sys.color.ohos_id_color_primary'))\n        .alignSelf(ItemAlign.Start)\n        .margin({\n          top: 10,\n          bottom: 16\n        })\n      Image(this.itemData?.image)\n        .width('100%')\n        .borderRadius(12)\n        .objectFit(ImageFit.Contain)\n        .margin({\n          bottom: 16\n        })\n        .height(80)\n        .width(80)\n\n      Column({ space: 16 }) {\n        ForEach(this.itemData?.answers, (item: Resource) => {\n          Text(item)\n            .fontSize(16)\n            .fontColor($r('sys.color.ohos_id_color_primary'))\n        }, (item: ResourceStr) => JSON.stringify(item))\n      }\n      .width('100%')\n      .alignItems(HorizontalAlign.Start)\n    }\n    .width('100%')\n    .padding({\n      left: 16,\n      right: 16\n    })\n  }\n}\n\nclass BasicDataSource<T> implements IDataSource {\n  private listeners: DataChangeListener[] = [];\n  private originDataArray: T[] = [];\n\n  public totalCount(): number {\n    return 0;\n  }\n\n  public getData(index: number): T {\n    return this.originDataArray[index];\n  }\n\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener);\n    }\n  }\n\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1);\n    }\n  }\n\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index);\n    })\n  }\n}\n\nexport class MyDataSource<T> extends BasicDataSource<T> {\n  private dataArray: T[] = [];\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): T {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: T): void {\n    this.dataArray.push(data);\n    this.notifyDataAdd(this.dataArray.length - 1);\n  }\n}
[h2]ListItemGroup使用场景
可以视作特殊List滑动场景，将ListItem需要销毁重建的子组件封装成自定义组件，并使用@Reusable装饰器修饰，使其具备组件复用能力。
@Entry\n@Component\nstruct ListItemGroupAndReusable {\n  data: DataSrc2 = new DataSrc2();\n\n  @Builder\n  itemHead(text: string) {\n    Text(text)\n      .fontSize(20)\n      .backgroundColor(0xAABBCC)\n      .width('100%')\n      .padding(10)\n  }\n\n  aboutToAppear() {\n    for (let i = 0; i < 10000; i++) {\n      let data_1 = new DataSrc1();\n      for (let j = 0; j < 12; j++) {\n        data_1.Data.push(`测试条目数据: ${i} - ${j}`);\n      }\n      this.data.Data.push(data_1);\n    }\n  }\n\n  build() {\n    Stack() {\n      List() {\n        LazyForEach(this.data, (item: DataSrc1, index: number) => {\n          ListItemGroup({ header: this.itemHead(index.toString()) }) {\n            LazyForEach(item, (ii: string, index: number) => {\n              ListItem() {\n                Inner({ str: ii });\n              }\n            })\n          }\n          .width('100%')\n          .height('60vp')\n        })\n      }\n    }\n    .width('100%')\n    .height('100%')\n  }\n}\n\n@Reusable\n@Component\nstruct Inner {\n  @State str: string = ''\n\n  aboutToReuse(param: ESObject) {\n    this.str = param.str;\n  }\n\n  build() {\n    Text(this.str)\n  }\n}\n\nclass DataSrc1 implements IDataSource {\n  listeners: DataChangeListener[] = [];\n  Data: string[] = [];\n\n  public totalCount(): number {\n    return this.Data.length;\n  }\n\n  public getData(index: number): string {\n    return this.Data[index];\n  }\n\n  // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener);\n    }\n  }\n\n  // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1);\n    }\n  }\n\n  // 通知LazyForEach组件需要重载所有子组件\n  notifyDataReload(): void {\n    this.listeners.forEach(listener => {\n      listener.onDataReloaded();\n    })\n  }\n\n  // 通知LazyForEach组件需要在index对应索引处添加子组件\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index);\n    })\n  }\n\n  // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件\n  notifyDataChange(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataChange(index);\n    })\n  }\n\n  // 通知LazyForEach组件需要在index对应索引处删除该子组件\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataDelete(index);\n    })\n  }\n\n  // 通知LazyForEach组件将from索引和to索引处的子组件进行交换\n  notifyDataMove(from: number, to: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataMove(from, to);\n    })\n  }\n}\n\nclass DataSrc2 implements IDataSource {\n  listeners: DataChangeListener[] = [];\n  Data: DataSrc1[] = [];\n\n  public totalCount(): number {\n    return this.Data.length;\n  }\n\n  public getData(index: number): DataSrc1 {\n    return this.Data[index];\n  }\n\n  // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener);\n    }\n  }\n\n  // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1);\n    }\n  }\n\n  // 通知LazyForEach组件需要重载所有子组件\n  notifyDataReload(): void {\n    this.listeners.forEach(listener => {\n      listener.onDataReloaded();\n    })\n  }\n\n  // 通知LazyForEach组件需要在index对应索引处添加子组件\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index);\n    })\n  }\n\n  // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件\n  notifyDataChange(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataChange(index);\n    })\n  }\n\n  // 通知LazyForEach组件需要在index对应索引处删除该子组件\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataDelete(index);\n    })\n  }\n\n  // 通知LazyForEach组件将from索引和to索引处的子组件进行交换\n  notifyDataMove(from: number, to: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataMove(from, to);\n    })\n  }\n}
[h2]多种条目类型使用场景
标准型
复用组件之间布局完全相同;示例同列表滚动中描述;
有限变化型
复用组件之间有不同，但是类型有限;示例为复用组件显式设置两个reuseId与使用两个自定义组件进行复用;
class MyDataSource implements IDataSource {\n  private dataArray: string[] = [];\n  private listener: DataChangeListener | undefined;\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n  }\n\n  public reloadListener(): void {\n    this.listener?.onDataReloaded();\n  }\n\n  public registerDataChangeListener(listener: DataChangeListener): void {\n    this.listener = listener;\n  }\n\n  public unregisterDataChangeListener(listener: DataChangeListener): void {\n    this.listener = undefined;\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i < 1000; i++) {\n      this.data.pushData(i+\"\");\n    }\n  }\n\n  build() {\n    Column() {\n      List({ space: 10 }) {\n        LazyForEach(this.data, (item: number) => {\n          ListItem() {\n            ReusableComponent({ item: item })\n              .reuseId(item % 2 === 0 ? 'ReusableComponentOne' : 'ReusableComponentTwo')\n          }\n          .backgroundColor(Color.Orange)\n          .width('100%')\n        }, (item: number) => item.toString())\n      }\n      .cachedCount(2)\n    }\n  }\n}\n\n@Reusable\n@Component\nstruct ReusableComponent {\n  @State item: number = 0;\n\n  aboutToReuse(params: ESObject) {\n    this.item = params.item;\n  }\n\n  build() {\n    Column() {\n      if (this.item % 2 === 0) {\n        Text(`Item ${this.item} ReusableComponentOne`)\n          .fontSize(20)\n          .margin({ left: 10 })\n      } else {\n        Text(`Item ${this.item} ReusableComponentTwo`)\n          .fontSize(20)\n          .margin({ left: 10 })\n      }\n    }.margin({ left: 10, right: 10 })\n  }\n}
组合型
复用组件之间有不同，情况非常多，但是拥有共同的子组件;示例按照组合型的组件复用方式，将三种复用组件转变为Builder函数后，内部共同的子组件就处于同一个父组件MyComponent下;对这些子组件使用组件复用时，它们的缓存池也会在父组件上共享，节省组件创建时的消耗。
class MyDataSource implements IDataSource {\n  private dataArray: string[] = [];\n  private listener: DataChangeListener | undefined;\n\n  public totalCount(): number {\n    return this.dataArray.length;\n  }\n\n  public getData(index: number): string {\n    return this.dataArray[index];\n  }\n\n  public pushData(data: string): void {\n    this.dataArray.push(data);\n  }\n\n  public reloadListener(): void {\n    this.listener?.onDataReloaded();\n  }\n\n  public registerDataChangeListener(listener: DataChangeListener): void {\n    this.listener = listener;\n  }\n\n  public unregisterDataChangeListener(listener: DataChangeListener): void {\n    this.listener = undefined;\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear() {\n    for (let i = 0; i < 1000; i++) {\n      this.data.pushData(i.toString())\n    }\n  }\n\n// itemBuilderOne作为复用组件的写法未展示，以下为转为Builder之后的写法\n  @Builder\n  itemBuilderOne(item: string) {\n    Column() {\n      ChildComponentA({ item: item })\n      ChildComponentB({ item: item })\n      ChildComponentC({ item: item })\n    }\n  }\n\n// itemBuilderTwo转为Builder之后的写法\n  @Builder\n  itemBuilderTwo(item: string) {\n    Column() {\n      ChildComponentA({ item: item })\n      ChildComponentC({ item: item })\n      ChildComponentD({ item: item })\n    }\n  }\n\n// itemBuilderThree转为Builder之后的写法\n  @Builder\n  itemBuilderThree(item: string) {\n    Column() {\n      ChildComponentA({ item: item })\n      ChildComponentB({ item: item })\n      ChildComponentD({ item: item })\n    }\n  }\n\n  build() {\n    List({ space: 40 }) {\n      LazyForEach(this.data, (item: string, index: number) => {\n        ListItem() {\n          if (index % 3 === 0) {\n            this.itemBuilderOne(item)\n          } else if (index % 5 === 0) {\n            this.itemBuilderTwo(item)\n          } else {\n            this.itemBuilderThree(item)\n          }\n        }\n        .backgroundColor('#cccccc')\n        .width('100%')\n        .onAppear(() => {\n          console.log(`ListItem ${index} onAppear`);\n        })\n      }, (item: number) => item.toString())\n    }\n    .width('100%')\n    .height('100%')\n    .cachedCount(0)\n  }\n}\n\n@Reusable\n@Component\nstruct ChildComponentA {\n  @State item: string = '';\n\n  aboutToReuse(params: ESObject) {\n    console.log(`ChildComponentA ${params.item} Reuse ${this.item}`);\n    this.item = params.item;\n  }\n\n  aboutToRecycle(): void {\n    console.log(`ChildComponentA ${this.item} Recycle`);\n  }\n\n  build() {\n    Column() {\n      Text(`Item ${this.item} Child Component A`)\n        .fontSize(20)\n        .margin({ left: 10 })\n        .fontColor(Color.Blue)\n      Grid() {\n        ForEach((new Array(20)).fill(''), (item: string,index: number) => {\n          GridItem() {\n            // 请开发者自行在src/main/resources/base/media路径下添加app.media.startIcon图片，否则运行时会因资源缺失而报错\n            Image($r('app.media.startIcon'))\n              .height(20)\n          }\n        })\n      }\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr')\n      .rowsTemplate('1fr 1fr 1fr 1fr')\n      .columnsGap(10)\n      .width('90%')\n      .height(160)\n    }\n    .margin({ left: 10, right: 10 })\n    .backgroundColor(0xFAEEE0)\n  }\n}\n\n@Reusable\n@Component\nstruct ChildComponentB {\n  @State item: string = '';\n\n  aboutToReuse(params: ESObject) {\n    this.item = params.item;\n  }\n\n  build() {\n    Row() {\n      Text(`Item ${this.item} Child Component B`)\n        .fontSize(20)\n        .margin({ left: 10 })\n        .fontColor(Color.Red)\n    }.margin({ left: 10, right: 10 })\n  }\n}\n\n@Reusable\n@Component\nstruct ChildComponentC {\n  @State item: string = '';\n\n  aboutToReuse(params: ESObject) {\n    this.item = params.item;\n  }\n\n  build() {\n    Row() {\n      Text(`Item ${this.item} Child Component C`)\n        .fontSize(20)\n        .margin({ left: 10 })\n        .fontColor(Color.Green)\n    }.margin({ left: 10, right: 10 })\n  }\n}\n\n@Reusable\n@Component\nstruct ChildComponentD {\n  @State item: string = '';\n\n  aboutToReuse(params: ESObject) {\n    this.item = params.item;\n  }\n\n  build() {\n    Row() {\n      Text(`Item ${this.item} Child Component D`)\n        .fontSize(20)\n        .margin({ left: 10 })\n        .fontColor(Color.Orange)\n    }.margin({ left: 10, right: 10 })\n  }\n}

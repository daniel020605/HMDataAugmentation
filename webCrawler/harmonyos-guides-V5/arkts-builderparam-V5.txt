@BuilderParam装饰器：引用@Builder函数
当开发者创建了自定义组件，并想对该组件添加特定功能，例如想在某一个指定的自定义组件中添加一个点击跳转操作，此时若直接在组件内嵌入事件方法，将会导致所有该自定义组件的实例都增加了功能。为解决此问题，ArkUI引入了@BuilderParam装饰器，@BuilderParam用来装饰指向@Builder方法的变量（@BuilderParam是用来承接@Builder函数的）。开发者可以在初始化自定义组件时，使用不同的方式（如：参数修改、尾随闭包、借用箭头函数等）对@BuilderParam装饰的自定义构建函数进行传参赋值，在自定义组件内部通过调用@BuilderParam为组件增加特定的功能。该装饰器用于声明任意UI描述的一个元素，类似slot占位符。
在阅读本文档前，建议提前阅读：@Builder。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 11开始，该装饰器支持在元服务中使用。
装饰器使用说明
[h2]初始化@BuilderParam装饰的方法
@BuilderParam装饰的方法只能被自定义构建函数（@Builder装饰的方法）初始化。
使用所属自定义组件的自定义构建函数或者全局的自定义构建函数，在本地初始化@BuilderParam。 @Builder function overBuilder() {}\n\n@Component\nstruct Child {\n  @Builder doNothingBuilder() {};\n  // 使用自定义组件的自定义构建函数初始化@BuilderParam\n  @BuilderParam customBuilderParam: () => void = this.doNothingBuilder;\n  // 使用全局自定义构建函数初始化@BuilderParam\n  @BuilderParam customOverBuilderParam: () => void = overBuilder;\n  build(){}\n} 用父组件自定义构建函数初始化子组件@BuilderParam装饰的方法。 @Component\nstruct Child {\n  @Builder customBuilder() {};\n  @BuilderParam customBuilderParam: () => void = this.customBuilder;\n\n  build() {\n    Column() {\n      this.customBuilderParam()\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @Builder componentBuilder() {\n    Text(`Parent builder `)\n  }\n\n  build() {\n    Column() {\n      Child({ customBuilderParam: this.componentBuilder })\n    }\n  }\n} 图1 示例效果图  需要注意this的指向。 以下示例对this的指向做了介绍。 @Component\nstruct Child {\n  label: string = `Child`;\n  @Builder customBuilder() {};\n  @Builder customChangeThisBuilder() {};\n  @BuilderParam customBuilderParam: () => void = this.customBuilder;\n  @BuilderParam customChangeThisBuilderParam: () => void = this.customChangeThisBuilder;\n\n  build() {\n    Column() {\n      this.customBuilderParam()\n      this.customChangeThisBuilderParam()\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  label: string = `Parent`;\n\n  @Builder componentBuilder() {\n    Text(`${this.label}`)\n  }\n\n  build() {\n    Column() {\n      // 调用this.componentBuilder()时，this指向当前@Entry所装饰的Parent组件，即label变量的值为\"Parent\"。\n      this.componentBuilder()\n      Child({\n        // 把this.componentBuilder传给子组件Child的@BuilderParam customBuilderParam，this指向的是子组件Child，即label变量的值为\"Child\"。\n        customBuilderParam: this.componentBuilder,\n        // 把():void=>{this.componentBuilder()}传给子组件Child的@BuilderParam customChangeThisBuilderParam，\n        // 因为箭头函数的this指向的是宿主对象，所以label变量的值为\"Parent\"。\n        customChangeThisBuilderParam: (): void => { this.componentBuilder() }\n      })\n    }\n  }\n} 图2 示例效果图  
限制条件
@BuilderParam装饰的变量只能使用@Builder函数来进行初始化。详情见@BuilderParam装饰器初始化的值必须为@Builder。 当@Require装饰器和@BuilderParam装饰器一起使用的时候，@BuilderParam装饰器必须进行初始化。详情见@Require装饰器和@BuilderParam装饰器联合使用。 在自定义组件尾随闭包的场景下，子组件有且仅有一个@BuilderParam用来接收此尾随闭包，且此@BuilderParam不能有参数。详情见尾随闭包初始化组件。 
使用场景
[h2]参数初始化组件
@BuilderParam装饰的方法可以是有参数和无参数的两种形式，需与指向的@Builder方法类型匹配。
class Tmp{\n  label: string = '';\n}\n\n@Builder function overBuilder($$: Tmp) {\n  Text($$.label)\n    .width(400)\n    .height(50)\n    .backgroundColor(Color.Green)\n}\n\n@Component\nstruct Child {\n  label: string = 'Child';\n  @Builder customBuilder() {};\n  // 无参数类型，指向的customBuilder也是无参数类型\n  @BuilderParam customBuilderParam: () => void = this.customBuilder;\n  // 有参数类型，指向的overBuilder也是有参数类型的方法\n  @BuilderParam customOverBuilderParam: ($$: Tmp) => void = overBuilder;\n\n  build() {\n    Column() {\n      this.customBuilderParam()\n      this.customOverBuilderParam({label: 'global Builder label' } )\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  label: string = 'Parent';\n\n  @Builder componentBuilder() {\n    Text(`${this.label}`)\n  }\n\n  build() {\n    Column() {\n      this.componentBuilder()\n      Child({ customBuilderParam: this.componentBuilder, customOverBuilderParam: overBuilder })\n    }\n  }\n}
图3 示例效果图
[h2]尾随闭包初始化组件
在自定义组件中使用@BuilderParam装饰的属性时也可通过尾随闭包进行初始化。在初始化自定义组件时，组件后紧跟一个大括号“{}”形成尾随闭包场景。
此场景下自定义组件内有且仅有一个使用@BuilderParam装饰的属性。 此场景下自定义组件不支持使用通用属性。 
开发者可以将尾随闭包内的内容看做@Builder装饰的函数传给@BuilderParam。
示例1：
@Component\nstruct CustomContainer {\n  @Prop header: string = '';\n  @Builder closerBuilder(){};\n  // 使用父组件的尾随闭包{}(@Builder装饰的方法)初始化子组件@BuilderParam\n  @BuilderParam closer: () => void = this.closerBuilder;\n\n  build() {\n    Column() {\n      Text(this.header)\n        .fontSize(30)\n      this.closer()\n    }\n  }\n}\n\n@Builder function specificParam(label1: string, label2: string) {\n  Column() {\n    Text(label1)\n      .fontSize(30)\n    Text(label2)\n      .fontSize(30)\n  }\n}\n\n@Entry\n@Component\nstruct CustomContainerUser {\n  @State text: string = 'header';\n\n  build() {\n    Column() {\n      // 创建CustomContainer，在创建CustomContainer时，通过其后紧跟一个大括号“{}”形成尾随闭包\n      // 作为传递给子组件CustomContainer @BuilderParam closer: () => void的参数\n      CustomContainer({ header: this.text }) {\n        Column() {\n          specificParam('testA', 'testB')\n        }.backgroundColor(Color.Yellow)\n        .onClick(() => {\n          this.text = 'changeHeader';\n        })\n      }\n    }\n  }\n}
图4 示例效果图
使用全局@Builder和局部@Builder通过尾随闭包的形式去初始化@ComponentV2修饰的自定义组件中的@BuilderParam。
示例2：
@ComponentV2\nstruct ChildPage {\n  @Require @Param message: string = \"\";\n  @Builder customBuilder() {};\n  @BuilderParam customBuilderParam: () => void = this.customBuilder;\n\n  build() {\n    Column() {\n      Text(this.message)\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold)\n      this.customBuilderParam()\n    }\n  }\n}\n\nconst builder_value: string = 'Hello World';\n@Builder function overBuilder() {\n  Row() {\n    Text(`全局 Builder: ${builder_value}`)\n      .fontSize(20)\n      .fontWeight(FontWeight.Bold)\n  }\n}\n\n@Entry\n@ComponentV2\nstruct ParentPage {\n  @Local label: string = `Parent Page`;\n\n  @Builder componentBuilder() {\n    Row(){\n      Text(`局部 Builder :${this.label}`)\n        .fontSize(20)\n        .fontWeight(FontWeight.Bold)\n    }\n  }\n\n  build() {\n    Column() {\n      ChildPage({ message: this.label}){\n        Column() {  // 使用局部@Builder，通过组件后紧跟一个大括号“{}”形成尾随闭包去初始化自定义组件@BuilderParam\n          this.componentBuilder();\n        }\n      }\n      Line()\n        .width('100%')\n        .height(10)\n        .backgroundColor('#000000').margin(10)\n      ChildPage({ message: this.label}){  // 使用全局@Builder，通过组件后紧跟一个大括号“{}”形成尾随闭包去初始化自定义组件@BuilderParam\n        Column() {\n          overBuilder();\n        }\n      }\n    }\n  }\n}
[h2]使用全局和局部@Builder初始化@BuilderParam
在自定义组件中，使用@BuilderParam修饰的变量接收来自父组件通过@Builder传递的内容进行初始化，因为父组件的@Builder可以使用箭头函数的形式改变当前的this指向，所以当使用@BuilderParam修饰的变量时，会展示出不同的内容。
@Component\nstruct ChildPage {\n  label: string = `Child Page`;\n  @Builder customBuilder() {};\n  @BuilderParam customBuilderParam: () => void = this.customBuilder;\n  @BuilderParam customChangeThisBuilderParam: () => void = this.customBuilder;\n\n  build() {\n    Column() {\n      this.customBuilderParam()\n      this.customChangeThisBuilderParam()\n    }\n  }\n}\n\nconst builder_value: string = 'Hello World';\n@Builder function overBuilder() {\n  Row() {\n    Text(`全局 Builder: ${builder_value}`)\n      .fontSize(20)\n      .fontWeight(FontWeight.Bold)\n  }\n}\n\n@Entry\n@Component\nstruct ParentPage {\n  label: string = `Parent Page`;\n\n  @Builder componentBuilder() {\n    Row(){\n      Text(`局部 Builder :${this.label}`)\n        .fontSize(20)\n        .fontWeight(FontWeight.Bold)\n    }\n  }\n\n  build() {\n    Column() {\n      // 调用this.componentBuilder()时，this指向当前@Entry所装饰的ParentPage组件，所以label变量的值为\"Parent Page\"。\n      this.componentBuilder()\n      ChildPage({\n        // 把this.componentBuilder传给子组件ChildPage的@BuilderParam customBuilderParam，this指向的是子组件ChildPage，所以label变量的值为\"Child Page\"。\n        customBuilderParam: this.componentBuilder,\n        // 把():void=>{this.componentBuilder()}传给子组件ChildPage的@BuilderParam customChangeThisBuilderParam，\n        // 因为箭头函数的this指向的是宿主对象，所以label变量的值为\"Parent Page\"。\n        customChangeThisBuilderParam: (): void => { this.componentBuilder() }\n      })\n      Line()\n        .width('100%')\n        .height(10)\n        .backgroundColor('#000000').margin(10)\n      // 调用全局overBuilder()时，this指向当前整个活动页，所以展示的内容为\"Hello World\"。\n      overBuilder()\n      ChildPage({\n        // 把全局overBuilder传给子组件ChildPage的@BuilderParam customBuilderParam，this指向当前整个活动页，所以展示的内容为\"Hello World\"。\n        customBuilderParam: overBuilder,\n        // 把全局overBuilder传给子组件ChildPage的@BuilderParam customChangeThisBuilderParam，this指向当前整个活动页，所以展示的内容为\"Hello World\"。\n        customChangeThisBuilderParam: overBuilder\n      })\n    }\n  }\n}
图5 示例效果图
[h2]在@ComponentV2修饰的自定义组件中使用@BuilderParam
使用全局@Builder和局部@Builder去初始化@CompoentV2修饰的自定义组件中的@BuilderParam属性。
@ComponentV2\nstruct ChildPage {\n  @Param label: string = `Child Page`;\n  @Builder customBuilder() {};\n  @BuilderParam customBuilderParam: () => void = this.customBuilder;\n  @BuilderParam customChangeThisBuilderParam: () => void = this.customBuilder;\n\n  build() {\n    Column() {\n      this.customBuilderParam()\n      this.customChangeThisBuilderParam()\n    }\n  }\n}\n\nconst builder_value: string = 'Hello World';\n@Builder function overBuilder() {\n  Row() {\n    Text(`全局 Builder: ${builder_value}`)\n      .fontSize(20)\n      .fontWeight(FontWeight.Bold)\n  }\n}\n\n@Entry\n@ComponentV2\nstruct ParentPage {\n  @Local label: string = `Parent Page`;\n\n  @Builder componentBuilder() {\n    Row(){\n      Text(`局部 Builder :${this.label}`)\n        .fontSize(20)\n        .fontWeight(FontWeight.Bold)\n    }\n  }\n\n  build() {\n    Column() {\n      // 调用this.componentBuilder()时，this指向当前@Entry所装饰的ParentPage组件，所以label变量的值为\"Parent Page\"。\n      this.componentBuilder()\n      ChildPage({\n        // 把this.componentBuilder传给子组件ChildPage的@BuilderParam customBuilderParam，this指向的是子组件ChildPage，所以label变量的值为\"Child Page\"。\n        customBuilderParam: this.componentBuilder,\n        // 把():void=>{this.componentBuilder()}传给子组件ChildPage的@BuilderParam customChangeThisBuilderPara\n        // 因为箭头函数的this指向的是宿主对象，所以label变量的值为\"Parent Page\"。\n        customChangeThisBuilderParam: (): void => { this.componentBuilder() }\n      })\n      Line()\n        .width('100%')\n        .height(5)\n        .backgroundColor('#000000').margin(10)\n      // 调用全局overBuilder()时，this指向当前整个活动页，所以展示的内容为\"Hello World\"。\n      overBuilder()\n      ChildPage({\n        // 把全局overBuilder传给子组件ChildPage的@BuilderParam customBuilderParam，this指向当前整个活动页，所以展示的内容为\"Hello World\"。\n        customBuilderParam: overBuilder,\n        // 把全局overBuilder传给子组件ChildPage的@BuilderParam customChangeThisBuilderParam，this指向当前整个活动页，所以展示的内容为\"Hello World\"。\n        customChangeThisBuilderParam: overBuilder\n      })\n    }\n  }\n}
图6 示例效果图
常见问题
[h2]改变内容UI不刷新
当调用自定义组件ChildPage时，把@Builder作为参数通过this.componentBuilder的形式传递，当前this会指向自定义组件内部，所以在父组件里面改变label的值，自定义组件ChildPage是感知不到的。
【反例】
@Component\nstruct ChildPage {\n  @State label: string = `Child Page`;\n  @Builder customBuilder() {};\n  @BuilderParam customChangeThisBuilderParam: () => void = this.customBuilder;\n\n  build() {\n    Column() {\n      this.customChangeThisBuilderParam()\n    }\n  }\n}\n\n@Entry\n@Component\nstruct ParentPage {\n  @State label: string = `Parent Page`;\n\n  @Builder componentBuilder() {\n    Row(){\n      Text(`Builder :${this.label}`)\n        .fontSize(20)\n        .fontWeight(FontWeight.Bold)\n    }\n  }\n\n  build() {\n    Column() {\n      ChildPage({\n        // 当前写法this指向ChildPage组件内\n        customChangeThisBuilderParam: this.componentBuilder\n      })\n      Button('点击改变label内容')\n        .onClick(() => {\n          this.label = 'Hello World';\n        })\n    }\n  }\n}
使用箭头函数的形式把@Builder传递进自定义组件ChildPage中，当前this指向会停留在父组件ParentPage里，所以在父组件里改变label的值，自定义组件ChildPage会感知到并重新渲染UI。
把@Builder改为@LocalBuilder也能实现动态渲染UI功能。
【正例】
@Component\nstruct ChildPage {\n  @State label: string = `Child Page`;\n  @Builder customBuilder() {};\n  @BuilderParam customChangeThisBuilderParam: () => void = this.customBuilder;\n\n  build() {\n    Column() {\n      this.customChangeThisBuilderParam()\n    }\n  }\n}\n\n@Entry\n@Component\nstruct ParentPage {\n  @State label: string = `Parent Page`;\n\n  @Builder componentBuilder() {\n    Row(){\n      Text(`Builder :${this.label}`)\n        .fontSize(20)\n        .fontWeight(FontWeight.Bold)\n    }\n  }\n\n  build() {\n    Column() {\n      ChildPage({\n        customChangeThisBuilderParam: () => { this.componentBuilder() }\n      })\n      Button('点击改变label内容')\n        .onClick(() => {\n          this.label = 'Hello World';\n        })\n    }\n  }\n}
[h2]@Require装饰器和@BuilderParam装饰器联合使用
由于@Require装饰器所装饰的变量需进行初始化，若变量未初始化，在编译时会输出报错信息。
【反例】
@Builder function globalBuilder() {\n  Text('Hello World')\n}\n\n@Entry\n@Component\nstruct customBuilderDemo {\n  build() {\n    Column() {\n      // 由于未对子组件ChildBuilder进行赋值，此处无论是编译还是编辑，均会报错。\n      ChildPage()\n    }\n  }\n}\n\n@Component\nstruct ChildPage {\n  @Require @BuilderParam ChildBuilder: () => void = globalBuilder;\n  build() {\n    Column() {\n      this.ChildBuilder()\n    }\n  }\n}
对使用@Require装饰器修饰的变量进行初始化，此时，编译不会报错，无报错信息。
【正例】
@Builder function globalBuilder() {\n  Text('Hello World')\n}\n\n@Entry\n@Component\nstruct customBuilderDemo {\n  build() {\n    Column() {\n      ChildPage({ChildBuilder: globalBuilder})\n    }\n  }\n}\n\n@Component\nstruct ChildPage {\n  @Require @BuilderParam ChildBuilder: () => void = globalBuilder;\n  build() {\n    Column() {\n      this.ChildBuilder()\n    }\n  }\n}
[h2]@BuilderParam装饰器初始化的值必须为@Builder
使用@State装饰器修饰的变量，给子组件@BuilderParam和ChildBuilder变量进行初始化，在编译时会输出报错信息。
【反例】
@Builder function globalBuilder() {\n  Text('Hello World')\n}\n@Entry\n@Component\nstruct customBuilderDemo {\n  @State message: string = \"\";\n  build() {\n    Column() {\n      // 子组件ChildBuilder接收@State修饰的变量，会出现编译和编辑报错\n      ChildPage({ChildBuilder: this.message})\n    }\n  }\n}\n\n@Component\nstruct ChildPage {\n  @BuilderParam ChildBuilder: () => void = globalBuilder;\n  build() {\n    Column() {\n      this.ChildBuilder()\n    }\n  }\n}
使用全局的@Builder修饰的globalBuilder()给子组件@BuilderParam修饰的ChildBuilder变量进行初始化，编译时没有报错，功能正常。
【正例】
@Builder function globalBuilder() {\n  Text('Hello World')\n}\n@Entry\n@Component\nstruct customBuilderDemo {\n  build() {\n    Column() {\n      ChildPage({ChildBuilder: globalBuilder})\n    }\n  }\n}\n\n@Component\nstruct ChildPage {\n  @BuilderParam ChildBuilder: () => void = globalBuilder;\n  build() {\n    Column() {\n      this.ChildBuilder()\n    }\n  }\n}

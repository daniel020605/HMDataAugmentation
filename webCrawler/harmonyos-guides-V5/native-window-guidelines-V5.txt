NativeWindow开发指导 (C/C++)
场景介绍
NativeWindow是本地平台化窗口，表示图形队列的生产者端。开发者可以通过NativeWindow接口进行申请和提交Buffer，配置Buffer属性信息。
针对NativeWindow，常见的开发场景如下：
 通过NativeWindow提供的Native API接口申请图形Buffer，并将生产图形内容写入图形Buffer，最终提交Buffer到图形队列 在适配EGL层的eglswapbuffer接口时，进行申请和提交Buffer 
接口说明
详细的接口说明请参考native_window。
开发步骤
以下步骤描述了如何使用NativeWindow提供的Native API接口，申请图形Buffer，并将生产图形内容写入图形Buffer后，最终提交Buffer到图形队列。
添加动态链接库
CMakeLists.txt中添加以下lib。
libace_ndk.z.so\nlibnative_window.so
头文件
#include <sys/poll.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <ace/xcomponent/native_interface_xcomponent.h>\n#include <native_window/external_window.h>
 获取OHNativeWindow实例。 可在OH_NativeXComponent_Callback提供的接口中获取OHNativeWindow，下面提供一份代码示例。XComponent模块的具体使用方法请参考XComponent开发指导。  在xxx.ets中添加一个XComponent组件。 XComponent({ id: 'xcomponentId', type: 'surface', libraryname: 'entry'})\n    .width(360)\n    .height(360) 在 native c++ 层获取 NativeXComponent。 napi_value exportInstance = nullptr;\n// 用来解析出被wrap了NativeXComponent指针的属性\nnapi_get_named_property(env, exports, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance);\nOH_NativeXComponent *nativeXComponent = nullptr;\n// 通过napi_unwrap接口，解析出NativeXComponent的实例指针\nnapi_unwrap(env, exportInstance, reinterpret_cast<void**>(&nativeXComponent));\n// 获取XComponentId\nchar idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {};\nuint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\nOH_NativeXComponent_GetXComponentId(nativeXComponent, idStr, &idSize); 定义 OH_NativeXComponent_Callback。 // 定义回调函数\nvoid OnSurfaceCreatedCB(OH_NativeXComponent* component, void* window)\n{\n    // 可获取 OHNativeWindow 实例\n    OHNativeWindow* nativeWindow = static_cast<OHNativeWindow*>(window);\n    // 此回调触发后，window默认引用计数会设置为1，若存在并发使用了window相关的接口和xcomponent析构的情况，\n    // 则需要通过OH_NativeWindow_NativeObjectReference和OH_NativeWindow_NativeObjectUnreference对window进行\n    // 手动引用计数加1和减1，防止xcomponent析构后，并发调用window相关接口触发野指针或空指针的崩溃。\n}\nvoid OnSurfaceChangedCB(OH_NativeXComponent* component, void* window)\n{\n    // 可获取 OHNativeWindow 实例\n    OHNativeWindow* nativeWindow = static_cast<OHNativeWindow*>(window);\n    // ...\n}\nvoid OnSurfaceDestroyedCB(OH_NativeXComponent* component, void* window)\n{\n    // 可获取 OHNativeWindow 实例\n    OHNativeWindow* nativeWindow = static_cast<OHNativeWindow*>(window);\n    // 此回调触发后，会将window进行引用计数减1的操作，当window的应用计数为0后，会触发window的析构，\n    // window析构后，不可再通过window进行接口调用，否则可能会触发野指针或空指针的崩溃。\n}\nvoid DispatchTouchEventCB(OH_NativeXComponent* component, void* window)\n{\n    // 可获取 OHNativeWindow 实例\n    OHNativeWindow* nativeWindow = static_cast<OHNativeWindow*>(window);\n    // ...\n} // 初始化 OH_NativeXComponent_Callback\nOH_NativeXComponent_Callback callback;\ncallback.OnSurfaceCreated = OnSurfaceCreatedCB;\ncallback.OnSurfaceChanged = OnSurfaceChangedCB;\ncallback.OnSurfaceDestroyed = OnSurfaceDestroyedCB;\ncallback.DispatchTouchEvent = DispatchTouchEventCB; 将OH_NativeXComponent_Callback 注册给 NativeXComponent。 // 注册回调函数\nOH_NativeXComponent_RegisterCallback(nativeXComponent, &callback);  设置OHNativeWindowBuffer的属性。使用OH_NativeWindow_NativeWindowHandleOpt设置OHNativeWindowBuffer的属性。 // 设置 OHNativeWindowBuffer 的宽高\nint32_t code = SET_BUFFER_GEOMETRY;\nint32_t width = 0x100;\nint32_t height = 0x100;\n// 这里的nativeWindow是从上一步骤中的回调函数中获得的\nint32_t ret = OH_NativeWindow_NativeWindowHandleOpt(nativeWindow, code, width, height); 从图形队列申请OHNativeWindowBuffer。 OHNativeWindowBuffer* buffer = nullptr;\nint releaseFenceFd = -1;\n// 通过 OH_NativeWindow_NativeWindowRequestBuffer 获取 OHNativeWindowBuffer 实例\nret = OH_NativeWindow_NativeWindowRequestBuffer(nativeWindow, &buffer, &releaseFenceFd);\nif (ret != 0 || buffer == nullptr) {\n    return;\n}\n// 通过 OH_NativeWindow_GetBufferHandleFromNative 获取 buffer 的 handle\nBufferHandle* bufferHandle = OH_NativeWindow_GetBufferHandleFromNative(buffer); 内存映射mmap。 #include <sys/mman.h>\n\n// 使用内存映射函数mmap将bufferHandle对应的共享内存映射到用户空间，可以通过映射出来的虚拟地址向bufferHandle中写入图像数据\n// bufferHandle->virAddr是bufferHandle在共享内存中的起始地址，bufferHandle->size是bufferHandle在共享内存中的内存占用大小\nvoid* mappedAddr = mmap(bufferHandle->virAddr, bufferHandle->size, PROT_READ | PROT_WRITE, MAP_SHARED, bufferHandle->fd, 0);\nif (mappedAddr == MAP_FAILED) {\n    // mmap failed\n} 将生产的内容写入OHNativeWindowBuffer，在这之前需要等待releaseFenceFd可用（注意releaseFenceFd不等于-1才需要调用poll）。如果没有等待releaseFenceFd事件的数据可用（POLLIN），则可能造成花屏、裂屏、HEBC（High Efficiency Bandwidth Compression，高效带宽压缩） fault等问题。releaseFenceFd是消费者进程创建的一个文件句柄，代表消费者消费buffer完毕，buffer可读，生产者可以开始填充buffer内容。 int retCode = -1;\nuint32_t timeout = 3000;\nif (releaseFenceFd != -1) {\n    struct pollfd pollfds = {0};\n    pollfds.fd = releaseFenceFd;\n    pollfds.events = POLLIN;\n    do {\n        retCode = poll(&pollfds, 1, timeout);\n    } while (retCode == -1 && (errno == EINTR || errno == EAGAIN));\n    close(releaseFenceFd); // 防止fd泄漏\n}\n\nstatic uint32_t value = 0x00;\nvalue++;\nuint32_t *pixel = static_cast<uint32_t *>(mappedAddr); // 使用mmap获取到的地址来访问内存\nfor (uint32_t x = 0; x < width; x++) {\n    for (uint32_t y = 0;  y < height; y++) {\n        *pixel++ = value;\n    }\n} 提交OHNativeWindowBuffer到图形队列。请注意OH_NativeWindow_NativeWindowFlushBuffer接口的acquireFenceFd不可以和OH_NativeWindow_NativeWindowRequestBuffer接口获取的releaseFenceFd相同，acquireFenceFd可传入默认值-1。acquireFenceFd是生产者需要传入的文件句柄，消费者获取到buffer后可根据生产者传入的acquireFenceFd决定何时去渲染并上屏buffer内容。 // 设置刷新区域，如果Region中的Rect为nullptr,或者rectNumber为0，则认为OHNativeWindowBuffer全部有内容更改。\nRegion region{nullptr, 0};\nint acquireFenceFd = -1;\n// 通过OH_NativeWindow_NativeWindowFlushBuffer 提交给消费者使用，例如：显示在屏幕上。\nOH_NativeWindow_NativeWindowFlushBuffer(nativeWindow, buffer, acquireFenceFd, region); 取消内存映射munmap。 // 内存使用完记得去掉内存映射\nint result = munmap(mappedAddr, bufferHandle->size);\nif (result == -1) {\n    // munmap failed\n} 

使用JSVM-API接口进行函数创建和调用
简介
函数调用允许开发者从JSVM模块中调用JavaScript函数，并传递参数进行调用，或者直接在JSVM模块中创建一个JavaScript方法。
基本概念
函数是一种非常重要的编程概念，可以执行特定的任务或操作、提高代码的可读性、把复杂任务简化、提高代码复用性以及支持代码的组织与管理。每个函数可以负责不同的功能，提供一种将代码模块化和组织结构化的方式，使其更易于理解、维护和重用。
接口说明
使用示例
JSVM-API接口开发流程参考使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应C++相关代码进行展示。
[h2]OH_JSVM function整合测试
cpp测试全量代码，入口为TEST_FUNC
#include \"hilog/log.h\"\n#include \"ark_runtime/jsvm.h\"\n\n#define LOG_DOMAIN 0x3200\n#define LOG_TAG \"APP\"\n\n#define CHECK_RET(cond) \\\n  if ((cond)) { \\\n    const JSVM_ExtendedErrorInfo* info; \\\n    OH_JSVM_GetLastErrorInfo(env, &info); \\\n    OH_LOG_ERROR(LOG_APP, \"jsvm fail file: %{public}s line: %{public}d ret = %{public}d message = %{public}s\", __FILE__, __LINE__, cond, info != nullptr ? info->errorMessage : \"\"); \\\n    return -1;   \\\n  }\n\n#define CHECK(cond) \\\n  if (!(cond)) { \\\n     OH_LOG_ERROR(LOG_APP, \"jsvm fail file: %{public}s line: %{public}d ret = %{public}d\", __FILE__, __LINE__, cond); \\\n     return -1;   \\\n  }\n\nJSVM_Value NativeCreateFunctionTest(JSVM_Env env, JSVM_CallbackInfo info) {\n    void *data;\n    size_t argc = 1;\n    JSVM_Value argv[1] = {nullptr};\n    JSVM_Value thisArg;\n    // 获取callback 参数信息\n    JSVM_Status ret = OH_JSVM_GetCbInfo(env, info, &argc, &argv[0], &thisArg, &data);\n    if (ret != JSVM_OK) {\n      const JSVM_ExtendedErrorInfo* info;\n      OH_JSVM_GetLastErrorInfo(env, &info);\n      OH_LOG_ERROR(LOG_APP, \"jsvm fail file: %{public}s line: %{public}d ret = %{public}d message = %{public}s\", __FILE__, __LINE__, ret, info != nullptr ? info->errorMessage : \"\");\n      return nullptr;\n    }\n    char message[256];\n    OH_JSVM_GetValueStringLatin1(env, argv[0], message, 256, nullptr);\n    if (data == nullptr) {\n        OH_LOG_ERROR(LOG_APP, \"jsvm: %{public}s; callback data null\", message);\n    } else {\n        OH_LOG_INFO(LOG_APP, \"jsvm: %{public}s; %{public}s\", message, (char*)data);\n    }\n    return nullptr;\n}\n\nstatic int32_t TEST_FUNC() {\n    JSVM_InitOptions initOptions{};\n    JSVM_VM vm;\n    JSVM_Env env = nullptr;\n    JSVM_VMScope vmScope;\n    JSVM_EnvScope envScope;\n    JSVM_HandleScope handleScope;\n    JSVM_Value result;\n    static bool isVMInit = false;\n    if (!isVMInit) {\n        isVMInit = true;\n        // 单个进程只用初始化一次\n        OH_JSVM_Init(&initOptions);\n    }\n    CHECK_RET(OH_JSVM_CreateVM(nullptr, &vm));\n    CHECK_RET(OH_JSVM_CreateEnv(vm, 0, nullptr, &env));\n    CHECK_RET(OH_JSVM_OpenVMScope(vm, &vmScope));\n    CHECK_RET(OH_JSVM_OpenEnvScope(env, &envScope));\n    CHECK_RET(OH_JSVM_OpenHandleScope(env, &handleScope));\n\n    // 创建并检查函数\n    char hello[] = \"Hello World!\";\n    JSVM_CallbackStruct cb = {NativeCreateFunctionTest, (void*)hello};\n    JSVM_Value func;\n    CHECK_RET(OH_JSVM_CreateFunction(env, \"\", JSVM_AUTO_LENGTH, &cb, &func));\n    bool isFunction = false;\n    CHECK_RET(OH_JSVM_IsFunction(env, func, &isFunction));\n    CHECK(isFunction);\n\n    // 将函数设置到全局对象中\n    JSVM_Value global;\n    CHECK_RET(OH_JSVM_GetGlobal(env, &global));\n    JSVM_Value key;\n    CHECK_RET(OH_JSVM_CreateStringUtf8(env, \"NativeFunc\", JSVM_AUTO_LENGTH, &key));\n    CHECK_RET(OH_JSVM_SetProperty(env, global, key, func));\n\n    // 通过call 接口调用函数\n    JSVM_Value argv[1] = {nullptr};\n    OH_JSVM_CreateStringUtf8(env, \"jsvm api call function\", JSVM_AUTO_LENGTH, &argv[0]);\n    CHECK_RET(OH_JSVM_CallFunction(env, global, func, 1, argv, &result));\n\n    // 通过script调用函数\n    JSVM_Script script;\n    JSVM_Value jsSrc;\n    const char* srcCallNative = R\"JS(NativeFunc('js source call function');)JS\";\n    CHECK_RET(OH_JSVM_CreateStringUtf8(env, srcCallNative, JSVM_AUTO_LENGTH, &jsSrc));\n    CHECK_RET(OH_JSVM_CompileScript(env, jsSrc, nullptr, 0, true, nullptr, &script));\n    CHECK_RET(OH_JSVM_RunScript(env, script, &result));\n\n    CHECK_RET(OH_JSVM_CloseHandleScope(env, handleScope));\n    CHECK_RET(OH_JSVM_CloseEnvScope(env, envScope));\n    CHECK_RET(OH_JSVM_CloseVMScope(vm, vmScope));\n    CHECK_RET(OH_JSVM_DestroyEnv(env));\n    CHECK_RET(OH_JSVM_DestroyVM(vm));\n    return 0;\n}
预期的输出
jsvm: jsvm api call function; Hello World!\njsvm: js source call function; Hello World!

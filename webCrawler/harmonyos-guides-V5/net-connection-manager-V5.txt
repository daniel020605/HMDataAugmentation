网络连接管理
简介
网络连接管理提供管理网络一些基础能力，包括WiFi/蜂窝/Ethernet等多网络连接优先级管理、网络质量评估、订阅默认/指定网络连接状态变化、查询网络连接信息、DNS解析等功能。
为了保证应用的运行效率，大部分API调用都是异步的，对于异步调用的API均提供了callback和Promise两种方式，以下示例均采用promise函数，更多方式可以查阅API参考。
基本概念
 网络生产者：数据网络的提供方，比如WiFi、蜂窝、Ethernet等。 网络消费者：数据网络的使用方，比如应用或系统服务。 网络探测：检测网络有效性，避免将网络从可用网络切换到不可用网络。内容包括绑定网络探测、DNS探测、HTTP探测及HTTPS探测。 网络优选：处理多网络共存时选择最优网络。在网络状态、网络信息及评分发生变化时被触发。 
约束
 开发语言：JS 本模块首批接口从API version 8开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。 
场景介绍
网络连接管理的典型场景有：
 接收指定网络的状态变化通知 获取所有注册的网络 根据数据网络查询网络的连接信息 使用对应网络解析域名，获取所有IP 
以下分别介绍具体开发方式。
接口说明
完整的JS API说明以及实例代码请参考：网络连接管理。
接收指定网络的状态变化通知
 声明接口调用所需要的权限：ohos.permission.GET_NETWORK_INFO。 此权限级别为normal，在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。 从@kit.NetworkKit中导入connection命名空间。 调用createNetConnection方法，指定网络能力、网络类型和超时时间（可选，如不传入代表默认网络；创建不同于默认网络时可通过指定这些参数完成），创建一个NetConnection对象。 调用该对象的on()方法，传入type和callback，订阅关心的事件。 调用该对象的register()方法，订阅指定网络状态变化的通知。 当网络可用时，会收到netAvailable事件的回调；当网络不可用时，会收到netUnavailable事件的回调。 当不使用该网络时，可以调用该对象的unregister()方法，取消订阅。 
// 引入包名\nimport { connection } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet netSpecifier: connection.NetSpecifier = {\n  netCapabilities: {\n    // 假设当前默认网络是WiFi，需要创建蜂窝网络连接，可指定网络类型为蜂窝网\n    bearerTypes: [connection.NetBearType.BEARER_CELLULAR],\n    // 指定网络能力为Internet\n    networkCap: [connection.NetCap.NET_CAPABILITY_INTERNET]\n  },\n};\n\n// 指定超时时间为10s(默认值为0)\nlet timeout = 10 * 1000;\n\n// 创建NetConnection对象\nlet conn = connection.createNetConnection(netSpecifier, timeout);\n\n// 订阅指定网络状态变化的通知\nconn.register((err: BusinessError, data: void) => {\n  console.log(JSON.stringify(err));\n});\n\n// 订阅事件，如果当前指定网络可用，通过on_netAvailable通知用户\nconn.on('netAvailable', ((data: connection.NetHandle) => {\n  console.log(\"net is available, netId is \" + data.netId);\n}));\n\n// 订阅事件，如果当前指定网络不可用，通过on_netUnavailable通知用户\nconn.on('netUnavailable', ((data: void) => {\n  console.log(\"net is unavailable, data is \" + JSON.stringify(data));\n}));\n\n// 当不使用该网络时，可以调用该对象的unregister()方法，取消订阅\nconn.unregister((err: BusinessError, data: void) => {\n});
监控默认网络变化并主动重建网络连接
根据当前网络状态及网络质量情况，默认网络可能会发生变化，如：
 在WiFi弱信号的情况下，默认网络可能会切换到蜂窝网络。 在蜂窝网络状态差的情况下，默认网络可能会切换到WiFi。 关闭WiFi后，默认网络可能会切换到蜂窝网络。 关闭蜂窝网络后，默认网络可能会切换到WiFi。 在WiFi弱信号的情况下，默认网络可能会切换到其他WiFi（存在跨网情况）。 在蜂窝网络状态差的情况下，默认网络可能会切换到其他蜂窝（存在跨网情况）。 
本节旨在介绍监控默认网络的变化后，应用报文能够快速迁移到新默认网络上，具体做法如下。
[h2]监控默认网络变化
import { connection } from '@kit.NetworkKit';\n\nasync function test() {\n  const netConnection = connection.createNetConnection();\n\n  /* 监听默认网络改变 */\n  netConnection.on('netAvailable', (data: connection.NetHandle) => {\n    console.log(JSON.stringify(data));\n  });\n}
[h2]默认网络变化后重新建立网络连接
原网络连接使用http模块建立网络连接
如果您使用了http模块建立网络连接，由于该模块没有提供Close接口用于关闭Socket，在切换默认网络并建立新的网络连接后原有Socket不会立即关闭。因此请切换使用Remote Communication Kit建立网络连接。
原网络连接使用Remote Communication Kit建立网络连接
import { rcp } from '@kit.RemoteCommunicationKit';\nimport { connection } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet session = rcp.createSession();\n\nasync function useRcp() {\n  /* 建立rcp请求 */\n  try {\n    const request = await session.get('https://www.example.com');\n    console.info(request.statusCode.toString());\n  } catch (e) {\n    console.error(e.code.toString());\n  }\n}\n\nasync function rcpTest() {\n  const netConnection = connection.createNetConnection();\n  netConnection.on('netAvailable', async (netHandle: connection.NetHandle) => {\n    /* 发生默认网络切换，重新建立session */\n    session.close();\n    session = rcp.createSession();\n    useRcp();\n  });\n  try {\n    netConnection.register(() => {\n    });\n    useRcp();\n  } catch (e) {\n    console.error(e.code.toString());\n  }\n}
原网络连接使用Socket模块建立连接
import { connection, socket } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet sock: socket.TCPSocket = socket.constructTCPSocketInstance();\n\nasync function useSocket() {\n  let tcpConnectOptions: socket.TCPConnectOptions = {\n    address: {\n      address: '192.168.xx.xxx',\n      port: 8080\n    },\n    timeout: 6000\n  }\n\n  /* 建立socket连接 */\n  sock.connect(tcpConnectOptions, (err: BusinessError) => {\n    if (err) {\n      console.error('connect fail');\n      return;\n    }\n    console.log('connect success');\n\n    /* 通过socket发送数据 */\n    let tcpSendOptions: socket.TCPSendOptions = {\n      data: 'Hello, server!'\n    }\n    sock.send(tcpSendOptions).then(() => {\n      console.log('send success');\n    }).catch((err: BusinessError) => {\n      console.error('send fail');\n    });\n  })\n}\n\nasync function socketTest() {\n  const netConnection = connection.createNetConnection();\n  netConnection.on('netAvailable', async (netHandle: connection.NetHandle) => {\n    console.log('default network changed');\n    await sock.close();\n    sock = socket.constructTCPSocketInstance();\n    useSocket();\n  });\n  try {\n    netConnection.register(() => {\n    });\n    useSocket();\n  } catch (e) {\n    console.error(e.code.toString());\n  }\n}
原网络连接使用Socket Library建立网络连接
请在监控到默认网络变化后关闭原有Socket并重新建立Socket连接。
获取所有注册的网络
 声明接口调用所需要的权限：ohos.permission.GET_NETWORK_INFO。 此权限级别为normal，在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。 从@kit.NetworkKit中导入connection命名空间。 调用getAllNets方法，获取所有处于连接状态的网络列表。 
// 引入包名\nimport { connection } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n// 构造单例对象\nexport class GlobalContext {\n  public netList: connection.NetHandle[] = [];\n  private constructor() {}\n  private static instance: GlobalContext;\n  private _objects = new Map<string, Object>();\n\n  public static getContext(): GlobalContext {\n    if (!GlobalContext.instance) {\n      GlobalContext.instance = new GlobalContext();\n    }\n    return GlobalContext.instance;\n  }\n\n  getObject(value: string): Object | undefined {\n    return this._objects.get(value);\n  }\n\n  setObject(key: string, objectClass: Object): void {\n    this._objects.set(key, objectClass);\n  }\n}\n\n// 获取所有处于连接状态的网络列表\nconnection.getAllNets().then((data: connection.NetHandle[]) => {\n  console.info(\"Succeeded to get data: \" + JSON.stringify(data));\n  if (data) {\n    GlobalContext.getContext().netList = data;\n  }\n});
根据数据网络查询网络的能力信息及连接信息
 声明接口调用所需要的权限：ohos.permission.GET_NETWORK_INFO。 此权限级别为normal，在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。 从@kit.NetworkKit中导入connection命名空间。 通过调用getDefaultNet方法，获取默认的数据网络(NetHandle)；或者通过调用getAllNets方法，获取所有处于连接状态的网络列表(Array<NetHandle>)。 调用getNetCapabilities方法，获取NetHandle对应网络的能力信息。能力信息包含了网络类型(蜂窝网络、Wi-Fi网络、以太网网络等)、网络具体能力等网络信息。 调用getConnectionProperties方法，获取NetHandle对应网络的连接信息。 
import { connection } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n// 构造单例对象\nexport class GlobalContext {\n  public netList: connection.NetHandle[] = [];\n  public netHandle: connection.NetHandle|null = null;\n  private constructor() {}\n  private static instance: GlobalContext;\n  private _objects = new Map<string, Object>();\n\n  public static getContext(): GlobalContext {\n    if (!GlobalContext.instance) {\n      GlobalContext.instance = new GlobalContext();\n    }\n    return GlobalContext.instance;\n  }\n\n  getObject(value: string): Object | undefined {\n    return this._objects.get(value);\n  }\n\n  setObject(key: string, objectClass: Object): void {\n    this._objects.set(key, objectClass);\n  }\n}\n\n// 调用getDefaultNet方法，获取默认的数据网络(NetHandle)\nconnection.getDefaultNet().then((data:connection.NetHandle) => {\n  if (data.netId == 0) {\n    // 当前无默认网络时，获取的netHandler的netid为0,属于异常情况，需要额外处理\n    return;\n  }\n  if (data) {\n    console.info(\"getDefaultNet get data: \" + JSON.stringify(data));\n    GlobalContext.getContext().netHandle = data;\n    // 获取netHandle对应网络的能力信息。能力信息包含了网络类型、网络具体能力等网络信息\n   connection.getNetCapabilities(GlobalContext.getContext().netHandle).then(\n      (data: connection.NetCapabilities) => {\n      console.info(\"getNetCapabilities get data: \" + JSON.stringify(data));\n      // 获取网络类型(bearerTypes)\n      let bearerTypes: Set<number> = new Set(data.bearerTypes);\n      let bearerTypesNum = Array.from(bearerTypes.values());\n      for (let item of bearerTypesNum) {\n        if (item == 0) {\n          // 蜂窝网\n          console.log(JSON.stringify(\"BEARER_CELLULAR\"));\n        } else if (item == 1) {\n          // Wi-Fi网络\n          console.log(JSON.stringify(\"BEARER_WIFI\"));\n        } else if (item == 3) {\n          // 以太网网络\n          console.log(JSON.stringify(\"BEARER_ETHERNET\"));\n        }\n      }\n      \n      // 获取网络具体能力(networkCap)\n      let itemNumber : Set<number> = new Set(data.networkCap);\n      let dataNumber = Array.from(itemNumber.values());\n      for (let item of dataNumber) {\n        if (item == 0) {\n          // 表示网络可以访问运营商的MMSC（Multimedia Message Service，多媒体短信服务）发送和接收彩信\n          console.log(JSON.stringify(\"NET_CAPABILITY_MMS\"));\n        } else if (item == 11) {\n          // 表示网络流量未被计费\n          console.log(JSON.stringify(\"NET_CAPABILITY_NOT_METERED\"));\n        } else if (item == 12) {\n          // 表示该网络应具有访问Internet的能力，该能力由网络提供者设置\n          console.log(JSON.stringify(\"NET_CAPABILITY_INTERNET\"));\n        } else if (item == 15) {\n          // 表示网络不使用VPN（Virtual Private Network，虚拟专用网络）\n          console.log(JSON.stringify(\"NET_CAPABILITY_NOT_VPN\"));\n        } else if (item == 16) {\n          // 表示该网络访问Internet的能力被网络管理成功验证，该能力由网络管理模块设置\n          console.log(JSON.stringify(\"NET_CAPABILITY_VALIDATED\"));\n        }\n      }\n    })\n  }\n})\n\n// 获取netHandle对应网络的连接信息。连接信息包含了链路信息、路由信息等\nconnection.getConnectionProperties(GlobalContext.getContext().netHandle).then((data: connection.ConnectionProperties) => {\n  console.info(\"getConnectionProperties get data: \" + JSON.stringify(data));\n})\n\n// 调用getAllNets,获取所有处于连接状态的网络列表(Array<NetHandle>)\nconnection.getAllNets().then((data: connection.NetHandle[]) => {\n  console.info(\"getAllNets get data: \" + JSON.stringify(data));\n  if (data) {\n    GlobalContext.getContext().netList = data;\n\n    let itemNumber : Set<connection.NetHandle> = new Set(GlobalContext.getContext().netList);\n    let dataNumber = Array.from(itemNumber.values());\n    for (let item of dataNumber) {\n      // 循环获取网络列表每个netHandle对应网络的能力信息\n      connection.getNetCapabilities(item).then((data: connection.NetCapabilities) => {\n        console.info(\"getNetCapabilities get data: \" + JSON.stringify(data));\n      })\n\n      // 循环获取网络列表每个netHandle对应的网络的连接信息\n      connection.getConnectionProperties(item).then((data: connection.ConnectionProperties) => {\n        console.info(\"getConnectionProperties get data: \" + JSON.stringify(data));\n      })\n    }\n  }\n})
使用对应网络解析域名，获取所有IP
 声明接口调用所需要的权限：ohos.permission.INTERNET 此权限级别为normal，在申请权限前，请保证符合权限使用的基本原则。然后参考访问控制-声明权限声明对应权限。 从@kit.NetworkKit中导入connection命名空间。 调用getAddressesByName方法，使用默认网络解析主机名以获取所有IP地址。 
// 引入包名\nimport { connection } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n// 使用默认网络解析主机名以获取所有IP地址\nconnection.getAddressesByName(\"xxxx\").then((data: connection.NetAddress[]) => {\n  console.info(\"Succeeded to get data: \" + JSON.stringify(data));\n});

Worker和宿主线程的即时消息通信
在ArkTS中，Worker相对于Taskpool存在一定的差异性，有数量限制但是可以长时间存在。一个Worker中可能会执行多个不同的任务，每个任务执行的时长或者返回的结果可能都不相同，宿主线程需要根据情况调用Worker中的不同方法，Worker则需要及时地将结果返回给宿主线程。
下面以Worker响应\"hello world\"请求为例进行说明。
首先，创建一个执行多个任务Worker。 // Worker.ets\nimport { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';\n\nconst workerPort: ThreadWorkerGlobalScope = worker.workerPort;\n// Worker接收宿主线程的消息，做相应的处理\nworkerPort.onmessage = (e: MessageEvents): void => {\n  if (e.data === 'hello world') {\n    workerPort.postMessage('success');\n  }\n} 这里的宿主线程为UI主线程，在宿主线程中创建这个Worker的对象，在点击Button的时候调用postmessage向Worker发送消息，通过Worker的onmessage方法接收Worker返回的数据。 // Index.ets\nimport { worker } from '@kit.ArkTS';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nfunction promiseCase() {\n  let p: Promise<void> = new Promise<void>((resolve: Function, reject: Function) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 100)\n  }).then(undefined, (error: BusinessError) => {\n  })\n  return p;\n}\n\nasync function postMessageTest() {\n  let ss = new worker.ThreadWorker(\"entry/ets/workers/Worker.ets\");\n  let res = undefined;\n  let flag = false;\n  let isTerminate = false;\n  ss.onexit = () => {\n    isTerminate = true;\n  }\n  // 接收Worker线程发送的消息\n  ss.onmessage = (e) => {\n    res = e.data;\n    flag = true;\n    console.info(\"worker:: res is  \" + res);\n  }\n  // 给Worker线程发送消息\n  ss.postMessage(\"hello world\");\n  while (!flag) {\n    await promiseCase();\n  }\n\n  ss.terminate();\n  while (!isTerminate) {\n    await promiseCase();\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            postMessageTest();\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n} 
在上文这段示例代码中，Worker接收来自宿主线程的消息，并做了相应处理后把结果发回给宿主线程。这样就可以实现宿主线程和Worker间的即时通信，方便宿主线程使用Worker的运行结果。

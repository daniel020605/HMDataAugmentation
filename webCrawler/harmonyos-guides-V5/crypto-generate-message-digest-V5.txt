消息摘要计算(ArkTS)
对应的算法规格请查看消息摘要计算算法规格。
开发步骤
在调用update接口传入数据时，可以一次性传入所有数据，也可以把数据人工分段，然后分段update。对于同一段数据而言，计算结果没有差异。对于数据量较大的数据，开发者可以根据实际需求选择是否分段传入。
下面分别提供两种方式的示例代码。
[h2]摘要算法（一次性传入）
 调用cryptoFramework.createMd，指定摘要算法SHA256，生成摘要实例（Md）。 调用Md.update，传入自定义消息，进行摘要更新计算。单次update长度没有限制。 调用Md.digest，获取摘要计算结果。 调用Md.getMdLength，获取摘要计算长度，单位为字节。 
 以使用await方式单次传入数据，获取摘要计算结果为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nasync function doMd() {\n  let mdAlgName = 'SHA256'; // 摘要算法名\n  let message = 'mdTestMessgae'; // 待摘要的数据\n  let md = cryptoFramework.createMd(mdAlgName);\n  // 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制\n  await md.update({ data: new Uint8Array(buffer.from(message, 'utf-8').buffer) });\n  let mdResult = await md.digest();\n  console.info('Md result:' + mdResult.data);\n  let mdLen = md.getMdLength();\n  console.info(\"md len: \" + mdLen);\n} 以使用同步方式单次传入数据，获取摘要计算结果为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nfunction doMdBySync() {\n  let mdAlgName = 'SHA256'; // 摘要算法名\n  let message = 'mdTestMessgae'; // 待摘要的数据\n  let md = cryptoFramework.createMd(mdAlgName);\n  // 数据量较少时，可以只做一次update，将数据全部传入，接口未对入参长度做限制\n  md.updateSync({ data: new Uint8Array(buffer.from(message, 'utf-8').buffer) });\n  let mdResult = md.digestSync();\n  console.info('[Sync]:Md result:' + mdResult.data);\n  let mdLen = md.getMdLength();\n  console.info(\"md len: \" + mdLen);\n} 
[h2]分段摘要算法
 调用cryptoFramework.createMd，指定摘要算法SHA256，生成摘要实例（Md）。 传入自定义消息，将一次传入数据量设置为20字节，多次调用Md.update，进行摘要更新计算。 调用Md.digest，获取摘要计算结果。 调用Md.getMdLength，获取摘要计算长度，单位为字节。 
 以使用await方式分段传入数据，获取摘要计算结果为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nasync function doLoopMd() {\n  let mdAlgName = \"SHA256\"; // 摘要算法名\n  let md = cryptoFramework.createMd(mdAlgName);\n  // 假设信息总共43字节，根据utf-8解码后，也是43字节\n  let messageText = \"aaaaa.....bbbbb.....ccccc.....ddddd.....eee\";\n  let messageData = new Uint8Array(buffer.from(messageText, 'utf-8').buffer);\n  let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求\n  for (let i = 0; i < messageData.length; i += updateLength) {\n    let updateMessage = messageData.subarray(i, i + updateLength);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    await md.update(updateMessageBlob);\n  }\n  let mdOutput = await md.digest();\n  console.info(\"md result: \" + mdOutput.data);\n  let mdLen = md.getMdLength();\n  console.info(\"md len: \" + mdLen);\n} 以使用同步方式分段传入数据，获取摘要计算结果为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nfunction doLoopMdBySync() {\n  let mdAlgName = \"SHA256\"; // 摘要算法名\n  let md = cryptoFramework.createMd(mdAlgName);\n  // 假设信息总共43字节，根据utf-8解码后，也是43字节\n  let messageText = \"aaaaa.....bbbbb.....ccccc.....ddddd.....eee\";\n  let messageData = new Uint8Array(buffer.from(messageText, 'utf-8').buffer);\n  let updateLength = 20; // 假设以20字节为单位进行分段update，实际并无要求\n  for (let i = 0; i < messageData.length; i += updateLength) {\n    let updateMessage = messageData.subarray(i, i + updateLength);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    md.updateSync(updateMessageBlob);\n  }\n  let mdOutput = md.digestSync();\n  console.info(\"[Sync]:md result: \" + mdOutput.data);\n  let mdLen = md.getMdLength();\n  console.info(\"md len: \" + mdLen);\n} 

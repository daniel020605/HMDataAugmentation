使用AVPlayer播放视频(C/C++)
使用AVPlayer可以实现端到端播放原始媒体资源，本开发指导将以完整地播放一个视频作为示例，向开发者讲解AVPlayer视频播放相关功能。
播放的全流程包含：创建AVPlayer，设置回调监听函数，设置播放资源，设置播放参数（音量/倍速/焦点模式），设置播放窗口，播放控制（播放/暂停/跳转/停止），重置，销毁播放器实例。
在进行应用开发的过程中，开发者可以通过AVPlayer的信息监听回调函数OH_AVPlayerOnInfoCallback和错误监听回调函数OH_AVPlayerOnErrorCallback主动获取播放过程信息。如果应用在视频播放器处于错误状态时执行操作，系统可能会抛出异常或生成其他未定义的行为。
图1 播放状态变化示意图
状态的详细说明请参考AVPlayerState。当播放处于prepared / playing / paused / completed状态时，播放引擎处于工作状态，这需要占用系统较多的运行内存。当客户端暂时不使用播放器时，调用reset()或release()回收内存资源，做好资源利用。
开发建议
当前指导仅介绍如何实现媒体资源播放，在应用开发过程中可能会涉及后台播放、播放冲突等情况，请根据实际需要参考以下说明。
 如果要实现后台播放或熄屏播放，需要接入AVSession（媒体会话）和申请长时任务，避免播放被系统强制中断。此功能仅提供ArkTS API。 应用在播放过程中，若播放的媒体数据涉及音频，根据系统音频管理策略（参考处理音频焦点事件），可能会被其他应用打断，建议通过OH_AVPlayer_SetOnInfoCallback()主动监听音频打断事件AV_INFO_TYPE_INTERRUPT_EVENT，根据其内容提示，做出相应的处理，避免出现应用状态与预期效果不一致的问题。 面对设备同时连接多个音频输出设备的情况，建议通过OH_AVPlayer_SetOnInfoCallback()主动监听音频输出设备改变事件AV_INFO_TYPE_AUDIO_OUTPUT_DEVICE_CHANGE，从而做出相应处理。 应用在播放过程中，系统内部可能异常，如网络数据下载失败、媒体服务死亡不可用等，建议通过OH_AVPlayer_SetOnErrorCallback()接口设置错误监听回调函数，根据不同错误类型，做出相应处理，避免出现播放异常。 使用OH_AVPlayer_SetOnInfoCallback()、OH_AVPlayer_SetOnErrorCallback()接口分别设置信息监听回调函数OH_AVPlayerOnInfoCallback和错误监听回调函数OH_AVPlayerOnErrorCallback。当应用成功设置信息监听回调函数OH_AVPlayerOnInfoCallback后，不再执行通过OH_AVPlayer_SetPlayerCallback()设置的信息监听回调函数OH_AVPlayerOnInfo；当应用成功设置错误监听回调函数OH_AVPlayerOnErrorCallback后，不再执行通过OH_AVPlayer_SetPlayerCallback()设置的错误监听回调函数OH_AVPlayerOnError。 
开发步骤及注意事项
在 CMake 脚本中链接动态库：
target_link_libraries(sample PUBLIC libavplayer.so)
使用OH_AVPlayer_SetOnInfoCallback()、OH_AVPlayer_SetOnErrorCallback()接口设置信息监听回调函数和错误监听回调函数，需要在 CMake 脚本中链接如下动态库：
target_link_libraries(sample PUBLIC libnative_media_core.so)
开发者使用系统日志能力时，需引入如下头文件：
#include <hilog/log.h>
并需要在 CMake 脚本中链接如下动态库:
target_link_libraries(sample PUBLIC libhilog_ndk.z.so)
开发者通过引入avplayer.h、avpalyer_base.h和native_averrors.h头文件，使用视频播放相关API。
详细的API说明请参考AVPlayer API。
 创建AVPlayer实例：调用OH_AVPlayer_Create()，AVPlayer初始化为AV_IDLE状态。 设置回调监听函数：使用OH_AVPlayer_SetOnInfoCallback()、OH_AVPlayer_SetOnErrorCallback()接口设置信息监听回调函数和错误监听回调函数，搭配全流程场景使用。支持的监听事件包括：     事件类型 说明    OH_AVPlayerOnInfoCallback 必要事件，监听播放器的过程信息。   OH_AVPlayerOnErrorCallback 必要事件，监听播放器的错误信息。    应用使用OH_AVPlayer_SetOnInfoCallback()、OH_AVPlayer_SetOnErrorCallback()接口设置信息监听回调函数和错误监听回调函数，可以获取更多信息，还可以通过设置 userData 区分不同播放实例。 设置资源：调用OH_AVPlayer_SetURLSource()，设置属性url，AVPlayer进入AV_INITIALIZED状态。 （可选）设置音频流类型：调用OH_AVPlayer_SetAudioRendererInfo()，设置AVPlayer音频流类型。 （可选）设置音频打断模式：调用OH_AVPlayer_SetAudioInterruptMode()，设置AVPlayer音频流打断模式。 设置播放画面窗口：调用OH_AVPlayer_SetVideoSurface()设置播放画面窗口。此函数必须在SetSource之后，Prepare之前调用。 准备播放：调用OH_AVPlayer_Prepare()，AVPlayer进入AV_PREPARED状态，此时可以获取时长，设置音量。 （可选）设置音频音效模式：调用OH_AVPlayer_SetAudioEffectMode()，设置AVPlayer音频音效模式。 视频播控：播放OH_AVPlayer_Play()，暂停OH_AVPlayer_Pause()，跳转OH_AVPlayer_Seek()，停止OH_AVPlayer_Stop()等操作。 （可选）更换资源：调用OH_AVPlayer_Reset()重置资源，AVPlayer重新进入AV_IDLE状态，允许更换资源url。 退出播放：调用OH_AVPlayer_Release()销毁实例，AVPlayer进入AV_RELEASED状态，退出播放。之后再操作AVPlayer实例则行为未知，可能导致应用进程崩溃，应用闪退。 
完整示例
#include \"napi/native_api.h\"\n\n#include <ace/xcomponent/native_interface_xcomponent.h>\n#include <multimedia/player_framework/avplayer.h>\n#include <multimedia/player_framework/avplayer_base.h>\n#include <multimedia/player_framework/native_averrors.h>\n\n#include <hilog/log.h>\n\n#define LOG_MSG_TAG \"AVPlayerNdk\"\n#define LOG(format, ...) ((void)OH_LOG_Print(LOG_APP, LOG_INFO, 0xFF00, LOG_MSG_TAG, format, ##__VA_ARGS__))\n#define LOGE(format, ...) ((void)OH_LOG_Print(LOG_APP, LOG_ERROR, 0xFF00, LOG_MSG_TAG, format, ##__VA_ARGS__))\n\ntypedef struct DemoNdkPlayer {\n    OH_AVPlayer *player = nullptr;\n    char *url = nullptr;\n    int32_t errorCode = AV_ERR_UNKNOWN;\n\n    int32_t value = -1;\n    int32_t state = -1;\n    int32_t stateChangeReason = -1;\n    AVPlayerState avState = AV_IDLE;\n    AVPlaybackSpeed speed = AV_SPEED_FORWARD_1_00_X;\n\n    float volume = 0.0;\n    int64_t duration = -1;\n\n    int32_t width = -1;\n    int32_t height = -1;\n\n    static OHNativeWindow *nativeWindow;\n\n    AVPlayerBufferingType bufferType = AVPLAYER_BUFFERING_START;\n    int32_t bufferValue = -1;\n\n    uint32_t *bitRates = nullptr;\n    size_t bitRatesSize = 0;\n    uint32_t bitRate = 0;\n\n    int32_t interruptType = -1;\n    int32_t interruptForce = -1;\n    int32_t interruptHint = -1;\n} DemoNdkPlayer;\n\nOHNativeWindow *DemoNdkPlayer::nativeWindow = nullptr;\n\nvoid HandleStateChange(OH_AVPlayer *player, AVPlayerState state) {\n    OH_AVErrCode ret;\n    switch (state) {\n        case AV_IDLE: // 成功调用reset接口后触发该状态机上报\n//            ret = OH_AVPlayer_SetURLSource(player, url); // 设置url\n//            if (ret != AV_ERR_OK) {\n//            // 处理异常\n//        }\n            break;\n        case AV_INITIALIZED:\n            ret = OH_AVPlayer_SetVideoSurface(player, DemoNdkPlayer::nativeWindow); // 设置视频播放 surface\n            LOG(\"OH_AVPlayer_SetVideoSurface ret:%d\", ret);\n            ret = OH_AVPlayer_Prepare(player); //设置播放源后触发该状态上报\n            if (ret != AV_ERR_OK) {\n            // 处理异常\n            }\n            break;\n        case AV_PREPARED:\n//            ret = OH_AVPlayer_SetAudioEffectMode(player, EFFECT_NONE); // 设置音频音效模式\n//            if (ret != AV_ERR_OK) {\n//            //处理异常    \n//            }  \n            ret = OH_AVPlayer_Play(player); // 调用播放接口开始播放\n            if (ret != AV_ERR_OK) {\n            // 处理异常\n            }\n            break;\n        case AV_PLAYING:\n//            ret = OH_AVPlayer_Pause(player); //调用暂停接口暂停播放\n//            if (ret != AV_ERR_OK) {\n//            // 处理异常\n//            }\n            break;\n        case AV_PAUSED:\n//            ret = OH_AVPlayer_Play(player); // 再次播放接口开始播放\n//            if (ret != AV_ERR_OK) {\n//            // 处理异常\n//            }\n           break;\n        case AV_STOPPED:\n            ret = OH_AVPlayer_Release(player); //调用reset接口初始化avplayer状态\n            if (ret != AV_ERR_OK) {\n            // 处理异常\n            }\n            break;\n        case AV_COMPLETED:\n            ret = OH_AVPlayer_Stop(player);// 调用播放结束接口\n            if (ret != AV_ERR_OK) {\n            // 处理异常\n            }\n            break;\n        default:\n            break;\n    }\n}\n\nvoid OHAVPlayerOnInfoCallback(OH_AVPlayer *player, AVPlayerOnInfoType type, OH_AVFormat *infoBody, void *userData) {\n    OH_AVErrCode ret;\n    int32_t value = -1;\n\n    DemoNdkPlayer *demoNdkPlayer = reinterpret_cast<DemoNdkPlayer *>(userData);\n    if (demoNdkPlayer == nullptr || player == nullptr) {\n        LOGE(\"OHAVPlayerOnInfoCallback demoNdkPlayer is nullptr\");\n        return;\n    }\n    switch (type) {\n    case AV_INFO_TYPE_STATE_CHANGE:\n        LOG(\"AVPlayerOnInfoType AV_INFO_TYPE_STATE_CHANGE\");\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_STATE, &demoNdkPlayer->state);\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_STATE_CHANGE_REASON, &demoNdkPlayer->stateChangeReason);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_STATE_CHANGE  state: %d ,stateChangeReason: %d\",\n            demoNdkPlayer->state, demoNdkPlayer->stateChangeReason);\n        demoNdkPlayer->avState = static_cast<AVPlayerState>(demoNdkPlayer->state);\n        HandleStateChange(player, demoNdkPlayer->avState);\n        break;\n    case AV_INFO_TYPE_SEEKDONE:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_SEEK_POSITION, &value);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_SEEKDONE value: %d\", value);\n        break;\n    case AV_INFO_TYPE_SPEEDDONE:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_PLAYBACK_SPEED, &value);\n        demoNdkPlayer->speed = static_cast<AVPlaybackSpeed>(value);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_SPEEDDONE value: %d\", value);\n        break;\n    case AV_INFO_TYPE_BITRATEDONE:\n        // 目前OH_AVFormat仅支持存储不支持存储uint32_t类型、自定义类型枚举数据\n        // 需要通过int32_t类型数据获取，然后强转为对应类型数据。\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_BITRATE, &value);\n        demoNdkPlayer->bitRate = static_cast<uint32_t>(value);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_BITRATEDONE value: %d\", value);\n        break;\n    case AV_INFO_TYPE_EOS:\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_EOS\");\n        break;\n    case AV_INFO_TYPE_POSITION_UPDATE:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_CURRENT_POSITION, &value);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_POSITION_UPDATE value: %d\", value);\n        break;\n    case AV_INFO_TYPE_MESSAGE:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_MESSAGE_TYPE, &value);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_MESSAGE value: %d\", value);\n        break;\n    case AV_INFO_TYPE_VOLUME_CHANGE:\n        OH_AVFormat_GetFloatValue(infoBody, OH_PLAYER_VOLUME, &demoNdkPlayer->volume);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_VOLUME_CHANGE value: %f\", demoNdkPlayer->volume);\n        break;\n    case AV_INFO_TYPE_RESOLUTION_CHANGE:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_VIDEO_WIDTH, &demoNdkPlayer->width);\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_VIDEO_HEIGHT, &demoNdkPlayer->height);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_RESOLUTION_CHANGE width: %d, height: %d\",\n            demoNdkPlayer->width, demoNdkPlayer->height);\n        break;\n    case AV_INFO_TYPE_BUFFERING_UPDATE:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_BUFFERING_TYPE, &value);\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_BUFFERING_VALUE, &demoNdkPlayer->bufferValue);\n        demoNdkPlayer->bufferType = static_cast<AVPlayerBufferingType>(value);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_BUFFERING_UPDATE bufferType: %d, bufferValue: %d\",\n            value, demoNdkPlayer->bufferValue);\n        break;\n    case AV_INFO_TYPE_BITRATE_COLLECT: {\n        uint8_t *bitRates = nullptr;\n        size_t size = 0;\n        OH_AVFormat_GetBuffer(infoBody, OH_PLAYER_BITRATE_ARRAY, &bitRates, &size);\n        demoNdkPlayer->bitRatesSize = size / sizeof(uint32_t);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_BITRATE_COLLECT bytes size: %zu, size: %zu\",\n            size, demoNdkPlayer->bitRatesSize );\n        if (demoNdkPlayer->bitRatesSize <= 0) {\n            LOGE(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_BITRATE_COLLECT invalid bitRatesSize\");\n            return;\n        }\n        demoNdkPlayer->bitRates = new uint32_t[demoNdkPlayer->bitRatesSize];\n        if (demoNdkPlayer->bitRates == nullptr || bitRates == nullptr) {\n            LOGE(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_BITRATE_COLLECT bitRates is nullptr\");\n            return;\n        }\n        memcpy((void *)(demoNdkPlayer->bitRates), (void *)bitRates, demoNdkPlayer->bitRatesSize * sizeof(uint32_t));\n        for (size_t i = 0; i < demoNdkPlayer->bitRatesSize; i++) {\n            LOGE(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_BITRATE_COLLECT bitRates[%zu]: %zu\",\n                i, *(demoNdkPlayer->bitRates + i));\n        }\n        break;\n    }\n    case AV_INFO_TYPE_INTERRUPT_EVENT:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_AUDIO_INTERRUPT_TYPE, &demoNdkPlayer->interruptType);\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_AUDIO_INTERRUPT_FORCE, &demoNdkPlayer->interruptForce);\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_AUDIO_INTERRUPT_HINT, &demoNdkPlayer->interruptHint);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_INTERRUPT_EVENT interruptType: %d, interruptForce: %d\"\n            \", interruptHint: %d\", demoNdkPlayer->interruptType, demoNdkPlayer->interruptForce,\n            demoNdkPlayer->interruptHint);\n        break;\n    case AV_INFO_TYPE_DURATION_UPDATE:\n        OH_AVFormat_GetLongValue(infoBody, OH_PLAYER_DURATION, &demoNdkPlayer->duration);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_DURATION_UPDATE value: %lld\", demoNdkPlayer->duration);\n        break;\n    case AV_INFO_TYPE_IS_LIVE_STREAM:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_IS_LIVE_STREAM, &value);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_IS_LIVE_STREAM value: %d\", value);\n        break;\n    case AV_INFO_TYPE_TRACKCHANGE:\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_TRACKCHANGE value: %d\", value);\n        break;\n    case AV_INFO_TYPE_TRACK_INFO_UPDATE:\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_TRACK_INFO_UPDATE value: %d\", value);\n        break;\n    case AV_INFO_TYPE_SUBTITLE_UPDATE:\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_SUBTITLE_UPDATE value: %d\", value);\n        break;\n    case AV_INFO_TYPE_AUDIO_OUTPUT_DEVICE_CHANGE:\n        OH_AVFormat_GetIntValue(infoBody, OH_PLAYER_AUDIO_DEVICE_CHANGE_REASON, &value);\n        LOG(\"OHAVPlayerOnInfoCallback AV_INFO_TYPE_AUDIO_OUTPUT_DEVICE_CHANGE value: %d\", value);\n        break;\n    default:\n        break;\n    }\n}\n\nvoid OHAVPlayerOnErrorCallback(OH_AVPlayer *player, int32_t errorCode, const char *errorMsg, void *userData) {\n    LOG(\"OHAVPlayerOnError errorCode: %d ,errorMsg: %s\", errorCode, errorMsg == nullptr ? \"unknown\" : errorMsg);\n    DemoNdkPlayer *demoNdkPlayer = reinterpret_cast<DemoNdkPlayer *>(userData);\n    if (demoNdkPlayer == nullptr || player == nullptr) {\n        LOGE(\"OHAVPlayerOnErrorCallback demoNdkPlayer or player is nullptr\");\n        return;\n    }\n    demoNdkPlayer->errorCode = errorCode;\n    // do something\n}\n\n// 调用播放方法时，需要在index.d.ts文件内描述映射的play方法，需要传入一个string类型的参数\n// ets文件调用播放方法时，传入文件路径 testNapi.play(\"/data/test/test.mp4\")\nstatic napi_value Play(napi_env env, napi_callback_info info)\n{\n    OH_AVErrCode ret;\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    \n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n    \n    // 获取参数类型\n    napi_valuetype stringType;\n    if (napi_ok != napi_typeof(env, args[0], &stringType)) {\n        // 处理异常\n        return nullptr;\n    }\n    \n    // 参数校验\n    if (napi_null == stringType) {\n        // 处理异常\n        return nullptr;\n    }\n    \n    // 获取传递的string长度\n    size_t length = 0;\n    if (napi_ok != napi_get_value_string_utf8(env, args[0], nullptr, 0, &length)) {\n        // 处理异常\n        return nullptr;\n    }\n    \n    // 如果传入的是\"\"，则直接返回\n    if (length == 0) {\n        // 处理异常\n        return nullptr;\n    }\n    \n    // 读取传入的string放入buffer中\n    char *url = new char[length + 1];\n    if (napi_ok != napi_get_value_string_utf8(env, args[0], url, length + 1, &length)) {\n        delete[] url;\n        url = nullptr;\n        // 处理异常\n        return nullptr;\n    }\n\n    // 通过新接口设置信息监听回调函数和错误监听回调函数，不用再调用OH_AVPlayer_SetPlayerCallback。\n    // 业务播放实例不再使用后，再释放对象。\n    OH_AVPlayer *player = OH_AVPlayer_Create();\n    DemoNdkPlayer *demoNdkPlayer = new DemoNdkPlayer({\n        .player = player,\n        .url = url,\n    });\n    LOG(\"call OH_AVPlayer_SetPlayerOnInfoCallback\");\n    ret = OH_AVPlayer_SetOnInfoCallback(player, OHAVPlayerOnInfoCallback, demoNdkPlayer);\n    LOG(\"OH_AVPlayer_SetPlayerOnInfoCallback ret:%d\", ret);\n    LOG(\"call OH_AVPlayer_SetPlayerOnErrorCallback\");\n    ret = OH_AVPlayer_SetOnErrorCallback(player, OHAVPlayerOnErrorCallback, demoNdkPlayer);\n    LOG(\"OH_AVPlayer_SetPlayerOnErrorCallback ret:%d\", ret);\n\n    if (ret != AV_ERR_OK) {\n    // 处理异常\n    }\n    ret = OH_AVPlayer_SetURLSource(player, url); // 设置url\n    if (ret != AV_ERR_OK) {\n    // 处理异常\n    }\n    // 设置音频流类型\n    OH_AudioStream_Usage streamUsage = OH_AudioStream_Usage::AUDIOSTREAM_USAGE_UNKNOWN;\n    ret = OH_AVPlayer_SetAudioRendererInfo(player, streamUsage);\n    if (ret != AV_ERR_OK) {\n    //处理异常    \n    }\n    // 设置音频流打断模式\n    OH_AudioInterrupt_Mode interruptMode = OH_AudioInterrupt_Mode::AUDIOSTREAM_INTERRUPT_MODE_INDEPENDENT;\n    ret = OH_AVPlayer_SetAudioInterruptMode(player, interruptMode);\n    if (ret != AV_ERR_OK) {\n    //处理异常    \n    }\n    napi_value value;\n    napi_create_int32(env, 0, &value);\n    return value;\n}\n\n// 定义 Surface 回调函数\nvoid OnSurfaceCreatedCB(OH_NativeXComponent *component, void *window) {\n    LOG(\"OnSurfaceCreatedCB...\");\n    // 可获取 OHNativeWindow 实例\n    OHNativeWindow * nativeWindow = static_cast<OHNativeWindow *>(window);\n    DemoNdkPlayer::nativeWindow = nativeWindow;\n    // ...\n}\n\nvoid OnSurfaceDestroyedCB(OH_NativeXComponent *component, void *window) {\n    LOG(\"OnSurfaceDestroyedCB...\");\n    // 可获取 OHNativeWindow 实例\n    OHNativeWindow * nativeWindow = static_cast<OHNativeWindow *>(window);\n    // ...\n}\n\nvoid Export(napi_env env, napi_value exports) {\n    if ((env == nullptr) || (exports == nullptr)) {\n        LOG(\"Export: env or exports is null\");\n        return;\n    }\n    napi_value exportInstance = nullptr;\n    if (napi_get_named_property(env, exports, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance) != napi_ok) {\n        LOG(\"Export: napi_get_named_property fail\");\n        return;\n    }\n    OH_NativeXComponent *nativeXComponent = nullptr;\n    if (napi_unwrap(env, exportInstance, reinterpret_cast<void **>(&nativeXComponent)) != napi_ok) {\n        LOG(\"Export: napi_unwrap fail\");\n        return;\n    }\n    char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {'\\0'};\n    uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;\n    if (OH_NativeXComponent_GetXComponentId(nativeXComponent, idStr, &idSize) != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {\n        LOG(\"OH_NativeXComponent_GetXComponentId fail\");\n        return;\n    }\n    LOG(\"call Export surfaceID=%s\", idStr);\n}\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        { \"Play\", nullptr, Play, nullptr, nullptr, nullptr, napi_default, nullptr }\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n\n    Export(env, exports);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version =1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void*)0),\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void)\n{\n    napi_module_register(&demoModule);\n}

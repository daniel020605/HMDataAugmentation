使用Picker选择媒体库资源
用户有时需要分享图片、视频等用户文件，开发者可以通过特定接口拉起系统图库，用户自行选择待分享的资源，然后最终完成分享。此接口本身无需申请权限，目前适用于界面UIAbility，使用窗口组件触发。具体使用方式如下：
 导入选择器模块和文件管理模块。 import { photoAccessHelper } from '@kit.MediaLibraryKit';\nimport { fileIo } from '@kit.CoreFileKit';\nimport { BusinessError } from '@kit.BasicServicesKit'; 创建图片-音频类型文件选择选项实例。 const photoSelectOptions = new photoAccessHelper.PhotoSelectOptions(); 配置可选的媒体文件类型和媒体文件的最大数目。 以下示例以图片选择为例，媒体文件类型请参见PhotoViewMIMETypes。 photoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE; // 过滤选择媒体文件类型为IMAGE\nphotoSelectOptions.maxSelectNumber = 5; // 选择媒体文件的最大数目 创建图库选择器实例，调用PhotoViewPicker.select接口拉起图库界面进行文件选择。文件选择成功后，返回PhotoSelectResult结果集。 let uris: Array<string> = [];\nconst photoViewPicker = new photoAccessHelper.PhotoViewPicker();\nphotoViewPicker.select(photoSelectOptions).then((photoSelectResult: photoAccessHelper.PhotoSelectResult) => {\n  uris = photoSelectResult.photoUris;\n  console.info('photoViewPicker.select to file succeed and uris are:' + uris);\n}).catch((err: BusinessError) => {\n  console.error(`Invoke photoViewPicker.select failed, code is ${err.code}, message is ${err.message}`);\n}) select返回的uri权限是只读权限，可以根据结果集中uri进行读取文件数据操作。注意不能在picker的回调里直接使用此uri进行打开文件操作，需要定义一个全局变量保存uri，类似使用一个按钮去触发打开文件。可参考指定URI读取文件数据。 也可以通过返回的uri获取图片或视频资源。 如有获取元数据需求，可以通过文件管理接口和文件URI根据uri获取部分文件属性信息，比如文件大小、访问时间、修改时间、文件名、文件路径等。 
指定URI读取文件数据
 待界面从图库返回后，再通过一个类似按钮的组件去调用其他函数，使用fileIo.openSync接口，通过媒体文件uri打开这个文件得到fd。这里需要注意接口权限参数是fileIo.OpenMode.READ_ONLY。 let uri: string = '';\nlet file = fileIo.openSync(uri, fileIo.OpenMode.READ_ONLY);\nconsole.info('file fd: ' + file.fd); 通过fd使用fileIo.readSync接口读取这个文件内的数据，读取完成后关闭fd。 let buffer = new ArrayBuffer(4096);\nlet readLen = fileIo.readSync(file.fd, buffer);\nconsole.info('readSync data to file succeed and buffer size is:' + readLen);\nfileIo.closeSync(file); 
指定URI获取图片或视频资源
媒体库支持Picker选择媒体文件URI后，根据指定URI获取图片或视频资源，下面以查询指定URI为'file://media/Photo/1/IMG_datetime_0001/displayName.jpg'为例。
import { dataSharePredicates } from '@kit.ArkData';\n\nconst context = getContext(this);\nlet phAccessHelper = photoAccessHelper.getPhotoAccessHelper(context);\n\nclass MediaDataHandler implements photoAccessHelper.MediaAssetDataHandler<ArrayBuffer> {\n  onDataPrepared(data: ArrayBuffer) {\n    if (data === undefined) {\n      console.error('Error occurred when preparing data');\n      return;\n    }\n    console.info('on image data prepared');\n    // 应用自定义对资源数据的处理逻辑\n  }\n}\n\nasync function example() {\n  let predicates: dataSharePredicates.DataSharePredicates = new dataSharePredicates.DataSharePredicates();\n  let uri = 'file://media/Photo/1/IMG_datetime_0001/displayName.jpg' // 需保证此uri已存在。\n  predicates.equalTo(photoAccessHelper.PhotoKeys.URI, uri.toString());\n  let fetchOptions: photoAccessHelper.FetchOptions = {\n    fetchColumns: [photoAccessHelper.PhotoKeys.TITLE],\n    predicates: predicates\n  };\n\n  try {\n    let fetchResult: photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> = await phAccessHelper.getAssets(fetchOptions);\n    let photoAsset: photoAccessHelper.PhotoAsset = await fetchResult.getFirstObject();\n    console.info('getAssets photoAsset.uri : ' + photoAsset.uri);\n    // 获取属性值，以标题为例；对于非默认查询的属性，get前需要在fetchColumns中添加对应列名\n    console.info('title : ' + photoAsset.get(photoAccessHelper.PhotoKeys.TITLE));\n    // 请求图片资源数据\n    let requestOptions: photoAccessHelper.RequestOptions = {\n      deliveryMode: photoAccessHelper.DeliveryMode.HIGH_QUALITY_MODE,\n    }\n    await photoAccessHelper.MediaAssetManager.requestImageData(context, photoAsset, requestOptions, new MediaDataHandler());\n    console.info('requestImageData successfully');\n    fetchResult.close();\n  } catch (err) {\n    console.error('getAssets failed with err: ' + err);\n  }\n}

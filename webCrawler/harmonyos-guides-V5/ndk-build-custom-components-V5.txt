构建自定义组件
ArkUI开发框架在NDK接口提供了自定义UI组件的能力，这些能力包括自定义测算，自定义布局和自定义绘制。开发者通过注册相关自定义回调事件接入ArkUI开发框架的布局渲染流程，这些事件需要使用registerNodeCustomEvent来进行声明，并通过addNodeCustomEventReceiver函数添加组件自定义事件的监听器，在该监听器的回调函数中处理相关自定义测算，自定义布局和自定义绘制逻辑。
 自定义组件事件注册需要addNodeCustomEventReceiver声明监听器注册和registerNodeCustomEvent声明需要的自定义事件类型，监听器只能监听已声明的事件。 需要关注事件的反注册逻辑，如在组件销毁前调用removeNodeCustomEventReceiver移除事件监听器，unregisterNodeCustomEvent通知ArkUI框架已监听的自定义组件事件不再需要监听。 addNodeCustomEventReceiver可以添加多个函数指针，每个函数指针都会在对应事件触发时触发，对应的removeNodeCustomEventReceiver需要传递对应的函数指针用于移除监听。 registerNodeCustomEventReceiver是全局监听函数，不同于addNodeCustomEventReceiver，registerNodeCustomEventReceiver能够监听所有Native组件的自定义事件触发，但只能传递一个函数指针，多次调用使用最后一次的函数指针进行回调，释放时使用unregisterNodeCustomEventReceiver进行反注册。 自定义组件相关接口（measureNode、layoutNode、setMeasuredSize、setLayoutPosition）仅允许在对应的自定义事件（ARKUI_NODE_CUSTOM_EVENT_ON_MEASURE、ARKUI_NODE_CUSTOM_EVENT_ON_LAYOUT）回调中使用。 
自定义布局容器
以下示例创建了一个自定义容器，该容器将子组件最大值加上额外边距作为自身大小，同时对子组件进行居中排布。
图1 自定义容器组件
 按照接入ArkTS页面创建前置工程。 创建自定义容器组件封装对象。 // ArkUICustomContainerNode.h\n// 自定义容器组件示例\n\n#ifndef MYAPPLICATION_ARKUICUSTOMCONTAINERNODE_H\n#define MYAPPLICATION_ARKUICUSTOMCONTAINERNODE_H\n\n#include \"ArkUINode.h\"\n\nnamespace NativeModule {\n\nclass ArkUICustomContainerNode : public ArkUINode {\npublic:\n    // 使用自定义组件类型ARKUI_NODE_CUSTOM创建组件。\n    ArkUICustomContainerNode()\n        : ArkUINode((NativeModuleInstance::GetInstance()->GetNativeNodeAPI())->createNode(ARKUI_NODE_CUSTOM)) {\n        // 注册自定义事件监听器。\n        nativeModule_->addNodeCustomEventReceiver(handle_, OnStaticCustomEvent);\n        // 声明自定义事件并转递自身作为自定义数据。\n        nativeModule_->registerNodeCustomEvent(handle_, ARKUI_NODE_CUSTOM_EVENT_ON_MEASURE, 0, this);\n        nativeModule_->registerNodeCustomEvent(handle_, ARKUI_NODE_CUSTOM_EVENT_ON_LAYOUT, 0, this);\n    }\n\n    ~ArkUICustomContainerNode() override {\n        // 反注册自定义事件监听器。\n        nativeModule_->removeNodeCustomEventReceiver(handle_, OnStaticCustomEvent);\n        // 取消声明自定义事件。\n        nativeModule_->unregisterNodeCustomEvent(handle_, ARKUI_NODE_CUSTOM_EVENT_ON_MEASURE);\n        nativeModule_->unregisterNodeCustomEvent(handle_, ARKUI_NODE_CUSTOM_EVENT_ON_LAYOUT);\n    }\n\n    void SetPadding(int32_t padding) {\n        padding_ = padding;\n        // 自定义属性事件更新需要主动调用标记脏区接口。\n        nativeModule_->markDirty(handle_, NODE_NEED_MEASURE);\n    }\n\nprivate:\n    static void OnStaticCustomEvent(ArkUI_NodeCustomEvent *event) {\n        // 获取组件实例对象，调用相关实例方法。\n        auto customNode = reinterpret_cast<ArkUICustomContainerNode *>(OH_ArkUI_NodeCustomEvent_GetUserData(event));\n        auto type = OH_ArkUI_NodeCustomEvent_GetEventType(event);\n        switch (type) {\n        case ARKUI_NODE_CUSTOM_EVENT_ON_MEASURE:\n            customNode->OnMeasure(event);\n            break;\n        case ARKUI_NODE_CUSTOM_EVENT_ON_LAYOUT:\n            customNode->OnLayout(event);\n            break;\n        default:\n            break;\n        }\n    }\n\n    // 自定义测算逻辑。\n    void OnMeasure(ArkUI_NodeCustomEvent *event) {\n        auto layoutConstrain = OH_ArkUI_NodeCustomEvent_GetLayoutConstraintInMeasure(event);\n        // 创建子节点布局限制，复用父组件布局中的百分比参考值。\n        auto childLayoutConstrain = OH_ArkUI_LayoutConstraint_Copy(layoutConstrain);\n        OH_ArkUI_LayoutConstraint_SetMaxHeight(childLayoutConstrain, 1000);\n        OH_ArkUI_LayoutConstraint_SetMaxWidth(childLayoutConstrain, 1000);\n        OH_ArkUI_LayoutConstraint_SetMinHeight(childLayoutConstrain, 0);\n        OH_ArkUI_LayoutConstraint_SetMinWidth(childLayoutConstrain, 0);\n\n        // 测算子节点获取子节点最大值。\n        auto totalSize = nativeModule_->getTotalChildCount(handle_);\n        int32_t maxWidth = 0;\n        int32_t maxHeight = 0;\n        for (uint32_t i = 0; i < totalSize; i++) {\n            auto child = nativeModule_->getChildAt(handle_, i);\n            // 调用测算接口测算Native组件。\n            nativeModule_->measureNode(child, childLayoutConstrain);\n            auto size = nativeModule_->getMeasuredSize(child);\n            if (size.width > maxWidth) {\n                maxWidth = size.width;\n            }\n            if (size.height > maxHeight) {\n                maxHeight = size.height;\n            }\n        }\n        // 自定义测算为所有子节点大小加固定边距。\n        nativeModule_->setMeasuredSize(handle_, maxWidth + 2 * padding_, maxHeight + 2 * padding_);\n    }\n\n    void OnLayout(ArkUI_NodeCustomEvent *event) {\n        // 获取父组件期望位置并设置。\n        auto position = OH_ArkUI_NodeCustomEvent_GetPositionInLayout(event);\n        nativeModule_->setLayoutPosition(handle_, position.x, position.y);\n\n        // 设置子组件居中对齐。\n        auto totalSize = nativeModule_->getTotalChildCount(handle_);\n        auto selfSize = nativeModule_->getMeasuredSize(handle_);\n        for (uint32_t i = 0; i < totalSize; i++) {\n            auto child = nativeModule_->getChildAt(handle_, i);\n            // 获取子组件大小。\n            auto childSize = nativeModule_->getMeasuredSize(child);\n            // 布局子组件位置。\n            nativeModule_->layoutNode(child, (selfSize.width - childSize.width) / 2,\n                                      (selfSize.height - childSize.height) / 2);\n        }\n    }\n\n    int32_t padding_ = 100;\n};\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUICUSTOMCONTAINERNODE_H 使用自定义容器创建带文本的示例界面，并沿用定时器模块相关简单实现。 // 自定义NDK接口入口。\n\n#include \"NativeEntry.h\"\n\n#include \"ArkUICustomContainerNode.h\"\n#include \"ArkUITextNode.h\"\n\n#include <arkui/native_node_napi.h>\n#include <arkui/native_type.h>\n#include <js_native_api.h>\n\nnamespace NativeModule {\n\nnapi_value CreateNativeRoot(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    // 获取NodeContent\n    ArkUI_NodeContentHandle contentHandle;\n    OH_ArkUI_GetNodeContentFromNapiValue(env, args[0], &contentHandle);\n    NativeEntry::GetInstance()->SetContentHandle(contentHandle);\n\n    // 创建自定义容器和文本组件。\n    auto node = std::make_shared<ArkUICustomContainerNode>();\n    node->SetBackgroundColor(0xFFE0FFFF);\n    auto textNode = std::make_shared<ArkUITextNode>();\n    textNode->SetTextContent(\"CustomContainer Example\");\n    textNode->SetFontSize(16);\n    textNode->SetBackgroundColor(0xFFfffacd);\n    textNode->SetTextAlign(ARKUI_TEXT_ALIGNMENT_CENTER);\n    node->AddChild(textNode);\n    CreateNativeTimer(env, textNode.get(), 1, [](void *userData, int32_t count) {\n        auto textNode = reinterpret_cast<ArkUITextNode *>(userData);\n        textNode->SetCircleColor(0xFF00FF7F);\n    });\n\n    // 保持Native侧对象到管理类中，维护生命周期。\n    NativeEntry::GetInstance()->SetRootNode(node);\n    g_env = env;\n    return nullptr;\n}\n\nnapi_value DestroyNativeRoot(napi_env env, napi_callback_info info) {\n    // 从管理类中释放Native侧对象。\n    NativeEntry::GetInstance()->DisposeRootNode();\n    return nullptr;\n}\n\n} // namespace NativeModule 
自定义绘制组件
以下示例创建了一个自定义绘制组件，该绘制组件能够绘制自定义矩形，并使用上述自定义容器进行布局排布。
图2 自定义绘制组件
 按照自定义布局容器章节准备前置工程。 创建自定义绘制组件封装对象。 // ArkUICustomNode.h\n// 自定义绘制组件示例\n\n#ifndef MYAPPLICATION_ARKUICUSTOMNODE_H\n#define MYAPPLICATION_ARKUICUSTOMNODE_H\n\n#include <native_drawing/drawing_brush.h>\n#include <native_drawing/drawing_canvas.h>\n#include <native_drawing/drawing_path.h>\n\n#include \"ArkUINode.h\"\n\nnamespace NativeModule {\n\nclass ArkUICustomNode : public ArkUINode {\npublic:\n    // 使用自定义组件类型ARKUI_NODE_CUSTOM创建组件。\n    ArkUICustomNode()\n        : ArkUINode((NativeModuleInstance::GetInstance()->GetNativeNodeAPI())->createNode(ARKUI_NODE_CUSTOM)) {\n        // 注册自定义事件监听器。\n        nativeModule_->addNodeCustomEventReceiver(handle_, OnStaticCustomEvent);\n        // 声明自定义事件并转递自身作为自定义数据。\n        nativeModule_->registerNodeCustomEvent(handle_, ARKUI_NODE_CUSTOM_EVENT_ON_DRAW, 0, this);\n    }\n\n    ~ArkUICustomNode() override {\n        // 反注册自定义事件监听器。\n        nativeModule_->removeNodeCustomEventReceiver(handle_, OnStaticCustomEvent);\n        // 取消声明自定义事件。\n        nativeModule_->unregisterNodeCustomEvent(handle_, ARKUI_NODE_CUSTOM_EVENT_ON_DRAW);\n    }\n\n    void SetRectColor(uint32_t color) {\n        color_ = color;\n        // 自定义绘制属性变更需要主动通知框架。\n        nativeModule_->markDirty(handle_, NODE_NEED_RENDER);\n    }\n\nprivate:\n    static void OnStaticCustomEvent(ArkUI_NodeCustomEvent *event) {\n        // 获取组件实例对象，调用相关实例方法。\n        auto customNode = reinterpret_cast<ArkUICustomNode *>(OH_ArkUI_NodeCustomEvent_GetUserData(event));\n        auto type = OH_ArkUI_NodeCustomEvent_GetEventType(event);\n        switch (type) {\n        case ARKUI_NODE_CUSTOM_EVENT_ON_DRAW:\n            customNode->OnDraw(event);\n            break;\n        default:\n            break;\n        }\n    }\n\n    // 自定义绘制逻辑。\n    void OnDraw(ArkUI_NodeCustomEvent *event) {\n        auto drawContext = OH_ArkUI_NodeCustomEvent_GetDrawContextInDraw(event);\n        // 获取图形绘制对象。\n        auto drawCanvas = reinterpret_cast<OH_Drawing_Canvas *>(OH_ArkUI_DrawContext_GetCanvas(drawContext));\n        // 获取组件大小。\n        auto size = OH_ArkUI_DrawContext_GetSize(drawContext);\n        // 绘制自定义内容。\n        auto path = OH_Drawing_PathCreate();\n        OH_Drawing_PathMoveTo(path, size.width / 4, size.height / 4);\n        OH_Drawing_PathLineTo(path, size.width * 3 / 4, size.height / 4);\n        OH_Drawing_PathLineTo(path, size.width * 3 / 4, size.height * 3 / 4);\n        OH_Drawing_PathLineTo(path, size.width / 4, size.height * 3 / 4);\n        OH_Drawing_PathLineTo(path, size.width / 4, size.height / 4);\n        OH_Drawing_PathClose(path);\n        auto brush = OH_Drawing_BrushCreate();\n        OH_Drawing_BrushSetColor(brush, color_);\n        OH_Drawing_CanvasAttachBrush(drawCanvas, brush);\n        OH_Drawing_CanvasDrawPath(drawCanvas, path);\n        // 释放资源\n        OH_Drawing_BrushDestroy(brush);\n        OH_Drawing_PathDestroy(path);\n    }\n\n    uint32_t color_ = 0xFFFFE4B5;\n};\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUICUSTOMNODE_H 使用自定义绘制组件和自定义容器创建示例界面，并沿用定时器模块相关简单实现。 // 自定义NDK接口入口组件。\n\n#include \"NativeEntry.h\"\n\n#include \"ArkUICustomContainerNode.h\"\n#include \"ArkUICustomNode.h\"\n\n#include <arkui/native_node_napi.h>\n#include <arkui/native_type.h>\n#include <js_native_api.h>\n\nnamespace NativeModule {\n\nnapi_value CreateNativeRoot(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    // 获取NodeContent\n    ArkUI_NodeContentHandle contentHandle;\n    OH_ArkUI_GetNodeContentFromNapiValue(env, args[0], &contentHandle);\n    NativeEntry::GetInstance()->SetContentHandle(contentHandle);\n\n    // 创建自定义容器和自定义绘制组件。\n    auto node = std::make_shared<ArkUICustomContainerNode>();\n    node->SetBackgroundColor(0xFFE0FFFF);\n    auto customNode = std::make_shared<ArkUICustomNode>();\n    customNode->SetBackgroundColor(0xFFD3D3D3);\n    customNode->SetWidth(150);\n    customNode->SetHeight(150);\n    node->AddChild(customNode);\n    CreateNativeTimer(env, customNode.get(), 1, [](void *userData, int32_t count) {\n        auto customNode = reinterpret_cast<ArkUICustomNode *>(userData);\n        customNode->SetRectColor(0xFF00FF7F);\n    });\n\n    // 保持Native侧对象到管理类中，维护生命周期。\n    NativeEntry::GetInstance()->SetRootNode(node);\n    g_env = env;\n    return nullptr;\n}\n\nnapi_value DestroyNativeRoot(napi_env env, napi_callback_info info) {\n    // 从管理类中释放Native侧对象。\n    NativeEntry::GetInstance()->DisposeRootNode();\n    return nullptr;\n}\n\n} // namespace NativeModule 

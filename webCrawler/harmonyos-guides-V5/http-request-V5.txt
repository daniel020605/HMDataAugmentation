HTTP数据请求
场景介绍
应用通过HTTP发起一个数据请求，支持常见的GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE、CONNECT方法。
接口说明
HTTP数据请求功能主要由http模块提供。
使用该功能需要申请ohos.permission.INTERNET权限。
权限申请请参考声明权限。
涉及的接口如下表，具体的接口说明请参考API文档。
request接口开发步骤
 从@kit.NetworkKit中导入http命名空间。 调用createHttp()方法，创建一个HttpRequest对象。 调用该对象的on()方法，订阅http响应头事件，此接口会比request请求先返回。可以根据业务需要订阅此消息。 调用该对象的request()方法，传入http请求的url地址和可选参数，发起网络请求。 按照实际业务需要，解析返回结果。 调用该对象的off()方法，取消订阅http响应头事件。 当该请求使用完毕时，调用destroy()方法主动销毁。 
// 引入包名\nimport { http } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n// 每一个httpRequest对应一个HTTP请求任务，不可复用\nlet httpRequest = http.createHttp();\n// 用于订阅HTTP响应头，此接口会比request请求先返回。可以根据业务需要订阅此消息\n// 从API 8开始，使用on('headersReceive', Callback)替代on('headerReceive', AsyncCallback)。 8+\nhttpRequest.on('headersReceive', (header) => {\n  console.info('header: ' + JSON.stringify(header));\n});\nhttpRequest.request(\n  // 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定\n  \"EXAMPLE_URL\",\n  {\n    method: http.RequestMethod.POST, // 可选，默认为http.RequestMethod.GET\n    // 开发者根据自身业务需要添加header字段\n    header: {\n      'Content-Type': 'application/json'\n    },\n    // 当使用POST请求时此字段用于传递请求体内容，具体格式与服务端协商确定\n    extraData: \"data to send\",\n    expectDataType: http.HttpDataType.STRING, // 可选，指定返回数据的类型\n    usingCache: true, // 可选，默认为true\n    priority: 1, // 可选，默认为1\n    connectTimeout: 60000, // 可选，默认为60000ms\n    readTimeout: 60000, // 可选，默认为60000ms\n    usingProtocol: http.HttpProtocol.HTTP1_1, // 可选，协议类型默认值由系统自动指定\n    usingProxy: false, // 可选，默认不使用网络代理，自API 10开始支持该属性\n    caPath:'/path/to/cacert.pem', // 可选，默认使用系统预制证书，自API 10开始支持该属性\n    clientCert: { // 可选，默认不使用客户端证书，自API 11开始支持该属性\n      certPath: '/path/to/client.pem', // 默认不使用客户端证书，自API 11开始支持该属性\n      keyPath: '/path/to/client.key', // 若证书包含Key信息，传入空字符串，自API 11开始支持该属性\n      certType: http.CertType.PEM, // 可选，默认使用PEM，自API 11开始支持该属性\n      keyPassword: \"passwordToKey\" // 可选，输入key文件的密码，自API 11开始支持该属性\n    },\n    multiFormDataList: [ // 可选，仅当Header中，'content-Type'为'multipart/form-data'时生效，自API 11开始支持该属性\n      {\n        name: \"Part1\", // 数据名，自API 11开始支持该属性\n        contentType: 'text/plain', // 数据类型，自API 11开始支持该属性\n        data: 'Example data', // 可选，数据内容，自API 11开始支持该属性\n        remoteFileName: 'example.txt' // 可选，自API 11开始支持该属性\n      }, {\n        name: \"Part2\", // 数据名，自API 11开始支持该属性\n        contentType: 'text/plain', // 数据类型，自API 11开始支持该属性\n        // data/app/el2/100/base/com.example.myapplication/haps/entry/files/fileName.txt\n        filePath: `${getContext(this).filesDir}/fileName.txt`, // 可选，传入文件路径，自API 11开始支持该属性\n        remoteFileName: 'fileName.txt' // 可选，自API 11开始支持该属性\n      }\n    ]\n  }, (err: BusinessError, data: http.HttpResponse) => {\n    if (!err) {\n      // data.result为HTTP响应内容，可根据业务需要进行解析\n      console.info('Result:' + JSON.stringify(data.result));\n      console.info('code:' + JSON.stringify(data.responseCode));\n      // data.header为HTTP响应头，可根据业务需要进行解析\n      console.info('header:' + JSON.stringify(data.header));\n      console.info('cookies:' + JSON.stringify(data.cookies)); // 8+\n      // 当该请求使用完毕时，调用destroy方法主动销毁\n      httpRequest.destroy();\n    } else {\n      console.error('error:' + JSON.stringify(err));\n      // 取消订阅HTTP响应头事件\n      httpRequest.off('headersReceive');\n      // 当该请求使用完毕时，调用destroy方法主动销毁\n      httpRequest.destroy();\n    }\n  }\n);
requestInStream接口开发步骤
 从@kit.NetworkKit中导入http命名空间。 调用createHttp()方法，创建一个HttpRequest对象。 调用该对象的on()方法，可以根据业务需要订阅HTTP响应头事件、HTTP流式响应数据接收事件、HTTP流式响应数据接收进度事件和HTTP流式响应数据接收完毕事件。 调用该对象的requestInStream()方法，传入http请求的url地址和可选参数，发起网络请求。 按照实际业务需要，可以解析返回的响应码。 调用该对象的off()方法，取消订阅响应事件。 当该请求使用完毕时，调用destroy()方法主动销毁。 
// 引入包名\nimport { http } from '@kit.NetworkKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n// 每一个httpRequest对应一个HTTP请求任务，不可复用\nlet httpRequest = http.createHttp();\n// 用于订阅HTTP响应头事件\nhttpRequest.on('headersReceive', (header: Object) => {\n  console.info('header: ' + JSON.stringify(header));\n});\n// 用于订阅HTTP流式响应数据接收事件\nlet res = new ArrayBuffer(0);\nhttpRequest.on('dataReceive', (data: ArrayBuffer) => {\n   const newRes = new ArrayBuffer(res.byteLength + data.byteLength);\n   const resView = new Uint8Array(newRes);\n   resView.set(new Uint8Array(res));\n   resView.set(new Uint8Array(data), res.byteLength);\n   res = newRes;\n   console.info('res length: ' + res.byteLength);\n});\n// 用于订阅HTTP流式响应数据接收完毕事件\nhttpRequest.on('dataEnd', () => {\n  console.info('No more data in response, data receive end');\n});\n// 用于订阅HTTP流式响应数据接收进度事件\nclass Data {\n  receiveSize: number = 0;\n  totalSize: number = 0;\n}\nhttpRequest.on('dataReceiveProgress', (data: Data) => {\n  console.log(\"dataReceiveProgress receiveSize:\" + data.receiveSize + \", totalSize:\" + data.totalSize);\n});\n\nlet streamInfo: http.HttpRequestOptions = {\n  method: http.RequestMethod.POST,  // 可选，默认为http.RequestMethod.GET\n  // 开发者根据自身业务需要添加header字段\n  header: {\n    'Content-Type': 'application/json'\n  },\n  // 当使用POST请求时此字段用于传递请求体内容，具体格式与服务端协商确定\n  extraData: \"data to send\",\n  expectDataType:  http.HttpDataType.STRING,// 可选，指定返回数据的类型\n  usingCache: true, // 可选，默认为true\n  priority: 1, // 可选，默认为1\n  connectTimeout: 60000, // 可选，默认为60000ms\n  readTimeout: 60000, // 可选，默认为60000ms。若传输的数据较大，需要较长的时间，建议增大该参数以保证数据传输正常终止\n  usingProtocol: http.HttpProtocol.HTTP1_1 // 可选，协议类型默认值由系统自动指定\n}\n\n// 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定\nhttpRequest.requestInStream(\"EXAMPLE_URL\", streamInfo).then((data: number) => {\n  console.info(\"requestInStream OK!\");\n  console.info('ResponseCode :' + JSON.stringify(data));\n  // 取消订阅HTTP响应头事件\n  httpRequest.off('headersReceive');\n  // 取消订阅HTTP流式响应数据接收事件\n  httpRequest.off('dataReceive');\n  // 取消订阅HTTP流式响应数据接收进度事件\n  httpRequest.off('dataReceiveProgress');\n  // 取消订阅HTTP流式响应数据接收完毕事件\n  httpRequest.off('dataEnd');\n  // 当该请求使用完毕时，调用destroy方法主动销毁\n  httpRequest.destroy();\n}).catch((err: Error) => {\n  console.info(\"requestInStream ERROR : err = \" + JSON.stringify(err));\n});
证书锁定
可以通过预置应用级证书，或者预置证书公钥哈希值的方式来进行证书锁定，即只有开发者特别指定的证书才能正常建立https连接。
两种方式都是在配置文件中配置的，配置文件在APP中的路径是：src/main/resources/base/profile/network_config.json。在该配置中，可以为预置的证书与网络服务器建立对应关系。
如果不知道服务器域名的证书，可以通过以下方式访问该域名获取证书，注意把www.example.com改成想要获取域名证书的域名，www.example.com.pem改成想保存的证书文件名：
openssl s_client -servername www.example.com -connect www.example.com:443 \\\n    < /dev/null | sed -n \"/-----BEGIN/,/-----END/p\" > www.example.com.pem
如果你的环境是Windows系统，需要注意：
 将/dev/null替换成NUL。 和Linux的OpenSSL表现可能不同，OpenSSL可能会等待用户输入才会退出，按Enter键即可。 如果没有sed命令，将输出中从-----BEGIN CERTIFICATE-----到-----END CERTIFICATE-----之间的部分复制下来保存即可（复制部分包括这两行）。 
[h2]预置应用级证书
直接把证书原文件预置在APP中。目前支持crt和pem格式的证书文件。
当前ohos.net.http和Image组件的证书锁定，会匹配证书链上所有证书的哈希值，如果服务器更新了任意一本证书，都会导致校验失败。如果服务器出现了更新证书的情况，APP版本应当随之更新并推荐消费者尽快升级APP版本，否则可能导致联网失败。
[h2]预置证书公钥哈希值
通过在配置中指定域名证书公钥的哈希值来只允许使用公钥哈希值匹配的域名证书访问此域名。
域名证书的公钥哈希值可以用如下的命令计算，这里假设域名证书是通过上面的OpenSSL命令获得的，并保存在www.example.com.pem文件。#开头的行是注释，可以不用输入：
# 从证书中提取出公钥\nopenssl x509 -in www.example.com.pem -pubkey -noout > www.example.com.pubkey.pem\n# 将pem格式的公钥转换成der格式\nopenssl asn1parse -noout -inform pem -in www.example.com.pubkey.pem -out www.example.com.pubkey.der\n# 计算公钥的SHA256并转换成base64编码\nopenssl dgst -sha256 -binary www.example.com.pubkey.der | openssl base64
[h2]JSON配置文件示例
预置应用级证书的配置例子如下：
{\n  \"network-security-config\": {\n    \"base-config\": {\n      \"trust-anchors\": [\n        {\n          \"certificates\": \"/etc/security/certificates\"\n        }\n      ]\n    },\n    \"domain-config\": [\n      {\n        \"domains\": [\n          {\n            \"include-subdomains\": true,\n            \"name\": \"example.com\"\n          }\n        ],\n        \"trust-anchors\": [\n          {\n            \"certificates\": \"/data/storage/el1/bundle/entry/resources/resfile\"\n          }\n        ]\n      }\n    ]\n  }\n}
预置证书公钥哈希值的配置例子如下:
{\n  \"network-security-config\": {\n    \"domain-config\": [\n      {\n        \"domains\": [\n          {\n            \"include-subdomains\": true,\n            \"name\": \"server.com\"\n          }\n        ],\n        \"pin-set\": {\n          \"expiration\": \"2024-11-08\",\n          \"pin\": [\n            {\n              \"digest-algorithm\": \"sha256\",\n              \"digest\": \"FEDCBA987654321\"\n            }\n          ]\n        }\n      }\n    ]\n  }\n}
各个字段含义:

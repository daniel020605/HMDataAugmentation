@performance/hp-arkui-no-func-as-arg-for-reusable-component
避免使用函数作为复用的自定义组件创建时的入参。
滑动丢帧场景下，建议优先修改。
规则配置
// code-linter.json5\n{\n  \"rules\": {\n    \"@performance/hp-arkui-no-func-as-arg-for-reusable-component\": \"warn\",\n  }\n}
选项
该规则无需配置额外选项。
正例
// 源码文件，请以工程实际为准\nimport { MyDataSource } from './MyDataSource';\n\n@Reusable\n@Component\nstruct ChildComponent {\n  @State desc: string = '';\n  @State sum: number = 0;\n\n  aboutToReuse(params: Record<string, Object>): void {\n    this.desc = params.desc as string;\n    this.sum = params.sum as number;\n  }\n\n  build() {\n    Column() {\n      Text('子组件' + this.desc)\n        .fontSize(30)\n        .fontWeight(30)\n      Text('结果' + this.sum)\n        .fontSize(30)\n        .fontWeight(30)\n    }\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent{\n  private data: MyDataSource = new MyDataSource();\n  @State sum: number = 0;\n\n  aboutToAppear(): void {\n    for (let index = 0; index < 20; index++) {\n      this.data.pushData(index.toString())\n    }\n    // 执行该异步函数\n    this.count();\n  }\n\n  // 模拟耗时操作逻辑\n  async count() {\n    let temp: number = 0;\n    for (let index = 0; index < 10000; index++) {\n      temp += index;\n    }\n    // 将结果放入状态变量中\n    this.sum = temp;\n  }\n\n  build() {\n    Column() {\n      List() {\n        LazyForEach(this.data, (item: string) => {\n          ListItem() {\n            // 子组件的传参通过状态变量进行\n            ChildComponent({ desc: item, sum: this.sum })\n          }\n          .width('100%')\n          .height(100)\n        }, (item: string) => item)\n      }\n      .width('100%')\n      .height('100%')\n    }\n  }\n}
反例
// 源码文件，请以工程实际为准\nimport { MyDataSource } from './MyDataSource';\n\n// 此处为复用的自定义组件\n@Reusable\n@Component\nstruct ChildComponent {\n  @State desc: string = '';\n  @State sum: number = 0;\n\n  aboutToReuse(params: Record<string, Object>): void {\n    this.desc = params.desc as string;\n    this.sum = params.sum as number;\n  }\n\n  build() {\n    Column() {\n      Text('子组件' + this.desc)\n        .fontSize(30)\n        .fontWeight(30)\n      Text('结果' + this.sum)\n        .fontSize(30)\n        .fontWeight(30)\n    }\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent{\n  private data: MyDataSource = new MyDataSource();\n\n  aboutToAppear(): void {\n    for (let index = 0; index < 20; index++) {\n      this.data.pushData(index.toString())\n    }\n  }\n\n  // 真实场景的函数中可能存在未知的耗时操作逻辑，此处用循环函数模拟耗时操作\n  count(): number {\n    let temp: number = 0;\n    for (let index = 0; index < 10000; index++) {\n      temp += index;\n    }\n    return temp;\n  }\n\n  build() {\n    Column() {\n      List() {\n        LazyForEach(this.data, (item: string) => {\n          ListItem() {\n            // 此处sum参数是函数获取的，实际开发场景无法预料该函数可能出现的耗时操作，每次进行组件复用都会重复触发此函数的调用\n            ChildComponent({ desc: item, sum: this.count() })\n          }\n          .width('100%')\n          .height(100)\n        }, (item: string) => item)\n      }\n      .height('100%')\n      .width('100%')\n    }\n  }\n}
规则集
plugin:@performance/recommended
Code Linter代码检查规则的配置指导请参考代码Code Linter检查。

使用JSVM-API接口进行生命周期相关开发
简介
在JSVM-API中，JSVM_Value是一个表示JavaScript值的抽象类型，它可以表示任何JavaScript值，包括基本类型（如数字、字符串、布尔值）和对象类型（如数组、函数、对象等）。
JSVM_Value的生命周期与其在JavaScript中的对应值的生命周期紧密相关。当JavaScript值被垃圾回收时，与之关联的JSVM_Value也将不再有效。重要的是不要在JavaScript值不再存在时尝试使用JSVM_Value。
框架层的scope通常用于管理JSVM_Value的生命周期。在JSVM-API中，可以使用OH_JSVM_OpenHandleScope和OH_JSVM_CloseHandleScope函数来创建和销毁scope。通过在scope内创建JSVM_Value，可以确保在scope结束时自动释放JSVM_Value，避免内存泄漏。
JSVM_Ref是一个JSVM-API类型，用于管理JSVM_Value的生命周期。JSVM_Ref允许您在JSVM_Value的生命周期内保持对其的引用，即使它已经超出了其原始上下文的范围。这使得您可以在不同的上下文中共享JSVM_Value，并确保在不再需要时正确释放其内存。
合理使用OH_JSVM_OpenHandleScope和OH_JSVM_CloseHandleScope管理JSVM_Value的生命周期，做到生命周期最小化，避免发生内存泄漏问题。
每个JSVM_Value属于特定的HandleScope，HandleScope通过OH_JSVM_OpenHandleScope和OH_JSVM_CloseHandleScope来建立和关闭，HandleScope关闭后，所属的JSVM_Value就会自动释放。
基本概念
JSVM-API提供了一组功能，使开发人员能够在JSVM-API模块中创建和操作JavaScript对象，管理引用和生命周期，并注册垃圾回收回调函数等。下面是一些基本概念：
作用域：用于创建一个范围，在范围内声明的引用在范围外部将不再生效。JSVM-API提供了创建、关闭普通和可逃逸的作用域的函数。引用管理：JSVM-API提供函数来创建、删除和管理对象的引用，以延长对象的生命周期，并避免在使用对象时发生内存泄漏。可逃逸的作用域：允许在创建的作用域中声明的对象返回到父作用域，通过OH_JSVM_OpenEscapableHandleScope和OH_JSVM_CloseEscapableHandleScope进行管理。垃圾回收回调：允许注册回调函数，以便在JavaScript对象被垃圾回收时执行特定的清理操作。
这些基本概念使开发人员能够在JSVM-API模块中安全且有效地操作JavaScript对象，并确保正确管理对象的生命周期。
接口说明
使用示例
JSVM-API接口开发流程参考使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应C++相关代码进行展示。
[h2]OH_JSVM_OpenHandleScope、OH_JSVM_CloseHandleScope
通过接口OH_JSVM_OpenHandleScope创建一个上下文环境使用。需要使用OH_JSVM_CloseHandleScope进行关闭。用于管理JavaScript对象的生命周期确保在JSVM-API模块代码处理JavaScript对象时能够正确地管理其句柄，以避免出现垃圾回收相关的问题。
cpp部分代码
// OH_JSVM_OpenHandleScope、OH_JSVM_CloseHandleScope的三种样例方法\nstatic JSVM_Value HandleScopeFor(JSVM_Env env, JSVM_CallbackInfo info) {\n    // 在for循环中频繁调用JSVM接口创建js对象时，要加handle_scope及时释放不再使用的资源。\n    // 下面例子中，每次循环结束局部变量res的生命周期已结束，因此加scope及时释放其持有的js对象，防止内存泄漏\n    constexpr uint32_t DIFF_VALUE_HUNDRED_THOUSAND = 10000;\n    JSVM_Value checked = nullptr;\n    for (int i = 0; i < DIFF_VALUE_HUNDRED_THOUSAND; i++) {\n        JSVM_HandleScope scope = nullptr;\n        JSVM_Status status = OH_JSVM_OpenHandleScope(env, &scope);\n        if (status != JSVM_OK || scope == nullptr) {\n            OH_JSVM_GetBoolean(env, false, &checked);\n            OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_OpenHandleScope: failed\");\n            return checked;\n        }\n        JSVM_Value res = nullptr;\n        OH_JSVM_CreateObject(env, &res);\n        status = OH_JSVM_CloseHandleScope(env, scope);\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_CloseHandleScope: failed\");\n        }\n    }\n    OH_JSVM_GetBoolean(env, true, &checked);\n    OH_LOG_INFO(LOG_APP, \"JSVM HandleScopeFor: success\");\n    return checked;\n}\n\n// HandleScopeFor注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.callback = HandleScopeFor, .data = nullptr},\n};\n\nstatic JSVM_CallbackStruct *method = param;\n// HandleScopeFor方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"HandleScopeFor\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n\nconst char *srcCallNative = \"HandleScopeFor()\";
预期输出
JSVM HandleScopeFor: success
[h2]OH_JSVM_OpenEscapableHandleScope、OH_JSVM_CloseEscapableHandleScope、OH_JSVM_EscapeHandle
通过接口 OH_JSVM_OpenEscapableHandleScope 创建出一个可逃逸的 handel scope，可将 1 个范围内声明的值返回到父作用域。创建的 scope 需使用 OH_JSVM_CloseEscapableHandleScope 进行关闭。OH_JSVM_EscapeHandle 将传入的 JavaScript 对象的生命周期提升到其父作用域。
通过上述接口可以更灵活的使用管理传入的 JavaScript 对象，特别是在处理跨作用域的值传递时非常有用。
cpp 部分代码
// OH_JSVM_OpenEscapableHandleScope、OH_JSVM_CloseEscapableHandleScope、OH_JSVM_EscapeHandle的样例方法\nstatic JSVM_Value EscapableHandleScopeTest(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 创建一个可逃逸的句柄作用域\n    JSVM_EscapableHandleScope scope = nullptr;\n    JSVM_Status status = OH_JSVM_OpenEscapableHandleScope(env, &scope);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_OpenEscapableHandleScope: failed\");\n        return nullptr;\n    }\n    // 在可逃逸的句柄作用域内创建一个obj\n    JSVM_Value obj;\n    OH_JSVM_CreateObject(env, &obj);\n    // 在对象中添加属性\n    JSVM_Value value = nullptr;\n    OH_JSVM_CreateStringUtf8(env, \"Test jsvm_escapable_handle_scope\", JSVM_AUTO_LENGTH, &value);\n    OH_JSVM_SetNamedProperty(env, obj, \"name\", value);\n    // 调用OH_JSVM_EscapeHandle将对象逃逸到作用域之外\n    JSVM_Value escapedObj = nullptr;\n    OH_JSVM_EscapeHandle(env, scope, obj, &escapedObj);\n    // 关闭可逃逸的句柄作用域，清理资源\n    status = OH_JSVM_CloseEscapableHandleScope(env, scope);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_CloseEscapableHandleScope: failed\");\n        return nullptr;\n    }\n    // 此时的escapedObj已逃逸，可以在作用域外继续使用escapedObj\n    bool result = false;\n    OH_JSVM_CreateStringUtf8(env, \"name\", JSVM_AUTO_LENGTH, &value);\n    OH_JSVM_HasProperty(env, escapedObj, value, &result);\n    if (result) {\n        OH_LOG_INFO(LOG_APP, \"JSVM EscapableHandleScopeTest: success\");\n    }\n    return escapedObj;\n}\n\n// EscapableHandleScopeTest注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.callback = EscapableHandleScopeTest, .data = nullptr},\n};\nstatic JSVM_CallbackStruct *method = param;\n// EscapableHandleScopeTest方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"escapableHandleScopeTest\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n\nconst char *srcCallNative = \"escapableHandleScopeTest()\";
预期输出
JSVM EscapableHandleScopeTest: success
[h2]OH_JSVM_CreateReference、OH_JSVM_DeleteReference、OH_JSVM_GetReferenceValue
调用 OH_JSVM_CreateReference 为 JavaScript 变量创建一个引用，以延长其生命周期。调用 OH_JSVM_GetReferenceValue 获取与引用关联的 JavaScript 变量。调用 OH_JSVM_DeleteReference 删除传入的引用。
调用者需要自己管理引用生命周期，引用有效期间 JavaScript 变量不会被垃圾回收处理。
[h2]OH_JSVM_ReferenceRef、OH_JSVM_ReferenceUnref
增加/减少 传入的引用的引用计数，并获取新的计数。当引用计数被置为 0 后，对于可以被设置为弱引用的 JavaScript 类型（对象、函数、外部变量），引用将被置为弱引用，在垃圾回收机制认为必要的时候该变量会被回收，当变量被回收后，调用 OH_JSVM_GetReferenceValue 会获得 JavaScript NULL；对于不可被置为弱引用的 JavaScript 类型，该引用会被清除，调用 OH_JSVM_GetReferenceValue 会获得 JavaScript NULL。
cpp部分代码
static JSVM_Value UseReference(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 创建 JavaScript 对象\n    JSVM_Value obj = nullptr;\n    OH_JSVM_CreateObject(env, &obj);\n    JSVM_Value value = nullptr;\n    OH_JSVM_CreateStringUtf8(env, \"UseReference\", JSVM_AUTO_LENGTH, &value);\n    OH_JSVM_SetNamedProperty(env, obj, \"name\", value);\n    \n    JSVM_Ref g_ref = nullptr;\n    // 创建对JavaScript对象的引用\n    JSVM_Status status = OH_JSVM_CreateReference(env, obj, 1, &g_ref);\n    if (status != JSVM_OK) {\n        return nullptr;\n    }\n\n    // 增加传入引用的引用计数并返回生成的引用计数\n    uint32_t result;\n    OH_JSVM_ReferenceRef(env, g_ref, &result);\n    OH_LOG_INFO(LOG_APP, \"JSVM OH_JSVM_ReferenceRef, count = %{public}d.\", result);\n    if (result != 2) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_ReferenceRef: failed\");\n        return nullptr;\n    }\n\n    //  减少传入引用的引用计数并返回生成的引用计数\n    uint32_t num;\n    OH_JSVM_ReferenceUnref(env, g_ref, &num);\n    OH_LOG_INFO(LOG_APP, \"JSVM OH_JSVM_ReferenceUnref, count = %{public}d.\", num);\n    if (num != 1) {\n        return nullptr;\n    }\n\n    JSVM_Value object = nullptr;\n    // 通过调用OH_JSVM_GetReferenceValue获取引用的JavaScript对象\n    status = OH_JSVM_GetReferenceValue(env, g_ref, &object);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_GetReferenceValue: failed\");\n        return nullptr;\n    }\n\n    // 不再使用引用，通过调用OH_JSVM_DeleteReference删除对JavaScript对象的引用\n    status = OH_JSVM_DeleteReference(env, g_ref);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_DeleteReference: failed\");\n        return nullptr;\n    }\n\n    // 将获取到的对象返回\n    OH_LOG_INFO(LOG_APP, \"JSVM UseReference success\");\n    return object;\n}\n\n// CreateReference、UseReference、DeleteReference注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.callback = UseReference, .data = nullptr},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateReference、UseReference、DeleteReference方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"useReference\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n\nconst char *srcCallNative = \"useReference()\";
预期结果
JSVM OH_JSVM_ReferenceRef, count = 2.\nJSVM OH_JSVM_ReferenceUnref, count = 1.\nJSVM UseReference success
[h2]OH_JSVM_AddFinalizer
为 JavaScript 对象添加 JSVM_Finalize 回调，当 JavaScript 对象被垃圾回收时执行函数回调，该接口通常被用于释放与 JavaScript 对象相关的原生对象。如果传入的参数类型不是 JavaScript 对象，该接口调用失败并返回错误码。
Finalizer 方法被注册后无法取消，如果在调用 OH_JSVM_DestroyEnv 前均未被执行，则在 OH_JVSM_DestroyEnv 时执行。
cpp 部分代码
static int AddFinalizer(JSVM_VM vm, JSVM_Env env) {\n    // 打开 handlescope\n    JSVM_HandleScope handleScope;\n    CHECK_RET(OH_JSVM_OpenHandleScope(env, &handleScope));\n    // 创建 object 并设置回调\n    JSVM_Value obj;\n    CHECK_RET(OH_JSVM_CreateObject(env, &obj));\n    CHECK_RET(OH_JSVM_AddFinalizer(\n        env, obj, nullptr,\n        [](JSVM_Env env, void *data, void *hint) -> void {\n            // Finalizer 方法，可在该方法中清理 Native 对象\n            OH_LOG_INFO(LOG_APP, \"JSVM: finalizer called.\");\n        },\n        nullptr, nullptr));\n    OH_LOG_INFO(LOG_APP, \"JSVM: finalizer added.\");\n    // 关闭 handlescope，触发 GC，GC 时 Finalizer 会被调用\n    CHECK_RET(OH_JSVM_CloseHandleScope(env, handleScope));\n    OH_LOG_INFO(LOG_APP, \"JSVM: before call gc.\");\n    CHECK_RET(OH_JSVM_MemoryPressureNotification(env, JSVM_MemoryPressureLevel::JSVM_MEMORY_PRESSURE_LEVEL_CRITICAL));\n    OH_LOG_INFO(LOG_APP, \"JSVM: after call gc.\");\n\n    return 0;\n}\n\nstatic void RunDemo(JSVM_VM vm, JSVM_Env env) {\n    if (AddFinalizer(vm, env) != 0) {\n        OH_LOG_INFO(LOG_APP, \"Run PromiseRegisterHandler failed\");\n    }\n}
预期结果
JSVM: finalizer added.\nJSVM: before call gc.\nJSVM: finalizer called.\nJSVM: after call gc.

@Local装饰器：组件内部状态
为了实现对@ComponentV2装饰的自定义组件中变量变化的观测，开发者可以使用@Local装饰器装饰变量。
在阅读本文档前，建议提前阅读：@ComponentV2。
从API version 12开始，在@ComponentV2装饰的自定义组件中支持使用@Local装饰器。
概述
@Local表示组件内部的状态，使得自定义组件内部的变量具有观测变化的能力：
 被@Local装饰的变量无法从外部初始化，因此必须在组件内部进行初始化。 当被@Local装饰的变量变化时，会刷新使用该变量的组件。 @Local支持观测number、boolean、string、Object、class等基本类型以及Array、Set、Map、Date等内嵌类型。 @Local的观测能力仅限于被装饰的变量本身。当装饰简单类型时，能够观测到对变量的赋值；当装饰对象类型时，仅能观测到对对象整体的赋值；当装饰数组类型时，能观测到数组整体以及数组元素项的变化；当装饰Array、Set、Map、Date等内嵌类型时，可以观测到通过API调用带来的变化。详见观察变化。 @Local支持null、undefined以及联合类型。 
状态管理V1版本@State装饰器的局限性
状态管理V1使用@State装饰器定义类中的状态变量。但由于@State装饰器能够从外部初始化，因此@State无法准确表达组件内部状态不能被外面修改的语义。
class ComponentInfo {\n  name: string;\n  count: number;\n  message: string;\n  constructor(name: string, count: number, message: string) {\n    this.name = name;\n    this.count = count;\n    this.message = message;\n  }\n}\n@Component\nstruct Child {\n  @State componentInfo: ComponentInfo = new ComponentInfo(\"Child\", 1, \"Hello World\");\n\n  build() {\n    Column() {\n      Text(`componentInfo.message is ${this.componentInfo.message}`)\n    }\n  }\n}\n@Entry\n@Component\nstruct Index {\n  build() {\n    Column() {\n      Child({componentInfo: new ComponentInfo(\"Unknown\", 0, \"Error\")})\n    }\n  }\n}
上述代码中，可以通过在初始化Child组件时，传入新的值来覆盖Child组件想要作为内部状态变量使用的componentInfo。但Child组件并不能感知到componentInfo从外部进行了初始化，这不利于组件内部状态的管理。因此推出@Local装饰器表示组件的内部状态。
装饰器说明
变量传递
观察变化
使用@Local装饰的变量具有被观测变化的能力。当装饰的变量发生变化时，会触发该变量绑定的UI组件刷新。
 当装饰的变量类型为boolean、string、number时，可以观察到对变量赋值的变化。 @Entry\n@ComponentV2\nstruct Index {\n  @Local count: number = 0;\n  @Local message: string = \"Hello\";\n  @Local flag: boolean = false;\n  build() {\n    Column() {\n      Text(`${this.count}`)\n      Text(`${this.message}`)\n      Text(`${this.flag}`)\n      Button(\"change Local\")\n        .onClick(()=>{\n          // 当@Local装饰简单类型时，能够观测到对变量的赋值\n          this.count++;\n          this.message += \" World\";\n          this.flag = !this.flag;\n      })\n    }\n  }\n} 当装饰的变量类型为类对象时，仅可以观察到对类对象整体赋值的变化，无法直接观察到对类成员属性赋值的变化，对类成员属性的观察依赖@ObservedV2和@Trace装饰器。注意，@Local无法和@Observed装饰的类实例对象混用。 class RawObject {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n@ObservedV2\nclass ObservedObject {\n  @Trace name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local rawObject: RawObject = new RawObject(\"rawObject\");\n  @Local observedObject: ObservedObject = new ObservedObject(\"observedObject\");\n  build() {\n    Column() {\n      Text(`${this.rawObject.name}`)\n      Text(`${this.observedObject.name}`)\n      Button(\"change object\")\n        .onClick(() => {\n          // 对类对象整体的修改均能观察到\n          this.rawObject = new RawObject(\"new rawObject\");\n          this.observedObject = new ObservedObject(\"new observedObject\");\n      })\n      Button(\"change name\")\n        .onClick(() => {\n          // @Local不具备观察类对象属性的能力，因此对rawObject.name的修改无法观察到\n          this.rawObject.name = \"new rawObject name\";\n          // 由于ObservedObject的name属性被@Trace装饰，因此对observedObject.name的修改能被观察到\n          this.observedObject.name = \"new observedObject name\";\n      })\n    }\n  }\n} 当装饰的变量类型为简单类型的数组时，可以观察到数组整体或数组项的变化。 @Entry\n@ComponentV2\nstruct Index {\n  @Local numArr: number[] = [1,2,3,4,5];\n  @Local dimensionTwo: number[][] = [[1,2,3],[4,5,6]];\n\n  build() {\n    Column() {\n      Text(`${this.numArr[0]}`)\n      Text(`${this.numArr[1]}`)\n      Text(`${this.numArr[2]}`)\n      Text(`${this.dimensionTwo[0][0]}`)\n      Text(`${this.dimensionTwo[1][1]}`)\n      Button(\"change array item\")\n        .onClick(() => {\n          this.numArr[0]++;\n          this.numArr[1] += 2;\n          this.dimensionTwo[0][0] = 0;\n          this.dimensionTwo[1][1] = 0;\n        })\n      Button(\"change whole array\")\n        .onClick(() => {\n          this.numArr = [5,4,3,2,1];\n          this.dimensionTwo = [[7,8,9],[0,1,2]];\n        })\n    }\n  }\n} 当装饰的变量是嵌套类或对象数组时，@Local无法观察深层对象属性的变化。对深层对象属性的观测依赖@ObservedV2与@Trace装饰器。 @ObservedV2\nclass Region {\n  @Trace x: number;\n  @Trace y: number;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n@ObservedV2\nclass Info {\n  @Trace region: Region;\n  @Trace name: string;\n  constructor(name: string, x: number, y: number) {\n    this.name = name;\n    this.region = new Region(x, y);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local infoArr: Info[] = [new Info(\"Ocean\", 28, 120), new Info(\"Mountain\", 26, 20)];\n  @Local originInfo: Info = new Info(\"Origin\", 0, 0);\n  build() {\n    Column() {\n      ForEach(this.infoArr, (info: Info) => {\n        Row() {\n          Text(`name: ${info.name}`)\n          Text(`region: ${info.region.x}-${info.region.y}`)\n        }\n      })\n      Row() {\n          Text(`Origin name: ${this.originInfo.name}`)\n          Text(`Origin region: ${this.originInfo.region.x}-${this.originInfo.region.y}`)\n      }\n      Button(\"change infoArr item\")\n        .onClick(() => {\n          // 由于属性name被@Trace装饰，所以能够观察到\n          this.infoArr[0].name = \"Win\";\n        })\n      Button(\"change originInfo\")\n        .onClick(() => {\n          // 由于变量originInfo被@Local装饰，所以能够观察到\n          this.originInfo = new Info(\"Origin\", 100, 100);\n        })\n      Button(\"change originInfo region\")\n        .onClick(() => {\n          // 由于属性x、y被@Trace装饰，所以能够观察到\n          this.originInfo.region.x = 25;\n          this.originInfo.region.y = 25;\n        })\n    }\n  }\n} 当装饰的变量类型是内置类型时，可以观察到变量整体赋值以及通过API调用带来的变化。     类型 可观测变化的API    Array push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort   Date setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds   Map set, clear, delete   Set add, clear, delete    
限制条件
@Local装饰器存在以下使用限制：
 @Local装饰器只能在@ComponentV2装饰的自定义组件中使用。 @ComponentV2\nstruct MyComponent {\n  @Local message: string = \"Hello World\"; // 正确用法\n  build() {\n  }\n}\n@Component\nstruct TestComponent {\n  @Local message: string = \"Hello World\"; // 错误用法，编译时报错\n  build() {\n  }\n} @Local装饰的变量表示组件内部状态，不允许从外部传入初始化。 @ComponentV2\nstruct ChildComponent {\n  @Local message: string = \"Hello World\";\n  build() {\n  }\n}\n@ComponentV2\nstruct MyComponent {\n  build() {\n    ChildComponent({ message: \"Hello\" }) // 错误用法，编译时报错\n  }\n} 
@Local与@State对比
@Local与@State的用法、功能对比如下：
使用场景
[h2]观测对象整体变化
被@ObservedV2与@Trace装饰的类对象实例，具有深度观测对象属性的能力。但当对对象整体赋值时，UI却无法刷新。使用@Local装饰对象，可以达到观测对象本身变化的效果。
@ObservedV2\nclass Info {\n  @Trace name: string;\n  @Trace age: number;\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  info: Info = new Info(\"Tom\", 25);\n  @Local localInfo: Info = new Info(\"Tom\", 25);\n  build() {\n    Column() {\n      Text(`info: ${this.info.name}-${this.info.age}`) // Text1\n      Text(`localInfo: ${this.localInfo.name}-${this.localInfo.age}`) // Text2\n      Button(\"change info&localInfo\")\n        .onClick(() => {\n          this.info = new Info(\"Lucy\", 18); // Text1不会刷新\n          this.localInfo = new Info(\"Lucy\", 18); // Text2会刷新\n      })\n    }\n  }\n}
[h2]装饰Date类型变量
当装饰的对象是Date时，可以观察到Date整体的赋值，同时可通过调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 更新Date的属性。
@Entry\n@ComponentV2\nstruct DatePickerExample {\n  @Local selectedDate: Date = new Date('2021-08-08');\n\n  build() {\n    Column() {\n      Button('set selectedDate to 2023-07-08')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate = new Date('2023-07-08');\n        })\n      Button('increase the year by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setFullYear(this.selectedDate.getFullYear() + 1);\n        })\n      Button('increase the month by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setMonth(this.selectedDate.getMonth() + 1);\n        })\n      Button('increase the day by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setDate(this.selectedDate.getDate() + 1);\n        })\n      DatePicker({\n        start: new Date('1970-1-1'),\n        end: new Date('2100-1-1'),\n        selected: this.selectedDate\n      })\n    }.width('100%')\n  }\n}
[h2]装饰Map类型变量
当装饰的对象是Map时，可以观察到对Map整体的赋值，同时可以通过调用Map的接口 set、clear、delete更新Map中的数据。
@Entry\n@ComponentV2\nstruct MapSample {\n  @Local message: Map<number, string> = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.message.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`).fontSize(30)\n          Text(`${item[1]}`).fontSize(30)\n          Divider()\n        })\n        Button('init map').onClick(() => {\n          this.message = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n        })\n        Button('set new one').onClick(() => {\n          this.message.set(4, \"d\");\n        })\n        Button('clear').onClick(() => {\n          this.message.clear();\n        })\n        Button('replace the first one').onClick(() => {\n          this.message.set(0, \"aa\");\n        })\n        Button('delete the first one').onClick(() => {\n          this.message.delete(0);\n        })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]装饰Set类型变量
当装饰的对象是Set时，可以观察到对Set整体的赋值，同时可以通过调用Set的接口add、clear、delete更新Set中的数据。
@Entry\n@ComponentV2\nstruct SetSample {\n  @Local message: Set<number> = new Set([0, 1, 2, 3, 4]);\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.message.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`).fontSize(30)\n          Divider()\n        })\n        Button('init set').onClick(() => {\n          this.message = new Set([0, 1, 2, 3, 4]);\n        })\n        Button('set new one').onClick(() => {\n          this.message.add(5);\n        })\n        Button('clear').onClick(() => {\n          this.message.clear();\n        })\n        Button('delete the first one').onClick(() => {\n          this.message.delete(0);\n        })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]联合类型
@Local支持null、undefined以及联合类型。在下面的示例中，count类型为number | undefined，点击改变count的类型，UI会随之刷新。
@Entry\n@ComponentV2\nstruct Index {\n  @Local count: number | undefined = 10;\n\n  build() {\n    Column() {\n      Text(`count(${this.count})`)\n      Button(\"change to undefined\")\n        .onClick(() => {\n          this.count = undefined;\n        })\n      Button(\"change to number\")\n        .onClick(() => {\n          this.count = 10;\n      })\n    }\n  }\n}
常见问题
[h2]复杂类型常量重复赋值给状态变量触发刷新
@Entry\n@ComponentV2\nstruct Index {\n  list: string[][] = [['a'], ['b'], ['c']];\n  @Local dataObjFromList: string[] = this.list[0];\n\n  @Monitor(\"dataObjFromList\")\n  onStrChange(monitor: IMonitor) {\n    console.log(\"dataObjFromList has changed\");\n  }\n\n  build() {\n    Column() {\n      Button('change to self').onClick(() => {\n        // 新值和本地初始化的值相同\n        this.dataObjFromList = this.list[0];\n      })\n    }\n  }\n}
以上示例每次点击Button('change to self')，把相同的Array类型常量赋值给一个Array类型的状态变量，都会触发刷新。原因是在状态管理V2中，会给使用状态变量装饰器如@Trace、@Local装饰的Date、Map、Set、Array添加一层代理用于观测API调用产生的变化。
当再次赋值list[0]时，dataObjFromList已经是一个Proxy类型，而list[0]是Array类型，判断是不相等的，因此会触发赋值和刷新。
为了避免这种不必要的赋值和刷新，可以使用UIUtils.getTarget()获取原始对象提前进行新旧值的判断，当两者相同时不执行赋值。
使用UIUtils.getTarget()方法示例
import { UIUtils } from '@ohos.arkui.StateManagement';\n\n@Entry\n@ComponentV2\nstruct Index {\n  list: string[][] = [['a'], ['b'], ['c']];\n  @Local dataObjFromList: string[] = this.list[0];\n\n  @Monitor(\"dataObjFromList\")\n  onStrChange(monitor: IMonitor) {\n    console.log(\"dataObjFromList has changed\");\n  }\n\n  build() {\n    Column() {\n      Button('change to self').onClick(() => {\n        // 获取原始对象来和新值做对比\n        if (UIUtils.getTarget(this.dataObjFromList) !== this.list[0]) {\n          this.dataObjFromList = this.list[0];\n        }\n      })\n    }\n  }\n}
[h2]在状态管理V2中使用animateTo动画效果异常
在下面的场景中，animateTo暂不支持直接在状态管理V2中使用。
@Entry\n@ComponentV2\nstruct Index {\n  @Local w: number = 50; // 宽度\n  @Local h: number = 50; // 高度\n  @Local message: string = 'Hello';\n\n  build() {\n    Column() {\n      Button('change size')\n        .margin(20)\n        .onClick(() => {\n          // 在执行动画前，存在额外的修改\n          this.w = 100;\n          this.h = 100;\n          this.message = 'Hello World';\n          animateTo({\n            duration: 1000\n          }, () => {\n            this.w = 200;\n            this.h = 200;\n            this.message = 'Hello ArkUI';\n          })\n        })\n      Column() {\n        Text(`${this.message}`)\n      }\n      .backgroundColor('#ff17a98d')\n      .width(this.w)\n      .height(this.h)\n    }\n  }\n}
上面的代码中，开发者预期显示的动画为绿色矩形从长宽100变化成200，字符串从Hello World变化成Hello ArkUI，但由于当前animateTo与V2在刷新机制上暂不兼容，在执行动画前额外的修改并不会生效，因此实际显示的动画为绿色矩形从长宽50变化成200，字符串从Hello变化成Hello ArkUI。
可以通过下面的方法暂时获得预期的显示效果。
@Entry\n@ComponentV2\nstruct Index {\n  @Local w: number = 50; // 宽度\n  @Local h: number = 50; // 高度\n  @Local message: string = 'Hello';\n\n  build() {\n    Column() {\n      Button('change size')\n        .margin(20)\n        .onClick(() => {\n          // 在执行动画前，存在额外的修改\n          this.w = 100;\n          this.h = 100;\n          this.message = 'Hello Word';\n          animateToImmediately({\n            duration: 0\n          }, () => {\n          })\n          animateTo({\n            duration: 1000\n          }, () => {\n            this.w = 200;\n            this.h = 200;\n            this.message = 'Hello ArkUI';\n          })\n        })\n      Column() {\n        Text(`${this.message}`)\n      }\n      .backgroundColor('#ff17a98d')\n      .width(this.w)\n      .height(this.h)\n    }\n  }\n}
原理为使用一个duration为0的animateToImmediately将额外的修改先刷新，再执行原来的动画达成预期的效果。
建议开发者在状态管理V2中谨慎使用animateTo接口。

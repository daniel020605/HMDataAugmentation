ArkUI数据更新场景
当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，因为ArkUI的标注和@Sendable装饰器不能同时修饰变量和对象，所以对于此类场景，需要使用makeObserved在ArkUI中导入可观察的Sendable共享数据。
本示例将说明下面的场景：
 makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI刷新。 从子线程中获取一个整体数据，然后对UI线程的可观察数据做整体替换。 从子线程获取的数据重新执行makeObserved，将数据变为可观察数据。 将数据从UI主线程传递回子线程时，仅传递不可观察的数据。makeObserved的返回值不可直接传给子线程。 
// SendableData.ets\n@Sendable\nexport class SendableData {\n  name: string = 'Tom';\n  age: number = 20;\n  gender: number = 1;\n  likes: number = 1;\n  follow: boolean = false;\n}
import { taskpool } from '@kit.ArkTS';\nimport { SendableData } from './SendableData';\nimport { UIUtils } from '@kit.ArkUI';\n\n@Concurrent\nfunction threadGetData(param: string): SendableData {\n  // 在子线程处理数据\n  let ret = new SendableData();\n  console.info(`Concurrent threadGetData, param ${param}`);\n  ret.name = param + \"-o\";\n  ret.age = Math.floor(Math.random() * 40);\n  ret.likes = Math.floor(Math.random() * 100);\n  return ret;\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  // 通过makeObserved给普通对象或是Sendable对象添加可观察能力\n  @Local send: SendableData = UIUtils.makeObserved(new SendableData());\n\n  build() {\n    Column() {\n      Text(this.send.name)\n      Button(\"change name\").onClick(() => {\n        // 可以观察到属性的改变\n        this.send.name += \"0\";\n      })\n\n      Button(\"task\").onClick(() => {\n        // 将待执行的函数放入taskpool内部任务队列等待，等待分发到工作线程执行。\n        // 因为数据的构建和处理可以在子线程中完成，但有观察能力的数据不能传给子线程，只有在UI主线程里才可以操作可观察的数据。\n        // 所以这里只是将`this.send`的属性`name`传给子线程操作。\n        taskpool.execute(threadGetData, this.send.name).then(val => {\n          // 和@Local一起使用，可以观察this.send的变化\n          this.send = UIUtils.makeObserved(val as SendableData);\n        })\n      })\n    }\n  }\n}

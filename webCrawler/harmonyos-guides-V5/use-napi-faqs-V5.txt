Node-API常见问题
ArkTS/JS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message
排查.cpp文件在注册模块时的模块名称与so的名称匹配一致。 如模块名为entry，则so的名字为libentry.so，napi_module中nm_modname字段应为entry，大小写与模块名保持一致。 排查so是否加载成功。 应用启动时过滤模块加载相关日志，重点搜索\"dlopen\"关键字，确认是否有相关报错信息；常见加载失败原因有权限不足、so文件不存在以及so已拉入黑名单等，可根据以下关键错误日志确认问题。其中，多线程场景(worker、taskpool等)下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。 排查依赖的so是否加载成功。 确定所依赖的其它so是否打包到应用中以及是否有权限打开。常见加载失败原因有权限不足、so文件不存在等，可根据以下关键错误日志确认问题。 排查模块导入方式与so路径是否对应。 若JS侧导入模块的形式为： import xxx from '@ohos.yyy.zzz'，则该so将在/system/lib/module/yyy中找libzzz.z.so或libzzz_napi.z.so，若so不存在或名称无法对应，则报错日志中会出现dlopen相关日志。 注意，32位系统路径为/system/lib，64位系统路径为/system/lib64。 
如果有明确的Error message，可以通过Error message判断当前问题。
接口执行结果非预期，日志显示occur exception need return
部分Node-API接口在调用结束前会进行检查，检查虚拟机中是否存在JS异常。如果存在异常，则会打印出occur exception need return日志，并打印出检查点所在的行号，以及对应的Node-API接口名称。
解决此类问题有以下两种思路：
若该异常开发者不关心，可以选择直接清除。 可直接使用napi接口napi_get_and_clear_last_exception，清理异常。调用时机：在打印occur exception need return日志的接口之前调用。 将该异常继续向上抛到ArkTS层，在ArkTS层进行捕获。 发生异常时，可以选择走异常分支， 确保不再走多余的Native逻辑 ，直接返回到ArkTS层。 
napi_value和napi_ref的生命周期有何区别
native_value由HandleScope管理，一般开发者不需要自己加HandleScope（uv_queue_work的complete callback除外）。 napi_ref由开发者自己管理，需要手动delete。 
Node-API接口返回值不是napi_ok时，如何排查定位
Node-API接口正常执行后，会返回一个napi_ok的状态枚举值，若napi接口返回值不为napi_ok，可从以下几个方面进行排查。
Node-API接口执行前一般会进行入参校验，首先进行的是判空校验。在代码中体现为： CHECK_ENV： env判空校验\nCHECK_ARG：其它入参判空校验 某些Node-API接口还有入参类型校验。比如napi_get_value_double接口是获取JS number对应的C double值，首先就要保证的是：JS value类型为number，因此可以看到相关校验。 RETURN_STATUS_IF_FALSE(env, nativeValue->TypeOf() == NATIVE_NUMBER, napi_number_expected); 还有一些接口会对其执行结果进行校验。比如napi_call_function这个接口，其功能是执行一个JS function，当JS function中出现异常时，Node-API将会返回napi_pending_exception的状态值。 auto resultValue = engine->CallFunction(nativeRecv, nativeFunc, nativeArgv, argc);\nRETURN_STATUS_IF_FALSE(env, resultValue != nullptr, napi_pending_exception) 还有一些状态值需要根据相应Node-API接口具体分析：确认具体的状态值，分析这个状态值在什么情况下会返回，再排查具体出错原因。 
napi_threadsafe_function内存泄漏，应该如何处理
napi_threadsafe_function（下文简称tsfn）在使用时，常常会调用 napi_acquire_threadsafe_function 来更改tsfn的引用计数，确保tsfn不会意外被释放。但在使用完成后，应该及时使用 napi_tsfn_release 模式调用 napi_release_threadsafe_function 方法，以确保在所有调用回调都执行完成后，其引用计数能回归到调用 napi_acquire_threadsafe_function 方法之前的水平。当其引用计数归为0时，tsfn才能正确的被释放。
当在env即将退出，但tsfn的引用计数未被归零时，应该使用 napi_tsfn_abort 模式调用 napi_release_threadsafe_function 方法，确保在env释放后不再对tsfn进行持有及使用。在env退出后，继续持有tsfn进行使用，是一种未定义的行为，可能会触发崩溃。
如下代码将展示通过注册 env_cleanup 钩子函数的方式，以确保在env退出后不再继续持有tsfn。
//napi_init.cpp\n#include <hilog/log.h> // hilog, 输出日志, 需链接 libhilog_ndk.z.so\n#include <thread> // 创建线程\n#include <unistd.h> // 线程休眠\n\n// 定义输出日志的标签和域\n#undef LOG_DOMAIN\n#undef LOG_TAG\n#define LOG_DOMAIN 0x2342\n#define LOG_TAG \"MY_TSFN_DEMO\"\n\n/*\n  为构造一个env生命周期小于native生命周期的场景,\n  本文需要使用worker, taskpool 或 napi_create_ark_runtime 等方法,\n  创建非主线程的ArkTS运行环境，并人为的提前结束掉该线程\n*/\n\n\n// 定义一个数据结构，模拟存储tsfn的场景\nclass MyTsfnContext {\npublic:\n// 因使用了napi方法, MyTsfnContext 应当只在js线程被构造\nMyTsfnContext(napi_env env, napi_value workName) {\n    // 注册env销毁钩子函数\n    napi_add_env_cleanup_hook(env, Cleanup, this);\n    // 创建线程安全函数\n    if (napi_create_threadsafe_function(env, nullptr, nullptr, workName, 1, 1, this,\n            TsfnFinalize, this, TsfnCallJs, &tsfn_) != napi_ok) {\n        OH_LOG_INFO(LOG_APP, \"tsfn is created failed\");\n        return;\n    };\n};\n\n~MyTsfnContext() { OH_LOG_INFO(LOG_APP, \"MyTsfnContext is deconstructed\"); };\n\nnapi_threadsafe_function GetTsfn() {\n    std::unique_lock<std::mutex> lock(mutex_);\n    return tsfn_;\n}\n\nbool Acquire() {\n    if (GetTsfn() == nullptr) {\n        return false;\n    };\n    return (napi_acquire_threadsafe_function(GetTsfn()) == napi_ok);\n};\n\nbool Release() {\n    if (GetTsfn() == nullptr) {\n        return false;\n    };\n    return (napi_release_threadsafe_function(GetTsfn(), napi_tsfn_release) == napi_ok);\n};\n\nbool Call(void *data) {\n    if (GetTsfn() == nullptr) {\n        return false;\n    };\n    return (napi_call_threadsafe_function(GetTsfn(), data, napi_tsfn_blocking) == napi_ok);\n};\n\nprivate:\n// 保护多线程读写tsfn的准确性\nstd::mutex mutex_;\nnapi_threadsafe_function tsfn_ = nullptr;\n\n// napi_add_env_cleanup_hook 回调\nstatic void Cleanup(void *data) {\n    MyTsfnContext *that = reinterpret_cast<MyTsfnContext *>(data);\n    napi_threadsafe_function tsfn = that->GetTsfn();\n    std::unique_lock<std::mutex> lock(that->mutex_);\n    that->tsfn_ = nullptr;\n    lock.unlock();\n    OH_LOG_WARN(LOG_APP, \"cleanup is called\");\n    napi_release_threadsafe_function(tsfn, napi_tsfn_abort);\n};\n\n// tsfn 释放时的回调\nstatic void TsfnFinalize(napi_env env, void *data, void *hint) {\n    MyTsfnContext *ctx = reinterpret_cast<MyTsfnContext *>(data);\n    OH_LOG_INFO(LOG_APP, \"tsfn is released\");\n    napi_remove_env_cleanup_hook(env, MyTsfnContext::Cleanup, ctx);\n    // cleanup 提前释放线程安全函数, 为避免UAF, 将释放工作交给调用方\n    if (ctx->GetTsfn() != nullptr) {\n        OH_LOG_INFO(LOG_APP, \"ctx is released\");\n        delete ctx;\n    }\n};\n\n// tsfn 发送到 js 线程执行的回调\nstatic void TsfnCallJs(napi_env env, napi_value func, void *context, void *data) {\n    MyTsfnContext *ctx = reinterpret_cast<MyTsfnContext *>(context);\n    char *str = reinterpret_cast<char *>(data);\n    OH_LOG_INFO(LOG_APP, \"tsfn is called, data is: \\\"%{public}s\\\"\", str);\n    // 业务逻辑已省略\n};\n};\n\n// 该方法需注册到模块Index.d.ts, 注册名为 myTsfnDemo, 接口描述如下\n// export const myTsfnDemo: () => void;\nnapi_value MyTsfnDemo(napi_env env, napi_callback_info info) {\n    OH_LOG_ERROR(LOG_APP, \"MyTsfnDemo is called\");\n    napi_value workName = nullptr;\n    napi_create_string_utf8(env, \"MyTsfnWork\", NAPI_AUTO_LENGTH, &workName);\n    MyTsfnContext *myContext = new MyTsfnContext(env, workName);\n    if (myContext->GetTsfn() == nullptr) {\n        OH_LOG_ERROR(LOG_APP, \"failed to create tsfn\");\n        delete myContext;\n        return nullptr;\n    };\n    char *data0 = new char[]{\"Im call in ArkTS Thread\"};\n    if (!myContext->Call(data0)) {\n        OH_LOG_INFO(LOG_APP, \"call tsfn failed\");\n    };\n\n    // 创建一个线程，模拟异步场景\n    std::thread(\n        [](MyTsfnContext *myCtx) {\n            if (!myCtx->Acquire()) {\n                OH_LOG_ERROR(LOG_APP, \"acquire tsfn failed\");\n                return;\n            };\n            char *data1 = new char[]{\"Im call in std::thread\"};\n            // 非必要操作, 仅用于异步流程tsfn仍有效\n            if (!myCtx->Call(data1)) {\n                OH_LOG_ERROR(LOG_APP, \"call tsfn failed\");\n            };\n            // 休眠 5s, 模拟耗时场景, env退出后, 异步任务仍未执行完成\n            sleep(5);\n            // 此时异步任务已执行完成, 但tsfn已被释放并置为 nullptr\n            char *data2 = new char[]{\"Im call after work\"};\n            if (!myCtx->Call(data2) && !myCtx->Release()) {\n                OH_LOG_ERROR(LOG_APP, \"call and release tsfn failed\");\n                delete myCtx;\n            }\n        },\n        myContext)\n        .detach();\n    return nullptr;\n};
以下内容为主线程逻辑，主要用作创建worker线程和通知worker执行任务
// 主线程 Index.ets\nimport worker, { MessageEvents } from '@ohos.worker';\n\nconst mWorker = new worker.ThreadWorker('../workers/Worker');\nmWorker.onmessage = (e: MessageEvents) => {\n    const action: string | undefined = e.data?.action;\n    if (action === 'kill') {\n        mWorker.terminate();\n    }\n}\n\n// 触发方式的注册已省略\nmWorker.postMessage({action: 'tsfn-demo'})
以下内容为Worker线程逻辑，主要用以触发Native任务
// worker.ets\nimport worker, { ThreadWorkerGlobalScope, MessageEvents, ErrorEvent } from '@ohos.worker';\nimport napiModule from 'libentry.so'; // libentry.so: napi 库的模块名称\n\nconst workerPort: ThreadWorkerGlobalScope = worker.workerPort;\n\nworkerPort.onmessage = (e: MessageEvents) => {\n    const action: string | undefined = e.data?.action;\n    if (action === 'tsfn-demo') {\n        // 触发 c++ 层的 tsfn demo\n        napiModule.myTsfnDemo();\n        // 通知主线程结束 worker\n        workerPort.postMessage({action: 'kill'});\n    };\n}
napi_get_uv_event_loop接口错误码说明
在HarmonyOS中，对使用非法的napi_env作为napi_get_uv_event_loop入参的行为加入了额外的参数校验，这一行为将直接反映到该接口的返回值上。该接口返回值详情如下：
当env且（或）loop为nullptr时，返回napi_invalid_arg。当env为有效的napi_env且loop为合法指针，返回napi_ok。当env不是有效的napi_env（如已释放的env），返回napi_generic_failure。
常见错误场景示例如下：
napi_value NapiInvalidArg(napi_env env, napi_callback_info)\n{\n    napi_status status = napi_ok;\n    status = napi_get_uv_event_loop(env, nullptr); // loop为nullptr, napi_invalid_arg\n    if (status == napi_ok) {\n        // do something\n    }\n\n    uv_loop_s* loop = nullptr;\n    status = napi_get_uv_event_loop(nullptr, &loop); // env为nullptr, napi_invalid_arg\n    if (status == napi_ok) {\n        // do something\n    }\n\n    status = napi_get_uv_event_loop(nullptr, nullptr); // env, loop均为nullptr, napi_invalid_arg\n    if (status == napi_ok) {\n        // do something\n    }\n\n    return nullptr;\n}\n\nnapi_value NapiGenericFailure(napi_env env, napi_callback_info)\n{\n    std::thread([]() {\n        napi_env env = nullptr;\n        napi_create_ark_runtime(&env); // 通常情况下，需要对该接口返回值进行判断\n        // napi_destroy_ark_runtime 会将指针置空，拷贝一份用以构造问题场景\n        napi_env copiedEnv = env;\n        napi_destroy_ark_runtime(&env);\n        uv_loop_s* loop = nullptr;\n        napi_status status = napi_get_uv_event_loop(copiedEnv, &loop); // env无效, napi_generic_failure\n        if (status == napi_ok) {\n            // do something\n        }\n    }).detach();;\n}

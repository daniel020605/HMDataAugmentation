手势拦截
手势拦截主要用于确保手势按需执行，有效解决手势冲突问题。典型应用场景包括：嵌套滚动、通过过滤组件响应手势的范围来优化交互体验。手势拦截主要采用手势触发控制和手势响应控制两种方式实现。
手势触发控制
手势触发控制是指，在系统判定阈值已满足的条件下，应用可自行判断是否应拦截手势，使手势操作失败。
图1 手势触发控制流程图
手势触发控制涉及以下接口。
用于手势拦截、获取手势识别器和初始化手势识别器开闭状态。是onGestureJudgeBegin接口的能力扩展，可以代替onGestureJudgeBegin接口。
获取手势识别器时，会获取一次交互中手势响应链上的所有手势识别器，以及当前即将触发的手势识别器，初始化手势的激活状态。
以下示例中，Image和Stack两个组件位于同一区域。长按Stack组件的上半部分可触发挂载在Stack组件上的长按手势，长按Stack组件的下半部分则会响应Image组件的拖拽操作。
图2 示例图
 Image组件设置拖拽。 Image($r('sys.media.ohos_app_icon'))\n  .draggable(true)\n  .onDragStart(()=>{\n    promptAction.showToast({ message: \"Drag 下半区蓝色区域，Image响应\" });\n  })\n  .width('200vp').height('200vp') Stack组件设置手势。 Stack() {}\n  .width('200vp')\n  .height('200vp')\n  .hitTestBehavior(HitTestMode.Transparent)\n  .gesture(GestureGroup(GestureMode.Parallel,\n    LongPressGesture()\n      .onAction((event: GestureEvent) => {\n        promptAction.showToast({ message: \"LongPressGesture 长按上半区 红色区域，红色区域响应\" });\n      })\n      .tag(\"longpress\")\n  )) Stack组件设置拦截。 .onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {\n  // 如果是长按类型手势，判断点击的位置是否在上半区\n  if (gestureInfo.type == GestureControl.GestureType.LONG_PRESS_GESTURE) {\n    if (event.fingerList.length > 0 && event.fingerList[0].localY < 100) {\n      return GestureJudgeResult.CONTINUE;\n    } else {\n      return GestureJudgeResult.REJECT;\n    }\n  }\n  return GestureJudgeResult.CONTINUE;\n}) 代码完整示例。 import { promptAction } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct Index {\n  scroller: Scroller = new Scroller();\n\n  build() {\n    Scroll(this.scroller) {\n      Column({ space: 8 }) {\n        Text(\"包括上下两层组件，上层组件绑定长按手势，下层组件绑定拖拽。其中上层组件下半区域绑定手势拦截，使该区域响应下层拖拽手势。\").width('100%').fontSize(20).fontColor('0xffdd00')\n        Stack({ alignContent: Alignment.Center }) {\n          Column() {\n            // 模拟上半区和下半区\n            Stack().width('200vp').height('100vp').backgroundColor(Color.Red)\n            Stack().width('200vp').height('100vp').backgroundColor(Color.Blue)\n          }.width('200vp').height('200vp')\n          // Stack的下半区是绑定了拖动手势的图像区域。\n          Image($r('sys.media.ohos_app_icon'))\n            .draggable(true)\n            .onDragStart(()=>{\n              promptAction.showToast({ message: \"Drag 下半区蓝色区域，Image响应\" });\n            })\n            .width('200vp').height('200vp')\n          // Stack的上半区是绑定了长按手势的浮动区域。\n          Stack() {\n          }\n          .width('200vp')\n          .height('200vp')\n          .hitTestBehavior(HitTestMode.Transparent)\n          .gesture(GestureGroup(GestureMode.Parallel,\n            LongPressGesture()\n              .onAction((event: GestureEvent) => {\n                promptAction.showToast({ message: \"LongPressGesture 长按上半区 红色区域，红色区域响应\" });\n              })\n              .tag(\"longpress\")\n          ))\n          .onGestureJudgeBegin((gestureInfo: GestureInfo, event: BaseGestureEvent) => {\n            // 如果是长按类型手势，判断点击的位置是否在上半区\n            if (gestureInfo.type == GestureControl.GestureType.LONG_PRESS_GESTURE) {\n              if (event.fingerList.length > 0 && event.fingerList[0].localY < 100) {\n                return GestureJudgeResult.CONTINUE;\n              } else {\n                return GestureJudgeResult.REJECT;\n              }\n            }\n            return GestureJudgeResult.CONTINUE;\n          })\n        }.width('100%')\n      }.width('100%')\n    }\n  }\n} 
手势响应控制
手势响应控制，指的是手势已经成功识别，但是开发者仍然可以通过调用API接口控制手势回调是否能够响应。
图3 手势响应控制流程图
手势响应控制的前提是手势识别成功，如果手势不成功也不会产生手势回调响应。
 业务手势作业流：指真正触发UI变化的业务手势，比如使页面滚动的PanGesture，触发点击的TapGesture等。 监听手势作业流：指在监听手势运行的过程中，应根据上下文的业务状态变化动态控制手势识别器的启停，例如在组件于嵌套滚动过程中是否已滑至边缘。这一监听事件可借助一个使用并行手势绑定方式的PanGesture实现，或者采用Touch事件来完成。 设置手势并行：此步骤并非必需，典型场景是在嵌套滚动中，设置外部组件的滚动手势与内部的滚动手势并行。 动态开闭手势：指通过手势识别器的setEnable方法，控制手势是否响应用户回调。 
手势响应控制涉及以下接口。
以下示例是两个Scroll组件的嵌套滚动场景，使用手势控制的api去控制外部组件和内部组件的嵌套滚动联动。
 使用shouldBuiltInRecognizerParallelWith接口设置外部Scroll组件的PanGesture手势，与内部Scroll组件的PanGesture手势并行。 .shouldBuiltInRecognizerParallelWith((current: GestureRecognizer, others: Array<GestureRecognizer>) => {\n  for (let i = 0; i < others.length; i++) {\n    let target = others[i].getEventTargetInfo();\n    if (target.getId() == \"inner\" && others[i].isBuiltIn() && others[i].getType() == GestureControl.GestureType.PAN_GESTURE) { // 找到将要组成并行手势的识别器\n      this.currentRecognizer = current; // 保存当前组件的识别器\n      this.childRecognizer = others[i]; // 保存将要组成并行手势的识别器\n      return others[i]; // 返回和当前手势将要组成并行手势的识别器\n    }\n  }\n  return undefined;\n}) 使用onGestureRecognizerJudgeBegin接口获取到Scroll组件的PanGesture手势识别器，同时根据内外Scroll组件的边界条件，初始化内外手势的开闭状态。 .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, others: Array<GestureRecognizer>) => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态        \n  let target = current.getEventTargetInfo();\n  if (target.getId() == \"outer\" && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {\n    for (let i = 0; i < others.length; i++) {\n      let target = others[i].getEventTargetInfo() as ScrollableTargetInfo;\n      if (target instanceof ScrollableTargetInfo && target.getId() == \"inner\") { // 找到响应链上对应并行的识别器\n        let panEvent = event as PanGestureEvent;\n        this.childRecognizer.setEnabled(true);\n        this.currentRecognizer.setEnabled(false);\n        if (target.isEnd()) { // 根据当前组件状态以及移动方向动态控制识别器使能状态\n          if (panEvent && panEvent.offsetY < 0) {\n            this.childRecognizer.setEnabled(false);\n            this.currentRecognizer.setEnabled(true);\n          }\n        } else if (target.isBegin()) {\n          if (panEvent.offsetY > 0) {\n            this.childRecognizer.setEnabled(false);\n            this.currentRecognizer.setEnabled(true);\n          }\n        }\n      }\n    }\n  }\n  return GestureJudgeResult.CONTINUE;\n}) 设置监听手势，监听Scroll组件状态，动态调整手势开闭状态，以使手势响应。 .parallelGesture( // 绑定一个Pan手势作为动态控制器\n  PanGesture()\n    .onActionUpdate((event: GestureEvent)=>{\n      if (this.childRecognizer.getState() != GestureRecognizerState.SUCCESSFUL || this.currentRecognizer.getState() != GestureRecognizerState.SUCCESSFUL) { // 如果识别器状态不是SUCCESSFUL，则不做控制\n        return;\n      }\n      let target = this.childRecognizer.getEventTargetInfo() as ScrollableTargetInfo;\n      let currentTarget = this.currentRecognizer.getEventTargetInfo() as ScrollableTargetInfo;\n      if (target instanceof ScrollableTargetInfo && currentTarget instanceof ScrollableTargetInfo) {\n        this.childRecognizer.setEnabled(true);\n        this.currentRecognizer.setEnabled(false);\n        if (target.isEnd()) { // 在移动过程中实时根据当前组件状态，控制识别器的开闭状态\n          if ((event.offsetY - this.lastOffset) < 0) {\n            this.childRecognizer.setEnabled(false);\n            if (currentTarget.isEnd()) {\n              this.currentRecognizer.setEnabled(false);\n            } else {\n              this.currentRecognizer.setEnabled(true);\n            }\n          }\n        } else if (target.isBegin()) {\n          if ((event.offsetY - this.lastOffset) > 0) {\n            this.childRecognizer.setEnabled(false);\n            if (currentTarget.isBegin()) {\n              this.currentRecognizer.setEnabled(false);\n            } else {\n              this.currentRecognizer.setEnabled(true);\n            }\n          }\n        }\n      }\n      this.lastOffset = event.offsetY\n  })\n) 代码完整示例。 // xxx.ets\n@Entry\n@Component\nstruct FatherControlChild {\n  scroller: Scroller = new Scroller();\n  scroller2: Scroller = new Scroller();\n  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n  private childRecognizer: GestureRecognizer = new GestureRecognizer();\n  private currentRecognizer: GestureRecognizer = new GestureRecognizer();\n  private lastOffset: number = 0;\n\n  build() {\n    Stack({ alignContent: Alignment.TopStart }) {\n      Scroll(this.scroller) { // 外部滚动容器\n        Column() {\n          Text(\"Scroll Area\")\n            .width('90%')\n            .height(150)\n            .backgroundColor(0xFFFFFF)\n            .borderRadius(15)\n            .fontSize(16)\n            .textAlign(TextAlign.Center)\n            .margin({ top: 10 })\n          Scroll(this.scroller2) { // 内部滚动容器\n            Column() {\n              Text(\"Scroll Area2\")\n                .width('90%')\n                .height(150)\n                .backgroundColor(0xFFFFFF)\n                .borderRadius(15)\n                .fontSize(16)\n                .textAlign(TextAlign.Center)\n                .margin({ top: 10 })\n              Column() {\n                ForEach(this.arr, (item: number) => {\n                  Text(item.toString())\n                    .width('90%')\n                    .height(150)\n                    .backgroundColor(0xFFFFFF)\n                    .borderRadius(15)\n                    .fontSize(16)\n                    .textAlign(TextAlign.Center)\n                    .margin({ top: 10 })\n                }, (item: string) => item)\n              }.width('100%')\n            }\n          }\n          .id(\"inner\")\n          .width('100%')\n          .height(800)\n        }.width('100%')\n      }\n      .id(\"outer\")\n      .height(600)\n      .scrollable(ScrollDirection.Vertical) // 滚动方向纵向\n      .scrollBar(BarState.On) // 滚动条常驻显示\n      .scrollBarColor(Color.Gray) // 滚动条颜色\n      .scrollBarWidth(10) // 滚动条宽度\n      .edgeEffect(EdgeEffect.None)\n      .shouldBuiltInRecognizerParallelWith((current: GestureRecognizer, others: Array<GestureRecognizer>) => {\n        for (let i = 0; i < others.length; i++) {\n          let target = others[i].getEventTargetInfo();\n          if (target.getId() == \"inner\" && others[i].isBuiltIn() && others[i].getType() == GestureControl.GestureType.PAN_GESTURE) { // 找到将要组成并行手势的识别器\n            this.currentRecognizer = current; // 保存当前组件的识别器\n            this.childRecognizer = others[i]; // 保存将要组成并行手势的识别器\n            return others[i]; // 返回和当前手势将要组成并行手势的识别器\n          }\n        }\n        return undefined;\n      })\n      .onGestureRecognizerJudgeBegin((event: BaseGestureEvent, current: GestureRecognizer, others: Array<GestureRecognizer>) => { // 在识别器即将要成功时，根据当前组件状态，设置识别器使能状态        \n        let target = current.getEventTargetInfo();\n        if (target.getId() == \"outer\" && current.isBuiltIn() && current.getType() == GestureControl.GestureType.PAN_GESTURE) {\n          for (let i = 0; i < others.length; i++) {\n            let target = others[i].getEventTargetInfo() as ScrollableTargetInfo;\n            if (target instanceof ScrollableTargetInfo && target.getId() == \"inner\") { // 找到响应链上对应并行的识别器\n              let panEvent = event as PanGestureEvent;\n              this.childRecognizer.setEnabled(true);\n              this.currentRecognizer.setEnabled(false);\n              if (target.isEnd()) { // 根据当前组件状态以及移动方向动态控制识别器使能状态\n                if (panEvent && panEvent.offsetY < 0) {\n                  this.childRecognizer.setEnabled(false);\n                  this.currentRecognizer.setEnabled(true);\n                }\n              } else if (target.isBegin()) {\n                if (panEvent.offsetY > 0) {\n                  this.childRecognizer.setEnabled(false);\n                  this.currentRecognizer.setEnabled(true);\n                }\n              }\n            }\n          }\n        }\n        return GestureJudgeResult.CONTINUE;\n      })\n      .parallelGesture( // 绑定一个Pan手势作为动态控制器\n        PanGesture()\n          .onActionUpdate((event: GestureEvent)=>{\n            if (this.childRecognizer.getState() != GestureRecognizerState.SUCCESSFUL || this.currentRecognizer.getState() != GestureRecognizerState.SUCCESSFUL) { // 如果识别器状态不是SUCCESSFUL，则不做控制\n              return;\n            }\n            let target = this.childRecognizer.getEventTargetInfo() as ScrollableTargetInfo;\n            let currentTarget = this.currentRecognizer.getEventTargetInfo() as ScrollableTargetInfo;\n            if (target instanceof ScrollableTargetInfo && currentTarget instanceof ScrollableTargetInfo) {\n              this.childRecognizer.setEnabled(true);\n              this.currentRecognizer.setEnabled(false);\n              if (target.isEnd()) { // 在移动过程中实时根据当前组件状态，控制识别器的开闭状态\n                if ((event.offsetY - this.lastOffset) < 0) {\n                  this.childRecognizer.setEnabled(false);\n                  if (currentTarget.isEnd()) {\n                    this.currentRecognizer.setEnabled(false);\n                  } else {\n                    this.currentRecognizer.setEnabled(true);\n                  }\n                }\n              } else if (target.isBegin()) {\n                if ((event.offsetY - this.lastOffset) > 0) {\n                  this.childRecognizer.setEnabled(false)\n                  if (currentTarget.isBegin()) {\n                    this.currentRecognizer.setEnabled(false);\n                  } else {\n                    this.currentRecognizer.setEnabled(true);\n                  }\n                }\n              }\n            }\n            this.lastOffset = event.offsetY;\n          })\n      )\n    }.width('100%').height('100%').backgroundColor(0xDCDCDC)\n  }\n} 

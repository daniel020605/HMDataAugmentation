媒体数据解析
调用者可以调用本模块的Native API接口，完成媒体数据的解封装相关操作，即从比特流数据中取出音频、视频、字幕等媒体sample，获得DRM相关信息
当前支持的数据输入类型有：远程连接(http协议)和文件描述符(fd)。
当前支持的解封装格式请参考AVCodec支持的格式。
适用场景：
 播放 播放媒体文件时，需要先对媒体流进行解封装，然后使用解封装获取的sample进行解码和播放。 音视频编辑 编辑媒体文件时，需要先对媒体流进行解封装，获取到指定sample进行编辑。 媒体文件格式转换（转封装） 媒体文件格式转换时，需要先对媒体流进行解封装，然后按需将媒体流封装至新的格式文件内。 
开发指导
详细的API说明参考AVDemuxer和AVSource
 调用解封装能力解析网络播放路径，需要声明权限：ohos.permission.INTERNET 调用解封装能力解析本地文件，需要向用户申请授权：ohos.permission.READ_MEDIA 如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法请参考ResourceManager API参考 
[h2]在 CMake 脚本中链接动态库
target_link_libraries(sample PUBLIC libnative_media_codecbase.so)\ntarget_link_libraries(sample PUBLIC libnative_media_avdemuxer.so)\ntarget_link_libraries(sample PUBLIC libnative_media_avsource.so)\ntarget_link_libraries(sample PUBLIC libnative_media_core.so)
上述'sample'字样仅为示例，此处由调用者根据实际工程目录自定义。
[h2]开发步骤
 添加头文件。 #include <multimedia/player_framework/native_avdemuxer.h>\n#include <multimedia/player_framework/native_avsource.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <fcntl.h>\n#include <sys/stat.h> 创建资源管理实例对象。 调用者HAP中使用open获取fd时，filepath需要转换为沙箱路径，才能获取沙盒资源。 // 创建文件操作符 fd，打开时对文件句柄必须有读权限(filePath 为待解封装文件路径，需预置文件，保证路径指向的文件存在)\nstd::string filePath = \"test.mp4\";\nint fd = open(filePath.c_str(), O_RDONLY);\nstruct stat fileStatus {};\nsize_t fileSize = 0;\nif (stat(filePath.c_str(), &fileStatus) == 0) {\n   fileSize = static_cast<size_t>(fileStatus.st_size);\n} else {\n   printf(\"get stat failed\");\n   return;\n}\n// 为 fd 资源文件创建 source 资源对象, 传入 offset 不为文件起始位置 或 size 不为文件大小时，可能会因不能获取完整数据导致 source 创建失败、或后续解封装失败等问题\nOH_AVSource *source = OH_AVSource_CreateWithFD(fd, 0, fileSize);\nif (source == nullptr) {\n   printf(\"create source failed\");\n   return;\n}\n// 为 uri 资源文件创建 source 资源对象(可选)\n// OH_AVSource *source = OH_AVSource_CreateWithURI(uri);\n\n// 为自定义数据源创建 source 资源对象(可选)。使用该方式前，需要先实现AVSourceReadAt接口函数实现。\n// 当使用OH_AVSource_CreateWithDataSource时需要补充g_filePath\n// g_filePath = filePath ;\n// OH_AVDataSource dataSource = {fileSize, AVSourceReadAt};\n// OH_AVSource *source = OH_AVSource_CreateWithDataSource(&dataSource); AVSourceReadAt接口函数，需要放在创建资源管理实例对象前实现： // 添加头文件\n#include <fstream> static std::string g_filePath;\n\nenum MediaDataSourceError : int32_t {\n   SOURCE_ERROR_IO = -2,\n   SOURCE_ERROR_EOF = -1\n};\n\nint32_t AVSourceReadAt(OH_AVBuffer *data, int32_t length, int64_t pos)\n{\n   if (data == nullptr) {\n      printf(\"AVSourceReadAt : data is nullptr!\\n\");\n      return MediaDataSourceError::SOURCE_ERROR_IO;\n   }\n\n   std::ifstream infile(g_filePath, std::ofstream::binary);\n   if (!infile.is_open()) {\n      printf(\"AVSourceReadAt : open file failed! file:%s\\n\", g_filePath.c_str());\n      return MediaDataSourceError::SOURCE_ERROR_IO;  // 打开文件失败\n   }\n\n   infile.seekg(0, std::ios::end);\n   int64_t fileSize = infile.tellg();\n   if (pos >= fileSize) {\n      printf(\"AVSourceReadAt : pos over or equals file size!\\n\");\n      return MediaDataSourceError::SOURCE_ERROR_EOF;  // pos已经是文件末尾位置，无法读取\n   }\n\n   if (pos + length > fileSize) {\n      length = fileSize - pos;    // pos+length长度超过文件大小时，读取从pos到文件末尾的数据\n   }\n\n   infile.seekg(pos, std::ios::beg);\n   if (length <= 0) {\n      printf(\"AVSourceReadAt : raed length less than zero!\\n\");\n      return MediaDataSourceError::SOURCE_ERROR_IO;\n   }\n   char* buffer = new char[length];\n   infile.read(buffer, length);\n   infile.close();\n\n   memcpy(reinterpret_cast<char *>(OH_AVBuffer_GetAddr(data)),\n      buffer, length);\n   delete[] buffer;\n\n   return length;\n} 创建解封装器实例对象。 // 为资源对象创建对应的解封装器\nOH_AVDemuxer *demuxer = OH_AVDemuxer_CreateWithSource(source);\nif (demuxer == nullptr) {\n   printf(\"create demuxer failed\");\n   return;\n} 注册DRM信息监听函数（可选，若非DRM码流或已获得DRM信息，可跳过此步）。 设置DRM信息监听的接口，回调函数支持返回解封装器实例，适用于多个解封装器场景。 // DRM信息监听回调OnDrmInfoChangedWithObj实现\nstatic void OnDrmInfoChangedWithObj(OH_AVDemuxer *demuxer, DRM_MediaKeySystemInfo *drmInfo)\n{\n   // 解析DRM信息，包括数量、DRM类型及对应pssh\n}\n\nDemuxer_MediaKeySystemInfoCallback callback = &OnDrmInfoChangedWithObj;\nDrm_ErrCode ret = OH_AVDemuxer_SetDemuxerMediaKeySystemInfoCallback(demuxer, callback); 在监听到DRM信息后，也可主动调用获取DRM信息(uuid及对应pssh)接口。 DRM_MediaKeySystemInfo mediaKeySystemInfo;\nOH_AVDemuxer_GetMediaKeySystemInfo(demuxer, &mediaKeySystemInfo); 在获取、解析DRM信息后，需创建对应DRM解决方案的MediaKeySystem、MediaKeySession，获取DRM许可证等。并根据需要设置音频解密配置(详见音频解码开发指南开发步骤第4步)、设置视频解密配置(详见视频解码开发指南开发步骤Surface模式第5步或Buffer模式第4步)，实现DRM内容解密。 获取文件轨道数（可选，若用户已知轨道信息，可跳过此步）。 // 从文件 source 信息获取文件轨道数，用户可通过该接口获取文件级别属性，具体支持信息参考附表 1\nOH_AVFormat *sourceFormat = OH_AVSource_GetSourceFormat(source);\nif (sourceFormat == nullptr) {\n   printf(\"get source format failed\");\n   return;\n}\nint32_t trackCount = 0;\nif (!OH_AVFormat_GetIntValue(sourceFormat, OH_MD_KEY_TRACK_COUNT, &trackCount)) {\n   printf(\"get track count from source format failed\");\n   return;\n}\nOH_AVFormat_Destroy(sourceFormat); 获取轨道index及信息（可选，若用户已知轨道信息，可跳过此步）。 uint32_t audioTrackIndex = 0;\nuint32_t videoTrackIndex = 0;\nint32_t w = 0;\nint32_t h = 0;\nint32_t trackType;\nfor (uint32_t index = 0; index < (static_cast<uint32_t>(trackCount)); index++) {\n   // 获取轨道信息，用户可通过该接口获取对应轨道级别属性，具体支持信息参考附表 2\n   OH_AVFormat *trackFormat = OH_AVSource_GetTrackFormat(source, index);\n   if (trackFormat == nullptr) {\n      printf(\"get track format failed\");\n      return;\n   }\n   if (!OH_AVFormat_GetIntValue(trackFormat, OH_MD_KEY_TRACK_TYPE, &trackType)) {\n      printf(\"get track type from track format failed\");\n      return;\n   }\n   static_cast<OH_MediaType>(trackType) == OH_MediaType::MEDIA_TYPE_AUD ? audioTrackIndex = index : videoTrackIndex = index;\n   // 获取视频轨宽高\n   if (trackType == OH_MediaType::MEDIA_TYPE_VID) {\n      if (!OH_AVFormat_GetIntValue(trackFormat, OH_MD_KEY_WIDTH, &w)) {\n         printf(\"get track width from track format failed\");\n         return;\n      }\n      if (!OH_AVFormat_GetIntValue(trackFormat, OH_MD_KEY_HEIGHT, &h)) {\n         printf(\"get track height from track format failed\");\n         return;\n      }\n   }\n   OH_AVFormat_Destroy(trackFormat);\n} 添加解封装轨道。 if(OH_AVDemuxer_SelectTrackByID(demuxer, audioTrackIndex) != AV_ERR_OK){\n   printf(\"select audio track failed: %d\", audioTrackIndex);\n   return;\n}\nif(OH_AVDemuxer_SelectTrackByID(demuxer, videoTrackIndex) != AV_ERR_OK){\n   printf(\"select video track failed: %d\", videoTrackIndex);\n   return;\n}\n// 取消选择轨道(可选)\n// OH_AVDemuxer_UnselectTrackByID(demuxer, audioTrackIndex); 调整轨道到指定时间点(可选)。 // 调整轨道到指定时间点，后续从该时间点进行解封装\n// 注意：\n// 1. mpegts格式文件使用OH_AVDemuxer_SeekToTime功能时，跳转到的位置可能为非关键帧。可在跳转后调用OH_AVDemuxer_ReadSampleBuffer，通过获取到的OH_AVCodecBufferAttr判断当前帧是否为关键帧。若非关键帧影响应用侧显示等功能，可在跳转后循环读取，获取到后续第一帧关键帧后，再进行解码等处理。\n// 2. ogg格式文件使用OH_AVDemuxer_SeekToTime功能时，会跳转到传入时间millisecond所在时间间隔(秒)的起始处，可能会导致一定数量的帧误差。\nOH_AVDemuxer_SeekToTime(demuxer, 0, OH_AVSeekMode::SEEK_MODE_CLOSEST_SYNC); 开始解封装，循环获取sample(以含音频、视频两轨的文件为例)。 BufferAttr包含的属性：  size：sample尺寸； offset：数据在AVBuffer中的偏移，一般为0； pts：文件封装的显示时间戳； flags：sample属性。      flag 描述    AVCODEC_BUFFER_FLAGS_NONE 默认。   AVCODEC_BUFFER_FLAGS_EOS 结尾sample，数据为空。   AVCODEC_BUFFER_FLAGS_SYNC_FRAME IDR帧或I帧。   AVCODEC_BUFFER_FLAGS_INCOMPLETE_FRAME 非完整的sample，一般由于buffer过小，无法拷贝完整的sample。   AVCODEC_BUFFER_FLAGS_CODEC_DATA 含参数集信息的帧。   AVCODEC_BUFFER_FLAGS_DISCARD 可丢弃的帧。    // 按照指定size创建buffer，用于保存用户解封装得到的数据。\n// buffer大小设置建议大于待获取的码流大小，示例中buffer大小设置为单帧图像的大小。\nOH_AVBuffer *buffer = OH_AVBuffer_Create(w * h * 3 >> 1);\nif (buffer == nullptr) {\n   printf(\"build buffer failed\");\n   return;\n}\nOH_AVCodecBufferAttr info;\nbool videoIsEnd = false;\nbool audioIsEnd = false;\nint32_t ret;\nwhile (!audioIsEnd || !videoIsEnd) {\n   // 在调用 OH_AVDemuxer_ReadSampleBuffer 接口获取数据前，需要先调用 OH_AVDemuxer_SelectTrackByID 选中需要获取数据的轨道\n   // 获取音频sample\n   if(!audioIsEnd) {\n      ret = OH_AVDemuxer_ReadSampleBuffer(demuxer, audioTrackIndex, buffer);\n      if (ret == AV_ERR_OK) {\n         // 可通过 buffer 获取并处理音频sample\n         OH_AVBuffer_GetBufferAttr(buffer, &info);\n         printf(\"audio info.size: %d\\n\", info.size);\n         if (info.flags == OH_AVCodecBufferFlags::AVCODEC_BUFFER_FLAGS_EOS) {\n            audioIsEnd = true;\n         }\n      }\n   }\n   if(!videoIsEnd) {\n      ret = OH_AVDemuxer_ReadSampleBuffer(demuxer, videoTrackIndex, buffer);\n      if (ret == AV_ERR_OK) {\n         // 可通过 buffer 获取并处理视频sample\n         OH_AVBuffer_GetBufferAttr(buffer, &info);\n         printf(\"video info.size: %d\\n\", info.size);\n         if (info.flags == OH_AVCodecBufferFlags::AVCODEC_BUFFER_FLAGS_EOS) {\n            videoIsEnd = true;\n         }\n      }\n   }\n}\nOH_AVBuffer_Destroy(buffer); 销毁解封装实例。 // 需要用户调用 OH_AVSource_Destroy 接口成功后，手动将对象置为 NULL，对同一对象重复调用 OH_AVSource_Destroy 会导致程序错误\nif (OH_AVSource_Destroy(source) != AV_ERR_OK) {\n   printf(\"destroy source pointer error\");\n}\nsource = NULL;\n// 需要用户调用 OH_AVDemuxer_Destroy 接口成功后，手动将对象置为 NULL，对同一对象重复调用 OH_AVDemuxer_Destroy 会导致程序错误\nif (OH_AVDemuxer_Destroy(demuxer) != AV_ERR_OK) {\n   printf(\"destroy demuxer pointer error\");\n}\ndemuxer = NULL;\nclose(fd); 
附表
[h2]文件级别属性支持范围
正常解析时才可以获取对应属性数据；如果文件信息错误或缺失，将导致解析异常，无法获取数据。
数据类型及详细取值范围参考媒体数据键值对。
表1 文件级别属性支持范围
[h2]轨道级别属性支持范围
正常解析时才可以获取对应属性数据；如果文件信息错误或缺失，将导致解析异常，无法获取数据。
数据类型及详细取值范围参考媒体数据键值对。
表2 轨道级别属性支持范围

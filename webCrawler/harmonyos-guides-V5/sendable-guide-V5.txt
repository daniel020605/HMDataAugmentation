Sendable使用场景
Sendable对象可以在不同并发实例间通过引用传递。通过引用传递方式传输对象相比序列化方式更加高效，同时不会丢失class上携带的成员方法。因此，Sendable主要可以解决两个场景的问题：
跨并发实例传输大数据（例如可能达到100KB以上的数据）。 跨并发实例传递带方法的class实例对象。 
跨并发实例传输大数据场景
由于跨并发实例序列化的开销随着数据量线性增长，因此当传输数据量较大时（100KB数据大约1ms传输耗时），跨并发实例的拷贝开销大，影响应用性能。引用传递方式传输对象可提升性能。
示例：
// Index.ets\nimport { taskpool } from '@kit.ArkTS';\nimport { testTypeA, testTypeB, Test } from './sendable';\nimport { BusinessError, emitter } from '@kit.BasicServicesKit';\n \n// 在并发函数中模拟数据处理\n@Concurrent\nasync function taskFunc(obj: Test) {\n  console.info(\"test task res1 is: \" + obj.data1.name + \" res2 is: \" + obj.data2.name);\n}\n \nasync function test() {\n  // 使用taskpool传递数据\n  let a: testTypeA = new testTypeA(\"testTypeA\");\n  let b: testTypeB = new testTypeB(\"testTypeB\");\n  let obj: Test = new Test(a, b);\n  let task: taskpool.Task = new taskpool.Task(taskFunc, obj);\n  await taskpool.execute(task);\n}\n \n@Concurrent\nfunction SensorListener() {\n  // 监听逻辑\n  // ...\n}\n \n@Entry\n@Component\nstruct Index {\n  build() {\n    Column() {\n      Text(\"Listener task\")\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .onClick(() => {\n          let sensorTask = new taskpool.LongTask(SensorListener);\n          emitter.on({ eventId: 0 }, (data) => {\n            // Do something here\n            console.info(`Receive ACCELEROMETER data: {${data.data?.x}, ${data.data?.y}, ${data.data?.z}`);\n          });\n          taskpool.execute(sensorTask).then(() => {\n            console.info(\"Add listener of ACCELEROMETER success\");\n          }).catch((e: BusinessError) => {\n            // Process error\n          })\n        })\n      Text(\"Data processing task\")\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .onClick(() => {\n          test();\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
// sendable.ets\n// 将数据量较大的数据在Sendable class中组装\n@Sendable\nexport class testTypeA {\n  name: string = \"A\";\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n@Sendable\nexport class testTypeB {\n  name: string = \"B\";\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n@Sendable\nexport class Test {\n  data1: testTypeA;\n  data2: testTypeB;\n  constructor(arg1: testTypeA, arg2: testTypeB) {\n    this.data1 = arg1;\n    this.data2 = arg2;\n  }\n}
跨并发实例传递带方法的class实例对象
由于序列化传输实例对象时会丢失方法，在必须调用实例方法的场景中，需使用引用传递方式进行开发。在数据处理过程中有需要解析的数据，可使用ASON工具进行数据解析。
示例：
// Index.ets\nimport { taskpool, ArkTSUtils } from '@kit.ArkTS';\nimport { SendableTestClass, ISendable } from './sendable';\n \n// 在并发函数中模拟数据处理\n@Concurrent\nasync function taskFunc(sendableObj: SendableTestClass) {\n  console.info(\"SendableTestClass: name is: \" + sendableObj.printName() + \", age is: \" + sendableObj.printAge() + \", sex is: \" + sendableObj.printSex());\n  sendableObj.setAge(28);\n  console.info(\"SendableTestClass: age is: \" + sendableObj.printAge());\n \n  // 解析sendableObj.arr数据生成JSON字符串\n  let str = ArkTSUtils.ASON.stringify(sendableObj.arr);\n  console.info(\"SendableTestClass: str is: \" + str);\n \n  // 解析该数据并生成ISendable数据\n  let jsonStr = '{\"name\": \"Alexa\", \"age\": 23, \"sex\": \"female\"}';\n  let obj = ArkTSUtils.ASON.parse(jsonStr) as ISendable;\n  console.info(\"SendableTestClass: type is: \" + typeof obj);\n  console.info(\"SendableTestClass: name is: \" + (obj as object)?.[\"name\"]); // 输出: 'Alexa'\n  console.info(\"SendableTestClass: age is: \" + (obj as object)?.[\"age\"]); // 输出: 23\n  console.info(\"SendableTestClass: sex is: \" + (obj as object)?.[\"sex\"]); // 输出: 'female'\n}\nasync function test() {\n  // 使用taskpool传递数据\n  let obj: SendableTestClass = new SendableTestClass();\n  let task: taskpool.Task = new taskpool.Task(taskFunc, obj);\n  await taskpool.execute(task);\n}\n \n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n \n  build() {\n    RelativeContainer() {\n      Text(this.message)\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .alignRules({\n          center: { anchor: '__container__', align: VerticalAlign.Center },\n          middle: { anchor: '__container__', align: HorizontalAlign.Center }\n        })\n        .onClick(() => {\n          test();\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
// sendable.ets\n// 定义模拟类Test，模仿开发过程中需传递带方法的class\nimport { lang, collections } from '@kit.ArkTS'\n\nexport type ISendable = lang.ISendable;\n\n@Sendable\nexport class SendableTestClass {\n  name: string = 'John';\n  age: number = 20;\n  sex: string = \"man\";\n  arr: collections.Array<number> = new collections.Array<number>(1, 2, 3);\n  constructor() {\n  }\n  setAge(age: number) : void {\n    this.age = age;\n  }\n\n  printName(): string {\n    return this.name;\n  }\n\n  printAge(): number {\n    return this.age;\n  }\n\n  printSex(): string {\n    return this.sex;\n  }\n}

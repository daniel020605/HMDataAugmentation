C++线程间数据共享场景
当应用在C++层进行多线程的并发计算时，因为ArkTS的API需要在ArkTS的环境执行，为了避免在非UI主线程每次回调等待UI主线程ArkTS环境中执行的API调用结果，需要在这些C++线程上创建ArkTS执行环境和直接调用API，并且可能需要在C++线程之间对Sendable对象进行共享和操作。
为了支持此类场景，需要实现在C++线程上创建调用ArkTS的能力，其次还需要对Sendable对象进行多线程共享和操作。
在C++线程上调用ArkTS能力
关于如何使用Node-API接口在C++线程创建ArkTS运行环境并调用，具体请见使用Node-API接口创建ArkTS运行时环境。
核心代码片段如下所示：
ArkTS文件定义
// SendableObjTest.ets\n@Sendable\nexport class SendableObjTest {\n  static newSendable() {\n    return 1024;\n  }\n}
Naitve实现加载ArkTS模块的能力
// napi_init.cpp\n#include \"napi/native_api.h\"\n#include <thread>\nstatic void *CreateArkRuntimeFunc(void *arg)\n{\n    // 1. 创建基础运行环境\n    napi_env env = nullptr;\n    napi_status ret = napi_create_ark_runtime(&env);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 2. 加载自定义模块，假定SendableObjTest中提供创建sendable对象的方法newSendable\n    napi_value test = nullptr;\n    ret = napi_load_module_with_info(env, \"entry/src/main/ets/pages/SendableObjTest\", \"com.example.myapplication/entry\", &test);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    napi_value sendableObjTest = nullptr;\n    ret = napi_get_named_property(env, test, \"SendableObjTest\", &sendableObjTest);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 3. 使用ArkTS中的newSendable，假设sendableObjTest中有一个函数newSendable能返回sendable对象\n    napi_value newSendable = nullptr;\n    ret = napi_get_named_property(env, sendableObjTest, \"newSendable\", &newSendable);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 4. 调用newSendable函数返回新创建的sendable对象，并保存在result中\n    napi_value result = nullptr;\n    ret = napi_call_function(env, sendableObjTest, newSendable, 0, nullptr, &result);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 5. 获取ArkTS返回的结果\n    int value0;\n    napi_get_value_int32(env, result, &value0);\n    if (value0 != 1024) {\n        std::abort();\n    }\n    // 6. 销毁ArkTS环境\n    ret = napi_destroy_ark_runtime(&env);\n    return nullptr;\n}
主要分为四个步骤：创建执行环境、加载模块、查找并调用模块（也可以直接通过Node-API接口创建Sendable对象）的函数和最后销毁执行环境。其中第二步加载模块具体可见使用Node-API接口进行模块加载，第三步查找并调用函数及更多Node-API接口能力可见Node-API。
在C++线程之间操作Sendable共享对象
实现在C++调用ArkTS能力之后，需要通过序列化和反序列化跨线程传递。因为napi_value不是多线程安全的，所以不能直接在多线程之间直接共享napi_value变量。
下面代码例子说明了如何序列化和反序列化传递对象，注意因为Sendable共享对象是引用传递，所以序列化不会产生另外一份拷贝数据，而是直接传递对象引用到反序列化线程，所以在性能上相比非Sendable对象的序列化和反序列化更为高效。
ArkTS文件定义
// SendableObjTest.ets\n@Sendable\nexport class SendableObjTest {\n  static newSendable() {\n    return 1024;\n  }\n}
Naitve实现两个线程的序列化反序列化Sendable的逻辑
// napi_init.cpp\n#include \"napi/native_api.h\"\n#include <thread>\n\nstatic void *serializationData = nullptr;\nstatic void *CreateEnvAndSendSendable(void *) {\n    // 1. 创建基础运行环境\n    napi_env env = nullptr;\n    napi_status ret = napi_create_ark_runtime(&env);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 2. 加载自定义模块，假定SendableObjTest中提供创建sendable对象的方法newSendable\n    napi_value test = nullptr;\n    ret = napi_load_module_with_info(env, \"entry/src/main/ets/pages/SendableObjTest\", \"com.example.myapplication/entry\",\n                                     &test);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    napi_value sendableObjTest = nullptr;\n    ret = napi_get_named_property(env, test, \"SendableObjTest\", &sendableObjTest);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 3. 使用ArkTS中的newSendable，假设sendableObjTest中有一个函数newSendable能返回sendable对象\n    napi_value newSendable = nullptr;\n    ret = napi_get_named_property(env, sendableObjTest, \"newSendable\", &newSendable);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 4. 调用newSendable函数返回新创建的sendable对象，并保存在result中\n    napi_value result = nullptr;\n    ret = napi_call_function(env, sendableObjTest, newSendable, 0, nullptr, &result);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 5. 序列化sendable对象\n    napi_value undefined;\n    napi_get_undefined(env, &undefined);\n    ret = napi_serialize(env, result, undefined, undefined, &serializationData);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    return nullptr;\n}\n\nstatic void *CreateEnvAndReceiveSendable(void *) {\n    // 1. 创建基础运行环境\n    napi_env env = nullptr;\n    napi_status ret = napi_create_ark_runtime(&env);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 2. 反序列化获取sendable共享对象，结果保存在result中，这个result就可以通过napi接口进行各种操作了\n    napi_value result = nullptr;\n    ret = napi_deserialize(env, serializationData, &result);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    // 3. 删除序列化数据\n    ret = napi_delete_serialization_data(env, serializationData);\n    if (ret != napi_ok) {\n        std::abort();\n    }\n    napi_valuetype valuetype0;\n    napi_typeof(env, result, &valuetype0);\n    if (valuetype0 != napi_number) {\n        std::abort();\n    }\n    int value0;\n    napi_get_value_int32(env, result, &value0);\n    if (value0 != 1024) {\n        std::abort();\n    }\n    return nullptr;\n}\n\nstatic napi_value TestSendSendable([[maybe_unused]] napi_env env, [[maybe_unused]] napi_callback_info info) {\n    std::thread t1(CreateEnvAndSendSendable, nullptr);\n    t1.join();\n    std::thread t2(CreateEnvAndReceiveSendable, nullptr);\n    t2.join();\n    return nullptr;\n}\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports) {\n    napi_property_descriptor desc[] = {\n        {\"testSendSendable\", nullptr, TestSendSendable, nullptr, nullptr, nullptr, napi_default, nullptr}};\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void *)0),\n    .reserved = {0},\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void) { \n    napi_module_register(&demoModule); \n}
// Index.d.ts\nexport const testSendSendable: () => void;
UI主线程发起调用
// Index.ets\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport testNapi from 'libentry.so';\nimport { SendableObjTest } from './SendableObjTest'\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            SendableObjTest.newSendable()\n            hilog.info(0x0000, 'testTag', 'Test send Sendable begin');\n            testNapi.testSendSendable();\n            hilog.info(0x0000, 'testTag', 'Test send Sendable end');\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
整个过程主要包括的逻辑实现为：
 在入口main函数所在的UI主线程创建ArkTS运行环境，并发起一个C++子线程创建Sendable对象保存到result中，然后将result引用的Sendable对象序列化到一个全局序列化数据serializationData中。 当这些流程完成后，发起另外一个C++子线程，并在这个新的线程中创建ArkTS运行环境。然后再通过反序列化接口从serializationData中反序列化出UI主线程创建的Sendable对象，并保存到result中，从而实现了Sendable对象的跨C++线程传递。反序列化完成后，需要销毁反序列化数据避免内存泄露。这时UI主线程和子线程都同时持有这个Sendable共享对象，即可通过Node-API进行对象操作，比如读写或者传递到ArkTS层等。     操作对象需要符合Sendable对象的规则，具体可见Sendable使用规则与约束。   

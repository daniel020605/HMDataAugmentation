普通对象
普通对象跨线程时通过拷贝形式传递，两个线程的对象内容一致，但是指向各自线程的隔离内存区间，被分配在各自线程的虚拟机本地堆（LocalHeap）。例如Ecmascript262规范定义的Object、Array、Map等对象是通过这种方式实现跨并发实例通信的。通信过程如下图所示：
使用示例
此处提供了一个传递普通对象的简单示例，具体实现如下：
// Test.ets\n// 自定义class TestA\nexport class TestA {\n  constructor(name: string) {\n    this.name = name;\n  }\n  name: string = 'ClassA';\n}
// Index.ets\nimport { taskpool } from '@kit.ArkTS';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { TestA } from './Test';\n\n@Concurrent\nasync function test1(arg: TestA) {\n  console.info(\"TestA name is: \" + arg.name);\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    RelativeContainer() {\n      Text(this.message)\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .alignRules({\n          center: { anchor: '__container__', align: VerticalAlign.Center },\n          middle: { anchor: '__container__', align: HorizontalAlign.Center }\n        })\n        .onClick(() => {\n          // 1. 创建Test实例objA\n          let objA = new TestA(\"TestA\");\n          // 2. 创建任务task，将objA传递给该任务，objA非sendable对象，通过序列化传递给子线程\n          let task = new taskpool.Task(test1, objA);\n          // 3. 执行任务\n          taskpool.execute(task).then(() => {\n            console.info(\"taskpool: execute task success!\");\n          }).catch((e:BusinessError) => {\n            console.error(`taskpool: execute task: Code: ${e.code}, message: ${e.message}`);\n          })\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}

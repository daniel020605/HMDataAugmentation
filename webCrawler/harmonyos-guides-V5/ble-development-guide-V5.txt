广播与扫描开发指导
简介
广播与扫描，主要提供了蓝牙设备的开启广播、关闭广播、开启扫描、关闭扫描方法，通过广播和扫描发现对端蓝牙设备，实现低功耗的通信。
场景介绍
主要场景有：
 开启、关闭广播 开启、关闭扫描 
接口说明
完整的 JS API 说明以及实例代码请参考：BLE 接口。
具体接口说明如下表。
主要场景开发步骤
[h2]开启、关闭广播
 import需要的ble模块。 开启设备的蓝牙。 需要SystemCapability.Communication.Bluetooth.Core系统能力。 开启广播，对端设备扫描该广播。 关闭广播。 示例代码： import { ble } from '@kit.ConnectivityKit';\nimport { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';\n\nconst TAG: string = 'BleAdvertisingManager';\n\nexport class BleAdvertisingManager {\n  private advHandle: number = 0xFF; // default invalid value\n\n  // 1 订阅广播状态\n  public onAdvertisingStateChange() {\n    try {\n      ble.on('advertisingStateChange', (data: ble.AdvertisingStateChangeInfo) => {\n        console.info(TAG, 'bluetooth advertising state = ' + JSON.stringify(data));\n        AppStorage.setOrCreate('advertiserState', data.state);\n      });\n    } catch (err) {\n      console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);\n    }\n  }\n\n  // 2 首次启动广播\n  public async startAdvertising() {\n    // 2.1 设置广播发送的参数\n    let setting: ble.AdvertiseSetting = {\n      interval: 160,\n      txPower: 0,\n      connectable: true\n    };\n    // 2.2 构造广播数据\n    let manufactureValueBuffer = new Uint8Array(4);\n    manufactureValueBuffer[0] = 1;\n    manufactureValueBuffer[1] = 2;\n    manufactureValueBuffer[2] = 3;\n    manufactureValueBuffer[3] = 4;\n    let serviceValueBuffer = new Uint8Array(4);\n    serviceValueBuffer[0] = 5;\n    serviceValueBuffer[1] = 6;\n    serviceValueBuffer[2] = 7;\n    serviceValueBuffer[3] = 8;\n    let manufactureDataUnit: ble.ManufactureData = {\n      manufactureId: 4567,\n      manufactureValue: manufactureValueBuffer.buffer\n    };\n    let serviceDataUnit: ble.ServiceData = {\n      serviceUuid: \"00001888-0000-1000-8000-00805f9b34fb\",\n      serviceValue: serviceValueBuffer.buffer\n    };\n    let advData: ble.AdvertiseData = {\n      serviceUuids: [\"00001888-0000-1000-8000-00805f9b34fb\"],\n      manufactureData: [manufactureDataUnit],\n      serviceData: [serviceDataUnit],\n      includeDeviceName: false // 表示是否携带设备名，可选参数。注意带上设备名时广播包长度不能超出31个字节。\n    };\n    let advResponse: ble.AdvertiseData = {\n      serviceUuids: [\"00001888-0000-1000-8000-00805f9b34fb\"],\n      manufactureData: [manufactureDataUnit],\n      serviceData: [serviceDataUnit]\n    };\n    // 2.3 构造广播启动完整参数AdvertisingParams\n    let advertisingParams: ble.AdvertisingParams = {\n      advertisingSettings: setting,\n      advertisingData: advData,\n      advertisingResponse: advResponse,\n      duration: 0 // 可选参数，若大于0，则广播发送一段时间后，则会临时停止，可重新启动发送\n    }\n\n    // 2.4 首次启动广播，且获取所启动广播的标识ID\n    try {\n      this.onAdvertisingStateChange();\n      this.advHandle = await ble.startAdvertising(advertisingParams);\n    } catch (err) {\n      console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);\n    }\n  }\n\n  // 4 临时停止广播，该广播资源仍然存在\n  public async disableAdvertising() {\n    // 4.1 构造临时停止广播参数\n    let advertisingDisableParams: ble.AdvertisingDisableParams = {\n      advertisingId: this.advHandle // 使用首次启动广播时获取到的广播标识ID\n    }\n    // 4.2 临时停止\n    try {\n      await ble.disableAdvertising(advertisingDisableParams);\n    } catch (err) {\n      console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);\n    }\n  }\n\n  // 5 再次启动广播\n  public async enableAdvertising(enableDuration: number) {\n    // 5.1 构造临时启动广播参数\n    let advertisingEnableParams: ble.AdvertisingEnableParams = {\n      advertisingId: this.advHandle, // 使用首次启动广播时获取到的广播标识ID\n      duration: enableDuration\n    }\n    // 5.2 再次启动\n    try {\n      await ble.enableAdvertising(advertisingEnableParams);\n    } catch (err) {\n      console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);\n    }\n  }\n\n  // 6 完全关闭广播，释放广播资源\n  public async stopAdvertising() {\n    try {\n      await ble.stopAdvertising(this.advHandle);\n      ble.off('advertisingStateChange', (data: ble.AdvertisingStateChangeInfo) => {\n        console.info(TAG, 'bluetooth advertising state = ' + JSON.stringify(data));\n      });\n    } catch (err) {\n      console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);\n    }\n  }\n}\n\nlet bleAdvertisingManager = new BleAdvertisingManager();\nexport default bleAdvertisingManager as BleAdvertisingManager; 错误码请参见蓝牙服务子系统错误码。 
[h2]开启、关闭扫描
 import需要的ble模块。 开启设备的蓝牙。 需要SystemCapability.Communication.Bluetooth.Core系统能力。 对端设备开启广播。 本端设备开启扫描，获取扫描结果。 关闭扫描。 示例代码: import { ble } from '@kit.ConnectivityKit';\nimport { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';\n\nconst TAG: string = 'BleScanManager';\nconst BLE_ADV_TYPE_FLAG = 0x01;\nconst BLE_ADV_TYPE_16_BIT_SERVICE_UUIDS_INCOMPLETE = 0x02;\nconst BLE_ADV_TYPE_16_BIT_SERVICE_UUIDS_COMPLETE = 0x03;\nconst BLE_ADV_TYPE_32_BIT_SERVICE_UUIDS_INCOMPLETE = 0x04;\nconst BLE_ADV_TYPE_32_BIT_SERVICE_UUIDS_COMPLETE = 0x05;\nconst BLE_ADV_TYPE_128_BIT_SERVICE_UUIDS_INCOMPLETE = 0x06;\nconst BLE_ADV_TYPE_128_BIT_SERVICE_UUIDS_COMPLETE = 0x07;\nconst BLE_ADV_TYPE_LOCAL_NAME_SHORT = 0x08;\nconst BLE_ADV_TYPE_LOCAL_NAME_COMPLETE = 0x09;\nconst BLE_ADV_TYPE_TX_POWER_LEVEL = 0x0A;\nconst BLE_ADV_TYPE_16_BIT_SERVICE_SOLICITATION_UUIDS = 0x14;\nconst BLE_ADV_TYPE_128_BIT_SERVICE_SOLICITATION_UUIDS = 0x15;\nconst BLE_ADV_TYPE_32_BIT_SERVICE_SOLICITATION_UUIDS = 0x1F;\nconst BLE_ADV_TYPE_16_BIT_SERVICE_DATA = 0x16;\nconst BLE_ADV_TYPE_32_BIT_SERVICE_DATA = 0x20;\nconst BLE_ADV_TYPE_128_BIT_SERVICE_DATA = 0x21;\nconst BLE_ADV_TYPE_MANUFACTURER_SPECIFIC_DATA = 0xFF;\n\nconst BLUETOOTH_UUID_16_BIT_LENGTH = 2;\nconst BLUETOOTH_UUID_32_BIT_LENGTH = 4;\nconst BLUETOOTH_UUID_128_BIT_LENGTH = 16;\n\nconst BLUETOOTH_MANUFACTURE_ID_LENGTH = 2;\n\nexport class BleScanManager {\n  // 1 订阅扫描结果\n  public onScanResult() {\n    ble.on('BLEDeviceFind', (data: Array<ble.ScanResult>) => {\n      if (data.length > 0) {\n        console.info(TAG, 'BLE scan result = ' + data[0].deviceId);\n        this.parseScanResult(data[0].data);\n      }\n    });\n  }\n\n  private parseScanResult(data: ArrayBuffer) {\n    let advData = new Uint8Array(data);\n    if (advData.byteLength == 0) {\n      console.warn(TAG, 'nothing, adv data length is 0');\n      return;\n    }\n    console.info(TAG, 'advData: ' + JSON.stringify(advData));\n\n    let advFlags: number = -1;\n    let txPowerLevel: number = -1;\n    let localName: string = \"\";\n    let serviceUuids: string[] = [];\n    let serviceSolicitationUuids: string[] = [];\n    let serviceDatas: Record<string, Uint8Array> = {};\n    let manufactureSpecificDatas: Record<number, Uint8Array> = {};\n\n    let curPos = 0;\n    while (curPos < advData.byteLength) {\n      let length = advData[curPos++];\n      if (length == 0) {\n        break;\n      }\n      let advDataLength = length - 1;\n      let advDataType = advData[curPos++];\n      switch (advDataType) {\n        case BLE_ADV_TYPE_FLAG:\n          advFlags = advData[curPos];\n          break;\n        case BLE_ADV_TYPE_LOCAL_NAME_SHORT:\n        case BLE_ADV_TYPE_LOCAL_NAME_COMPLETE:\n          localName = advData.slice(curPos, curPos + advDataLength).toString();\n          break;\n        case BLE_ADV_TYPE_TX_POWER_LEVEL:\n          txPowerLevel = advData[curPos];\n          break;\n        case BLE_ADV_TYPE_16_BIT_SERVICE_UUIDS_INCOMPLETE:\n        case BLE_ADV_TYPE_16_BIT_SERVICE_UUIDS_COMPLETE:\n          this.parseServiceUuid(BLUETOOTH_UUID_16_BIT_LENGTH, curPos, advDataLength, advData, serviceUuids);\n          break;\n        case BLE_ADV_TYPE_32_BIT_SERVICE_UUIDS_INCOMPLETE:\n        case BLE_ADV_TYPE_32_BIT_SERVICE_UUIDS_COMPLETE:\n          this.parseServiceUuid(BLUETOOTH_UUID_32_BIT_LENGTH, curPos, advDataLength, advData, serviceUuids);\n          break;\n        case BLE_ADV_TYPE_128_BIT_SERVICE_UUIDS_INCOMPLETE:\n        case BLE_ADV_TYPE_128_BIT_SERVICE_UUIDS_COMPLETE:\n          this.parseServiceUuid(BLUETOOTH_UUID_128_BIT_LENGTH, curPos, advDataLength, advData, serviceUuids);\n          break;\n        case BLE_ADV_TYPE_16_BIT_SERVICE_SOLICITATION_UUIDS:\n          this.parseServiceSolicitationUuid(BLUETOOTH_UUID_16_BIT_LENGTH, curPos, advDataLength,\n            advData, serviceSolicitationUuids);\n          break;\n        case BLE_ADV_TYPE_32_BIT_SERVICE_SOLICITATION_UUIDS:\n          this.parseServiceSolicitationUuid(BLUETOOTH_UUID_32_BIT_LENGTH, curPos, advDataLength,\n            advData, serviceSolicitationUuids);\n          break;\n        case BLE_ADV_TYPE_128_BIT_SERVICE_SOLICITATION_UUIDS:\n          this.parseServiceSolicitationUuid(BLUETOOTH_UUID_128_BIT_LENGTH, curPos, advDataLength,\n            advData, serviceSolicitationUuids);\n          break;\n        case BLE_ADV_TYPE_16_BIT_SERVICE_DATA:\n          this.parseServiceData(BLUETOOTH_UUID_16_BIT_LENGTH, curPos, advDataLength, advData, serviceDatas);\n          break;\n        case BLE_ADV_TYPE_32_BIT_SERVICE_DATA:\n          this.parseServiceData(BLUETOOTH_UUID_32_BIT_LENGTH, curPos, advDataLength, advData, serviceDatas);\n          break;\n        case BLE_ADV_TYPE_128_BIT_SERVICE_DATA:\n          this.parseServiceData(BLUETOOTH_UUID_128_BIT_LENGTH, curPos, advDataLength, advData, serviceDatas);\n          break;\n        case BLE_ADV_TYPE_MANUFACTURER_SPECIFIC_DATA:\n          this.parseManufactureData(curPos, advDataLength, advData, manufactureSpecificDatas);\n          break;\n        default:\n          break;\n      }\n      curPos += advDataLength;\n    }\n  }\n\n  private parseServiceUuid(uuidLength: number, curPos: number, advDataLength: number,\n    advData: Uint8Array, serviceUuids: string[]) {\n    while (advDataLength > 0) {\n      let tmpData: Uint8Array = advData.slice(curPos, curPos + uuidLength);\n      serviceUuids.push(this.getUuidFromUint8Array(uuidLength, tmpData));\n      advDataLength -= uuidLength;\n      curPos += uuidLength;\n    }\n  }\n\n  private parseServiceSolicitationUuid(uuidLength: number, curPos: number, advDataLength: number,\n    advData: Uint8Array, serviceSolicitationUuids: string[]) {\n    while (advDataLength > 0) {\n      let tmpData: Uint8Array = advData.slice(curPos, curPos + uuidLength);\n      serviceSolicitationUuids.push(this.getUuidFromUint8Array(uuidLength, tmpData));\n      advDataLength -= uuidLength;\n      curPos += uuidLength;\n    }\n  }\n\n  private getUuidFromUint8Array(uuidLength: number, uuidData: Uint8Array): string {\n    let uuid = \"\";\n    let temp: string = \"\";\n    for (let i = uuidLength - 1; i > -1; i--) {\n      temp += uuidData[i].toString(16).padStart(2, \"0\");\n    }\n    switch (uuidLength) {\n      case BLUETOOTH_UUID_16_BIT_LENGTH:\n        uuid = `0000${temp}-0000-1000-8000-00805F9B34FB`;\n        break;\n      case BLUETOOTH_UUID_32_BIT_LENGTH:\n        uuid = `${temp}-0000-1000-8000-00805F9B34FB`;\n        break;\n      case BLUETOOTH_UUID_128_BIT_LENGTH:\n        uuid = `${temp.substring(0, 8)}-${temp.substring(8, 12)}-${temp.substring(12, 16)}-${temp.substring(16, 20)}-${temp.substring(20, 32)}`;\n        break;\n      default:\n        break;\n    }\n    return uuid;\n  }\n\n  private parseServiceData(uuidLength: number, curPos: number, advDataLength: number,\n    advData: Uint8Array, serviceDatas: Record<string, Uint8Array>) {\n    let tmpUuid: Uint8Array = advData.slice(curPos, curPos + uuidLength);\n    let tmpValue: Uint8Array = advData.slice(curPos + uuidLength, curPos + advDataLength);\n    serviceDatas[tmpUuid.toString()] = tmpValue;\n  }\n\n  private parseManufactureData(curPos: number, advDataLength: number,\n    advData: Uint8Array, manufactureSpecificDatas: Record<number, Uint8Array>) {\n    let manufactureId: number = (advData[curPos + 1] << 8) + advData[curPos];\n    let tmpValue: Uint8Array = advData.slice(curPos + BLUETOOTH_MANUFACTURE_ID_LENGTH, curPos + advDataLength);\n    manufactureSpecificDatas[manufactureId] = tmpValue;\n  }\n\n  // 2 开启扫描\n  public startScan() {\n    // 2.1 构造扫描过滤器，需要能够匹配预期的广播包内容\n    let manufactureId = 4567;\n    let manufactureData: Uint8Array = new Uint8Array([1, 2, 3, 4]);\n    let manufactureDataMask: Uint8Array = new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF]);\n    let scanFilter: ble.ScanFilter = { // 根据业务实际情况定义过滤器\n      manufactureId: manufactureId,\n      manufactureData: manufactureData.buffer,\n      manufactureDataMask: manufactureDataMask.buffer\n    };\n\n    // 2.2 构造扫描参数\n    let scanOptions: ble.ScanOptions = {\n      interval: 0,\n      dutyMode: ble.ScanDuty.SCAN_MODE_LOW_POWER,\n      matchMode: ble.MatchMode.MATCH_MODE_AGGRESSIVE\n    }\n    try {\n      this.onScanResult(); // 订阅扫描结果\n      ble.startBLEScan([scanFilter], scanOptions);\n      console.info(TAG, 'startBleScan success');\n    } catch (err) {\n      console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);\n    }\n  }\n\n  // 3 关闭扫描\n  public stopScan() {\n    try {\n      ble.off('BLEDeviceFind', (data: Array<ble.ScanResult>) => { // 取消订阅扫描结果\n        console.info(TAG, 'off success');\n      });\n      ble.stopBLEScan();\n      console.info(TAG, 'stopBleScan success');\n    } catch (err) {\n      console.error(TAG, 'errCode: ' + (err as BusinessError).code + ', errMessage: ' + (err as BusinessError).message);\n    }\n  }\n}\n\nlet bleScanManager = new BleScanManager();\nexport default bleScanManager as BleScanManager; 错误码请参见蓝牙服务子系统错误码。 

同层渲染
在系统中，应用可以使用Web组件加载Web网页。在非原生框架的UI组件功能或性能不如原生组件时，可使用同层渲染，使用ArkUI组件渲染这些组件（简称为同层组件）。
使用场景
[h2]Web网页
小程序的地图组件，可以使用ArkUI的XComponent组件渲染来提升性能。小程序的输入框组件，可以使用ArkUI的TextInput组件渲染，达到与原生应用一致的输入体验。
 在网页侧，应用开发者可将<embed>、<object>的网页UI组件（简称为同层标签），按一定规则进行同层渲染，详细规格见同层渲染规格小节。 在应用侧，应用开发者可以通过Web组件的同层渲染事件上报接口，感知到H5同层标签的生命周期以及输入事件，进行同层渲染组件的相应业务逻辑处理。 在应用侧，应用开发者可以使用ArkUI的NodeContainer等接口，构建H5同层标签对应的同层渲染组件。可支持同层渲染的ArkUI常用组件包括：TextInput, XComponent, Canvas, Video, Web。具体规格可参见同层渲染规格小节。 
[h2]三方UI框架
Flutter提供了PlatformView与Texture抽象组件，这些组件可使用原生组件渲染，用来支持Flutter组件功能不足的部分。Weex2.0框架的Camera、Video、Canvas组件。
 在三方框架页面侧，由于Flutter、Weex等三方框架不在操作系统范围，本文不列举可被同层渲染的三方框架UI组件的范围与使用方式。 在应用侧，应用开发者可以使用ArkUI的NodeContainer等接口，构建三方框架同层标签对应的同层渲染组件。可支持同层渲染的ArkUI常用组件包括：TextInput, XComponent, Canvas, Video, Web。具体规格可参见同层渲染规格。 
整体架构
ArkWeb同层渲染特性主要提供两种能力：同层标签生命周期和事件命中转发处理。
同层标签生命周期主要关联前端标签（<embed>/<object>），同时命中到同层标签的事件会被上报到开发者侧，由开发者分发到对应组件树。整体框架如下图所示：
图1 同层渲染整体架构
规格约束
[h2]可被同层渲染的ArkUI组件
以下规格对Web网页和三方框架场景均生效。
支持的组件范围:
 基础组件：AlphabetIndexer, Blank, Button, CalendarPicker, Checkbox, CheckboxGroup, ContainerSpan, DataPanel, DatePicker, Divider, Gauge, Hyperlink, Image, ImageAnimator, ImageSpan, LoadingProgress, Marquee, PatternLock, Progress, QRCode, Radio, Rating, Refresh, ScrollBar, Search, Span, Select, Slider, Text, TextArea, TextClock, TextInput, TextPicker, TextTimer, TimePicker, Toggle 容器类组件：Badge, Column, ColumnSplit, Counter, Flex, GridCol, GridRow, Grid, GridItem，List, ListItem, ListItemGroup, RelativeContainer, Row, RowSplit, Scroll, Stack, Swiper, Tabs, TabContent, NodeContainer, SideBarContainer, Stepper, StepperItem, WaterFlow, FlowItem 自绘制类组件：XComponent, Canvas, Video, Web 命令式自定义绘制节点：BuilderNode, ComponentContent, ContentSlot, FrameNode, Graphics, NodeController, RenderNode, XComponentNode, AttributeUpdater，CAPI（支持同层渲染的组件范围同ArkTS） 
支持的组件通用属性与事件:
 不支持的通用属性：分布式迁移标识，特效绘制合并。 其他未明确标注不支持的属性与事件及组件能力，均默认支持。 
[h2]Web网页的同层渲染标签
此规格仅针对Web网页，不适用于三方框架场景。
如果应用需要在Web组件加载的网页中使用同层渲染，需要按照以下规格将网页中的<embed>、<object>标签指定为同层渲染组件。
支持的产品形态：
当前仅支持移动设备和平板形态。
支持的H5标签：
 支持<embed>标签：在开启同层渲染后，仅支持type类型为native前缀的标签识别为同层组件，不支持自定义属性。 支持<object>标签：在开启同层渲染后，支持将非标准MIME type的object标签识别为同层组件，支持通过param/value的自定义属性解析。 不支持W3C规范标准标签（如<input>、<video>）定义为同层标签。 不支持同时配置<object>标签和<embed>标签作为同层标签。 标签类型只支持英文字符，不区分大小写。 
同层标签的属性支持范围：
支持满足W3C标准的CSS样式属性。
同层标签的生命周期管理：
当Embed标签生命周期变化时触发onNativeEmbedLifecycleChange()回调。
 支持创建、销毁、位置宽高变化、不支持可见状态变化。 支持同层组件所在Web页面进入前进后退缓存。 
同层标签的输入事件分发处理：
 支持触摸事件TouchEvent的DOWN/UP/MOVE/CANCEL。支持配置触摸事件消费结果，默认为应用侧消费。 不支持同层标签所在的应用页面缩放和initialScale、zoom、zoomIn、zoomOut等缩放接口。 暂不支持鼠标、键盘、触摸板事件。 
约束限制：
 Web页面内不建议超过5个同层标签。超过5个后，渲染性能将会下降。 受GPU限制，同层标签最大高度不超过8000px，最大纹理大小为8000px。 开启同层渲染后，Web组件打开的所有Web页面将不支持同步渲染模式RenderMode。 Video组件：在非全屏Video变为全屏时，Video组件变为非纹理导出模式，视频播放状态保持延续；恢复为非全屏时，变为纹理导出模式，视频播放状态保持延续。 Web组件：仅支持一层同层渲染嵌套，不支持多层同层渲染嵌套。输入事件只支持滑动、点击、缩放、长按 ，不支持拖拽、旋转。 涉及界面交互的ArkUI组件（如TextInput等）：建议在页面布局中使用Stack包裹同层组件容器与BuilderNode，并使两者位置一致，NodeContainer要与<embed>/<object>标签对齐，以保障组件正常交互。如两者位置不一致，可能出现的问题有：TextInput/TextArea等附属的文本选择框位置错位（如下图）、LoadingProgress/Marquee等组件的动画启停与组件可见状态不匹配。 图2 未使用Stack包裹，TextInput的位置错位  图3 使用Stack包裹，TextInput的位置正常  
Web页面中同层渲染输入框
在Web页面中，可以使用ArkUI原生的TextInput组件进行同层渲染。此处利用同层渲染展示三个输入框，渲染效果图如下：
图4 同层渲染输入框
 在Web页面中标记需要同层渲染的HTML标签。 同层渲染支持<embed>/<object>两种标签。type类型可任意指定，两个字符串参数均不区分大小写，ArkWeb内核将会统一转换为小写。其中，tag字符串使用全字符串匹配，type使用字符串前缀匹配。 若开发者不使用该接口或该接口接收的为非法字符串（空字符串）时，ArkWeb内核将使用默认设置，即\"embed\" + \"native/\"前缀模式。若指定类型与w3c定义的object或embed标准类型重合，如registerNativeEmbedRule(\"object\", \"application/pdf\")，ArkWeb将遵循w3c标准行为，不会将其识别为同层标签。  采用<embed>标签。 <!--HAP's src/main/resources/rawfile/text.html-->\n<!DOCTYPE html>\n<html>\n<head>\n    <title>同层渲染测试html</title>\n    <meta name=\"viewport\">\n</head>\n\n<body style=\"background:white\">\n\n<embed id = \"input1\" type=\"native/view\" style=\"width: 100%; height: 100px; margin: 30px; margin-top: 600px\"/>\n\n<embed id = \"input2\" type=\"native/view2\" style=\"width: 100%; height: 100px; margin: 30px; margin-top: 50px\"/>\n\n<embed id = \"input3\" type=\"native/view3\" style=\"width: 100%; height: 100px; margin: 30px; margin-top: 50px\"/>\n\n</body>\n</html> 采用<object>标签。 需要使用registerNativeEmbedRule注册object标签。 // ...\nWeb({src: $rawfile(\"text.html\"), controller: this.browserTabController})\n  // 注册同层标签为\"object\"，类型为\"test\"前缀\n  .registerNativeEmbedRule(\"object\", \"test\")\n  // ... 与registerNativeEmbedRule相对应的前端页面代码，类型可使用\"test\"及以\"test\"为前缀的字串。 <!--HAP's src/main/resources/rawfile/text.html-->\n<!DOCTYPE html>\n<html>\n<head>\n    <title>同层渲染测试html</title>\n    <meta name=\"viewport\">\n</head>\n\n<body style=\"background:white\">\n\n<object id = \"input1\" type=\"test/input\" style=\"width: 100%; height: 100px; margin: 30px; margin-top: 600px\"></object>\n\n<object id = \"input2\" type=\"test/input\" style=\"width: 100%; height: 100px; margin: 30px; margin-top: 50px\"></object>\n\n<object id = \"input3\" type=\"test/input\" style=\"width: 100%; height: 100px; margin: 30px; margin-top: 50px\"></object>\n\n</body>\n</html>  在应用侧开启同层渲染功能。 同层渲染功能默认不开启，如果要使用同层渲染的功能，可通过enableNativeEmbedMode来开启。 // xxx.ets\nimport { webview } from '@kit.ArkWeb';\n@Entry\n@Component\nstruct WebComponent {\n  controller: webview.WebviewController = new webview.WebviewController();\n\n  build() {\n    Column() {\n      Web({ src: 'www.example.com', controller: this.controller })\n        // 配置同层渲染开关开启。\n        .enableNativeEmbedMode(true)\n    }\n  }\n} 创建自定义组件。 同层渲染功能开启后，展示在对应区域的原生组件。 @Component\nstruct TextInputComponent {\n  @Prop params: Params\n  @State bkColor: Color = Color.White\n\n  build() {\n    Column() {\n      TextInput({text: '', placeholder: 'please input your word...'})\n        .placeholderColor(Color.Gray)\n        .id(this.params?.elementId)\n        .placeholderFont({size: 13, weight: 400})\n        .caretColor(Color.Gray)\n        .width(this.params?.width)\n        .height(this.params?.height)\n        .fontSize(14)\n        .fontColor(Color.Black)\n    }\n    //自定义组件中的最外层容器组件宽高应该为同层标签的宽高\n    .width(this.params.width)\n    .height(this.params.height)\n  }\n}\n\n@Builder\nfunction TextInputBuilder(params:Params) {\n  TextInputComponent({params: params})\n    .width(params.width)\n    .height(params.height)\n    .backgroundColor(Color.White)\n} 创建节点控制器。 用于控制和反馈对应NodeContainer上的节点行为。 class MyNodeController extends NodeController {\n  private rootNode: BuilderNode<[Params]> | undefined | null;\n  private embedId_: string = \"\";\n  private surfaceId_: string = \"\";\n  private renderType_: NodeRenderType = NodeRenderType.RENDER_TYPE_DISPLAY;\n  private width_: number = 0;\n  private height_: number = 0;\n  private type_: string = \"\";\n  private isDestroy_: boolean = false;\n\n  setRenderOption(params: NodeControllerParams) {\n    this.surfaceId_ = params.surfaceId;\n    this.renderType_ = params.renderType;\n    this.embedId_ = params.embedId;\n    this.width_ = params.width;\n    this.height_ = params.height;\n    this.type_ = params.type;\n  }\n\n  // 必须要重写的方法，用于构建节点数、返回节点数挂载在对应NodeContainer中。\n  // 在对应NodeContainer创建的时候调用、或者通过rebuild方法调用刷新。\n  makeNode(uiContext: UIContext): FrameNode | null {\n    if (this.isDestroy_) { // rootNode为null\n      return null;\n    }\n    if (!this.rootNode) {// rootNode 为undefined时\n      this.rootNode = new BuilderNode(uiContext, { surfaceId: this.surfaceId_, type: this.renderType_ });\n      if(this.rootNode) {\n        this.rootNode.build(wrapBuilder(TextInputBuilder), {  textOne: \"myTextInput\", width: this.width_, height: this.height_  })\n        return this.rootNode.getFrameNode();\n      }else{\n        return null;\n      }\n    }\n    // 返回FrameNode节点。\n    return this.rootNode.getFrameNode();\n  }\n\n  setBuilderNode(rootNode: BuilderNode<Params[]> | null): void {\n    this.rootNode = rootNode;\n  }\n\n  getBuilderNode(): BuilderNode<[Params]> | undefined | null {\n    return this.rootNode;\n  }\n\n  updateNode(arg: Object): void {\n    this.rootNode?.update(arg);\n  }\n\n  getEmbedId(): string {\n    return this.embedId_;\n  }\n  \n  setDestroy(isDestroy: boolean): void {\n    this.isDestroy_ = isDestroy;\n    if (this.isDestroy_) {\n      this.rootNode = null;\n    }\n  }\n \n  postEvent(event: TouchEvent | undefined): boolean {\n    return this.rootNode?.postTouchEvent(event) as boolean\n  }\n} 监听同层渲染的生命周期变化。 开启该功能后，每当网页中存在同层渲染支持的标签时，ArkWeb内核会触发由onNativeEmbedLifecycleChange注册的回调函数。 开发者则需要调用onNativeEmbedLifecycleChange来监听同层渲染标签的生命周期变化。 build() {\n  Row() {\n    Column() {\n      Stack() {\n        ForEach(this.componentIdArr, (componentId: string) => {\n          NodeContainer(this.nodeControllerMap.get(componentId))\n            .position(this.positionMap.get(componentId))\n            .width(this.widthMap.get(componentId))\n            .height(this.heightMap.get(componentId))\n        }, (embedId: string) => embedId)\n        // Web组件加载本地text.html页面\n        Web({src: $rawfile(\"text.html\"), controller: this.browserTabController})\n          // 配置同层渲染开关开启\n          .enableNativeEmbedMode(true)\n            // 注册同层标签为\"object\"，类型为\"test\"前缀\n          .registerNativeEmbedRule(\"object\", \"test\")\n            // 获取embed标签的生命周期变化数据\n          .onNativeEmbedLifecycleChange((embed) => {\n            console.log(\"NativeEmbed surfaceId\" + embed.surfaceId);\n            // 如果使用embed.info.id作为映射nodeController的key，请在h5页面显式指定id\n            const componentId = embed.info?.id?.toString() as string\n            if (embed.status == NativeEmbedStatus.CREATE) {\n              console.log(\"NativeEmbed create\" + JSON.stringify(embed.info));\n              // 创建节点控制器、设置参数并rebuild\n              let nodeController = new MyNodeController()\n              // embed.info.width和embed.info.height单位是px格式，需要转换成ets侧的默认单位vp\n              nodeController.setRenderOption({surfaceId : embed.surfaceId as string,\n                type : embed.info?.type as string,\n                renderType : NodeRenderType.RENDER_TYPE_TEXTURE,\n                embedId : embed.embedId as string,\n                width : px2vp(embed.info?.width),\n                height : px2vp(embed.info?.height)})\n              this.edges = {left: `${embed.info?.position?.x as number}px`, top: `${embed.info?.position?.y as number}px`}\n              nodeController.setDestroy(false);\n              //根据web传入的embed的id属性作为key，将nodeController存入Map\n              this.nodeControllerMap.set(componentId, nodeController);\n              this.widthMap.set(componentId, px2vp(embed.info?.width));\n              this.heightMap.set(componentId, px2vp(embed.info?.height));\n              this.positionMap.set(componentId, this.edges);\n              // 将web传入的embed的id属性存入@State状态数组变量中，用于动态创建nodeContainer节点容器,需要将push动作放在set之后\n              this.componentIdArr.push(componentId)\n            } else if (embed.status == NativeEmbedStatus.UPDATE) {\n              let nodeController = this.nodeControllerMap.get(componentId);\n              console.log(\"NativeEmbed update\" + JSON.stringify(embed));\n              this.edges = {left: `${embed.info?.position?.x as number}px`, top: `${embed.info?.position?.y as number}px`}\n              this.positionMap.set(componentId, this.edges);\n              this.widthMap.set(componentId, px2vp(embed.info?.width));\n              this.heightMap.set(componentId, px2vp(embed.info?.height));\n              nodeController?.updateNode({textOne: 'update', width: px2vp(embed.info?.width), height: px2vp(embed.info?.height)} as ESObject)\n            } else if (embed.status == NativeEmbedStatus.DESTROY) {\n              console.log(\"NativeEmbed destroy\" + JSON.stringify(embed));\n              let nodeController = this.nodeControllerMap.get(componentId);\n              nodeController?.setDestroy(true)\n              this.nodeControllerMap.clear();\n              this.positionMap.delete(componentId);\n              this.widthMap.delete(componentId);\n              this.heightMap.delete(componentId);\n              this.componentIdArr.filter((value: string) => value != componentId)\n            } else {\n              console.log(\"NativeEmbed status\" + embed.status);\n            }\n          })\n      }.height(\"80%\")\n    }\n  }\n} 同层渲染手势事件。 开启该功能后，每当在同层渲染的区域进行触摸操作时，ArkWeb内核会触发onNativeEmbedGestureEvent注册的回调函数。 开发者则需要调用onNativeEmbedGestureEvent来监听同层渲染同层渲染区域的手势事件。 build() {\n  Row() {\n    Column() {\n      Stack() {\n        ForEach(this.componentIdArr, (componentId: string) => {\n          NodeContainer(this.nodeControllerMap.get(componentId))\n            .position(this.positionMap.get(componentId))\n            .width(this.widthMap.get(componentId))\n            .height(this.heightMap.get(componentId))\n        }, (embedId: string) => embedId)\n        // Web组件加载本地text.html页面。\n        Web({src: $rawfile(\"text.html\"), controller: this.browserTabController})\n          // 配置同层渲染开关开启。\n          .enableNativeEmbedMode(true)\n            // 获取embed标签的生命周期变化数据。\n          .onNativeEmbedLifecycleChange((embed) => {\n            // 生命周期变化实现\n          })\n          .onNativeEmbedGestureEvent((touch) => {\n            console.log(\"NativeEmbed onNativeEmbedGestureEvent\" + JSON.stringify(touch.touchEvent));\n            this.componentIdArr.forEach((componentId: string) => {\n              let nodeController = this.nodeControllerMap.get(componentId);\n              // 将获取到的同层区域的事件发送到该区域embedId对应的nodeController上\n              if(nodeController?.getEmbedId() == touch.embedId) {\n                let ret = nodeController?.postEvent(touch.touchEvent)\n                if(ret) {\n                  console.log(\"onNativeEmbedGestureEvent success \" + componentId);\n                } else {\n                  console.log(\"onNativeEmbedGestureEvent fail \" + componentId);\n                }\n                if(touch.result) {\n                  // 通知Web组件手势事件消费结果\n                  touch.result.setGestureEventResult(ret);\n                }\n              }\n            })\n          })\n      }\n    }\n  }\n} 
完整示例：
使用前请在module.json5中添加网络权限，添加方法请参考在配置文件中声明权限。
\"requestPermissions\":[\n    {\n      \"name\" : \"ohos.permission.INTERNET\"\n    }\n  ]
应用侧代码。
// 创建NodeController\nimport webview from '@ohos.web.webview';\nimport { UIContext } from '@ohos.arkui.UIContext';\nimport { NodeController, BuilderNode, NodeRenderType, FrameNode } from \"@ohos.arkui.node\";\n\n@Observed\ndeclare class Params{\n  elementId: string\n  textOne: string\n  textTwo: string\n  width: number\n  height: number\n}\n\ndeclare class NodeControllerParams {\n  surfaceId: string\n  type: string\n  renderType: NodeRenderType\n  embedId: string\n  width: number\n  height: number\n}\n\n// 用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用。\nclass MyNodeController extends NodeController {\n  private rootNode: BuilderNode<[Params]> | undefined | null;\n  private embedId_: string = \"\";\n  private surfaceId_: string = \"\";\n  private renderType_: NodeRenderType = NodeRenderType.RENDER_TYPE_DISPLAY;\n  private width_: number = 0;\n  private height_: number = 0;\n  private type_: string = \"\";\n  private isDestroy_: boolean = false;\n\n  setRenderOption(params: NodeControllerParams) {\n    this.surfaceId_ = params.surfaceId;\n    this.renderType_ = params.renderType;\n    this.embedId_ = params.embedId;\n    this.width_ = params.width;\n    this.height_ = params.height;\n    this.type_ = params.type;\n  }\n\n  // 必须要重写的方法，用于构建节点数、返回节点数挂载在对应NodeContainer中。\n  // 在对应NodeContainer创建的时候调用、或者通过rebuild方法调用刷新。\n  makeNode(uiContext: UIContext): FrameNode | null {\n    if (this.isDestroy_) { // rootNode为null\n      return null;\n    }\n    if (!this.rootNode) {// rootNode 为undefined时\n      this.rootNode = new BuilderNode(uiContext, { surfaceId: this.surfaceId_, type: this.renderType_ });\n      if(this.rootNode) {\n        this.rootNode.build(wrapBuilder(TextInputBuilder), {  textOne: \"myTextInput\", width: this.width_, height: this.height_  })\n        return this.rootNode.getFrameNode();\n      }else{\n        return null;\n      }\n    }\n    // 返回FrameNode节点。\n    return this.rootNode.getFrameNode();\n  }\n\n  setBuilderNode(rootNode: BuilderNode<Params[]> | null): void {\n    this.rootNode = rootNode;\n  }\n\n  getBuilderNode(): BuilderNode<[Params]> | undefined | null {\n    return this.rootNode;\n  }\n\n  updateNode(arg: Object): void {\n    this.rootNode?.update(arg);\n  }\n\n  getEmbedId(): string {\n    return this.embedId_;\n  }\n\n  setDestroy(isDestroy: boolean): void {\n    this.isDestroy_ = isDestroy;\n    if (this.isDestroy_) {\n      this.rootNode = null;\n    }\n  }\n\n  postEvent(event: TouchEvent | undefined): boolean {\n    return this.rootNode?.postTouchEvent(event) as boolean\n  }\n}\n\n@Component\nstruct TextInputComponent {\n  @Prop params: Params\n  @State bkColor: Color = Color.White\n\n  build() {\n    Column() {\n      TextInput({text: '', placeholder: 'please input your word...'})\n        .placeholderColor(Color.Gray)\n        .id(this.params?.elementId)\n        .placeholderFont({size: 13, weight: 400})\n        .caretColor(Color.Gray)\n        .fontSize(14)\n        .fontColor(Color.Black)\n    }\n    //自定义组件中的最外层容器组件宽高应该为同层标签的宽高\n    .width(this.params.width)\n    .height(this.params.height)\n  }\n}\n\n// @Builder中为动态组件的具体组件内容。\n@Builder\nfunction TextInputBuilder(params:Params) {\n  TextInputComponent({params: params})\n    .width(params.width)\n    .height(params.height)\n    .backgroundColor(Color.White)\n}\n\n@Entry\n@Component\nstruct Page{\n  browserTabController: WebviewController = new webview.WebviewController()\n  private nodeControllerMap: Map<string, MyNodeController> = new Map();\n  @State componentIdArr: Array<string> = [];\n  @State posMap: Map<string, Position | undefined> = new Map();\n  @State widthMap: Map<string, number> = new Map();\n  @State heightMap: Map<string, number> = new Map();\n  @State positionMap: Map<string, Edges> = new Map();\n  @State edges: Edges = {};\n\n  build() {\n    Row() {\n      Column() {\n        Stack() {\n          ForEach(this.componentIdArr, (componentId: string) => {\n            NodeContainer(this.nodeControllerMap.get(componentId))\n              .position(this.positionMap.get(componentId))\n              .width(this.widthMap.get(componentId))\n              .height(this.heightMap.get(componentId))\n          }, (embedId: string) => embedId)\n          // Web组件加载本地text.html页面。\n          Web({src: $rawfile(\"text.html\"), controller: this.browserTabController})\n            // 配置同层渲染开关开启。\n            .enableNativeEmbedMode(true)\n            // 获取embed标签的生命周期变化数据。\n            .onNativeEmbedLifecycleChange((embed) => {\n               console.log(\"NativeEmbed surfaceId\" + embed.surfaceId);\n               // 如果使用embed.info.id作为映射nodeController的key，请在h5页面显式指定id\n               const componentId = embed.info?.id?.toString() as string\n               if (embed.status == NativeEmbedStatus.CREATE) {\n                 console.log(\"NativeEmbed create\" + JSON.stringify(embed.info));\n                 // 创建节点控制器、设置参数并rebuild\n                 let nodeController = new MyNodeController()\n                 // embed.info.width和embed.info.height单位是px格式，需要转换成ets侧的默认单位vp\n                 nodeController.setRenderOption({surfaceId : embed.surfaceId as string,\n                   type : embed.info?.type as string,\n                   renderType : NodeRenderType.RENDER_TYPE_TEXTURE,\n                   embedId : embed.embedId as string,\n                   width : px2vp(embed.info?.width),\n                   height : px2vp(embed.info?.height)})\n                 this.edges = {left: `${embed.info?.position?.x as number}px`, top: `${embed.info?.position?.y as number}px`}\n                 nodeController.setDestroy(false);\n                 //根据web传入的embed的id属性作为key，将nodeController存入Map\n                 this.nodeControllerMap.set(componentId, nodeController);\n                 this.widthMap.set(componentId, px2vp(embed.info?.width));\n                 this.heightMap.set(componentId, px2vp(embed.info?.height));\n                 this.positionMap.set(componentId, this.edges);\n                 // 将web传入的embed的id属性存入@State状态数组变量中，用于动态创建nodeContainer节点容器,需要将push动作放在set之后\n                 this.componentIdArr.push(componentId)\n               } else if (embed.status == NativeEmbedStatus.UPDATE) {\n                 let nodeController = this.nodeControllerMap.get(componentId);\n                 console.log(\"NativeEmbed update\" + JSON.stringify(embed));\n                 this.edges = {left: `${embed.info?.position?.x as number}px`, top: `${embed.info?.position?.y as number}px`}\n                 this.positionMap.set(componentId, this.edges);\n                 this.widthMap.set(componentId, px2vp(embed.info?.width));\n                 this.heightMap.set(componentId, px2vp(embed.info?.height));\n                 nodeController?.updateNode({textOne: 'update', width: px2vp(embed.info?.width), height: px2vp(embed.info?.height)} as ESObject)\n               } else if (embed.status == NativeEmbedStatus.DESTROY) {\n                 console.log(\"NativeEmbed destroy\" + JSON.stringify(embed));\n                 let nodeController = this.nodeControllerMap.get(componentId);\n                 nodeController?.setDestroy(true)\n                 this.nodeControllerMap.clear();\n                 this.positionMap.delete(componentId);\n                 this.widthMap.delete(componentId);\n                 this.heightMap.delete(componentId);\n                 this.componentIdArr.filter((value: string) => value != componentId)\n               } else {\n                 console.log(\"NativeEmbed status\" + embed.status);\n               }\n             })// 获取同层渲染组件触摸事件信息。\n            .onNativeEmbedGestureEvent((touch) => {\n              console.log(\"NativeEmbed onNativeEmbedGestureEvent\" + JSON.stringify(touch.touchEvent));\n              this.componentIdArr.forEach((componentId: string) => {\n                let nodeController = this.nodeControllerMap.get(componentId);\n                // 将获取到的同层区域的事件发送到该区域embedId对应的nodeController上\n                if(nodeController?.getEmbedId() == touch.embedId) {\n                  let ret = nodeController?.postEvent(touch.touchEvent)\n                  if(ret) {\n                    console.log(\"onNativeEmbedGestureEvent success \" + componentId);\n                  } else {\n                    console.log(\"onNativeEmbedGestureEvent fail \" + componentId);\n                  }\n                  if(touch.result) {\n                    // 通知Web组件手势事件消费结果\n                    touch.result.setGestureEventResult(ret);\n                  }\n                }\n              })\n            })\n        }\n      }\n    }\n  }\n}
绘制XComponent+AVPlayer和Button组件
开发者可通过enableNativeEmbedMode()控制同层渲染开关。Html文件中需要显式使用embed标签，并且embed标签内type必须以“native/”开头。同层标签对应的元素区域的背景为透明。
 应用侧代码组件使用示例。 // HAP's src/main/ets/pages/Index.ets\n// 创建NodeController\nimport { webview } from '@kit.ArkWeb';\nimport { UIContext, NodeController, BuilderNode, NodeRenderType, FrameNode } from \"@kit.ArkUI\";\nimport { AVPlayerDemo } from './PlayerDemo';\n\n@Observed\ndeclare class Params {\n  textOne : string\n  textTwo : string\n  width : number\n  height : number\n}\n\ndeclare class NodeControllerParams {\n  surfaceId : string\n  type : string\n  renderType : NodeRenderType\n  embedId : string\n  width : number\n  height : number\n}\n\n// 用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeContainer一起使用。\nclass MyNodeController extends NodeController {\n  private rootNode: BuilderNode<[Params]> | undefined | null;\n  private embedId_ : string = \"\";\n  private surfaceId_ : string = \"\";\n  private renderType_ :NodeRenderType = NodeRenderType.RENDER_TYPE_DISPLAY;\n  private width_ : number = 0;\n  private height_ : number = 0;\n  private type_ : string = \"\";\n  private isDestroy_ : boolean = false;\n\n  setRenderOption(params : NodeControllerParams) {\n    this.surfaceId_ = params.surfaceId;\n    this.renderType_ = params.renderType;\n    this.embedId_ = params.embedId;\n    this.width_ = params.width;\n    this.height_ = params.height;\n    this.type_ = params.type;\n  }\n  // 必须要重写的方法，用于构建节点数、返回节点数挂载在对应NodeContainer中。\n  // 在对应NodeContainer创建的时候调用、或者通过rebuild方法调用刷新。\n  makeNode(uiContext: UIContext): FrameNode | null{\n    if (this.isDestroy_) { // rootNode为null\n      return null;\n    }\n    if (!this.rootNode) { // rootNode 为undefined时\n      this.rootNode = new BuilderNode(uiContext, { surfaceId: this.surfaceId_, type: this.renderType_});\n      if (this.type_ === 'native/video') {\n        this.rootNode.build(wrapBuilder(VideoBuilder), {textOne: \"myButton\", width : this.width_, height : this.height_});\n      } else {\n        // other\n      }\n    }\n    // 返回FrameNode节点。\n    return this.rootNode.getFrameNode();\n  }\n\n  setBuilderNode(rootNode: BuilderNode<Params[]> | null): void{\n    this.rootNode = rootNode;\n  }\n\n  getBuilderNode(): BuilderNode<[Params]> | undefined | null{\n    return this.rootNode;\n  }\n\n  updateNode(arg: Object): void {\n    this.rootNode?.update(arg);\n  }\n  getEmbedId() : string {\n    return this.embedId_;\n  }\n\n  setDestroy(isDestroy : boolean) : void {\n    this.isDestroy_ = isDestroy;\n    if (this.isDestroy_) {\n      this.rootNode = null;\n    }\n  }\n\n  postEvent(event: TouchEvent | undefined) : boolean {\n    return this.rootNode?.postTouchEvent(event) as boolean\n  }\n}\n\n@Component\nstruct VideoComponent {\n  @ObjectLink params: Params\n  @State bkColor: Color = Color.Red\n  mXComponentController: XComponentController = new XComponentController();\n  @State player_changed: boolean = false;\n  player?: AVPlayerDemo;\n\n  build() {\n    Column() {\n      Button(this.params.textOne)\n\n      XComponent({ id: 'video_player_id', type: XComponentType.SURFACE, controller: this.mXComponentController})\n        .border({width: 1, color: Color.Red})\n        .onLoad(() => {\n          this.player = new AVPlayerDemo();\n          this.player.setSurfaceID(this.mXComponentController.getXComponentSurfaceId());\n          this.player_changed = !this.player_changed;\n          this.player.avPlayerLiveDemo()\n        })\n        .width(300)\n        .height(200)\n    }\n    //自定义组件中的最外层容器组件宽高应该为同层标签的宽高\n    .width(this.params.width)\n    .height(this.params.height)\n  }\n}\n// @Builder中为动态组件的具体组件内容。\n@Builder\nfunction VideoBuilder(params: Params) {\n  VideoComponent({ params: params })\n    .backgroundColor(Color.Gray)\n}\n\n@Entry\n@Component\nstruct WebIndex {\n  browserTabController: WebviewController = new webview.WebviewController()\n  private nodeControllerMap: Map<string, MyNodeController> = new Map();\n  @State componentIdArr: Array<string> = [];\n\n  aboutToAppear() {\n    // 配置web开启调试模式。\n    webview.WebviewController.setWebDebuggingAccess(true);\n  }\n\n  build(){\n    Row() {\n      Column() {\n        Stack() {\n          ForEach(this.componentIdArr, (componentId: string) => {\n            NodeContainer(this.nodeControllerMap.get(componentId))\n          }, (embedId: string) => embedId)\n          // Web组件加载本地test.html页面。\n          Web({ src: $rawfile(\"test.html\"), controller: this.browserTabController })\n            // 配置同层渲染开关开启。\n            .enableNativeEmbedMode(true)\n              // 获取embed标签的生命周期变化数据。\n            .onNativeEmbedLifecycleChange((embed) => {\n              console.log(\"NativeEmbed surfaceId\" + embed.surfaceId);\n              // 1. 如果使用embed.info.id作为映射nodeController的key，请在h5页面显式指定id\n              const componentId = embed.info?.id?.toString() as string\n              if (embed.status == NativeEmbedStatus.CREATE) {\n                console.log(\"NativeEmbed create\" + JSON.stringify(embed.info))\n                // 创建节点控制器，设置参数并rebuild。\n                let nodeController = new MyNodeController()\n                // 1. embed.info.width和embed.info.height单位是px格式，需要转换成ets侧的默认单位vp\n                nodeController.setRenderOption({surfaceId : embed.surfaceId as string, type : embed.info?.type as string,\n                  renderType : NodeRenderType.RENDER_TYPE_TEXTURE, embedId : embed.embedId as string,\n                  width : px2vp(embed.info?.width), height : px2vp(embed.info?.height)})\n                nodeController.setDestroy(false);\n                // 根据web传入的embed的id属性作为key，将nodeController存入map。\n                this.nodeControllerMap.set(componentId, nodeController)\n                // 将web传入的embed的id属性存入@State状态数组变量中，用于动态创建nodeContainer节点容器，需要将push动作放在set之后。\n                this.componentIdArr.push(componentId)\n              } else if (embed.status == NativeEmbedStatus.UPDATE) {\n                let nodeController = this.nodeControllerMap.get(componentId)\n                nodeController?.updateNode({textOne: 'update', width: px2vp(embed.info?.width), height: px2vp(embed.info?.height)} as ESObject)\n              } else {\n                let nodeController = this.nodeControllerMap.get(componentId);\n                nodeController?.setDestroy(true)\n                this.nodeControllerMap.clear();\n                this.componentIdArr.length = 0;\n              }\n            })// 获取同层渲染组件触摸事件信息。\n            .onNativeEmbedGestureEvent((touch) => {\n              console.log(\"NativeEmbed onNativeEmbedGestureEvent\" + JSON.stringify(touch.touchEvent));\n              this.componentIdArr.forEach((componentId: string) => {\n                let nodeController = this.nodeControllerMap.get(componentId)\n                // 将获取到的同层区域的事件发送到该区域embedId对应的nodeController上\n                if (nodeController?.getEmbedId() === touch.embedId) {\n                  let ret = nodeController?.postEvent(touch.touchEvent)\n                  if (ret) {\n                    console.log(\"onNativeEmbedGestureEvent success \" + componentId)\n                  } else {\n                    console.log(\"onNativeEmbedGestureEvent fail \" + componentId)\n                  }\n                  if (touch.result) {\n                    // 通知Web组件手势事件消费结果\n                    touch.result.setGestureEventResult(ret);\n                  }\n                }\n              })\n            })\n        }\n      }\n    }\n  }\n} 应用侧代码，视频播放示例，使用时需替换正确的视频链接地址。 // HAP's src/main/ets/pages/PlayerDemo.ets\nimport { media } from '@kit.MediaKit';\nimport { BusinessError } from '@ohos.base';\n\nexport class AVPlayerDemo {\n  private count: number = 0;\n  private surfaceID: string = ''; // surfaceID用于播放画面显示，具体的值需要通过Xcomponent接口获取，相关文档链接见上面Xcomponent创建方法。\n  private isSeek: boolean = true; // 用于区分模式是否支持seek操作。\n\n  setSurfaceID(surface_id: string){\n    console.log('setSurfaceID : ' + surface_id);\n    this.surfaceID = surface_id;\n  }\n  // 注册avplayer回调函数。\n  setAVPlayerCallback(avPlayer: media.AVPlayer) {\n    // seek操作结果回调函数。\n    avPlayer.on('seekDone', (seekDoneTime: number) => {\n      console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);\n    })\n    // error回调监听函数，当avplayer在操作过程中出现错误时，调用reset接口触发重置流程。\n    avPlayer.on('error', (err: BusinessError) => {\n      console.error(`Invoke avPlayer failed, code is ${err.code}, message is ${err.message}`);\n      avPlayer.reset();\n    })\n    // 状态机变化回调函数。\n    avPlayer.on('stateChange', async (state: string, reason: media.StateChangeReason) => {\n      switch (state) {\n        case 'idle': // 成功调用reset接口后触发该状态机上报。\n          console.info('AVPlayer state idle called.');\n          avPlayer.release(); // 调用release接口销毁实例对象。\n          break;\n        case 'initialized': // avplayer 设置播放源后触发该状态上报。\n          console.info('AVPlayer state initialized called.');\n          avPlayer.surfaceId = this.surfaceID; // 设置显示画面，当播放的资源为纯音频时无需设置。\n          avPlayer.prepare();\n          break;\n        case 'prepared': // prepared调用成功后上报该状态机。\n          console.info('AVPlayer state prepared called.');\n          avPlayer.play(); // 调用播放接口开始播放。\n          break;\n        case 'playing': // play成功调用后触发该状态机上报。\n          console.info('AVPlayer state prepared called.');\n          if(this.count !== 0) {\n            if (this.isSeek) {\n              console.info('AVPlayer start to seek.');\n              avPlayer.seek(avPlayer.duration); // seek到视频末尾。\n            } else {\n              // 当播放模式不支持seek操作时继续播放到结尾。\n              console.info('AVPlayer wait to play end.');\n            }\n          } else {\n            avPlayer.pause(); // 调用暂停接口暂停播放。\n          }\n          this.count++;\n          break;\n        case 'paused': // pause成功调用后触发该状态机上报。\n          console.info('AVPlayer state paused called.');\n          avPlayer.play(); // 再次播放接口开始播放。\n          break;\n        case 'completed': //播放接口后触发该状态机上报。\n          console.info('AVPlayer state paused called.');\n          avPlayer.stop(); // 调用播放接口接口。\n          break;\n        case 'stopped': // stop接口后触发该状态机上报。\n          console.info('AVPlayer state stopped called.');\n          avPlayer.reset(); // 调用reset接口初始化avplayer状态。\n          break;\n        case 'released': //播放接口后触发该状态机上报。\n          console.info('AVPlayer state released called.');\n          break;\n        default:\n          break;\n      }\n    })\n  }\n\n  // 通过url设置网络地址来实现播放直播码流。\n  async avPlayerLiveDemo(){\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数。\n    this.setAVPlayerCallback(avPlayer);\n    this.isSeek = false; // 不支持seek操作。\n    // 使用时需要自行替换视频链接\n    avPlayer.url = 'https://xxx.xxx/demo.mp4';\n  }\n} 前端页面示例。 <!--HAP's src/main/resources/rawfile/test.html-->\n<!DOCTYPE html>\n<html>\n<head>\n    <title>同层渲染测试html</title>\n    <meta name=\"viewport\">\n</head>\n<body>\n<div>\n    <div id=\"bodyId\">\n        <embed id=\"nativeVideo\" type = \"native/video\" width=\"1000\" height=\"1500\" src=\"test\" style = \"background-color:red\"/>\n    </div>\n</div>\n</body>\n</html>  

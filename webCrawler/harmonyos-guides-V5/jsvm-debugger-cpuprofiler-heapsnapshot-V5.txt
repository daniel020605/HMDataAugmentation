JSVM-API调试&定位
JSVM，既标准JS引擎，是严格遵守Ecmascript规范的JavaScript代码执行引擎。 详情参考：JSVM。
基于JSVM的JS代码调试调优能力包括：Debugger、CPU Profiler、Heap Snapshot、Heap Statistics。涉及以下接口：
本文将介绍调试、CPU Profiler、Heap Snapshot的使用方法。
调试能力使用方法
[h2]使用 OH_JSVM_OpenInspector
 在应用工程配置文件module.json中配置网络权限： 
\"requestPermissions\": [{\n  \"name\": \"ohos.permission.INTERNET\",\n  \"reason\": \"$string:app_name\",\n  \"usedScene\": {\n    \"abilities\": [\n      \"FromAbility\"\n    ],\n    \"when\": \"inuse\"\n  }\n}]
 为避免debugger过程中的暂停被误报为无响应异常，可以开启DevEco Studio的Debug模式（无需设置断点），或者可以在非主线程的其他线程中运行JSVM。 在执行JS代码之前，调用OH_JSVM_OpenInspector在指定的主机和端口上激活inspector，创建socket。例如OH_JSVM_OpenInspector(env, \"localhost\", 9225)，在端侧本机端口9225创建socket。 调用OH_JSVM_WaitForDebugger，等待建立socket连接。 检查端侧端口是否打开成功。hdc shell \"netstat -anp | grep 9225\"。结果为9225端口状态为“LISTEN\"即可。 转发端口。hdc fport tcp:9229 tcp:9225。转发PC侧端口9229到端侧端口9225。结果为\"Forwardport result:OK\"即可。 在chrome浏览器地址栏输入\"localhost:9229/json\"，回车。获取端口连接信息。拷贝\"devtoolsFrontendUrl\"字段url内容到地址栏，回车，进入DevTools源码页，将看到在应用中通过OH_JSVM_RunScript执行的JS源码，此时暂停在第一行JS源码处。 用户可在源码页打断点，通过按钮发出各种调试命令控制JS代码执行，并查看变量。 调用OH_JSVM_CloseInspector关闭inspector，结束socket连接。 
示例代码
JSVM-API接口开发流程参考使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应C++相关代码进行展示。
#include \"ark_runtime/jsvm.h\"\n\n#include <string>\n\nusing namespace std;\n\n// 待调试的JS源码\nstatic string srcDebugger = R\"JS(\nconst concat = (...args) => args.reduce((a, b) => a + b);\nvar dialogue = concat('\"What ', 'is ', 'your ', 'name ', '?\"');\ndialogue = concat(dialogue, ' --', '\"My ', 'name ', 'is ', 'Bob ', '.\"');\n)JS\";\n\n// 开启debugger\nstatic void EnableInspector(JSVM_Env env) {\n    // 在指定的主机和端口上激活inspector，创建socket。\n    OH_JSVM_OpenInspector(env, \"localhost\", 9225);\n    // 等待建立socket连接。\n    OH_JSVM_WaitForDebugger(env, true);\n}\n\n// 关闭debugger\nstatic void CloseInspector(JSVM_Env env) {\n    // 关闭inspector，结束socket连接。\n    OH_JSVM_CloseInspector(env);\n}\n\nstatic void RunScript(JSVM_Env env) {\n    JSVM_HandleScope handleScope;\n    OH_JSVM_OpenHandleScope(env, &handleScope);\n\n    JSVM_Value jsSrc;\n    OH_JSVM_CreateStringUtf8(env, srcDebugger.c_str(), srcDebugger.size(), &jsSrc);\n\n    JSVM_Script script;\n    OH_JSVM_CompileScript(env, jsSrc, nullptr, 0, true, nullptr, &script);\n\n    JSVM_Value result;\n    OH_JSVM_RunScript(env, script, &result);\n\n    OH_JSVM_CloseHandleScope(env, handleScope);\n}\n\nvoid TestJSVM() {\n    JSVM_InitOptions initOptions{};\n    OH_JSVM_Init(&initOptions);\n\n    JSVM_VM vm;\n    OH_JSVM_CreateVM(nullptr, &vm);\n    JSVM_VMScope vmScope;\n    OH_JSVM_OpenVMScope(vm, &vmScope);\n\n    JSVM_Env env;\n    OH_JSVM_CreateEnv(vm, 0, nullptr, &env);\n    // 执行JS代码之前打开debugger。\n    EnableInspector(env);\n    JSVM_EnvScope envScope;\n    OH_JSVM_OpenEnvScope(env, &envScope);\n\n    // 执行JS代码。\n    RunScript(env);\n\n    OH_JSVM_CloseEnvScope(env, envScope);\n    // 执行JS代码之后关闭debugger。\n    CloseInspector(env);\n    OH_JSVM_DestroyEnv(env);\n    OH_JSVM_CloseVMScope(vm, vmScope);\n    OH_JSVM_DestroyVM(vm);\n}
[h2]使用 OH_JSVM_OpenInspectorWithName
 在应用工程配置文件module.json中配置网络权限： 
\"requestPermissions\": [{\n  \"name\": \"ohos.permission.INTERNET\",\n  \"reason\": \"$string:app_name\",\n  \"usedScene\": {\n    \"abilities\": [\n      \"FromAbility\"\n    ],\n    \"when\": \"inuse\"\n  }\n}]
 为避免debugger过程中的暂停被误报为无响应异常，可以开启DevEco Studio的Debug模式（无需设置断点），或者可以在非主线程的其他线程中运行JSVM。 打开 inspector 端口, 链接 devtools 用于调试, 其流程如下: 在执行JS代码之前，调用OH_JSVM_OpenInspector在指定的主机和端口上激活inspector，创建socket。例如OH_JSVM_OpenInspectorWithName(env, 123, “test”)，创建 tcp socket 及其对应的 unixdomain 端口 调用OH_JSVM_WaitForDebugger，等待建立socket连接。 检查端侧端口是否打开成功。hdc shell \"cat /proc/net/unix | grep jsvm\"。结果出现可用的 unix 端口即可, 如: jsvm_devtools_remote_9229_123, 其中 9229 为 tcp 端口号, 123 为对应的 pid 转发端口。hdc fport tcp:9229 tcp:9229。转发PC侧端口9229到端侧端口9229。结果为\"Forwardport result:OK\"即可。 在 chrome 浏览器地址栏输入 \"localhost:9229/json\"，回车。获取端口连接信息。打开Chrome开发者工具，拷贝\"devtoolsFrontendUrl\"字段url内容到地址栏，回车，进入DevTools源码页，将看到在应用中通过OH_JSVM_RunScript执行的JS源码，此时暂停在第一行JS源码处。 用户可在源码页打断点，通过按钮发出各种调试命令控制JS代码执行，并查看变量。 调用OH_JSVM_CloseInspector关闭inspector，结束socket连接。 
代码示例
对应的 enable inspector 替换为下面的即可
// 开启debugger\nstatic void EnableInspector(JSVM_Env env) {\n    // 在指定的主机和端口上激活inspector，创建socket。\n    OH_JSVM_OpenInspectorWithName(env, 123, \"test\");\n    // 等待建立socket连接。\n    OH_JSVM_WaitForDebugger(env, true);\n}
CPU Profiler及Heap Snapshot使用方法
[h2]CPU Profiler接口使用方法
 在执行JS代码之前，调用OH_JSVM_StartCpuProfiler开始采样并返回JSVM_CpuProfiler。 在执行JS代码后，调用OH_JSVM_StopCpuProfiler，传入1中返回的JSVM_CpuProfiler，传入输出流回调及输出流指针。数据将会写入指定的输出流中。 输出数据为JSON字符串。可存入.cpuprofile文件中。该文件类型可导入Chrome浏览器-DevTools-JavaScript Profiler工具中解析成性能分析视图。 
[h2]Heap Snapshot接口使用方法
1.为分析某段JS代码的堆对象创建情况。可在执行JS代码前后，分别调用一次OH_JSVM_TakeHeapSnapshot。传入输出流回调及输出流指针。数据将会写入指定的输出流中。
2.输出数据可存入.heapsnapshot文件中。该文件类型可导入Chrome浏览器-DevTools-Memory工具中解析成内存分析视图。
[h2]示例代码
JSVM-API接口开发流程参考使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应C++相关代码进行展示。
#include \"ark_runtime/jsvm.h\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\n// 待调优的JS代码。\nstatic string srcProf = R\"JS(\nfunction sleep(delay) {\n    var start = (new Date()).getTime();\n    while ((new Date()).getTime() - start < delay) {\n        continue;\n    }\n}\n\nfunction work3() {\n    sleep(300);\n}\n\nfunction work2() {\n    work3();\n    sleep(200);\n}\n\nfunction work1() {\n    work2();\n    sleep(100);\n}\n\nwork1();\n)JS\";\n\n// 数据输出流回调，用户自定义，处理返回的调优数据，此处以写入文件为例。\nstatic bool OutputStream(const char *data, int size, void *streamData) {\n    auto &os = *reinterpret_cast<ofstream *>(streamData);\n    if (data) {\n        os.write(data, size);\n    } else {\n        os.close();\n    }\n    return true;\n}\n\nstatic JSVM_CpuProfiler ProfilingBegin(JSVM_VM vm) {\n    // 文件输出流，保存调优数据，/data/storage/el2/base/files为沙箱路径。以包名为com.example.helloworld为例。\n    // 实际文件会保存到/data/app/el2/100/base/com.example.helloworld/files/heap-snapshot-begin.heapsnapshot。\n    ofstream heapSnapshot(\"/data/storage/el2/base/files/heap-snapshot-begin.heapsnapshot\",\n                          ios::out | ios:: binary | ios::trunc);\n    // 执行JS前获取一次Heap Snapshot数据。\n    OH_JSVM_TakeHeapSnapshot(vm, OutputStream, &heapSnapshot);\n    JSVM_CpuProfiler cpuProfiler;\n    // 开启CPU Profiler。\n    OH_JSVM_StartCpuProfiler(vm, &cpuProfiler);\n    return cpuProfiler;\n}\n\n// 关闭调优数据采集工具\nstatic void ProfilingEnd(JSVM_VM vm, JSVM_CpuProfiler cpuProfiler) {\n    // 文件输出流，保存调优数据，/data/storage/el2/base/files为沙箱路径。以包名为com.example.helloworld为例。\n    // 实际文件会保存到/data/app/el2/100/base/com.example.helloworld/files/cpu-profile.cpuprofile。\n    ofstream cpuProfile(\"/data/storage/el2/base/files/cpu-profile.cpuprofile\",\n                        ios::out | ios:: binary | ios::trunc);\n    // 关闭CPU Profiler，获取数据。\n    OH_JSVM_StopCpuProfiler(vm, cpuProfiler, OutputStream, &cpuProfile);\n    ofstream heapSnapshot(\"/data/storage/el2/base/files/heap-snapshot-end.heapsnapshot\",\n                              ios::out | ios:: binary | ios::trunc);\n    // 执行JS后再获取一次Heap Snapshot数据，与执行前数据作对比，以分析内存问题或者进行内存调优。\n    OH_JSVM_TakeHeapSnapshot(vm, OutputStream, &heapSnapshot);\n}\n\nstatic JSVM_Value RunScriptWithStatistics(JSVM_Env env, JSVM_CallbackInfo info) {\n    JSVM_VM vm;\n    OH_JSVM_GetVM(env, &vm);\n\n    // 开始调优。\n    auto cpuProfiler = ProfilingBegin(vm);\n\n    JSVM_HandleScope handleScope;\n    OH_JSVM_OpenHandleScope(env, &handleScope);\n\n    JSVM_Value jsSrc;\n    OH_JSVM_CreateStringUtf8(env, srcProf.c_str(), srcProf.size(), &jsSrc);\n\n    JSVM_Script script;\n    OH_JSVM_CompileScript(env, jsSrc, nullptr, 0, true, nullptr, &script);\n\n    JSVM_Value result;\n    // 执行JS代码。\n    OH_JSVM_RunScript(env, script, &result);\n\n    OH_JSVM_CloseHandleScope(env, handleScope);\n\n    // 结束调优。\n    ProfilingEnd(vm, cpuProfiler);\n    return nullptr;\n}\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = RunScriptWithStatistics},\n};\nstatic JSVM_CallbackStruct *method = param;\n// runScriptWithStatistics方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"runScriptWithStatistics\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};
// 样例测试JS
const char *srcCallNative = R\"JS(runScriptWithStatistics();)JS\";

使用JSVM-API接口进行object相关开发
简介
使用JSVM-API接口进行object相关开发，处理JavaScript对象的基本操作的功能，例如创建对象、获取原型、冻结和密封对象，检查对象的类型等。这些操作是在处理JavaScript对象时非常常见的，提供了一种与JavaScript对象交互的方式。
基本概念
在JSVM接口开发中，经常需要定义和操作对象。例如，创建一个API接口，该接口接受一个对象作为输入参数，对该对象执行某些操作，并返回一个结果对象。在这个过程中，需要确保接口的定义清晰、规范，并且与对象的属性和方法相兼容。
接口（API）：接口定义了组件之间的交互协议，包括输入参数、输出结果以及可能的错误处理。通过接口，组件可以相互调用和交换数据，而无需了解对方的内部实现细节。对象（Object）：在JavaScript，对象是一种复合数据类型，允许存储多个不同类型的值作为一个单独的实体。对象是属性和方法的集合。属性是与对象相关联的值，而方法则是对象可以执行的操作。
接口说明
使用示例
JSVM-API接口开发流程参考使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应C++及ArkTS相关代码进行展示。
[h2]OH_JSVM_GetPrototype
获取给定JavaScript对象的原型。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// GetPrototype注册回调\n// OH_JSVM_GetPrototype的样例方法\nstatic JSVM_Value GetPrototype(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value argv[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, argv, nullptr, nullptr);\n    JSVM_Value result{nullptr};\n    JSVM_Status status = OH_JSVM_GetPrototype(env, argv[0], &result);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM GetPrototype fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM GetPrototype success\");\n    }\n    return result;\n}\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = GetPrototype},\n};\nstatic JSVM_CallbackStruct *method = param;\n// GetPrototype方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"getPrototype\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(const myObject = {};\n    const proto = getPrototype(myObject);\n    console.log(proto === Object.prototype);)JS\";
预期的输出结果
JSVM GetPrototype success
[h2]OH_JSVM_CreateObject
创建一个默认的JavaScript Object对象。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_CreateObject的样例方法\nstatic JSVM_Value CreateObject(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    JSVM_Value object = nullptr;\n    // 创建一个空对象\n    JSVM_Status status = OH_JSVM_CreateObject(env, &object);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM CreateObject fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM CreateObject success\");\n    }\n    // 设置对象的属性\n    JSVM_Value name = nullptr;\n    // 设置属性名为 \"name\"\n    OH_JSVM_CreateStringUtf8(env, \"name\", JSVM_AUTO_LENGTH, &name);\n    JSVM_Value value = nullptr;\n    // 设置属性值为 \"Hello from N-API!\"\n    OH_JSVM_CreateStringUtf8(env, \"Hello OH_JSVM_CreateObject!\", JSVM_AUTO_LENGTH, &value);\n    // 将属性设置到对象上\n    OH_JSVM_SetProperty(env, object, name, value);\n    return object;\n}\n// CreateObject注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = CreateObject},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateObject方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"createObject\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(createObject())JS\";
预期的输出结果
JSVM CreateObject success
[h2]OH_JSVM_ObjectFreeze
冻结给定的对象，防止向其添加新属性，删除现有属性，防止更改现有属性的可枚举性、可配置性或可写性，并防止更改现有属性的值。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_ObjectFreeze的样例方法\nstatic JSVM_Value ObjectFreeze(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 接受一个JavaScript侧传入的object\n    size_t argc = 1;\n    JSVM_Value argv[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, argv, nullptr, nullptr);\n    // 调用接口OH_JSVM_ObjectFreeze将传入的object冻结\n    JSVM_Status status = OH_JSVM_ObjectFreeze(env, argv[0]);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"Test JSVM OH_JSVM_ObjectFreeze success\");\n    }\n    // 测试冻结后的对象中属性能否修改\n    JSVM_Value value = nullptr;\n    OH_JSVM_CreateInt32(env, 111111, &value);\n    OH_JSVM_SetNamedProperty(env, argv[0], \"data\", value);\n    // 将冻结后修改过的属性返回JavaScript侧\n    return argv[0];\n}\n// ObjectFreeze注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = ObjectFreeze},\n};\nstatic JSVM_CallbackStruct *method = param;\n// ObjectFreeze方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"objectFreeze\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(let obj = { data: 55, message: \"hello world\"};\n  objectFreeze(obj))JS\";
预期的输出结果
Test JSVM OH_JSVM_ObjectFreeze success
[h2]OH_JSVM_ObjectSeal
密封给定的对象。这可以防止向其添加新属性，以及将所有现有属性标记为不可配置。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_ObjectSeal的样例方法\nstatic JSVM_Value ObjectSeal(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 接受一个JavaScript侧传入的object\n    size_t argc = 1;\n    JSVM_Value argv[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, argv, nullptr, nullptr);\n    // 调用接口OH_JSVM_ObjectSeal将传入的object封闭，使其无法添加新的属性\n    JSVM_Status status = OH_JSVM_ObjectSeal(env, argv[0]);\n    if (status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"Test JSVM OH_JSVM_ObjectSeal success\");\n    }\n    // 检查封闭后的对象中属性能否修改、删除、新增\n    // 封闭后对象修改\n    JSVM_Value changeValue = nullptr;\n    OH_JSVM_CreateInt32(env, 111111, &changeValue);\n    OH_JSVM_SetNamedProperty(env, argv[0], \"data\", changeValue);\n    // 封闭后对象删除\n    JSVM_Value deleteProperty = nullptr;\n    OH_JSVM_CreateStringUtf8(env, \"message\", JSVM_AUTO_LENGTH, &deleteProperty);\n    bool result = false;\n    OH_JSVM_DeleteProperty(env, argv[0], deleteProperty, &result);\n    if (result) {\n        OH_LOG_INFO(LOG_APP, \"Test JSVM OH_JSVM_ObjectSeal failed\");\n    }\n    // 封闭后对象新增\n    JSVM_Value addValue = nullptr;\n    OH_JSVM_CreateStringUtf8(env, \"addValue\", JSVM_AUTO_LENGTH, &addValue);\n    OH_JSVM_SetNamedProperty(env, argv[0], \"newProperty\", addValue);\n    // 将封闭后改动过的对象返回JavaScript侧\n    return argv[0];\n}\n// ObjectSeal注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = ObjectSeal},\n};\nstatic JSVM_CallbackStruct *method = param;\n// ObjectSeal方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"objectSeal\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS( let obj = { data: 55, message: \"hello world\"};\n  objectSeal(obj))JS\";
预期的输出结果
Test JSVM OH_JSVM_ObjectSeal success
[h2]OH_JSVM_Typeof
返回JavaScript对象的类型。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_Typeof的样例方法\nstatic JSVM_Value GetTypeof(JSVM_Env env, JSVM_CallbackInfo info) {\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    JSVM_ValueType valueType;\n    OH_JSVM_Typeof(env, args[0], &valueType);\n    JSVM_Value type = nullptr;\n    switch (valueType) {\n    case JSVM_UNDEFINED:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is undefined\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is undefined\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_NULL:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is null\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is null\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_BOOLEAN:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is boolean\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is boolean\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_NUMBER:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is number\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is number\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_STRING:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is string\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is string\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_SYMBOL:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is symbol\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is symbol\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_OBJECT:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is object\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is object\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_FUNCTION:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is function\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is function\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_EXTERNAL:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is external\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is external\", JSVM_AUTO_LENGTH, &type);\n        break;\n    case JSVM_BIGINT:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type is bigint\");\n        OH_JSVM_CreateStringUtf8(env, \"Input type is bigint\", JSVM_AUTO_LENGTH, &type);\n        break;\n    default:\n        OH_LOG_INFO(LOG_APP, \"JSVM Input type does not match any\");\n        OH_JSVM_CreateStringUtf8(env, \" \", JSVM_AUTO_LENGTH, &type);\n        break;\n    }\n    return type;\n}\n// GetTypeof注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = GetTypeof},\n};\nstatic JSVM_CallbackStruct *method = param;\n// GetTypeof方法别名，TS侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"getTypeof\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(getTypeof(true);)JS\";
预期的输出结果
JSVM Input type is boolean
[h2]OH_JSVM_Instanceof
判断一个对象是否是某个构造函数的实例。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_Instanceof的样例方法\nstatic JSVM_Value InstanceOf(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 获取两个JavaScript侧传入的参数\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    bool result = false;\n    JSVM_Status status = OH_JSVM_Instanceof(env, args[0], args[1], &result);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM InstanceOf fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM InstanceOf：%{public}d\", result);\n    }\n    JSVM_Value returnValue = nullptr;\n    OH_JSVM_GetBoolean(env, result, &returnValue);\n    return returnValue;\n}\n// InstanceOf注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = InstanceOf},\n};\nstatic JSVM_CallbackStruct *method = param;\n// InstanceOf方法别名，TS侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"instanceOf\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(class Person {\n        name;\n        age;\n        constructor(name, age) {\n          this.name = name;\n          this.age = age;\n        }\n      }\n     instanceOf(new Person('Alice', 30), Person);\n     ;)JS\";
预期的输出结果
JSVM InstanceOf：1
[h2]OH_JSVM_TypeTagObject
使用类型标签type_tag来标记JavaScript对象，后续可以更精确地识别JavaScript对象。
[h2]OH_JSVM_CheckObjectTypeTag
检查给定的类型标签是否与对象上的类型标签匹配。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n#define NUMBERINT_FOUR 4\n// 定义一个静态常量JSVM_TypeTag数组存储类型标签\nstatic const JSVM_TypeTag TagsData[NUMBERINT_FOUR] = {\n    {0x9e4b2449547061b3, 0x33999f8a6516c499},\n    {0x1d55a794c53a726d, 0x43633f509f9c944e},\n    {0, 0}, // 用于表示无标签或默认标签\n    {0x6a971439f5b2e5d7, 0x531dc28a7e5317c0},\n};\n// OH_JSVM_TypeTagObject的样例方法\nstatic JSVM_Value SetTypeTagToObject(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 获取两个JavaScript侧传入的参数\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 获取索引数字转换为JSVM_Value\n    int32_t index = 0;\n    OH_JSVM_GetValueInt32(env, args[1], &index);\n    // 给参数（对象）设置类型标签\n    JSVM_Status status = OH_JSVM_TypeTagObject(env, args[0], &TagsData[index]);\n    // 将bool结果转换为JSVM_Value并返回\n    JSVM_Value result = nullptr;\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM SetTypeTagToObject fail\");\n        OH_JSVM_GetBoolean(env, false, &result);\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM SetTypeTagToObject success\");\n        OH_JSVM_GetBoolean(env, true, &result);\n    }\n    return result;\n}\n// OH_JSVM_CheckObjectTypeTag的样例方法\nstatic JSVM_Value CheckObjectTypeTag(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 获取两个JavaScript侧传入的参数\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 获取索引数字转换为JSVM_Value\n    int32_t index = 0;\n    OH_JSVM_GetValueInt32(env, args[1], &index);\n    // 检查对象的类型标签\n    bool checkResult = false;\n    JSVM_Status status = OH_JSVM_CheckObjectTypeTag(env, args[0], &TagsData[index], &checkResult);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM SetTypeTagToObject fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM SetTypeTagToObject:%{public}d\", checkResult);\n    }\n    // 将bool结果转换为JSVM_Value并返回\n    JSVM_Value checked = nullptr;\n    OH_JSVM_GetBoolean(env, checkResult, &checked);\n    return checked;\n}\n// SetTypeTagToObject，CheckObjectTypeTag注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = SetTypeTagToObject},\n    {.data = nullptr, .callback = CheckObjectTypeTag},\n};\nstatic JSVM_CallbackStruct *method = param;\n// SetTypeTagToObject，CheckObjectTypeTag方法别名，TS侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"setTypeTagToObject\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n    {\"checkObjectTypeTag\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(\n         class Obj {\n           data;\n           message;\n         }\n         let obj= { data: 0, message: \"hello world\"};\n         setTypeTagToObject(obj, 0);\n         checkObjectTypeTag(obj,0);)JS\";
预期的输出结果
JSVM SetTypeTagToObject success\nJSVM SetTypeTagToObject:1
[h2]OH_JSVM_CreateExternal
创建一个包装了外部指针的JavaScript对象。
注意：JavaScript对象被垃圾回收时，包装的外部指针指向的内容不被GC直接管理，仅调用传入的第三个参数对应的函数（如果传入时不为nullptr）。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_CreateExternal的样例方法\nstatic JSVM_Value CreateExternal(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t dataSize = 10;\n    void *data = malloc(dataSize);\n    if (data == nullptr) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM Failed to malloc.\");\n        return nullptr;\n    }\n    memset(data, 0, dataSize);\n    const char* testStr = \"test\";\n    JSVM_Value external = nullptr;\n    JSVM_Status status = OH_JSVM_CreateExternal(\n        env, data, [](JSVM_Env env, void *data, void *hint) {free(data);}, (void *)testStr, &external);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM Failed to create external data, status:%{public}d.\", status);\n        free(data);\n        data = nullptr;\n        return nullptr;\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM CreateExternal success\");\n    }\n    return external;\n}\n// CreateExternal注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = CreateExternal},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateExternal方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"createExternal\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(createExternal())JS\";
预期的输出结果
JSVM CreateExternal success
[h2]OH_JSVM_GetValueExternal
OH_JSVM_CreateExternal可以创建包装自定义的C/C++对象并将其公开给JavaScript代码，而OH_JSVM_GetValueExternal就是用来获得OH_JSVM_CreateExternal所包装的外部对象的指针。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_GetValueExternal的样例方法\nstatic JSVM_Value GetValueExternal(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    static int data = 0x12345;\n    JSVM_Value externalValue = nullptr;\n    JSVM_Status status = OH_JSVM_CreateExternal(env, (void*)&data, nullptr, nullptr, &externalValue);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM OH_JSVM_CreateExternal fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM OH_JSVM_CreateExternal success\");\n    }\n    void *data_value;\n    status = OH_JSVM_GetValueExternal(env, externalValue, &data_value);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM GetValueExternal fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM GetValueExternal success\");\n    }\n    // 将符号位转化为int类型传出去\n    JSVM_Value returnValue = nullptr;\n    int retData = *static_cast<int *>(data_value);\n    OH_JSVM_CreateInt32(env, retData, &returnValue);\n    return returnValue;\n}\n// GetValueExternal注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = GetValueExternal},\n};\nstatic JSVM_CallbackStruct *method = param;\n// GetValueExternal方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"getValueExternal\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(getValueExternal())JS\";
预期的输出结果
JSVM OH_JSVM_CreateExternal success\nJSVM GetValueExternal success
[h2]OH_JSVM_CreateSymbol
用于创建一个新的Symbol。Symbol是一种特殊的数据类型，用于表示唯一的标识符。与字符串或数字不同，符号的值是唯一的，即使两个符号具有相同的描述，它们也是不相等的。符号通常用作对象属性的键，以确保属性的唯一性。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_CreateSymbol的样例方法\nstatic JSVM_Value CreateSymbol(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    JSVM_Value result = nullptr;\n    const char *des = \"only\";\n    OH_JSVM_CreateStringUtf8(env, des, JSVM_AUTO_LENGTH, &result);\n    JSVM_Value returnSymbol = nullptr;\n    OH_JSVM_CreateSymbol(env, result, &returnSymbol);\n    JSVM_ValueType valuetypeSymbol;\n    OH_JSVM_Typeof(env, returnSymbol, &valuetypeSymbol);\n    if (valuetypeSymbol == JSVM_SYMBOL) {\n        OH_LOG_INFO(LOG_APP, \"JSVM CreateSymbol Success\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM CreateSymbol fail\");\n    }\n    return returnSymbol;\n}\n// CreateSymbol注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = CreateSymbol},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateSymbol方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"createSymbol\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(createSymbol())JS\";
预期的输出结果
JSVM CreateSymbol Success
[h2]OH_JSVM_SymbolFor
在全局注册表中搜索具有给定描述的现有Symbol，如果该Symbol已经存在，它将被返回，否则将在注册表中创建一个新Symbol。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// 定义一个常量，用于存储最大字符串长度\nstatic const int MAX_BUFFER_SIZE = 128;\n// OH_JSVM_SymbolFor的样例方法\nstatic JSVM_Value SymbolFor(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    JSVM_Value description = nullptr;\n    OH_JSVM_CreateStringUtf8(env, \"test_demo\", 9, &description);\n    char buffer[MAX_BUFFER_SIZE];\n    size_t bufferSize = MAX_BUFFER_SIZE;\n    size_t copied = 0;\n    OH_JSVM_GetValueStringUtf8(env, description, buffer, bufferSize, &copied);\n    JSVM_Value symbol = nullptr;\n    OH_JSVM_CreateSymbol(env, description, &symbol);\n    JSVM_Value result_symbol = nullptr;\n    JSVM_Status status = OH_JSVM_SymbolFor(env, buffer, copied, &result_symbol);\n    JSVM_ValueType valuetypeSymbol;\n    OH_JSVM_Typeof(env, result_symbol, &valuetypeSymbol);\n    if (valuetypeSymbol == JSVM_SYMBOL && status == JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"JSVM OH_JSVM_SymbolFor success\");\n    }\n    // 返回结果\n    return result_symbol;\n}\n// SymbolFor注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = SymbolFor},\n};\nstatic JSVM_CallbackStruct *method = param;\n// SymbolFor方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"symbolFor\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char* srcCallNative = R\"JS(symbolFor())JS\";
预期的输出结果
JSVM OH_JSVM_SymbolFor success

同步任务开发指导 (TaskPool和Worker)
同步任务是指在多个线程之间协调执行的任务，其目的是确保多个任务按照一定的顺序和规则执行，例如使用锁来防止数据竞争。
同步任务的实现需要考虑多个线程之间的协作和同步，以确保数据的正确性和程序的正确执行。
由于TaskPool偏向于单个独立的任务，因此当各个同步任务之间相对独立时推荐使用TaskPool，例如一系列导入的静态方法，或者单例实现的方法。如果同步任务之间有关联性，则需要使用Worker，例如无法单例创建的类对象实现的方法。
使用TaskPool处理同步任务
当调度独立的任务，或者一系列任务为静态方法实现，或者可以通过单例构造唯一的句柄或类对象，可在不同任务线程之间使用时，推荐使用TaskPool。
由于Actor模型不同线程间内存隔离的特性，普通单例无法在不同线程间使用。可以通过共享模块导出单例解决该问题。
 定义并发函数，实现业务逻辑。 创建任务Task，通过execute()接口执行该任务。 对任务返回的结果进行操作。 
如下示例中业务使用TaskPool调用相关同步方法的代码，首先定义并发函数taskpoolFunc，需要注意必须使用@Concurrent装饰器装饰该函数；其次定义函数mainFunc，该函数功能为创建任务，执行任务并对任务返回的结果进行操作。
// Index.ets代码\nimport { taskpool} from '@kit.ArkTS';\n\n// 步骤1: 定义并发函数，实现业务逻辑\n@Concurrent\nasync function taskpoolFunc(num: number): Promise<number> {\n  // 根据业务逻辑实现相应的功能\n  let tmpNum: number = num + 100;\n  return tmpNum;\n}\n\nasync function mainFunc(): Promise<void> {\n  // 步骤2: 创建任务并执行\n  let task1: taskpool.Task = new taskpool.Task(taskpoolFunc, 1);\n  let res1: number = await taskpool.execute(task1) as number;\n  let task2: taskpool.Task = new taskpool.Task(taskpoolFunc, res1);\n  let res2: number = await taskpool.execute(task2) as number;\n  // 步骤3: 对任务返回的结果进行操作\n  console.info(\"taskpool: task res1 is: \" + res1);\n  console.info(\"taskpool: task res2 is: \" + res2);\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(async () => {\n            mainFunc();\n          })\n      }\n      .width('100%')\n      .height('100%')\n    }\n  }\n}
使用Worker处理关联的同步任务
当一系列同步任务需要使用同一个句柄调度，或者需要依赖某个类对象调度，无法在不同任务池之间共享时，需要使用Worker。
 在UI主线程中创建Worker对象，同时接收Worker线程发送回来的消息。DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，点击鼠标右键 > New > Worker，即可自动生成Worker的模板文件及配置信息。 // Index.ets\nimport { worker } from '@kit.ArkTS';\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            let w: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/MyWorker.ts');\n            w.onmessage = (): void => {\n              // 接收Worker子线程的结果\n            }\n            w.onerror = (): void => {\n              // 接收Worker子线程的错误信息\n            }\n            // 向Worker子线程发送Set消息\n            w.postMessage({'type': 0, 'data': 'data'})\n            // 向Worker子线程发送Get消息\n            w.postMessage({'type': 1})\n            // ...\n            // 根据实际业务，选择时机以销毁线程\n            w.terminate()\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n} 在Worker线程中绑定Worker对象，同时处理同步任务逻辑。 // handle.ts代码\nexport default class Handle {\n  syncGet() {\n    return;\n  }\n\n  syncSet(num: number) {\n    return;\n  }\n} // MyWorker.ts代码\nimport { worker, ThreadWorkerGlobalScope, MessageEvents } from '@kit.ArkTS';\nimport Handle from './handle';  // 返回句柄\n\nlet workerPort : ThreadWorkerGlobalScope = worker.workerPort;\n\n// 无法传输的句柄，所有操作依赖此句柄\nlet handler: Handle = new Handle()\n\n// Worker线程的onmessage逻辑\nworkerPort.onmessage = (e : MessageEvents): void => {\n switch (e.data.type as number) {\n  case 0:\n   handler.syncSet(e.data.data);\n   workerPort.postMessage('success set');\n   break;\n  case 1:\n   handler.syncGet();\n   workerPort.postMessage('success get');\n   break;\n }\n} 

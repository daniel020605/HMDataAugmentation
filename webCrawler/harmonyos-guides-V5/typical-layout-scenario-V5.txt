典型布局场景
虽然不同应用的页面千变万化，但对其进行拆分和分析，页面中的很多布局场景是相似的。本小节将介绍如何借助自适应布局、响应式布局以及常见的容器类组件，实现应用中的典型布局场景。
在本文媒体查询小节中已经介绍了如何通过媒体查询监听断点变化，后续的示例中不再重复介绍此部分代码。
页签栏
布局效果
页签在底部
页签的图标和文字垂直布局
页签宽度均分
页签高度固定72vp
页签在底部
页签的图标和文字水平布局
页签宽度均分
页签高度固定56vp
页签在左边
页签的图标和文字垂直布局
页签宽度固定96vp
页签高度总占比‘60%’后均分
实现方案
不同断点下，页签在页面中的位置及尺寸都有差异，可以结合响应式布局能力，设置不同断点下Tab组件的barPosition、vertical、barWidth和barHeight属性实现目标效果。
另外，页签栏中的文字和图片的相对位置不同，同样可以通过设置不同断点下tabBar对应的CustomBuilder中的布局方向，实现目标效果。
参考代码
import { BreakpointSystem, BreakpointState } from '../common/breakpointsystem'\n\ninterface TabBar  {\n  name: string\n  icon: Resource\n  selectIcon: Resource\n}\ninterface marginGenerate {\n  top: number,\n  left?:number\n}\n\n@Entry\n@Component\nstruct Home {\n  @State currentIndex: number = 0\n  @State tabs: Array<TabBar> = [{\n                                  name: '首页',\n                                  icon: $r('app.media.ic_music_home'),\n                                  selectIcon: $r('app.media.ic_music_home_selected')\n                                }, {\n                                  name: '排行榜',\n                                  icon: $r('app.media.ic_music_ranking'),\n                                  selectIcon: $r('app.media.ic_music_ranking_selected')\n                                }, {\n                                  name: '我的',\n                                  icon: $r('app.media.ic_music_me_nor'),\n                                  selectIcon: $r('app.media.ic_music_me_selected')\n                                }]\n  @State compStr: BreakpointState<string> = BreakpointState.of({ sm: \"sm\", md: \"md\", lg: \"lg\" })\n  @State compDirection: BreakpointState<FlexDirection> = BreakpointState.of({\n    sm: FlexDirection.Column,\n    md: FlexDirection.Row,\n    lg: FlexDirection.Column\n  });\n  @State compBarPose: BreakpointState<BarPosition> = BreakpointState.of({\n    sm: BarPosition.End,\n    md: BarPosition.End,\n    lg: BarPosition.Start\n  });\n  @State compVertical: BreakpointState<boolean> = BreakpointState.of({\n    sm: false,\n    md: false,\n    lg: true\n  });\n  @State compBarWidth: BreakpointState<string> = BreakpointState.of({\n    sm: '100%', md: '100%', lg: '96vp'\n  });\n  @State compBarHeight: BreakpointState<string> = BreakpointState.of({\n    sm: '72vp', md: '56vp', lg: '60%'\n  });\n  @State compMargin: BreakpointState<marginGenerate> = BreakpointState.of({\n    sm: ({ top: 4 } as marginGenerate),\n    md: ({ left: 8 } as marginGenerate),\n    lg: ({ top: 4 } as marginGenerate)\n  });\n\n  @Builder TabBarBuilder(index: number, tabBar: TabBar) {\n    Flex({\n      direction: this.compDirection.value,\n      justifyContent: FlexAlign.Center,\n      alignItems: ItemAlign.Center\n    }) {\n      Image(this.currentIndex === index ? tabBar.selectIcon : tabBar.icon)\n        .size({ width: 36, height: 36 })\n      Text(tabBar.name)\n        .fontColor(this.currentIndex === index ? '#FF1948' : '#999')\n        .margin(this.compMargin.value)\n        .fontSize(16)\n    }\n    .width('100%')\n    .height('100%')\n  }\n  aboutToAppear() {\n    BreakpointSystem.getInstance().attach(this.compStr)\n    BreakpointSystem.getInstance().attach(this.compDirection)\n    BreakpointSystem.getInstance().attach(this.compBarPose)\n    BreakpointSystem.getInstance().attach(this.compVertical)\n    BreakpointSystem.getInstance().attach(this.compBarWidth)\n    BreakpointSystem.getInstance().attach(this.compBarHeight)\n    BreakpointSystem.getInstance().attach(this.compMargin)\n    BreakpointSystem.getInstance().start()\n  }\n\n  aboutToDisappear() {\n    BreakpointSystem.getInstance().detach(this.compStr)\n    BreakpointSystem.getInstance().detach(this.compDirection)\n    BreakpointSystem.getInstance().detach(this.compBarPose)\n    BreakpointSystem.getInstance().detach(this.compVertical)\n    BreakpointSystem.getInstance().detach(this.compBarWidth)\n    BreakpointSystem.getInstance().detach(this.compBarHeight)\n    BreakpointSystem.getInstance().detach(this.compMargin)\n    BreakpointSystem.getInstance().stop()\n  }\n\n  build() {\n    Tabs({\n      barPosition:this.compBarPose.value\n    }) {\n      ForEach(this.tabs, (item:TabBar, index) => {\n        TabContent() {\n          Stack() {\n            Text(item.name).fontSize(30)\n          }.width('100%').height('100%')\n        }.tabBar(this.TabBarBuilder(index!, item))\n      })\n    }\n    .vertical(this.compVertical.value)\n    .barWidth(this.compBarWidth.value)\n    .barHeight(this.compBarHeight.value)\n    .animationDuration(0)\n    .onChange((index: number) => {\n      this.currentIndex = index\n    })\n  }\n}
运营横幅（Banner）
布局效果
实现方案
运营横幅通常使用Swiper组件实现。不同断点下，运营横幅中展示的图片数量不同。只需要结合响应式布局，配置不同断点下Swiper组件的displayCount属性，即可实现目标效果。
参考代码
import { BreakpointSystem, BreakPointType } from '../common/breakpointsystem'\n\n@Entry\n@Component\nexport default struct Banner {\n  private data: Array<Resource> = [\n    $r('app.media.banner1'),\n    $r('app.media.banner2'),\n    $r('app.media.banner3'),\n    $r('app.media.banner4'),\n    $r('app.media.banner5'),\n    $r('app.media.banner6'),\n  ]\n  private breakpointSystem: BreakpointSystem = new BreakpointSystem()\n  @StorageProp('currentBreakpoint') currentBreakpoint: string = 'md'\n\n  aboutToAppear() {\n    this.breakpointSystem.register()\n  }\n\n  aboutToDisappear() {\n    this.breakpointSystem.unregister()\n  }\n\n  build() {\n    Swiper() {\n      ForEach(this.data, (item:Resource) => {\n        Image(item)\n          .size({ width: '100%', height: 200 })\n          .borderRadius(12)\n          .padding(8)\n      })\n    }\n    .indicator(new BreakPointType({ sm: true, md: false, lg: false }).getValue(this.currentBreakpoint)!)\n    .displayCount(new BreakPointType({ sm: 1, md: 2, lg: 3 }).getValue(this.currentBreakpoint)!)\n  }\n}
网格
布局效果
实现方案
不同断点下，页面中图片的排布不同，此场景可以通过响应式布局能力结合Grid组件实现，通过调整不同断点下的Grid组件的columnsTemplate属性即可实现目标效果。
另外，由于本例中各列的宽度相同，也可以通过响应式布局能力结合List组件实现，通过调整不同断点下的List组件的lanes属性也可实现目标效果。
参考代码
通过Grid组件实现
import { BreakpointSystem, BreakPointType } from '../common/breakpointsystem'\n\ninterface GridItemInfo {\n  name: string\n  image: Resource\n}\n\n@Entry\n@Component\nstruct MultiLaneList {\n  private data: GridItemInfo[] = [\n    { name: '歌单集合1', image: $r('app.media.1') },\n    { name: '歌单集合2', image: $r('app.media.2') },\n    { name: '歌单集合3', image: $r('app.media.3') },\n    { name: '歌单集合4', image: $r('app.media.4') },\n    { name: '歌单集合5', image: $r('app.media.5') },\n    { name: '歌单集合6', image: $r('app.media.6') },\n    { name: '歌单集合7', image: $r('app.media.7') },\n    { name: '歌单集合8', image: $r('app.media.8') },\n    { name: '歌单集合9', image: $r('app.media.9') },\n    { name: '歌单集合10', image: $r('app.media.10') },\n    { name: '歌单集合11', image: $r('app.media.11') },\n    { name: '歌单集合12', image: $r('app.media.12') }\n  ]\n  private breakpointSystem: BreakpointSystem = new BreakpointSystem()\n  @StorageProp('currentBreakpoint') currentBreakpoint: string = 'md'\n\n  aboutToAppear() {\n    this.breakpointSystem.register()\n  }\n\n  aboutToDisappear() {\n    this.breakpointSystem.unregister()\n  }\n\n  build() {\n    Grid() {\n      ForEach(this.data, (item: GridItemInfo) => {\n        GridItem() {\n          Column() {\n            Image(item.image)\n              .aspectRatio(1.8)\n            Text(item.name)\n              .margin({ top: 8 })\n              .fontSize(20)\n          }.padding(4)\n        }\n      })\n    }\n    .columnsTemplate(new BreakPointType({\n      sm: '1fr 1fr',\n      md: '1fr 1fr 1fr 1fr',\n      lg: '1fr 1fr 1fr 1fr 1fr 1fr'\n    }).getValue(this.currentBreakpoint)!)\n  }\n}
通过List组件实现
import { BreakpointSystem, BreakPointType } from '../common/breakpointsystem'\n\ninterface ListItemInfo {\n  name: string\n  image: Resource\n}\n\n@Entry\n@Component\nstruct MultiLaneList {\n  private data: ListItemInfo[] = [\n    { name: '歌单集合1', image: $r('app.media.1') },\n    { name: '歌单集合2', image: $r('app.media.2') },\n    { name: '歌单集合3', image: $r('app.media.3') },\n    { name: '歌单集合4', image: $r('app.media.4') },\n    { name: '歌单集合5', image: $r('app.media.5') },\n    { name: '歌单集合6', image: $r('app.media.6') },\n    { name: '歌单集合7', image: $r('app.media.7') },\n    { name: '歌单集合8', image: $r('app.media.8') },\n    { name: '歌单集合9', image: $r('app.media.9') },\n    { name: '歌单集合10', image: $r('app.media.10') },\n    { name: '歌单集合11', image: $r('app.media.11') },\n    { name: '歌单集合12', image: $r('app.media.12') }\n  ]\n  private breakpointSystem: BreakpointSystem = new BreakpointSystem()\n  @StorageProp('currentBreakpoint') currentBreakpoint: string = 'md'\n\n  aboutToAppear() {\n    this.breakpointSystem.register()\n  }\n\n  aboutToDisappear() {\n    this.breakpointSystem.unregister()\n  }\n\n  build() {\n    List() {\n      ForEach(this.data, (item: ListItemInfo) => {\n        ListItem() {\n          Column() {\n            Image(item.image)\n            Text(item.name)\n              .margin({ top: 8 })\n              .fontSize(20)\n          }.padding(4)\n        }\n      })\n    }\n    .lanes(new BreakPointType({ sm: 2, md: 4, lg: 6 }).getValue(this.currentBreakpoint)!)\n    .width('100%')\n  }\n}
侧边栏
布局效果
实现方案
侧边栏通常通过SideBarContainer组件实现，结合响应式布局能力，在不同断点下为SideBarConContainer组件的sideBarWidth、showControlButton等属性配置不同的值，即可实现目标效果。
参考代码
import { BreakpointSystem, BreakPointType } from '../common/breakpointsystem'\n\ninterface imagesInfo{\n  label:string,\n  imageSrc:Resource\n}\nconst images:imagesInfo[]=[\n  {\n    label:'moon',\n    imageSrc:$r('app.media.my_image_moon')\n  },\n  {\n    label:'sun',\n    imageSrc:$r('app.media.my_image')\n  }\n]\n\n@Entry\n@Component\nstruct SideBarSample {\n  @StorageLink('currentBreakpoint') private currentBreakpoint: string = \"md\";\n  private breakpointSystem: BreakpointSystem = new BreakpointSystem()\n  @State selectIndex: number = 0;\n  @State showSideBar:boolean=false;\n\n  aboutToAppear() {\n    this.breakpointSystem.register() \n  }\n\n  aboutToDisappear() {\n    this.breakpointSystem.unregister()\n  }\n\n  @Builder itemBuilder(index: number) {\n    Text(images[index].label)\n      .fontSize(24)\n      .fontWeight(FontWeight.Bold)\n      .borderRadius(5)\n      .margin(20)\n      .backgroundColor('#ffffff')\n      .textAlign(TextAlign.Center)\n      .width(180)\n      .height(36)\n      .onClick(() => {\n        this.selectIndex = index;\n        if(this.currentBreakpoint === 'sm'){\n          this.showSideBar=false\n        }\n      })\n  }\n\n  build() {\n    SideBarContainer(this.currentBreakpoint === 'sm' ? SideBarContainerType.Overlay : SideBarContainerType.Embed) {\n      Column() {\n        this.itemBuilder(0)\n        this.itemBuilder(1)\n      }.backgroundColor('#F1F3F5')\n      .justifyContent(FlexAlign.Center)\n\n      Column() {\n        Image(images[this.selectIndex].imageSrc)\n          .objectFit(ImageFit.Contain)\n          .height(300)\n          .width(300)\n      }\n      .justifyContent(FlexAlign.Center)\n      .width('100%')\n      .height('100%')\n    }\n    .height('100%')\n    .sideBarWidth(this.currentBreakpoint === 'sm' ? '100%' : '33.33%')\n    .minSideBarWidth(this.currentBreakpoint === 'sm' ? '100%' : '33.33%')\n    .maxSideBarWidth(this.currentBreakpoint === 'sm' ? '100%' : '33.33%')\n    .showControlButton(this.currentBreakpoint === 'sm')\n    .autoHide(false)\n    .showSideBar(this.currentBreakpoint !== 'sm'||this.showSideBar)\n    .onChange((isBarShow: boolean) => {\n      if(this.currentBreakpoint === 'sm'){\n          this.showSideBar=isBarShow\n        }         \n    })\n  }\n}
单/双栏
布局效果
单栏显示，在首页中点击选项可以显示详情。
点击详情上方的返回键图标或使用系统返回键可以返回到主页。
实现方案
单/双栏场景可以使用Navigation组件实现，Navigation组件可以根据窗口宽度自动切换单/双栏显示，减少开发工作量。
参考代码
// 工程配置文件module.json5中配置 {\"routerMap\": \"$profile:route_map\"}\n// route_map.json\n{\n  \"routerMap\": [\n    {\n      \"name\": \"Moon\",\n      \"pageSourceFile\": \"src/main/ets/pages/Moon.ets\",\n      \"buildFunction\": \"MoonBuilder\",\n      \"data\": {\n        \"description\": \"this is Moon\"\n      }\n    },\n    {\n      \"name\": \"Sun\",\n      \"pageSourceFile\": \"src/main/ets/pages/Sun.ets\",\n      \"buildFunction\": \"SunBuilder\"\n    }\n  ]\n}\n// Moon.ets\n@Builder\nexport function MoonBuilder(name: string, param: Object) {\n  Moon()\n}\n@Component\nexport struct Moon {\n  private imageSrc: Resource=$r('app.media.my_image_moon')\n  private label: string='moon'\n  build() {\n    Column(){\n    NavDestination(){\n    Column() {\n      Image(this.imageSrc)\n        .objectFit(ImageFit.Contain)\n        .height(300)\n        .width(300)\n    }\n    .justifyContent(FlexAlign.Center)\n    .width('100%')\n    .height('100%')\n     }.title(this.label)\n     }\n  }\n}\n// Sun.ets\n@Builder\nexport function SunBuilder(name: string, param: Object) {\n  Sun()\n}\n@Component\nexport struct Sun {\n  private imageSrc: Resource=$r('app.media.my_image')\n  private label: string='Sun'\n  build() {\n    Column(){\n    NavDestination(){\n    Column() {\n      Image(this.imageSrc)\n        .objectFit(ImageFit.Contain)\n        .height(300)\n        .width(300)\n    }\n    .justifyContent(FlexAlign.Center)\n    .width('100%')\n    .height('100%')\n     }.title(this.label)\n     }\n  }\n}\n//NavigationSample.ets\ninterface arrSample{\n  label:string,\n  pagePath:string\n}\n\n@Entry\n@Component\nstruct NavigationSample {\n  pageInfos: NavPathStack = new NavPathStack();\n  private arr:arrSample[]=[\n    {\n      label:'moon',\n      pagePath:'Moon'\n    },\n    {\n      label:'sun',\n      pagePath:'Sun'\n    }\n  ]\n  build() {\n    Navigation(this.pageInfos) {\n      Column({space: 30}) { \n      ForEach(this.arr, (item: arrSample) => {\n         Text(item.label)\n        .fontSize(24)\n        .fontWeight(FontWeight.Bold)\n        .borderRadius(5)\n        .backgroundColor('#FFFFFF')\n        .textAlign(TextAlign.Center)\n        .width(180)\n        .height(36)\n        .onClick(()=>{\n          this.pageInfos.clear();\n          this.pageInfos.pushPath({name:item.pagePath})\n        })\n        })\n      }\n      .justifyContent(FlexAlign.Center)\n      .height('100%')\n      .width('100%')\n    }\n    .mode(NavigationMode.Auto)\n    .backgroundColor('#F1F3F5')\n    .height('100%')\n    .width('100%')\n    .navBarWidth(360)\n    .hideToolBar(true)\n    .title('Sample')\n  }\n}
三分栏
布局效果
单栏显示。
点击侧边栏控制按钮控制侧边栏的显示/隐藏。
点击首页的选项可以进入到内容区，内容区点击返回按钮可返回首页。
双栏显示。
点击侧边栏控制按钮控制侧边栏的显示/隐藏。
点击左侧导航区不同的选项可以刷新右侧内容区的显示。
三分栏显示。
点击侧边栏控制按钮控制侧边栏的显示/隐藏，来回切换二分/三分栏显示。
点击左侧导航区不同的选项可以刷新右侧内容区的显示。
窗口宽度变化时，优先变化右侧内容区的宽度大小。
场景说明
为充分利用设备的屏幕尺寸优势，应用在大屏设备上常常有二分栏或三分栏的设计，即“A+C”，“B+C”或“A+B+C”的组合，其中A是侧边导航区，B是列表导航区，C是内容区。在用户动态改变窗口宽度时，当窗口宽度大于或等于840vp时页面呈现A+B+C三列，放大缩小优先变化C列；当窗口宽度小于840vp大于等于600vp时呈现B+C列，放大缩小时优先变化C列；当窗口宽度小于600vp大于等于360vp时，仅呈现C列。
实现方案
三分栏场景可以组合使用SideBarContainer组件与Navigation组件实现，SideBarContainer组件可以通过侧边栏控制按钮控制显示/隐藏，Navigation组件可以根据窗口宽度自动切换该组件内单/双栏显示，结合响应式布局能力，在不同断点下为SideBarConContainer组件的minContentWidth属性配置不同的值，即可实现目标效果。设置minContentWidth属性的值可以通过断点监听窗口尺寸变化的同时设置不同的值并储存成一个全局对象。
参考代码
// 工程配置文件module.json5中配置 {\"routerMap\": \"$profile:route_map\"}\n// route_map.json\n{\n  \"routerMap\": [\n    {\n      \"name\": \"B1Page\",\n      \"pageSourceFile\": \"src/main/ets/pages/B1Page.ets\",\n      \"buildFunction\": \"B1PageBuilder\",\n      \"data\": {\n        \"description\": \"this is B1Page\"\n      }\n    },\n    {\n      \"name\": \"B2Page\",\n      \"pageSourceFile\": \"src/main/ets/pages/B2Page.ets\",\n      \"buildFunction\": \"B2PageBuilder\"\n    }\n  ]\n}\n// EntryAbility.ts\nimport { window, display } from '@kit.ArkUI'\nimport { Ability,UIAbility } from '@kit.AbilityKit'\n\nexport default class EntryAbility extends UIAbility {\n  private windowObj?: window.Window\n  private curBp?: string\n  private myWidth?: number\n  // ...\n  // 根据当前窗口尺寸更新断点\n  private updateBreakpoint(windowWidth:number) :void{\n    // 将长度的单位由px换算为vp\n    let windowWidthVp = windowWidth / (display.getDefaultDisplaySync().densityDPI / 160)\n    let newBp: string = ''\n    let newWd: number\n    if (windowWidthVp < 320) {\n      newBp = 'xs'\n      newWd = 360\n    } else if (windowWidthVp < 600) {\n      newBp = 'sm'\n      newWd = 360\n    } else if (windowWidthVp < 840) {\n      newBp = 'md'\n      newWd = 600\n    } else {\n      newBp = 'lg'\n      newWd = 600\n    }\n    if (this.curBp !== newBp) {\n      this.curBp = newBp\n      this.myWidth = newWd\n      // 使用状态变量记录当前断点值\n      AppStorage.setOrCreate('currentBreakpoint', this.curBp)\n      // 使用状态变量记录当前minContentWidth值\n      AppStorage.setOrCreate('myWidth', this.myWidth)\n    }\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage) :void{\n    windowStage.getMainWindow().then((windowObj) => {\n      this.windowObj = windowObj\n      // 获取应用启动时的窗口尺寸\n      this.updateBreakpoint(windowObj.getWindowProperties().windowRect.width)\n      // 注册回调函数，监听窗口尺寸变化\n      windowObj.on('windowSizeChange', (windowSize)=>{\n        this.updateBreakpoint(windowSize.width)\n      })\n    });\n   // ...应用启动页面\n   windowStage.loadContent('pages/Index', (err) => {\n      if (err.code) {      \n        return;\n      }\n    });\n  }\n    \n  // 窗口销毁时，取消窗口尺寸变化监听\n  onWindowStageDestroy() :void {\n    if (this.windowObj) {\n      this.windowObj.off('windowSizeChange')\n    }\n  }\n  //...\n}\n\n\n// B1Page.ets\n@Builder\nexport function B1PageBuilder() {\n  B1Page()\n}\n@Component\nexport struct B1Page {\n  private imageSrc: Resource = $r('app.media.startIcon');\n  private label: string = \"B1\"\n  build() {\n    Column() {\n      NavDestination() {\n        Column() {\n          Image(this.imageSrc)\n            .objectFit(ImageFit.Contain)\n            .height(300)\n            .width(300)\n        }\n        .justifyContent(FlexAlign.Center)\n        .width('100%')\n        .height('100%')\n      }.title(this.label)\n    }\n  }\n}\n// B2Page.ets\n@Builder\nexport function B2PageBuilder() {\n  B2Page()\n}\n@Component\nexport struct B2Page {\n  private imageSrc: Resource = $r('app.media.startIcon');\n  private label: string = \"B2\"\n  build() {\n    Column() {\n      NavDestination() {\n        Column() {\n          Image(this.imageSrc)\n            .objectFit(ImageFit.Contain)\n            .height(300)\n            .width(300)\n        }\n        .justifyContent(FlexAlign.Center)\n        .width('100%')\n        .height('100%')\n      }.title(this.label)\n    }\n  }\n}\n\n//TripleColumnSample.ets\ninterface arrSampleObj{\n  label:string,\n  pagePath:string\n}\n@Entry\n@Component\nstruct TripleColumnSample {\n  @State arr: number[] = [1, 2, 3];\n  @StorageProp('myWidth') myWidth: number = 360;\n  pageInfos:NavPathStack = new NavPathStack();\n  @State arrSample: arrSampleObj[] = [\n    {\n        label:'B1',\n        pagePath:'B1Page'\n    },\n    {\n        label:'B2',\n        pagePath:'B2Page'\n    }\n  ];\n\n  @Builder NavigationTitle() {\n    Column() {\n      Text('Sample')\n        .fontColor('#000000')\n        .fontSize(24)\n        .width('100%')\n        .height('100%')\n        .align(Alignment.BottomStart)\n        .margin({left:'5%'})\n    }.alignItems(HorizontalAlign.Start)\n  }\n\n  build() {\n    SideBarContainer() {\n      Column() {\n        List() {\n          ForEach(this.arr, (item: number, index) => {\n            ListItem() {\n              Text('A' + item)\n                .width('100%')\n                .height(\"20%\")\n                .fontSize(24)\n                .fontWeight(FontWeight.Bold)\n                .textAlign(TextAlign.Center)\n                .backgroundColor('#66000000')\n            }\n          })\n        }.divider({ strokeWidth: 5, color: '#F1F3F5' })\n      }.width('100%')\n      .height('100%')\n      .justifyContent(FlexAlign.SpaceEvenly)\n      .backgroundColor('#F1F3F5')\n\n      Column() {\n        Navigation(this.pageInfos) {\n          List() {\n            ListItem() {\n              Column() {\n                ForEach(this.arrSample, (item: arrSampleObj, index) => {\n                  ListItem() {\n                    Text(item.label)\n                      .fontSize(24)\n                      .fontWeight(FontWeight.Bold)\n                      .backgroundColor('#66000000')\n                      .textAlign(TextAlign.Center)\n                      .width('100%')\n                      .height('30%')\n                      .margin({\n                        bottom:10\n                      })\n                  }.onClick(() => {\n                    this.pageInfos.clear();\n                    this.pageInfos.pushPath({ name: item.pagePath })\n                  })\n                })\n              }\n            }.width('100%')\n          }\n        }\n        .mode(NavigationMode.Auto)\n        .minContentWidth(360)\n        .navBarWidth(240)\n        .backgroundColor('#FFFFFF')\n        .height('100%')\n        .width('100%')\n        .hideToolBar(true)\n        .title(this.NavigationTitle)\n      }.width('100%').height('100%')\n    }.sideBarWidth(240)\n    .minContentWidth(this.myWidth)\n  }\n}
自定义弹窗
布局效果
实现方案
自定义弹窗通常通过CustomDialogController实现，有两种方式实现本场景的目标效果：
 通过gridCount属性配置自定义弹窗的宽度。 系统默认对不同断点下的窗口进行了栅格化：sm断点下为4栅格，md断点下为8栅格，lg断点下为12栅格。通过gridCount属性可以配置弹窗占据栅格中的多少列，将该值配置为4即可实现目标效果。 将customStyle设置为true，即弹窗的样式完全由开发者自定义。 开发者自定义弹窗样式时，开发者可以根据需要配置弹窗的宽高和背景色（非弹窗区域保持默认的半透明色）。自定义弹窗样式配合栅格组件同样可以实现目标效果。 
参考代码
@Entry\n@Component\nstruct CustomDialogSample {\n  // 通过gridCount配置弹窗的宽度\n  dialogControllerA: CustomDialogController = new CustomDialogController({\n    builder: CustomDialogA ({\n      cancel: this.onCancel,\n      confirm: this.onConfirm\n    }),\n    cancel: this.onCancel,\n    autoCancel: true,\n    gridCount: 4,\n    customStyle: false\n  })\n  // 自定义弹窗样式\n  dialogControllerB: CustomDialogController = new CustomDialogController({\n    builder: CustomDialogB ({\n      cancel: this.onCancel,\n      confirm: this.onConfirm\n    }),\n    cancel: this.onCancel,\n    autoCancel: true,\n    customStyle: true\n  })\n\n  onCancel() {\n    console.info('callback when dialog is canceled')\n  }\n\n  onConfirm() {\n    console.info('callback when dialog is confirmed')\n  }\n\n  build() {\n    Column() {\n      Button('CustomDialogA').margin(12)\n        .onClick(() => {\n          this.dialogControllerA.open()\n        })\n      Button('CustomDialogB').margin(12)\n        .onClick(() => {\n          this.dialogControllerB.open()\n        })\n    }.width('100%').height('100%').justifyContent(FlexAlign.Center)\n  }\n}\n\n@CustomDialog\nstruct CustomDialogA {\n  controller?: CustomDialogController\n  cancel?: () => void\n  confirm?: () => void\n\n  build() {\n    Column() {\n      Text('是否删除此联系人?')\n        .fontSize(16)\n        .fontColor('#E6000000')\n        .margin({bottom: 8, top: 24, left: 24, right: 24})\n      Row() {\n        Text('取消')\n          .fontColor('#007DFF')\n          .fontSize(16)\n          .layoutWeight(1)\n          .textAlign(TextAlign.Center)\n          .onClick(()=>{\n            if(this.controller){\n                 this.controller.close()\n             }\n            this.cancel!()\n          })\n        Line().width(1).height(24).backgroundColor('#33000000').margin({left: 4, right: 4})\n        Text('删除')\n          .fontColor('#FA2A2D')\n          .fontSize(16)\n          .layoutWeight(1)\n          .textAlign(TextAlign.Center)\n          .onClick(()=>{\n             if(this.controller){\n                 this.controller.close()\n             }\n            this.confirm!()\n          })\n      }.height(40)\n      .margin({left: 24, right: 24, bottom: 16})\n    }.borderRadius(24)\n  }\n}\n\n@CustomDialog\nstruct CustomDialogB {\n  controller?: CustomDialogController\n  cancel?: () => void\n  confirm?: () => void\n\n  build() {\n    GridRow({columns: {sm: 4, md: 8, lg: 12}}) {\n      GridCol({span: 4, offset: {sm: 0, md: 2, lg: 4}}) {\n        Column() {\n          Text('是否删除此联系人?')\n            .fontSize(16)\n            .fontColor('#E6000000')\n            .margin({bottom: 8, top: 24, left: 24, right: 24})\n          Row() {\n            Text('取消')\n              .fontColor('#007DFF')\n              .fontSize(16)\n              .layoutWeight(1)\n              .textAlign(TextAlign.Center)\n              .onClick(()=>{\n                if(this.controller){\n                 this.controller.close()\n                }\n                this.cancel!()\n              })\n            Line().width(1).height(24).backgroundColor('#33000000').margin({left: 4, right: 4})\n            Text('删除')\n              .fontColor('#FA2A2D')\n              .fontSize(16)\n              .layoutWeight(1)\n              .textAlign(TextAlign.Center)\n              .onClick(()=>{\n                 if(this.controller){\n                 this.controller.close()\n                }\n                this.confirm!()\n              })\n          }.height(40)\n          .margin({left: 24, right: 24, bottom: 16})\n        }.borderRadius(24).backgroundColor('#FFFFFF')\n      }\n    }.margin({left: 24, right: 24})\n  }\n}
大图浏览
布局效果
实现方案
图片通常使用Image组件展示，Image组件的objectFit属性默认为ImageFit.Cover，即保持宽高比进行缩小或者放大以使得图片两边都大于或等于显示边界。在大图浏览场景下，因屏幕与图片的宽高比可能有差异，常常会发生图片被截断的问题。此时只需将Image组件的objectFit属性设置为ImageFit.Contain，即保持宽高比进行缩小或者放大并使得图片完全显示在显示边界内，即可解决该问题。
参考代码
@Entry\n@Component\nstruct BigImage {\n  build() {\n    Row() {\n      Image($r(\"app.media.image\"))\n        .objectFit(ImageFit.Contain)\n    }\n  }\n}
操作入口
布局效果
实现方案
Scroll（内容超出宽度时可滚动） + Row（横向均分：justifyContent（FlexAlign.SpaceAround）、 最小宽度约束：constraintSize({ minWidth: '100%' }）
参考代码
interface OperationItem {\n  name: string\n  icon: Resource\n}\n\n@Entry\n@Component\nexport default struct OperationEntries {\n  @State listData: Array<OperationItem> = [\n    { name: '私人FM', icon: $r('app.media.self_fm') },\n    { name: '歌手', icon: $r('app.media.singer') },\n    { name: '歌单', icon: $r('app.media.song_list') },\n    { name: '排行榜', icon: $r('app.media.rank') },\n    { name: '热门', icon: $r('app.media.hot') },\n    { name: '运动音乐', icon: $r('app.media.sport') },\n    { name: '音乐FM', icon: $r('app.media.audio_fm') },\n    { name: '福利', icon: $r('app.media.bonus') }]\n\n  build() {\n    Scroll() {\n      Row() {\n        ForEach(this.listData, (item:OperationItem) => {\n          Column() {\n            Image(item.icon)\n              .width(48)\n              .aspectRatio(1)\n            Text(item.name)\n              .margin({ top: 8 })\n              .fontSize(16)\n          }\n          .justifyContent(FlexAlign.Center)\n          .height(104)\n          .padding({ left: 12, right: 12 })\n        })\n      }\n      .constraintSize({ minWidth: '100%' }).justifyContent(FlexAlign.SpaceAround)\n    }\n    .width('100%')\n    .scrollable(ScrollDirection.Horizontal)\n  }\n}
顶部
布局效果
实现方案
最外层使用栅格行组件GridRow布局
文本标题使用栅格列组件GridCol
搜索框使用栅格列组件GridCol
参考代码
@Entry\n@Component\nexport default struct Header {\n  @State needWrap: boolean = true\n\n  build() {\n    GridRow() {\n      GridCol({ span: { sm: 12, md: 6, lg: 7 } }) {\n        Row() {\n          Text('推荐').fontSize(24)\n          Blank()\n          Image($r('app.media.ic_public_more'))\n            .width(32)\n            .height(32)\n            .objectFit(ImageFit.Contain)\n            .visibility(this.needWrap ? Visibility.Visible : Visibility.None)\n        }\n        .width('100%').height(40)\n        .alignItems(VerticalAlign.Center)\n      }\n\n      GridCol({ span: { sm: 12, md: 6, lg: 5 } }) {\n        Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Center }) {\n          Search({ placeholder: '猜您喜欢: 万水千山' })\n            .placeholderFont({ size: 16 })\n            .margin({ top: 4, bottom: 4 })\n          Image($r('app.media.audio_fm'))\n            .width(32)\n            .height(32)\n            .objectFit(ImageFit.Contain)\n            .flexShrink(0)\n            .margin({ left: 12 })\n          Image($r('app.media.ic_public_more'))\n            .width(32)\n            .height(32)\n            .objectFit(ImageFit.Contain)\n            .flexShrink(0)\n            .margin({ left: 12 })\n            .visibility(this.needWrap ? Visibility.None : Visibility.Visible)\n        }\n      }\n    }.onBreakpointChange((breakpoint: string) => {\n      if (breakpoint === 'sm') {\n        this.needWrap = true\n      } else {\n        this.needWrap = false\n      }\n    })\n    .padding({ left: 12, right: 12 })\n  }\n}
缩进布局
布局效果
实现方案
借助栅格组件，控制待显示内容在不同的断点下占据不同的列数，即可实现不同设备上的缩进效果。另外还可以调整不同断点下栅格组件与两侧的间距，获得更好的显示效果。
参考代码
@Entry\n@Component\nstruct IndentationSample {\n  @State private gridMargin: number = 24\n  build() {\n    Row() {\n      GridRow({columns: {sm: 4, md: 8, lg: 12}, gutter: 24}) {\n        GridCol({span: {sm: 4, md: 6, lg: 8}, offset: {md: 1, lg: 2}}) {\n          Column() {\n            ForEach([0, 1, 2, 4], () => {\n              Column() {\n                ItemContent()\n              }\n            })\n          }.width('100%')\n        }\n      }\n      .margin({left: this.gridMargin, right: this.gridMargin})\n      .onBreakpointChange((breakpoint: string) => {\n        if (breakpoint === 'lg') {\n          this.gridMargin = 48\n        } else if (breakpoint === 'md') {\n          this.gridMargin = 32\n        } else {\n          this.gridMargin = 24\n        }\n      })\n    }\n    .height('100%')\n    .alignItems((VerticalAlign.Center))\n    .backgroundColor('#F1F3f5')\n  }\n}\n\n@Component\nstruct ItemContent {\n  build() {\n    Column() {\n      Row() {\n        Row() {\n        }\n        .width(28)\n        .height(28)\n        .borderRadius(14)\n        .margin({ right: 15 })\n        .backgroundColor('#E4E6E8')\n\n        Row() {\n        }\n        .width('30%').height(20).borderRadius(4)\n        .backgroundColor('#E4E6E8')\n      }.width('100%').height(28)\n\n      Row() {\n      }\n      .width('100%')\n      .height(68)\n      .borderRadius(16)\n      .margin({ top: 12 })\n      .backgroundColor('#E4E6E8')\n    }\n    .height(128)\n    .borderRadius(24)\n    .backgroundColor('#FFFFFF')\n    .padding({ top: 12, bottom: 12, left: 18, right: 18 })\n    .margin({ bottom: 12 })\n  }\n}
挪移布局
布局效果
实现方案
不同断点下，栅格子元素占据的列数会随着开发者的配置发生改变。当一行中的列数超过栅格组件在该断点的总列数时，可以自动换行，即实现”上下布局”与”左右布局”之间切换的效果。
参考代码
@Entry\n@Component\nstruct DiversionSample {\n  @State private currentBreakpoint: string = 'md'\n  @State private imageHeight: number = 0\n  build() {\n    Row() {\n      GridRow() {\n        GridCol({span: {sm: 12, md: 6, lg: 6}}) {\n          Image($r('app.media.illustrator'))\n          .aspectRatio(1)\n          .onAreaChange((oldValue: Area, newValue: Area) => {\n            this.imageHeight = Number(newValue.height)\n          })\n          .margin({left: 12, right: 12})\n        }\n\n        GridCol({span: {sm: 12, md: 6, lg: 6}}) {\n          Column(){\n            Text($r('app.string.user_improvement'))\n              .textAlign(TextAlign.Center)\n              .fontSize(20)\n              .fontWeight(FontWeight.Medium)\n            Text($r('app.string.user_improvement_tips'))\n              .textAlign(TextAlign.Center)\n              .fontSize(14)\n              .fontWeight(FontWeight.Medium)\n          }\n          .margin({left: 12, right: 12})\n          .justifyContent(FlexAlign.Center)\n          .height(this.currentBreakpoint === 'sm' ? 100 : this.imageHeight)\n        }\n      }.onBreakpointChange((breakpoint: string) => {\n        this.currentBreakpoint = breakpoint;\n      })\n    }\n    .height('100%')\n    .alignItems((VerticalAlign.Center))\n    .backgroundColor('#F1F3F5')\n  }\n}
重复布局
布局效果
单列显示，共8个元素
可以通过上下滑动查看不同的元素。
实现方案
不同断点下，配置栅格子组件占据不同的列数，即可实现“小屏单列显示、大屏双列显示”的效果。另外，还可以通过栅格组件的onBreakpointChange事件，调整页面中显示的元素数量。
参考代码
@Entry\n@Component\nstruct RepeatSample {\n  @State private currentBreakpoint: string = 'md'\n  @State private listItems: number[] = [1, 2, 3, 4, 5, 6, 7, 8]\n  @State private gridMargin: number = 24\n\n  build() {\n    Row() {\n      // 当目标区域不足以显示所有元素时，可以通过上下滑动查看不同的元素\n      Scroll() {\n        GridRow({gutter: 24}) {\n          ForEach(this.listItems, () => {\n           // 通过配置元素在不同断点下占的列数，实现不同的布局效果\n            GridCol({span: {sm: 12, md: 6, lg: 6}}) {\n              Column() {\n                RepeatItemContent()\n              }\n            }\n          })\n        }\n        .margin({left: this.gridMargin, right: this.gridMargin})\n        .onBreakpointChange((breakpoint: string) => {\n          this.currentBreakpoint = breakpoint;\n          if (breakpoint === 'lg') {\n            this.gridMargin = 48\n          } else if (breakpoint === 'md') {\n            this.gridMargin = 32\n          } else {\n            this.gridMargin = 24\n          }\n        })\n      }.height(348)\n    }\n    .height('100%')\n    .backgroundColor('#F1F3F5')\n  }\n}\n\n@Component\nstruct RepeatItemContent {\n  build() {\n    Flex() {\n      Row() {\n      }\n      .width(43)\n      .height(43)\n      .borderRadius(12)\n      .backgroundColor('#E4E6E8')\n      .flexGrow(0)\n\n      Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Start, justifyContent: FlexAlign.SpaceAround }) {\n        Row() {\n        }\n        .height(10)\n        .width('80%')\n        .backgroundColor('#E4E6E8')\n\n        Row() {\n        }\n        .height(10)\n        .width('50%')\n        .backgroundColor('#E4E6E8')\n      }\n      .flexGrow(1)\n      .margin({ left: 13 })\n    }\n    .padding({ top: 13, bottom: 13, left: 13, right: 37 })\n    .height(69)\n    .backgroundColor('#FFFFFF')\n    .borderRadius(24)\n  }\n}

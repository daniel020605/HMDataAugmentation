出现/消失转场
transition是基础的组件转场接口，用于实现一个组件出现或者消失时的动画效果。可以通过TransitionEffect对象的组合使用，定义出各式效果。
表1 转场效果接口
通过此方法组合非对称的出现消失转场效果。
- appear:出现转场的效果。
- disappear：消失转场的效果。
定义转场效果的动画参数：
- 如果不定义会跟随animateTo的动画参数。
- 不支持通过控件的animation接口配置动画参数。
- TransitionEffect中animation的onFinish不生效。
 创建TransitionEffect。 // 出现时会是所有转场效果的出现效果叠加，消失时会是所有消失转场效果的叠加\n// 用于说明各个effect跟随的动画参数\nprivate effect: object =\n  TransitionEffect.OPACITY // 创建了透明度转场效果，这里没有调用animation接口，会跟随animateTo的动画参数\n    // 通过combine方法，添加缩放转场效果，并指定了springMotion(0.6, 1.2)曲线\n    .combine(TransitionEffect.scale({ x: 0, y: 0 }).animation({ curve: curves.springMotion(0.6, 1.2) }))\n    // 添加旋转转场效果，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion(0.6, 1.2)\n    .combine(TransitionEffect.rotate({ angle: 90 }))\n    // 添加平移转场效果，动画参数会跟随其之上带animation的TransitionEffect，也就是springMotion(0.6, 1.2)\n    .combine(TransitionEffect.translate({ x: 150, y: 150 })\n    // 添加move转场效果，并指定了springMotion曲线\n    .combine(TransitionEffect.move(TransitionEdge.END)).animation({curve: curves.springMotion()}))\n    // 添加非对称的转场效果，由于这里没有设置animation，会跟随上面的TransitionEffect的animation效果，也就是springMotion\n    .combine(TransitionEffect.asymmetric(TransitionEffect.scale({ x: 0, y: 0 }), TransitionEffect.rotate({ angle: 90 }))); 将转场效果通过transition接口设置到组件。 Text('test')\n  .transition(this.effect) 新增或者删除组件触发转场。 @State isPresent: boolean = true;\n// ...\nif (this.isPresent) {\n  Text('test')\n    .transition(this.effect)\n}\n// ...\n// 控制新增或者删除组件\n// 方式一：将控制变量放到animateTo闭包内，未通过animation接口定义动画参数的TransitionEffect将跟随animateTo的动画参数\nthis.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {\n  this.isPresent = false;\n})\n\n// 方式二：直接控制删除或者新增组件，动画参数由TransitionEffect的animation接口配置\nthis.isPresent = false; 
完整的示例代码和效果如下，示例中采用直接删除或新增组件的方式触发转场，也可以替换为在animateTo闭包内改变控制变量触发转场。
import { curves } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct TransitionEffectDemo {\n  @State isPresent: boolean = false;\n  // 第一步，创建TransitionEffect\n  private effect: TransitionEffect =\n    // 创建默认透明度转场效果,并指定了springMotion(0.6, 0.8)曲线\n    TransitionEffect.OPACITY.animation({\n      curve: curves.springMotion(0.6, 0.8)\n    })// 通过combine方法,这里的动画参数会跟随上面的TransitionEffect，也就是springMotion(0.6, 0.8)\n      .combine(TransitionEffect.scale({\n        x: 0,\n        y: 0\n      }))// 添加旋转转场效果，这里的动画参数会跟随上面带animation的TransitionEffect，也就是springMotion(0.6, 0.8)\n      .combine(TransitionEffect.rotate({ angle: 90 }))// 添加平移转场效果，这里的动画参数使用指定的springMotion()\n      .combine(TransitionEffect.translate({ y: 150 })\n        .animation({ curve: curves.springMotion() }))// 添加move转场效果，这里的动画参数会跟随上面的TransitionEffect，也就是springMotion()\n      .combine(TransitionEffect.move(TransitionEdge.END))\n\n  build() {\n    Stack() {\n      if (this.isPresent) {\n        Column() {\n          Text('ArkUI')\n            .fontWeight(FontWeight.Bold)\n            .fontSize(20)\n            .fontColor(Color.White)\n        }\n        .justifyContent(FlexAlign.Center)\n        .width(150)\n        .height(150)\n        .borderRadius(10)\n        .backgroundColor(0xf56c6c)\n        // 第二步：将转场效果通过transition接口设置到组件\n        .transition(this.effect)\n      }\n\n      // 边框\n      Column()\n        .width(155)\n        .height(155)\n        .border({\n          width: 5,\n          radius: 10,\n          color: Color.Black\n        })\n\n      // 第三步：新增或者删除组件触发转场，控制新增或者删除组件\n      Button('Click')\n        .margin({ top: 320 })\n        .onClick(() => {\n          this.isPresent = !this.isPresent;\n        })\n    }\n    .width('100%')\n    .height('60%')\n  }\n}
对多个组件添加转场效果时，可以通过在animation动画参数中配置不同的delay值，实现组件渐次出现消失的效果：
const ITEM_COUNTS = 9;\nconst ITEM_COLOR = '#ED6F21';\nconst INTERVAL = 30;\nconst DURATION = 300;\n\n@Entry\n@Component\nstruct Index1 {\n  @State isGridShow: boolean = false;\n  private dataArray: number[] = new Array(ITEM_COUNTS);\n\n  aboutToAppear(): void {\n    for (let i = 0; i < ITEM_COUNTS; i++) {\n      this.dataArray[i] = i;\n    }\n  }\n\n  build() {\n    Stack() {\n      if (this.isGridShow) {\n        Grid() {\n          ForEach(this.dataArray, (item: number, index: number) => {\n            GridItem() {\n              Stack() {\n                Text((item + 1).toString())\n              }\n              .size({ width: 50, height: 50 })\n              .backgroundColor(ITEM_COLOR)\n              .transition(TransitionEffect.OPACITY\n                .combine(TransitionEffect.scale({ x: 0.5, y: 0.5 }))// 对每个方格的转场添加delay，实现组件的渐次出现消失效果\n                .animation({ duration: DURATION, curve: Curve.Friction, delay: INTERVAL * index }))\n              .borderRadius(10)\n            }\n            // 消失时，如果不对方格的所有父控件添加转场效果，则方格的消失转场不会生效\n            // 此处让方格的父控件在出现消失转场时一直以0.99的透明度显示，使得方格的转场效果不受影响\n            .transition(TransitionEffect.opacity(0.99))\n          }, (item: number) => item.toString())\n        }\n        .columnsTemplate('1fr 1fr 1fr')\n        .rowsGap(15)\n        .columnsGap(15)\n        .size({ width: 180, height: 180 })\n        // 消失时，如果不对方格的所有父控件添加转场效果，则方格的消失转场不会生效\n        // 此处让父控件在出现消失转场时一直以0.99的透明度显示，使得方格的转场效果不受影响\n        .transition(TransitionEffect.opacity(0.99))\n      }\n    }\n    .size({ width: '100%', height: '100%' })\n    .onClick(() => {\n      this.getUIContext()?.animateTo({\n        duration: DURATION + INTERVAL * (ITEM_COUNTS - 1),\n        curve: Curve.Friction\n      }, () => {\n        this.isGridShow = !this.isGridShow;\n      })\n    })\n  }\n}

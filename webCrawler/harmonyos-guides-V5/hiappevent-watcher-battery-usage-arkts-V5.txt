订阅24h功耗器件分解统计事件（ArkTS）
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
接口名
描述
addWatcher(watcher: Watcher): AppEventPackageHolder
添加应用事件观察者，以添加对应用事件的订阅。
removeWatcher(watcher: Watcher): void
移除应用事件观察者，以移除对应用事件的订阅。
开发步骤
以实现对应用内多线程执行耗时操作生成的24h功耗器件分解统计事件订阅为例，说明开发步骤。
 编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下： import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit';\n\nhiAppEvent.addWatcher({\n   // 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者\n   name: \"watcher\",\n   // 开发者可以订阅感兴趣的系统事件，此处是订阅了应用24h功耗器件分解统计事件\n   appEventFilters: [\n     {\n       domain: hiAppEvent.domain.OS,\n       names: [hiAppEvent.event.BATTERY_USAGE]\n     }\n   ],\n   // 开发者可以自行实现订阅实时回调函数，以便对订阅获取到的事件数据进行自定义处理\n   onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {\n     hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);\n     for (const eventGroup of appEventGroups) {\n       // 开发者可以根据事件集合中的事件名称区分不同的系统事件\n       hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);\n       for (const eventInfo of eventGroup.appEventInfos) {\n         // 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中\n         hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo=${JSON.stringify(eventInfo)}`);\n       }\n     }\n   }\n }); 工程中构造高耗电测试场景，并进行相关测试，使设备产生实际耗电，演示示例如下：          开发者自测试可跳过此步骤，仅需完成应用安装后并断开充电（充电状态下测试会导致无数据上报），使用应用5分钟以上。          1）工程中添加“entry > src > main > ets > workers> worker.ets”文件，构造一个死循环，接收到主线程的消息后触发CPU高负载事件，完整示例代码如下       import { worker } from '@kit.ArkTS';\n\nlet workerPort = worker.workerPort;\nworkerPort.onmessage = (message) => {\n  eatCpu();\n}\nfunction eatCpu(): void {\n  let val:number = 0;\n  while (true) {\n    val++; \n  }\n}         2）工程中添加“entry > src > main > ets > tester> CpuTester.ets”文件，在CpuTester 类中的start方法中开启多个线程的死循环，以触发多线程的CPU高负载事件，完整示例代码如下：       import { worker } from '@kit.ArkTS';\n\nexport default class CpuTester {\n  workerInstance: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/worker.ets');\n  start(threadNum: number) {\n    for (let index = 0; index < threadNum; index++) {\n      this.workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ets');\n      this.workerInstance.postMessage('msg');\n    }\n  }\n}         3）编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，添加“CPU加压”按钮并在其onClick函数构造多线程执行死循环，以触发CPU高负载事件，完整示例代码如下：       import CpuTester from '../tester/CpuTester';\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  @State enable: boolean = true;\n\n  @State threadNum: number = 5;\n\n  cpuTester: CpuTester = new CpuTester();\n\nbuild() {\n  Row() {\n    Column() {\n      Text(this.message)\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n      Button('CPU加压')\n        .fontSize(18)\n        .margin(12)\n        .fontWeight(FontWeight.Bold)\n        .enabled(this.enable)\n        .onClick(() => {\n          this.cpuTester.start(this.threadNum);\n          this.enable = false;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}  4）安装运行测试应用到测试机上，断开USB（2in1设备还需要断开充电线）； 5）打开测试应用，然后在应用界面中点击“CPU加压”按钮，持续十分钟，测试过程保持屏幕长亮。 测试完成后连接USB，0点后在Log窗口看到对系统事件数据的处理日志（快速触发上报方式：执行命令hdc shell hidumper -s 1213 -a '--test 1'，进入测试模式不进行时间跳变的校验，然后修改设备时间为下午的11点58分）：HiAppEvent onReceive: domain=OS\nHiAppEvent eventName=BATTERY_USAGE\nHiAppEvent eventInfo={\"domain\":\"OS\",\"name\":\"BATTERY_USAGE\",\"eventType\":2,\"params\":{\"audio_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"audio_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"background_usage\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"begin_time\":1709654400000,\"bundle_name\":\"com.example.myapplication\",\"bundle_version\":\"1.0.0\",\"cpu_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"cpu_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,125647],\"ddr_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"ddr_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,207],\"display_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"display_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8606],\"end_time\":1709740800000,\"foreground_usage\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67766],\"gpu_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"gpu_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48],\"modem_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"modem_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"others_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"others_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1170],\"rom_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"rom_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"time\":1709740801326,\"wifi_background_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\"wifi_foreground_energy\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}} 

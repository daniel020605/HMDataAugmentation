加解密(C/C++)
以AES 256密钥为例，完成加解密。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
在CMake脚本中链接相关动态库
target_link_libraries(entry PUBLIC libhuks_ndk.z.so)
开发步骤
生成密钥
 指定密钥别名。 初始化密钥属性集。 调用OH_Huks_GenerateKeyItem生成密钥，具体请参考密钥生成。 
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
加密
 获取密钥别名。 获取待加密的数据。 调用OH_Huks_InitParamSet指定算法参数配置。 在下方示例中，使用算法AES进行加密时，必须要选择其对应分组模式以及填充模式，用例中选取的分组模式为CBC、填充模式为PKCS7，此时必须要填参数IV。 调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。 调用OH_Huks_FinishSession结束密钥会话，获取加密后的密文。 
解密
 获取密钥别名。 获取待解密的密文。 调用OH_Huks_InitParamSet指定算法参数配置。 在下方示例中，使用算法AES进行解密时，必须要选择其对应分组模式以及填充模式，用例中选取的分组模式为CBC、填充模式为PKCS7，此时必须要填参数IV。 调用OH_Huks_InitSession初始化密钥会话，并获取会话的句柄handle。 调用OH_Huks_FinishSession结束密钥会话，获取解密后的数据。 
删除密钥
当密钥废弃不用时，需要调用OH_Huks_DeleteKeyItem删除密钥，具体请参考密钥删除。
#include \"huks/native_huks_api.h\"\n#include \"huks/native_huks_param.h\"\n#include \"napi/native_api.h\"\n#include <string.h>\nOH_Huks_Result InitParamSet(\n    struct OH_Huks_ParamSet **paramSet,\n    const struct OH_Huks_Param *params,\n    uint32_t paramCount)\n{\n    OH_Huks_Result ret = OH_Huks_InitParamSet(paramSet);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    ret = OH_Huks_AddParams(*paramSet, params, paramCount);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        OH_Huks_FreeParamSet(paramSet);\n        return ret;\n    }\n    ret = OH_Huks_BuildParamSet(paramSet);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        OH_Huks_FreeParamSet(paramSet);\n        return ret;\n    }\n    return ret;\n}\nstatic const uint32_t IV_SIZE = 16;\nstatic uint8_t IV[IV_SIZE] = { 0 }; // this is a test value, for real use the iv should be different every time\nstatic struct OH_Huks_Param g_genEncDecParams[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_AES\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_ENCRYPT | OH_HUKS_KEY_PURPOSE_DECRYPT\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_AES_KEY_SIZE_256\n    }, {\n        .tag = OH_HUKS_TAG_PADDING,\n        .uint32Param = OH_HUKS_PADDING_NONE\n    }, {\n        .tag = OH_HUKS_TAG_BLOCK_MODE,\n        .uint32Param = OH_HUKS_MODE_CBC\n    }\n};\nstatic struct OH_Huks_Param g_encryptParams[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_AES\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_ENCRYPT\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_AES_KEY_SIZE_256\n    }, {\n        .tag = OH_HUKS_TAG_PADDING,\n        .uint32Param = OH_HUKS_PADDING_NONE\n    }, {\n        .tag = OH_HUKS_TAG_BLOCK_MODE,\n        .uint32Param = OH_HUKS_MODE_CBC\n    }, {\n        .tag = OH_HUKS_TAG_IV,\n        .blob = {\n            .size = IV_SIZE,\n            .data = (uint8_t *)IV // this is a test value, for real use the iv should be different every time \n        }\n    }\n};\nstatic struct OH_Huks_Param g_decryptParams[] = {\n    {\n        .tag = OH_HUKS_TAG_ALGORITHM,\n        .uint32Param = OH_HUKS_ALG_AES\n    }, {\n        .tag = OH_HUKS_TAG_PURPOSE,\n        .uint32Param = OH_HUKS_KEY_PURPOSE_DECRYPT\n    }, {\n        .tag = OH_HUKS_TAG_KEY_SIZE,\n        .uint32Param = OH_HUKS_AES_KEY_SIZE_256\n    }, {\n        .tag = OH_HUKS_TAG_PADDING,\n        .uint32Param = OH_HUKS_PADDING_NONE\n    }, {\n        .tag = OH_HUKS_TAG_BLOCK_MODE,\n        .uint32Param = OH_HUKS_MODE_CBC\n    }, {\n        .tag = OH_HUKS_TAG_IV,\n        .blob = {\n            .size = IV_SIZE,\n            .data = (uint8_t *)IV // this is a test value, for real use the iv should be different every time \n        }\n    }\n};\nstatic const uint32_t AES_COMMON_SIZE = 1024;\nOH_Huks_Result HksAesCipherTestEncrypt(\n        const struct OH_Huks_Blob *keyAlias,\n        const struct OH_Huks_ParamSet *encryptParamSet, const struct OH_Huks_Blob *inData, struct OH_Huks_Blob *cipherText)\n{\n    uint8_t handleE[sizeof(uint64_t)] = {0};\n    struct OH_Huks_Blob handleEncrypt = {sizeof(uint64_t), handleE};\n    OH_Huks_Result ret = OH_Huks_InitSession(keyAlias, encryptParamSet, &handleEncrypt, nullptr);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    ret = OH_Huks_FinishSession(&handleEncrypt, encryptParamSet, inData, cipherText);\n    return ret;\n}\nOH_Huks_Result HksAesCipherTestDecrypt(\n    const struct OH_Huks_Blob *keyAlias,\n    const struct OH_Huks_ParamSet *decryptParamSet, const struct OH_Huks_Blob *cipherText, struct OH_Huks_Blob *plainText,\n    const struct OH_Huks_Blob *inData)\n{\n    uint8_t handleD[sizeof(uint64_t)] = {0};\n    struct OH_Huks_Blob handleDecrypt = {sizeof(uint64_t), handleD};\n    OH_Huks_Result ret = OH_Huks_InitSession(keyAlias, decryptParamSet, &handleDecrypt, nullptr);\n    if (ret.errorCode != OH_HUKS_SUCCESS) {\n        return ret;\n    }\n    ret = OH_Huks_FinishSession(&handleDecrypt, decryptParamSet, cipherText, plainText);\n    return ret;\n}\nstatic napi_value EncDecKey(napi_env env, napi_callback_info info)\n{\n    char tmpKeyAlias[] = \"test_enc_dec\";\n    struct OH_Huks_Blob keyAlias = { (uint32_t)strlen(tmpKeyAlias), (uint8_t *)tmpKeyAlias };\n    struct OH_Huks_ParamSet *genParamSet = nullptr;\n    struct OH_Huks_ParamSet *encryptParamSet = nullptr;\n    struct OH_Huks_ParamSet *decryptParamSet = nullptr;\n    OH_Huks_Result ohResult;\n    do {\n        /* 1. Generate Key */\n        /*\n        * 模拟生成密钥场景\n        * 1.1. 确定密钥别名\n        */\n        /*\n        * 1.2. 获取生成密钥算法参数配置\n        */\n        ohResult = InitParamSet(&genParamSet, g_genEncDecParams, sizeof(g_genEncDecParams) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /*\n        * 1.3. 调用generateKeyItem\n        */\n        ohResult = OH_Huks_GenerateKeyItem(&keyAlias, genParamSet, nullptr);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 2. Encrypt */\n        /*\n        * 模拟加密场景\n        * 2.1. 获取密钥别名\n        */\n        /*\n        * 2.2. 获取待加密的数据\n        */\n        /*\n        * 2.3. 获取加密算法参数配置\n        */\n        ohResult = InitParamSet(&encryptParamSet, g_encryptParams, sizeof(g_encryptParams) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        char tmpInData[] = \"AES_ECB_INDATA_1\";\n        struct OH_Huks_Blob inData = { (uint32_t)strlen(tmpInData), (uint8_t *)tmpInData };\n        uint8_t cipher[AES_COMMON_SIZE] = {0};\n        struct OH_Huks_Blob cipherText = {AES_COMMON_SIZE, cipher};\n        /*\n        * 2.4. 调用initSession获取handle\n        */\n        /*\n        * 2.5. 调用finishSession获取加密后的密文\n        */\n        ohResult = HksAesCipherTestEncrypt(&keyAlias, encryptParamSet, &inData, &cipherText);\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        /* 3. Decrypt */\n        /*\n        * 模拟解密场景\n        * 3.1. 获取密钥别名\n        */\n        /*\n        * 3.2. 获取待解密的密文\n        */\n        /*\n        * 3.3. 获取解密算法参数配置\n        */\n        ohResult = InitParamSet(&decryptParamSet, g_decryptParams, sizeof(g_decryptParams) / sizeof(OH_Huks_Param));\n        if (ohResult.errorCode != OH_HUKS_SUCCESS) {\n            break;\n        }\n        uint8_t plain[AES_COMMON_SIZE] = {0};\n        struct OH_Huks_Blob plainText = {AES_COMMON_SIZE, plain};\n        /*\n        * 3.4. 调用initSession获取handle\n        */\n        /*\n        * 3.5. 调用finishSession获取解密后的数据\n        */\n        ohResult = HksAesCipherTestDecrypt(&keyAlias, decryptParamSet, &cipherText, &plainText, &inData);\n    } while (0);\n    /* 4. Delete Key */\n    /*\n    * 模拟删除密钥场景\n    * 4.1. 获取密钥别名\n    */\n    /*\n    * 4.2. 调用deleteKeyItem删除密钥    \n    */\n    (void)OH_Huks_DeleteKeyItem(&keyAlias, genParamSet);\n        \n    OH_Huks_FreeParamSet(&genParamSet);\n    OH_Huks_FreeParamSet(&encryptParamSet);\n    OH_Huks_FreeParamSet(&decryptParamSet);\n    \n    napi_value ret;\n    napi_create_int32(env, ohResult.errorCode, &ret);\n    return ret;\n}

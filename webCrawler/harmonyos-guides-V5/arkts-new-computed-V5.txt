@Computed装饰器：计算属性
@Computed装饰器：计算属性，在被计算的值变化的时候，只会计算一次。主要应用于解决UI多次重用该属性从而重复计算导致的性能问题。
状态变量的变化可以触发其关联@Computed的重新计算。在阅读本文档前，建议提前阅读：@ComponentV2，@ObservedV2和@Trace，@Local。
@Computed装饰器从API version 12开始支持。
概述
@Computed为方法装饰器，装饰getter方法。@Computed会检测被计算的属性变化，当被计算的属性变化时，@Computed只会被求解一次。
对于复杂的计算，@Computed会有性能收益。
装饰器说明
@Computed语法：
@Computed\nget varName(): T {\n    return value;\n}
使用限制
@Computed为方法装饰器，仅能装饰getter方法。 @Computed\nget fullName() { // 正确用法\n  return this.firstName + ' ' + this.lastName;\n}\n@Computed val: number = 0; // 错误用法，编译时报错\n@Computed\nfunc() { // 错误用法，编译时报错\n} 在@Computed装饰的getter方法中，不能改变参与计算的属性。 @Computed\nget fullName() {\n  this.lastName += 'a'; // 错误，不能改变参与计算的属性\n  return this.firstName + ' ' + this.lastName;\n} @Computed不能和双向绑定!!连用，@Computed装饰的是getter访问器，不会被子组件同步，也不能被赋值。开发者自己实现的计算属性的setter不生效，且产生编译时报错。 @ComponentV2\nstruct Child {\n  @Param double: number = 100;\n  @Event $double: (val: number) => void;\n\n  build() {\n    Button('ChildChange')\n      .onClick(() => {\n        this.$double(200);\n      })\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  @Local count: number = 100;\n\n  @Computed\n  get double() {\n    return this.count * 2;\n  }\n\n  // @Computed装饰的属性是只读的，开发者自己实现的setter不生效，且产生编译时报错\n  set double(newValue : number) {\n    this.count = newValue / 2;\n  }\n\n  build() {\n    Scroll() {\n      Column({ space: 3 }) {\n        Text(`${this.count}`)\n        // 错误写法，@Computed装饰的属性方法是只读的，无法和双向绑定连用\n        Child({ double: this.double!! })\n      }\n    }\n  }\n} @Computed为状态管理V2提供的能力，只能在@ComponentV2和@ObservedV2中使用。 多个@Computed一起使用时，警惕循环求解。 @Local a : number = 1;\n@Computed\nget b() {\n  return this.a + ' ' + this.c;  // 错误写法，存在循环b -> c -> b\n}\n@Computed\nget c() {\n  return this.a + ' ' + this.b; // 错误写法，存在循环c -> b -> c\n} 
使用场景
[h2]当被计算的属性变化时，@Computed装饰的getter访问器只会被求解一次
在自定义组件中使用计算属性。
点击第一个Button改变lastName，触发@Computed fullName重新计算。this.fullName被绑定在两个Text组件上，观察fullName日志，可以发现，计算只发生了一次。对于前两个Text组件，this.lastName + ' '+ this.firstName这段逻辑被求解了两次。如果UI中有多处需要使用this.lastName + ' '+ this.firstName这段计算逻辑，可以使用计算属性，减少计算次数。点击第二个Button，age自增，UI无变化。因为age非状态变量，只有被观察到的变化才会触发@Computed fullName重新计算。
@Entry\n@ComponentV2\nstruct Index {\n  @Local firstName: string = 'Li';\n  @Local lastName: string = 'Hua';\n  age: number = 20; // 无法触发Computed\n\n  @Computed\n  get fullName() {\n    console.info(\"---------Computed----------\");\n    return this.firstName + ' ' + this.lastName + this.age;\n  }\n\n  build() {\n    Column() {\n      Text(this.lastName + ' ' + this.firstName)\n      Text(this.lastName + ' ' + this.firstName)\n      Divider()\n      Text(this.fullName)\n      Text(this.fullName)\n      Button('changed lastName').onClick(() => {\n        this.lastName += 'a';\n      })\n\n      Button('changed age').onClick(() => {\n        this.age++;  // 无法触发Computed\n      })\n    }\n  }\n}
但是需要注意，计算属性本身是有性能开销的，实际应用开发中：
如果是上面这种简单计算，可以不使用计算属性。如果在视图中只使用一次，也可以不使用计算属性，建议直接求解。
在@ObservedV2装饰的类中使用计算属性。
点击Button改变lastName，触发@Computed fullName重新计算，且只被计算一次。
@ObservedV2\nclass Name {\n  @Trace firstName: string = 'Li';\n  @Trace lastName: string = 'Hua';\n\n  @Computed\n  get fullName() {\n    console.info('---------Computed----------');\n    return this.firstName + ' ' + this.lastName;\n  }\n}\n\nconst name: Name = new Name();\n\n@Entry\n@ComponentV2\nstruct Index {\n  name1: Name = name;\n\n  build() {\n    Column() {\n      Text(this.name1.fullName)\n      Text(this.name1.fullName)\n      Button('changed lastName').onClick(() => {\n        this.name1.lastName += 'a';\n      })\n    }\n  }\n}
[h2]@Computed装饰的属性可以被@Monitor监听变化
下面的例子展示了使用计算属性求解fahrenheit和kelvin。
点击“-”，celsius-- -> fahrenheit -> kelvin --> kelvin改变触发onKelvinMonitor。点击“+”，celsius++ -> fahrenheit -> kelvin --> kelvin改变触发onKelvinMonitor。
@Entry\n@ComponentV2\nstruct MyView {\n  @Local celsius: number = 20;\n\n  @Computed\n  get fahrenheit(): number {\n    return this.celsius * 9 / 5 + 32; // C -> F\n  }\n\n  @Computed\n  get kelvin(): number {\n    return (this.fahrenheit - 32) * 5 / 9 + 273.15; // F -> K\n  }\n\n  @Monitor(\"kelvin\")\n  onKelvinMonitor(mon: IMonitor) {\n    console.log(\"kelvin changed from \" + mon.value()?.before + \" to \" + mon.value()?.now);\n  }\n\n  build() {\n    Column({ space: 20 }) {\n      Row({ space: 20 }) {\n        Button('-')\n          .onClick(() => {\n            this.celsius--;\n          })\n\n        Text(`Celsius ${this.celsius.toFixed(1)}`).fontSize(50)\n\n        Button('+')\n          .onClick(() => {\n            this.celsius++;\n          })\n      }\n\n      Text(`Fahrenheit ${this.fahrenheit.toFixed(2)}`).fontSize(50)\n      Text(`Kelvin ${this.kelvin.toFixed(2)}`).fontSize(50)\n    }\n    .width('100%')\n  }\n}
[h2]@Computed装饰的属性可以初始化@Param
下面的例子展示了@Computed初始@Param。
点击Button('-')和Button('+')改变商品数量，quantity是被@Trace装饰的，其改变时可以被观察到的。quantity的改变触发total和qualifiesForDiscount重新计算，计算商品总价和是否可以享有优惠。total和qualifiesForDiscount的改变触发子组件Child对应Text组件刷新。
@ObservedV2\nclass Article {\n  @Trace quantity: number = 0;\n  unitPrice: number = 0;\n\n  constructor(quantity: number, unitPrice: number) {\n    this.quantity = quantity;\n    this.unitPrice = unitPrice;\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  @Local shoppingBasket: Article[] = [new Article(1, 20), new Article(5, 2)];\n\n  @Computed\n  get total(): number {\n    return this.shoppingBasket.reduce((acc: number, item: Article) => acc + (item.quantity * item.unitPrice), 0);\n  }\n\n  @Computed\n  get qualifiesForDiscount(): boolean {\n    return this.total >= 100;\n  }\n\n  build() {\n    Column() {\n      Text(`Shopping List: `).fontSize(30)\n      ForEach(this.shoppingBasket, (item: Article) => {\n        Row() {\n          Text(`unitPrice: ${item.unitPrice}`)\n          Button('-').onClick(() => {\n            if (item.quantity > 0) {\n              item.quantity--;\n            }\n          })\n          Text(`quantity: ${item.quantity}`)\n          Button('+').onClick(() => {\n            item.quantity++;\n          })\n        }\n\n        Divider()\n      })\n      Child({ total: this.total, qualifiesForDiscount: this.qualifiesForDiscount })\n    }.alignItems(HorizontalAlign.Start)\n  }\n}\n\n@ComponentV2\nstruct Child {\n  @Param total: number = 0;\n  @Param qualifiesForDiscount: boolean = false;\n\n  build() {\n    Row() {\n      Text(`Total: ${this.total} `).fontSize(30)\n      Text(`Discount: ${this.qualifiesForDiscount} `).fontSize(30)\n    }\n  }\n}

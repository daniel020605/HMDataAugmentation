音频解码
开发者可以调用本模块的Native API接口，完成音频解码，即将媒体数据解码为PCM码流。
当前支持的解码能力请参考AVCodec支持的格式。
适用场景
 音频播放 在播放音频之前，需要先解码音频，再将数据输送到硬件扬声器播放。 音频渲染 在对音频文件进行音效处理之前，需要先解码再由音频处理模块进行音频渲染。 音频编辑 音频编辑（如调整单个声道的播放倍速等）需要基于PCM码流进行，所以需要先将音频文件解码。 
通过MP3音频编码流程生成的码流无法直接通过MP3音频解码流程进行解码。建议通过（PCM码流->MP3音频编码->封装->解封装->MP3音频解码）流程进行。
开发指导
详细的API说明请参考API文档。
参考以下示例代码，完成音频解码的全流程，包括：创建解码器、设置解码参数（采样率/码率/声道数等）、开始、刷新、重置、销毁资源。
在应用开发过程中，开发者应按一定顺序调用方法，执行对应操作，否则系统可能会抛出异常或生成其他未定义的行为。具体顺序可参考下列开发步骤及对应说明。
如下为音频解码调用关系图：
 虚线表示可选。 实线表示必选。 
[h2]在 CMake 脚本中链接动态库
target_link_libraries(sample PUBLIC libnative_media_codecbase.so)\ntarget_link_libraries(sample PUBLIC libnative_media_core.so)\ntarget_link_libraries(sample PUBLIC libnative_media_acodec.so)
[h2]开发步骤
 添加头文件。 #include <multimedia/player_framework/native_avcodec_audiocodec.h>\n#include <multimedia/native_audio_channel_layout.h>\n#include <multimedia/player_framework/native_avcapability.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h> 创建解码器实例对象，OH_AVCodec *为解码器实例指针。 //c++标准库命名空间\nusing namespace std;\n// 通过 codec name 创建解码器\nOH_AVCapability *capability = OH_AVCodec_GetCapability(OH_AVCODEC_MIMETYPE_AUDIO_MPEG, false);\nconst char *name = OH_AVCapability_GetName(capability);\nOH_AVCodec *audioDec_ = OH_AudioCodec_CreateByName(name); // 设置判定是否为编码；设置false表示当前是解码。\nbool isEncoder = false;\n// 通过 Mimetype 创建解码器\nOH_AVCodec *audioDec_ = OH_AudioCodec_CreateByMime(OH_AVCODEC_MIMETYPE_AUDIO_MPEG, isEncoder); // 初始化队列\nclass ADecBufferSignal {\npublic:\n    std::mutex inMutex_;\n    std::mutex outMutex_;\n    std::mutex startMutex_;\n    std::condition_variable inCond_;\n    std::condition_variable outCond_;\n    std::condition_variable startCond_;\n    std::queue<uint32_t> inQueue_;\n    std::queue<uint32_t> outQueue_;\n    std::queue<OH_AVBuffer *> inBufferQueue_;\n    std::queue<OH_AVBuffer *> outBufferQueue_;\n};\nADecBufferSignal *signal_; 调用OH_AudioCodec_RegisterCallback()注册回调函数。 注册回调函数指针集合OH_AVCodecCallback，包括：  OH_AVCodecOnError：解码器运行错误。 OH_AVCodecOnStreamChanged：码流信息变化，如声道变化等。 OH_AVCodecOnNeedInputBuffer：运行过程中需要新的输入数据，即解码器已准备好，可以输入数据。 OH_AVCodecOnNewOutputBuffer：运行过程中产生了新的输出数据，即解码完成。  开发者可以通过处理该回调报告的信息，确保解码器正常运转。     回调中不建议进行耗时操作。   // OH_AVCodecOnError回调函数的实现\nstatic void OnError(OH_AVCodec *codec, int32_t errorCode, void *userData)\n{\n    (void)codec;\n    (void)errorCode;\n    (void)userData;\n}\n// OH_AVCodecOnStreamChanged回调函数的实现\nstatic void OnOutputFormatChanged(OH_AVCodec *codec, OH_AVFormat *format, void *userData)\n{\n    (void)codec;\n    (void)format;\n    (void)userData;\n}\n// OH_AVCodecOnNeedInputBuffer回调函数的实现\nstatic void OnInputBufferAvailable(OH_AVCodec *codec, uint32_t index, OH_AVBuffer *data, void *userData)\n{\n    (void)codec;\n    ADecBufferSignal *signal = static_cast<ADecBufferSignal *>(userData);\n    unique_lock<mutex> lock(signal->inMutex_);\n    signal->inQueue_.push(index);\n    signal->inBufferQueue_.push(data);\n    signal->inCond_.notify_all();\n    // 解码输入码流送入inBufferQueue_队列\n}\n// OH_AVCodecOnNewOutputBuffer回调函数的实现\nstatic void OnOutputBufferAvailable(OH_AVCodec *codec, uint32_t index, OH_AVBuffer *data, void *userData)\n{\n    (void)codec;\n    ADecBufferSignal *signal = static_cast<ADecBufferSignal *>(userData);\n    unique_lock<mutex> lock(signal->outMutex_);\n    signal->outQueue_.push(index);\n    signal->outBufferQueue_.push(data);\n    signal->outCond_.notify_all();\n    // 将对应输出buffer的 index 送入outQueue_队列\n    // 将对应解码完成的数据data送入outBufferQueue_队列\n}\nsignal_ = new ADecBufferSignal();\nOH_AVCodecCallback cb_ = {&OnError, &OnOutputFormatChanged, &OnInputBufferAvailable, &OnOutputBufferAvailable};\nint32_t ret = OH_AudioCodec_RegisterCallback(audioDec_, cb_, signal_);\nif (ret != AVCS_ERR_OK) {\n    // 异常处理\n} （可选）OH_AudioCodec_SetDecryptionConfig设置解密配置。 当获取到DRM信息(参考音视频解封装开发步骤第4步)后，通过此接口进行解密配置。 DRM相关接口详见DRM API文档。 此接口需在Prepare前调用。 添加头文件: #include <multimedia/drm_framework/native_mediakeysystem.h>\n#include <multimedia/drm_framework/native_mediakeysession.h>\n#include <multimedia/drm_framework/native_drm_err.h>\n#include <multimedia/drm_framework/native_drm_common.h> 在 CMake 脚本中链接动态库: target_link_libraries(sample PUBLIC libnative_drm.so) 使用示例: // 根据DRM信息创建指定的DRM系统, 以创建\"com.wiseplay.drm\"为例\nMediaKeySystem *system = nullptr;\nint32_t ret = OH_MediaKeySystem_Create(\"com.wiseplay.drm\", &system);\nif (system == nullptr) {\n    printf(\"create media key system failed\");\n    return;\n}\n\n// 创建解密会话\nMediaKeySession *session = nullptr;\nDRM_ContentProtectionLevel contentProtectionLevel = CONTENT_PROTECTION_LEVEL_SW_CRYPTO;\nret = OH_MediaKeySystem_CreateMediaKeySession(system, &contentProtectionLevel, &session);\nif (ret != DRM_OK) {\n    // 如创建失败，请查看DRM接口文档及日志信息\n    printf(\"create media key session failed.\");\n    return;\n}\nif (session == nullptr) {\n    printf(\"media key session is nullptr.\");\n    return;\n}\n// 获取许可证请求、设置许可证响应等\n// 设置解密配置, 即将解密会话、安全通路标志(当前音频解密不支持安全通路，应设置为false)设置到解码器中。\nbool secureAudio = false;\nret = OH_AudioCodec_SetDecryptionConfig(audioDec_, session, secureAudio); 调用OH_AudioCodec_Configure()配置解码器。 配置选项key值说明：     key 描述 AAC Flac Vorbis MPEG G711mu AMR(amrnb、amrwb) APE    OH_MD_KEY_AUD_SAMPLE_RATE 采样率 必须 必须 必须 必须 必须 必须 必须   OH_MD_KEY_AUD_CHANNEL_COUNT 声道数 必须 必须 必须 必须 必须 必须 必须   OH_MD_KEY_MAX_INPUT_SIZE 最大输入长度 可选 可选 可选 可选 可选 可选 可选   OH_MD_KEY_AAC_IS_ADTS 是否adts 可选，默认1 - - - - - -   OH_MD_KEY_AUDIO_SAMPLE_FORMAT 输出音频流格式 可选（SAMPLE_S16LE，SAMPLE_F32LE） 可选 可选（SAMPLE_S16LE，SAMPLE_F32LE） 可选 可选（默认SAMPLE_S16LE） 可选（SAMPLE_S16LE，SAMPLE_F32LE） 可选   OH_MD_KEY_BITRATE 码率 可选 可选 可选 可选 可选 可选 可选   OH_MD_KEY_IDENTIFICATION_HEADER ID Header - - 必须（和Codec_Config二选一） - - - -   OH_MD_KEY_SETUP_HEADER Setup Header - - 必须（和Codec_Config二选一） - - - -   OH_MD_KEY_CODEC_CONFIG 编解码器特定数据 可选 - 必须（和上述ID和Setup二选一） - - - 可选    各音频解码类型参数范围说明：     音频解码类型 采样率(Hz) 声道数    AAC 8000、11025、12000、16000、22050、24000、32000、44100、48000、64000、88200、96000 1~8   Flac 8000、11025、12000、16000、22050、24000、32000、44100、48000、64000、88200、96000、192000 1~8   Vorbis 8000、11025、12000、16000、22050、24000、32000、44100、48000、64000、88200、96000、176400、192000 1~8   MPEG(MP3) 8000、11025、12000、16000、22050、24000、32000、44100、48000 1~2   G711mu 8000 1   AMR(amrnb) 8000 1   AMR(amrwb) 16000 1   APE 8000、11025、12000、16000、22050、24000、32000、44100、48000、64000、88200、96000、176400、192000 1~2   Opus 8000、12000、16000、24000、48000 1~2   AudioVivid 32000、44100、48000、96000、192000 1~16    // 设置解码分辨率\nint32_t ret;\n// 配置音频采样率（必须）\nconstexpr uint32_t DEFAULT_SAMPLERATE = 44100;\n// 配置音频码率（可选）\nconstexpr uint32_t DEFAULT_BITRATE = 32000;\n// 配置音频声道数（必须）\nconstexpr uint32_t DEFAULT_CHANNEL_COUNT = 2;\n// 配置最大输入长度（可选）\nconstexpr uint32_t DEFAULT_MAX_INPUT_SIZE = 1152;\n// 配置是否为ADTS解码（aac解码时可选）\nconstexpr uint32_t DEFAULT_AAC_TYPE = 1;\nOH_AVFormat *format = OH_AVFormat_Create();\n// 写入format\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_AUD_SAMPLE_RATE, DEFAULT_SAMPLERATE);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_BITRATE, DEFAULT_BITRATE);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_AUD_CHANNEL_COUNT, DEFAULT_CHANNEL_COUNT);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_MAX_INPUT_SIZE, DEFAULT_MAX_INPUT_SIZE);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_AAC_IS_ADTS, DEFAULT_AAC_TYPE);\n// 配置解码器\nret = OH_AudioCodec_Configure(audioDec_, format);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_AudioCodec_Prepare()，解码器就绪。 ret = OH_AudioCodec_Prepare(audioDec_);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_AudioCodec_Start()启动解码器，进入运行态。 unique_ptr<ifstream> inputFile_ = make_unique<ifstream>();\nunique_ptr<ofstream> outFile_ = make_unique<ofstream>();\n// 打开待解码二进制文件路径\ninputFile_->open(inputFilePath.data(), ios::in | ios::binary); \n// 配置解码文件输出路径\noutFile_->open(outputFilePath.data(), ios::out | ios::binary);\n// 开始解码\nret = OH_AudioCodec_Start(audioDec_);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} （可选）调用OH_AVCencInfo_SetAVBuffer()，设置cencInfo。 若当前播放的节目是DRM加密节目，且由上层应用做媒体解封装，则须调用OH_AVCencInfo_SetAVBuffer()将cencInfo设置给AVBuffer，以实现AVBuffer中媒体数据的解密。 添加头文件： #include <multimedia/player_framework/native_cencinfo.h> 在 CMake 脚本中链接动态库： target_link_libraries(sample PUBLIC libnative_media_avcencinfo.so) 使用示例： auto buffer = signal_->inBufferQueue_.front();\nuint32_t keyIdLen = DRM_KEY_ID_SIZE;\nuint8_t keyId[] = {\n    0xd4, 0xb2, 0x01, 0xe4, 0x61, 0xc8, 0x98, 0x96,\n    0xcf, 0x05, 0x22, 0x39, 0x8d, 0x09, 0xe6, 0x28};\nuint32_t ivLen = DRM_KEY_IV_SIZE;\nuint8_t iv[] = {\n    0xbf, 0x77, 0xed, 0x51, 0x81, 0xde, 0x36, 0x3e,\n    0x52, 0xf7, 0x20, 0x4f, 0x72, 0x14, 0xa3, 0x95};\nuint32_t encryptedBlockCount = 0;\nuint32_t skippedBlockCount = 0;\nuint32_t firstEncryptedOffset = 0;\nuint32_t subsampleCount = 1;\nDrmSubsample subsamples[1] = { {0x10, 0x16} };\n// 创建CencInfo实例\nOH_AVCencInfo *cencInfo = OH_AVCencInfo_Create();\nif (cencInfo == nullptr) {\n    // 异常处理\n}\n// 设置解密算法\nOH_AVErrCode errNo = OH_AVCencInfo_SetAlgorithm(cencInfo, DRM_ALG_CENC_AES_CTR);\nif (errNo != AV_ERR_OK) {\n    // 异常处理\n}\n// 设置KeyId和Iv\nerrNo = OH_AVCencInfo_SetKeyIdAndIv(cencInfo, keyId, keyIdLen, iv, ivLen);\nif (errNo != AV_ERR_OK) {\n    // 异常处理\n}\n// 设置Sample信息\nerrNo = OH_AVCencInfo_SetSubsampleInfo(cencInfo, encryptedBlockCount, skippedBlockCount, firstEncryptedOffset,\n    subsampleCount, subsamples);\nif (errNo != AV_ERR_OK) {\n    // 异常处理\n}\n// 设置模式：KeyId、Iv和SubSamples已被设置\nerrNo = OH_AVCencInfo_SetMode(cencInfo, DRM_CENC_INFO_KEY_IV_SUBSAMPLES_SET);\nif (errNo != AV_ERR_OK) {\n    // 异常处理\n}\n// 将CencInfo设置到AVBuffer中\nerrNo = OH_AVCencInfo_SetAVBuffer(cencInfo, buffer);\nif (errNo != AV_ERR_OK) {\n    // 异常处理\n}\n// 销毁CencInfo实例\nerrNo = OH_AVCencInfo_Destroy(cencInfo);\nif (errNo != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_AudioCodec_PushInputBuffer()，写入待解码的数据。 需开发者填充完整的输入数据后调用。 如果是结束，需要对flags标识成AVCODEC_BUFFER_FLAGS_EOS。 uint32_t index = signal_->inQueue_.front();\nauto buffer = signal_->inBufferQueue_.front();\nint64_t size;\nint64_t pts;\n// size是待解码数据的每帧帧长度。pts是每帧的时间戳，用于指示音频应该何时被播放。\n// size和pts的获取来源：音视频资源文件或者待解码的数据流\n// 若是解码音视频资源文件，则需从解封装OH_AVDemuxer_ReadSampleBuffer的buffer中获取\n// 若是解码数据流，则需要从数据流的提供者获取。\n// 此处为了介绍解码功能以测试文件中保存的size和pts为示例\ninputFile_.read(reinterpret_cast<char *>(&size), sizeof(size));\ninputFile_.read(reinterpret_cast<char *>(&pts), sizeof(pts));\ninputFile_.read((char *)OH_AVBuffer_GetAddr(buffer), size);\nOH_AVCodecBufferAttr attr = {0};\nif (inputFile_->eof()) {\n    attr.size = 0;\n    attr.flags = AVCODEC_BUFFER_FLAGS_EOS;\n} else {\n    attr.size = size;\n    attr.flags = AVCODEC_BUFFER_FLAGS_NONE;\n}\nattr.pts = pts;\nOH_AVBuffer_SetBufferAttr(buffer, &attr);\nint32_t ret = OH_AudioCodec_PushInputBuffer(audioDec_, index);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_AudioCodec_FreeOutputBuffer()，释放解码后的数据。 在取走解码PCM码流后，就应及时调用OH_AudioCodec_FreeOutputBuffer()进行释放。 从API version 11开始，Audio Vivid新增获取获取元数据。 uint32_t index = signal_->outQueue_.front();\nOH_AVBuffer *data = signal_->outBufferQueue_.front();\n// 获取buffer attributes\nOH_AVCodecBufferAttr attr = {0};\nret = OH_AVBuffer_GetBufferAttr(data, &attr);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\n// 将解码完成数据data写入到对应输出文件中\npcmOutputFile_.write(reinterpret_cast<char *>(OH_AVBuffer_GetAddr(data)), attr.size);\n\n// API version 11开始提供 获取audio vivid 元数据\nOH_AVFormat * format = OH_AVBuffer_GetParameter(data);\nuint8_t *metadata = nullptr;\nsize_t metaSize;\nOH_AVFormat_GetBuffer(format,OH_MD_KEY_AUDIO_VIVID_METADATA,&metadata,&metaSize);\n\nret = OH_AudioCodec_FreeOutputBuffer(audioDec_, index);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\nif (attr.flags == AVCODEC_BUFFER_FLAGS_EOS) {\n    // 结束\n} （可选）调用OH_AudioCodec_Flush()刷新解码器。 调用OH_AudioCodec_Flush()后，解码器仍处于运行态，但会将当前队列清空，将已解码的数据释放。 此时需要调用OH_AudioCodec_Start()重新开始解码。 使用情况：  在文件EOS之后，需要调用刷新。 在执行过程中遇到可继续执行的错误时（即OH_AudioCodec_IsValid 为true）调用。  // 刷新解码器 audioDec_\nret = OH_AudioCodec_Flush(audioDec_);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\n// 重新开始解码\nret = OH_AudioCodec_Start(audioDec_);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} （可选）调用OH_AudioCodec_Reset()重置解码器。 调用OH_AudioCodec_Reset()后，解码器回到初始化的状态，需要调用OH_AudioCodec_Configure()重新配置，然后调用OH_AudioCodec_Start()重新开始解码。 // 重置解码器 audioDec_\nret = OH_AudioCodec_Reset(audioDec_);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\n// 重新配置解码器参数\nret = OH_AudioCodec_Configure(audioDec_, format);\nif (ret != AV_ERR_OK) {\n// 异常处理\n} 调用OH_AudioCodec_Stop()停止解码器。 停止后，可以通过调用OH_AudioCodec_Start()重新进入已启动状态（started），但需要注意的是，如果编解码器之前已输入数据，则需要重新输入编解码器数据。 // 终止解码器 audioDec_\nret = OH_AudioCodec_Stop(audioDec_);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_AudioCodec_Destroy()销毁解码器实例，释放资源。     不要重复销毁解码器   // 调用OH_AudioCodec_Destroy, 注销解码器\nret = OH_AudioCodec_Destroy(audioDec_);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} else {\n    audioDec_ = NULL; // 不可重复destroy\n} 

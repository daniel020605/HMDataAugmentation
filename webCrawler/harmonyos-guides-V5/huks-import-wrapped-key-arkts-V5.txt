加密导入密钥(ArkTS)
以加密导入ECDH密钥对为例，涉及业务侧加密密钥的密钥生成、协商等操作不在本示例中体现。
具体的场景介绍及支持的算法规格，请参考密钥导入的支持的算法。
开发步骤
 设备A（导入设备）将待导入密钥转换成HUKS密钥材料格式To_Import_Key（仅针对非对称密钥，若待导入密钥是对称密钥则可省略此步骤）。 设备B（被导入设备）生成一个加密导入用途的、用于协商的非对称密钥对Wrapping_Key（公钥Wrapping_Pk，私钥Wrapping_Sk），其密钥用途设置为unwrap，导出Wrapping_Key的公钥材料Wrapping_Pk并保存。 设备A使用和设备B同样的算法，生成一个加密导入用途的、用于协商的非对称密钥对Caller_Key（公钥Caller_Pk，私钥Caller_Sk），导出Caller_Key的公钥材料Caller_Pk并保存。 设备A生成一个对称密钥Caller_Kek，该密钥后续将用于加密To_Import_Key。 设备A基于Caller_Key的私钥Caller_Sk和设备B Wrapping_Key的公钥Wrapping_Pk，协商出Shared_Key。 设备A使用Caller_Kek加密To_Import_Key，生成To_Import_Key_Enc。 设备A使用Shared_Key加密Caller_Kek，生成Caller_Kek_Enc。 设备A封装Caller_Pk、Caller_Kek_Enc、To_Import_Key_Enc等加密导入的密钥材料并发送给设备B，加密导入密钥材料格式见加密导入密钥材料格式。 设备B导入封装的加密密钥材料。 设备A、B删除用于加密导入的密钥。 
import { huks } from '@kit.UniversalKeystoreKit';\n\nlet IV = '0000000000000000';\nlet AAD = \"abababababababab\";\nlet NONCE = \"hahahahahaha\";\nlet TAG_SIZE = 16;\nlet FILED_LENGTH = 4;\nlet importedAes192PlainKey = \"The aes192 key to import\";\nlet callerAes256Kek = \"The is kek to encrypt aes192 key\";\nlet callerKeyAlias = \"test_caller_key_ecdh_aes192\";\nlet callerKekAliasAes256 = \"test_caller_kek_ecdh_aes256\";\nlet callerAgreeKeyAliasAes256 = \"test_caller_agree_key_ecdh_aes256\";\nlet importedKeyAliasAes192 = \"test_import_key_ecdh_aes192\";\nlet huksPubKey: Uint8Array;\nlet callerSelfPublicKey: Uint8Array;\nlet outSharedKey: Uint8Array;\nlet outPlainKeyEncData: Uint8Array;\nlet outKekEncData: Uint8Array;\nlet outKekEncTag: Uint8Array;\nlet outAgreeKeyEncTag: Uint8Array;\nlet mask = [0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000];\n\nfunction subUint8ArrayOf(arrayBuf: Uint8Array, start: number, end: number) {\n  let arr: number[] = [];\n  for (let i = start; i < end && i < arrayBuf.length; ++i) {\n    arr.push(arrayBuf[i]);\n  }\n  return new Uint8Array(arr);\n}\n\nfunction stringToUint8Array(str: string) {\n  let arr: number[] = [];\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  return new Uint8Array(arr);\n}\n\nfunction assignLength(length: number, arrayBuf: Uint8Array, startIndex: number) {\n  let index = startIndex;\n  for (let i = 0; i < 4; i++) {\n    arrayBuf[index++] = (length & mask[i]) >> (i * 8);\n  }\n  return 4;\n}\n\nfunction assignData(data: Uint8Array, arrayBuf: Uint8Array, startIndex: number) {\n  let index = startIndex;\n  for (let i = 0; i < data.length; i++) {\n    arrayBuf[index++] = data[i];\n  }\n  return data.length;\n}\n\nlet genWrappingKeyParams: huks.HuksOptions = {\n  properties: new Array<huks.HuksParam>(\n    {\n      tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n      value: huks.HuksKeyAlg.HUKS_ALG_ECC\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n      value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_UNWRAP\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n      value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PADDING,\n      value: huks.HuksKeyPadding.HUKS_PADDING_NONE\n    }\n  )\n}\nlet genCallerEcdhParams: huks.HuksOptions = {\n  properties: new Array<huks.HuksParam>(\n    {\n      tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n      value: huks.HuksKeyAlg.HUKS_ALG_ECC\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n      value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n      value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256\n    }\n  )\n}\nlet importParamsCallerKek: huks.HuksOptions = {\n  properties: new Array<huks.HuksParam>(\n    {\n      tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n      value: huks.HuksKeyAlg.HUKS_ALG_AES\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n      value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n      value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PADDING,\n      value: huks.HuksKeyPadding.HUKS_PADDING_NONE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n      value: huks.HuksCipherMode.HUKS_MODE_GCM\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_DIGEST,\n      value: huks.HuksKeyDigest.HUKS_DIGEST_NONE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_IV,\n      value: stringToUint8Array(IV)\n    }\n  ),\n  inData: stringToUint8Array(callerAes256Kek)\n}\nlet importParamsAgreeKey: huks.HuksOptions = {\n  properties: new Array<huks.HuksParam>(\n    {\n      tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n      value: huks.HuksKeyAlg.HUKS_ALG_AES\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n      value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n      value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PADDING,\n      value: huks.HuksKeyPadding.HUKS_PADDING_NONE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n      value: huks.HuksCipherMode.HUKS_MODE_GCM\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_DIGEST,\n      value: huks.HuksKeyDigest.HUKS_DIGEST_NONE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_IV,\n      value: stringToUint8Array(IV)\n    }\n  ),\n}\nlet callerAgreeParams: huks.HuksOptions = {\n  properties: new Array<huks.HuksParam>(\n    {\n      tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n      value: huks.HuksKeyAlg.HUKS_ALG_ECDH\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n      value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n      value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256\n    }\n  )\n}\nlet encryptKeyCommonParams: huks.HuksOptions = {\n  properties: new Array<huks.HuksParam>(\n    {\n      tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n      value: huks.HuksKeyAlg.HUKS_ALG_AES\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n      value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n      value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PADDING,\n      value: huks.HuksKeyPadding.HUKS_PADDING_NONE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n      value: huks.HuksCipherMode.HUKS_MODE_GCM\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_NONCE,\n      value: stringToUint8Array(NONCE)\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_ASSOCIATED_DATA,\n      value: stringToUint8Array(AAD)\n    }\n  ),\n}\nlet importWrappedAes192Params: huks.HuksOptions = {\n  properties: new Array<huks.HuksParam>(\n    {\n      tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n      value: huks.HuksKeyAlg.HUKS_ALG_AES\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n      value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |\n      huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n      value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_192\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_PADDING,\n      value: huks.HuksKeyPadding.HUKS_PADDING_NONE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n      value: huks.HuksCipherMode.HUKS_MODE_CBC\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_DIGEST,\n      value: huks.HuksKeyDigest.HUKS_DIGEST_NONE\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_UNWRAP_ALGORITHM_SUITE,\n      value: huks.HuksUnwrapSuite.HUKS_UNWRAP_SUITE_ECDH_AES_256_GCM_NOPADDING\n    },\n    {\n      tag: huks.HuksTag.HUKS_TAG_IV,\n      value: stringToUint8Array(IV)\n    }\n  )\n}\n\nasync function publicGenerateItemFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise generateKeyItem`);\n  try {\n    await huks.generateKeyItem(keyAlias, huksOptions)\n      .then(data => {\n        console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((err: Error) => {\n        console.error(`promise: generateKeyItem failed, ${JSON.stringify(err)}`);\n      })\n  } catch (err) {\n    console.error(`promise: generateKeyItem invalid, ${JSON.stringify(err)}`);\n  }\n}\n\nasync function publicImportKeyItemFunc(keyAlias: string, HuksOptions: huks.HuksOptions) {\n  console.info(`enter promise importKeyItem`);\n  try {\n    await huks.importKeyItem(keyAlias, HuksOptions)\n      .then(data => {\n        console.info(`promise: importKeyItem success, data = ${JSON.stringify(data)}`);\n      }).catch((err: Error) => {\n        console.error(`promise: importKeyItem failed, ${JSON.stringify(err)}`);\n      })\n  } catch (err) {\n    console.error(`promise: importKeyItem input arg invalid, ${JSON.stringify(err)}`);\n  }\n}\n\nasync function publicDeleteKeyItemFunc(KeyAlias: string, HuksOptions: huks.HuksOptions) {\n  console.info(`enter promise deleteKeyItem`);\n  try {\n    await huks.deleteKeyItem(KeyAlias, HuksOptions)\n      .then(data => {\n        console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((err: Error) => {\n        console.error(`promise: deleteKeyItem failed, ${JSON.stringify(err)}`);\n      })\n  } catch (err) {\n    console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(err)}`);\n  }\n}\n\nfunction importWrappedKeyItem(keyAlias: string, wrappingKeyAlias: string, huksOptions: huks.HuksOptions) {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      huks.importWrappedKeyItem(keyAlias, wrappingKeyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n    }\n  });\n}\n\nasync function publicImportWrappedKeyFunc(keyAlias: string, wrappingKeyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise importWrappedKeyItem`);\n  for (let i = 0; i < huksOptions.inData!.length; i++) {\n    console.error(`${i}: ${huksOptions.inData![i]}`);\n  }\n  try {\n    await importWrappedKeyItem(keyAlias, wrappingKeyAlias, huksOptions)\n      .then((data) => {\n        console.info(`promise: importWrappedKeyItem success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        console.error(`promise: importWrappedKeyItem failed, ${JSON.stringify(error)}`);\n      });\n  } catch (error) {\n    console.error(`promise: importWrappedKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nasync function publicImportWrappedKeyPromise(keyAlias: string, wrappingKeyAlias: string,\n  huksOptions: huks.HuksOptions) {\n  console.info(`enter promise importWrappedKeyItem`);\n  try {\n    await huks.importWrappedKeyItem(keyAlias, wrappingKeyAlias, huksOptions)\n      .then((data) => {\n        console.info(`promise: importWrappedKeyItem success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        console.error(`promise: importWrappedKeyItem failed, ${JSON.stringify(error)}`);\n      });\n  } catch (error) {\n    console.error(`promise: importWrappedKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nasync function publicInitFunc(srcKeyAlias: string, HuksOptions: huks.HuksOptions) {\n  let handle: number = 0;\n  console.info(`enter promise doInit`);\n  try {\n    await huks.initSession(srcKeyAlias, HuksOptions)\n      .then((data) => {\n        console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);\n        handle = data.handle;\n      })\n      .catch((error: Error) => {\n        console.error(`promise: doInit key failed, ${JSON.stringify(error)}`);\n      });\n  } catch (error) {\n    console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);\n  }\n  return handle;\n}\n\nasync function publicUpdateSessionFunction(handle: number, HuksOptions: huks.HuksOptions) {\n  const maxUpdateSize = 64;\n  const inData = HuksOptions.inData!;\n  const lastInDataPosition = inData.length - 1;\n  let inDataSegSize = maxUpdateSize;\n  let inDataSegPosition = 0;\n  let isFinished = false;\n  let outData: number[] = [];\n\n  while (inDataSegPosition <= lastInDataPosition) {\n    if (inDataSegPosition + maxUpdateSize > lastInDataPosition) {\n      isFinished = true;\n      inDataSegSize = lastInDataPosition - inDataSegPosition + 1;\n      console.info(`enter promise doUpdate`);\n      break;\n    }\n    HuksOptions.inData = new Uint8Array(\n      Array.from(inData).slice(inDataSegPosition, inDataSegPosition + inDataSegSize)\n    );\n    console.info(`enter promise doUpdate`);\n    try {\n      await huks.updateSession(handle, HuksOptions)\n        .then((data) => {\n          console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);\n          outData = outData.concat(Array.from(data.outData!));\n        })\n        .catch((error: Error) => {\n          console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);\n        });\n    } catch (error) {\n      console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);\n    }\n    if ((!isFinished) && (inDataSegPosition + maxUpdateSize > lastInDataPosition)) {\n      console.error(`update size invalid isFinished = ${isFinished}`);\n      console.error(`inDataSegPosition = ${inDataSegPosition}`);\n      console.error(`lastInDataPosition = ${lastInDataPosition}`);\n      return;\n    }\n    inDataSegPosition += maxUpdateSize;\n  }\n  return outData;\n}\n\nasync function publicFinishSession(handle: number, HuksOptions: huks.HuksOptions, inData: number[]) {\n  let outData: number[] = [];\n  console.info(`enter promise doFinish`);\n  try {\n    await huks.finishSession(handle, HuksOptions)\n      .then((data) => {\n        console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);\n        outData = inData.concat(Array.from(data.outData!));\n      })\n      .catch((error: Error) => {\n        console.error(`promise: doFinish key failed, ${JSON.stringify(error)}`);\n      });\n  } catch (error) {\n    console.error(`promise: doFinish input arg invalid, ${JSON.stringify(error)}`);\n  }\n  return new Uint8Array(outData);\n}\n\nasync function cipherFunction(keyAlias: string, HuksOptions: huks.HuksOptions) {\n  let handle = await publicInitFunc(keyAlias, HuksOptions);\n  let tmpData = await publicUpdateSessionFunction(handle, HuksOptions);\n  let outData = await publicFinishSession(handle, HuksOptions, tmpData!);\n  return outData;\n}\n\nasync function agreeFunction(keyAlias: string, HuksOptions: huks.HuksOptions, huksPublicKey: Uint8Array) {\n  let handle = await publicInitFunc(keyAlias, HuksOptions);\n  let outSharedKey: Uint8Array = new Uint8Array;\n  HuksOptions.inData = huksPublicKey;\n  console.info(`enter promise doUpdate`);\n  try {\n    await huks.updateSession(handle, HuksOptions)\n      .then((data) => {\n        console.error(`promise: doUpdate success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);\n      });\n  } catch (error) {\n    console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);\n  }\n  console.info(`enter promise doInit`);\n  try {\n    await huks.finishSession(handle, HuksOptions)\n      .then((data) => {\n        console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);\n        outSharedKey = data.outData as Uint8Array;\n      })\n      .catch((error: Error) => {\n        console.error(`promise: doInit key failed, ${JSON.stringify(error)}`);\n      });\n  } catch (error) {\n    console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);\n  }\n  return outSharedKey;\n}\n\nasync function ImportKekAndAgreeSharedSecret(callerKekAlias: string, importKekParams: huks.HuksOptions,\n  callerKeyAlias: string, huksPublicKey: Uint8Array, agreeParams: huks.HuksOptions) {\n  await publicImportKeyItemFunc(callerKekAlias, importKekParams);\n  outSharedKey = await agreeFunction(callerKeyAlias, agreeParams, huksPublicKey);\n  importParamsAgreeKey.inData = outSharedKey;\n  await publicImportKeyItemFunc(callerAgreeKeyAliasAes256, importParamsAgreeKey);\n}\n\nasync function generateAndExportPublicKey(keyAlias: string, HuksOptions: huks.HuksOptions, caller: Boolean) {\n  await publicGenerateItemFunc(keyAlias, HuksOptions);\n  try {\n    await huks.exportKeyItem(keyAlias, HuksOptions)\n      .then((data) => {\n        console.info(`promise: exportKeyItem success, data = ${JSON.stringify(data)}`);\n        if (caller) {\n          callerSelfPublicKey = data.outData as Uint8Array;\n        } else {\n          huksPubKey = data.outData as Uint8Array;\n        }\n      })\n      .catch((error: Error) => {\n        console.error(`promise: exportKeyItem failed, ${JSON.stringify(error)}`);\n      });\n  } catch (error) {\n    console.error(`promise: generate pubKey failed, ${JSON.stringify(error)}`);\n  }\n}\n\nasync function EncryptImportedPlainKeyAndKek(keyAlias: string) {\n  encryptKeyCommonParams.inData = stringToUint8Array(keyAlias)\n  let plainKeyEncData = await cipherFunction(callerKekAliasAes256, encryptKeyCommonParams);\n  outKekEncTag = subUint8ArrayOf(plainKeyEncData, plainKeyEncData.length - TAG_SIZE, plainKeyEncData.length)\n  outPlainKeyEncData = subUint8ArrayOf(plainKeyEncData, 0, plainKeyEncData.length - TAG_SIZE)\n  encryptKeyCommonParams.inData = stringToUint8Array(callerAes256Kek)\n  let kekEncData = await cipherFunction(callerAgreeKeyAliasAes256, encryptKeyCommonParams)\n  outAgreeKeyEncTag = subUint8ArrayOf(kekEncData, kekEncData.length - TAG_SIZE, kekEncData.length)\n  outKekEncData = subUint8ArrayOf(kekEncData, 0, kekEncData.length - TAG_SIZE)\n}\n\nasync function BuildWrappedDataAndImportWrappedKey(plainKey: string) {\n  let plainKeySizeBuff = new Uint8Array(4);\n  assignLength(plainKey.length, plainKeySizeBuff, 0);\n  let wrappedData = new Uint8Array(\n    FILED_LENGTH + huksPubKey.length +\n      FILED_LENGTH + AAD.length +\n      FILED_LENGTH + NONCE.length +\n      FILED_LENGTH + TAG_SIZE +\n      FILED_LENGTH + outKekEncData.length +\n      FILED_LENGTH + AAD.length +\n      FILED_LENGTH + NONCE.length +\n      FILED_LENGTH + TAG_SIZE +\n      FILED_LENGTH + plainKeySizeBuff.length +\n      FILED_LENGTH + outPlainKeyEncData.length\n  );\n  let index = 0;\n  let AADUint8Array = stringToUint8Array(AAD);\n  let NonceArray = stringToUint8Array(NONCE);\n  index += assignLength(callerSelfPublicKey.length, wrappedData, index); // 4\n  index += assignData(callerSelfPublicKey, wrappedData, index); // 91\n  index += assignLength(AADUint8Array.length, wrappedData, index); // 4\n  index += assignData(AADUint8Array, wrappedData, index); // 16\n  index += assignLength(NonceArray.length, wrappedData, index); // 4\n  index += assignData(NonceArray, wrappedData, index); // 12\n  index += assignLength(outAgreeKeyEncTag.length, wrappedData, index); // 4\n  index += assignData(outAgreeKeyEncTag, wrappedData, index); // 16\n  index += assignLength(outKekEncData.length, wrappedData, index); // 4\n  index += assignData(outKekEncData, wrappedData, index); // 32\n  index += assignLength(AADUint8Array.length, wrappedData, index); // 4\n  index += assignData(AADUint8Array, wrappedData, index); // 16\n  index += assignLength(NonceArray.length, wrappedData, index); // 4\n  index += assignData(NonceArray, wrappedData, index); // 12\n  index += assignLength(outKekEncTag.length, wrappedData, index); // 4\n  index += assignData(outKekEncTag, wrappedData, index); // 16\n  index += assignLength(plainKeySizeBuff.length, wrappedData, index); // 4\n  index += assignData(plainKeySizeBuff, wrappedData, index); // 4\n  index += assignLength(outPlainKeyEncData.length, wrappedData, index); // 4\n  index += assignData(outPlainKeyEncData, wrappedData, index); // 24\n  return wrappedData;\n}\n\n/* 模拟加密导入密钥场景，设备A为远端设备（导入设备），设备B为本端设备（被导入设备） */\nasync function ImportWrappedKey() {\n  /**\n   * 1.设备A将待导入密钥转换成HUKS密钥材料格式To_Import_Key（仅针对非对称密钥，若待导入密钥是对称密钥则可省略此步骤），\n   *   本示例使用importedAes256PlainKey（对称密钥）作为模拟\n   */\n\n  /* 2.设备B生成一个加密导入用途的、用于协商的非对称密钥对Wrapping_Key（公钥Wrapping_Pk，私钥Wrapping_Sk），其密钥用途设置为unwrap，导出Wrapping_Key公钥Wrapping_Pk存放在变量huksPubKey中 */\n  const srcKeyAliasWrap = 'HUKS_Basic_Capability_Import_0200';\n  await generateAndExportPublicKey(srcKeyAliasWrap, genWrappingKeyParams, false);\n\n  /* 3.设备A使用和设备B同样的算法，生成一个加密导入用途的、用于协商的非对称密钥对Caller_Key（公钥Caller_Pk，私钥Caller_Sk），导出Caller_Key公钥Caller_Pk存放在变量callerSelfPublicKey中 */\n  await generateAndExportPublicKey(callerKeyAlias, genCallerEcdhParams, true);\n\n  /**\n   * 4.设备A生成一个对称密钥Caller_Kek，该密钥后续将用于加密To_Import_Key\n   * 5.设备A基于Caller_Key的私钥Caller_Sk和Wrapping_Key的公钥Wrapping_Pk，协商出Shared_Key\n   */\n  await ImportKekAndAgreeSharedSecret(callerKekAliasAes256, importParamsCallerKek, callerKeyAlias, huksPubKey,\n    callerAgreeParams);\n\n  /**\n   * 6.设备A使用Caller_Kek加密To_Import_Key，生成To_Import_Key_Enc\n   * 7.设备A使用Shared_Key加密Caller_Kek，生成Caller_Kek_Enc\n   */\n  await EncryptImportedPlainKeyAndKek(importedAes192PlainKey);\n\n  /* 8.设备A封装Caller_Pk、To_Import_Key_Enc、Caller_Kek_Enc等加密导入的材料并发送给设备B。本示例作为变量存放在callerSelfPublicKey，PlainKeyEncData，KekEncData */\n  let wrappedData = await BuildWrappedDataAndImportWrappedKey(importedAes192PlainKey);\n  importWrappedAes192Params.inData = wrappedData;\n\n  /* 9.设备B导入封装的加密密钥材料 */\n  await publicImportWrappedKeyFunc(importedKeyAliasAes192, srcKeyAliasWrap, importWrappedAes192Params);\n\n  /* 10.设备A、B删除用于加密导入的密钥 */\n  await publicDeleteKeyItemFunc(srcKeyAliasWrap, genWrappingKeyParams);\n  await publicDeleteKeyItemFunc(callerKeyAlias, genCallerEcdhParams);\n  await publicDeleteKeyItemFunc(importedKeyAliasAes192, importWrappedAes192Params);\n  await publicDeleteKeyItemFunc(callerKekAliasAes256, callerAgreeParams);\n}
调测验证
调用huks.isKeyItemExist验证密钥是否存在，如密钥存在即表示密钥导入成功。
import { huks } from '@kit.UniversalKeystoreKit';\n\n/*\n * 确定密钥别名和封装密钥属性参数集\n */\nlet keyAlias = 'test_import_key_ecdh_aes192';\nlet isKeyExist: Boolean;\nlet keyProperties: Array<huks.HuksParam> = [{\n  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n  value: huks.HuksKeyAlg.HUKS_ALG_AES,\n}];\nlet huksOptions: huks.HuksOptions = {\n  properties: keyProperties, // 非空填充\n  inData: new Uint8Array(new Array()) // 非空填充\n}\ntry {\n  huks.isKeyItemExist(keyAlias, huksOptions, (error, data) => {\n    if (error) {\n      console.error(`callback: isKeyItemExist failed, ${JSON.stringify(error)}`);\n    } else {\n      if (data !== null && data.valueOf() !== null) {\n        isKeyExist = data.valueOf();\n        console.info(`callback: isKeyItemExist success, isKeyExist = ${isKeyExist}`);\n      }\n    }\n  });\n} catch (error) {\n  console.error(`callback: isKeyItemExist input arg invalid, ${JSON.stringify(error)}`);\n}

TaskPool简介
任务池（TaskPool）作用是为应用程序提供一个多线程的运行环境，降低整体资源的消耗、提高系统的整体性能，且您无需关心线程实例的生命周期。具体接口信息及使用方法详情请见TaskPool。
TaskPool运作机制
TaskPool运作机制示意图
TaskPool支持开发者在宿主线程封装任务抛给任务队列，系统选择合适的工作线程，进行任务的分发及执行，再将结果返回给宿主线程。接口直观易用，支持任务的执行、取消，以及指定优先级的能力，同时通过系统统一线程管理，结合动态调度及负载均衡算法，可以节约系统资源。系统默认会启动一个任务工作线程，当任务较多时会扩容，工作线程数量上限跟当前设备的物理核数相关，具体数量内部管理，保证最优的调度及执行效率，长时间没有任务分发时会缩容，减少工作线程数量。
TaskPool注意事项
 实现任务的函数需要使用@Concurrent装饰器标注，且仅支持在.ets文件中使用。 从API version 11开始，跨并发实例传递带方法的实例对象时，该类必须使用装饰器@Sendable装饰器标注，且仅支持在.ets文件中使用。 任务函数在TaskPool工作线程的执行耗时不能超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时），否则会被强制退出。 实现任务的函数入参需满足序列化支持的类型，详情请参见线程间通信对象。 ArrayBuffer参数在TaskPool中默认转移，需要设置转移列表的话可通过接口setTransferList()设置。 由于不同线程中上下文对象是不同的，因此TaskPool工作线程只能使用线程安全的库，例如UI相关的非线程安全库不能使用。 序列化传输的数据量大小限制为16MB。 Priority的IDLE优先级是用来标记需要在后台运行的耗时任务（例如数据同步、备份），它的优先级别是最低的。这种优先级标记的任务只会在所有线程都空闲的情况下触发执行，并且只会占用一个线程来执行。 Promise不支持跨线程传递，如果TaskPool返回pending或rejected状态的Promise，会返回失败；对于fulfilled状态的Promise，TaskPool会解析返回的结果，如果结果可以跨线程传递，则返回成功。 不支持在TaskPool工作线程中使用AppStorage。 
@Concurrent装饰器
在使用TaskPool时，执行的并发函数需要使用该装饰器修饰，否则无法通过相关校验。
从API version 9开始，支持使用@Concurrent装饰器声明并校验并发函数。
[h2]装饰器说明
由于@Concurrent标记的函数不能访问闭包，因此@Concurrent标记的函数内部不能调用当前文件的其他函数，例如：
function bar() {\n}\n\n@Concurrent\nfunction foo() {\nbar(); // 违反闭包原则，报错\n}
[h2]装饰器使用示例
并发函数一般使用
并发函数为一个计算两数之和的普通函数，taskpool执行该函数并返回结果。
示例：
import { taskpool } from '@kit.ArkTS';\n\n@Concurrent\nfunction add(num1: number, num2: number): number {\n  return num1 + num2;\n}\n\nasync function ConcurrentFunc(): Promise<void> {\n  try {\n    let task: taskpool.Task = new taskpool.Task(add, 1, 2);\n    console.info(\"taskpool res is: \" + await taskpool.execute(task));\n  } catch (e) {\n    console.error(\"taskpool execute error is: \" + e);\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World'\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            ConcurrentFunc();\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
并发函数返回Promise
并发函数中返回Promise的表现需关注，如下例所示，其中testPromise、testPromise1等并发同步函数会处理该Promise并返回结果。
示例：
import { taskpool } from '@kit.ArkTS';\n\n@Concurrent\nfunction testPromise(args1: number, args2: number): Promise<number> {\n  return new Promise<number>((testFuncA, testFuncB)=>{\n    testFuncA(args1 + args2);\n  });\n}\n\n@Concurrent\nasync function testPromise1(args1: number, args2: number): Promise<number> {\n  return new Promise<number>((testFuncA, testFuncB)=>{\n    testFuncA(args1 + args2);\n  });\n}\n\n@Concurrent\nasync function testPromise2(args1: number, args2: number): Promise<number> {\n  return await new Promise<number>((testFuncA, testFuncB)=>{\n    testFuncA(args1 + args2);\n  });\n}\n\n@Concurrent\nfunction testPromise3() {\n  return Promise.resolve(1);\n}\n\n@Concurrent\nasync function testPromise4(): Promise<number> {\n  return 1;\n}\n\n@Concurrent\nasync function testPromise5(): Promise<string> {\n  return await new Promise((resolve) => {\n    setTimeout(()=>{\n      resolve(\"Promise setTimeout after resolve\");\n    }, 1000)\n  });\n}\n\nasync function testConcurrentFunc() {\n  let task1: taskpool.Task = new taskpool.Task(testPromise, 1, 2);\n  let task2: taskpool.Task = new taskpool.Task(testPromise1, 1, 2);\n  let task3: taskpool.Task = new taskpool.Task(testPromise2, 1, 2);\n  let task4: taskpool.Task = new taskpool.Task(testPromise3);\n  let task5: taskpool.Task = new taskpool.Task(testPromise4);\n  let task6: taskpool.Task = new taskpool.Task(testPromise5);\n\n  taskpool.execute(task1).then((d:object)=>{\n    console.info(\"task1 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task1 catch e: \" + e);\n  })\n  taskpool.execute(task2).then((d:object)=>{\n    console.info(\"task2 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task2 catch e: \" + e);\n  })\n  taskpool.execute(task3).then((d:object)=>{\n    console.info(\"task3 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task3 catch e: \" + e);\n  })\n  taskpool.execute(task4).then((d:object)=>{\n    console.info(\"task4 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task4 catch e: \" + e);\n  })\n  taskpool.execute(task5).then((d:object)=>{\n    console.info(\"task5 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task5 catch e: \" + e);\n  })\n  taskpool.execute(task6).then((d:object)=>{\n    console.info(\"task6 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task6 catch e: \" + e);\n  })\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    Row() {\n      Column() {\n        Button(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            testConcurrentFunc();\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
并发函数中使用自定义类或函数
并发函数中使用自定义类或函数时需定义在不同文件，否则会被认为是闭包，如下例所示。
示例：
// Index.ets\nimport { taskpool } from '@kit.ArkTS';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { testAdd, MyTestA, MyTestB } from './Test';\n\nfunction add(arg: number) {\n  return ++arg;\n}\n\nclass TestA {\n  constructor(name: string) {\n    this.name = name;\n  }\n  name: string = 'ClassA';\n}\n\nclass TestB {\n  static nameStr: string = 'ClassB';\n}\n\n@Concurrent\nfunction TestFunc() {\n  // case1：在并发函数中直接调用同文件内定义的类或函数\n\n  // 直接调用同文件定义的函数add()，add飘红报错：Only imported variables and local variables can be used in @Concurrent decorated functions. <ArkTSCheck>\n  // add(1);\n  // 直接使用同文件定义的TestA构造，TestA飘红报错：Only imported variables and local variables can be used in @Concurrent decorated functions. <ArkTSCheck>\n  // let a = new TestA(\"aaa\");\n  // 直接访问同文件定义的TestB的成员nameStr，TestB飘红报错：Only imported variables and local variables can be used in @Concurrent decorated functions. <ArkTSCheck>\n  // console.info(\"TestB name is: \" + TestB.nameStr);\n\n  // case2：在并发函数中调用定义在Test.ets文件并导入当前文件的类或函数\n\n  // 输出结果：res1 is: 2\n  console.info(\"res1 is: \" + testAdd(1));\n  let tmpStr = new MyTestA(\"TEST A\");\n  // 输出结果：res2 is: TEST A\n  console.info(\"res2 is: \" + tmpStr.name);\n  // 输出结果：res3 is: MyTestB\n  console.info(\"res3 is: \" + MyTestB.nameStr);\n}\n\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    RelativeContainer() {\n      Text(this.message)\n        .id('HelloWorld')\n        .fontSize(50)\n        .fontWeight(FontWeight.Bold)\n        .alignRules({\n          center: { anchor: '__container__', align: VerticalAlign.Center },\n          middle: { anchor: '__container__', align: HorizontalAlign.Center }\n        })\n        .onClick(() => {\n          let task = new taskpool.Task(TestFunc);\n          taskpool.execute(task).then(() => {\n            console.info(\"taskpool: execute task success!\");\n          }).catch((e:BusinessError) => {\n            console.error(`taskpool: execute: Code: ${e.code}, message: ${e.message}`);\n          })\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
// Test.ets\nexport function testAdd(arg: number) {\n  return ++arg;\n}\n\n@Sendable\nexport class MyTestA {\n  constructor(name: string) {\n    this.name = name;\n  }\n  name: string = 'MyTestA';\n}\n\nexport class MyTestB {\n  static nameStr:string = 'MyTestB';\n}
并发异步函数中使用Promise
并发异步函数中如果使用Promise，建议搭配await使用捕获Promise中可能发生的异常。推荐使用示例如下。
示例：
import { taskpool } from '@kit.ArkTS'\n\n@Concurrent\nasync function testPromiseError() {\n  await new Promise<number>((resolve, reject) => {\n    resolve(1);\n  }).then(()=>{\n    throw new Error(\"testPromise Error\");\n  })\n}\n\n@Concurrent\nasync function testPromiseError1() {\n  await new Promise<string>((resolve, reject) => {\n    reject(\"testPromiseError1 Error msg\");\n  })\n}\n\n@Concurrent\nfunction testPromiseError2() {\n  return new Promise<string>((resolve, reject) => {\n    reject(\"testPromiseError2 Error msg\");\n  })\n}\n\nasync function testConcurrentFunc() {\n  let task1: taskpool.Task = new taskpool.Task(testPromiseError);\n  let task2: taskpool.Task = new taskpool.Task(testPromiseError1);\n  let task3: taskpool.Task = new taskpool.Task(testPromiseError2);\n\n  taskpool.execute(task1).then((d:object)=>{\n    console.info(\"task1 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task1 catch e: \" + e);\n  })\n  taskpool.execute(task2).then((d:object)=>{\n    console.info(\"task2 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task2 catch e: \" + e);\n  })\n  taskpool.execute(task3).then((d:object)=>{\n    console.info(\"task3 res is: \" + d);\n  }).catch((e:object)=>{\n    console.info(\"task3 catch e: \" + e);\n  })\n}\n\n@Entry\n@Component\nstruct Index {\n  @State message: string = 'Hello World';\n\n  build() {\n    Row() {\n      Column() {\n        Button(this.message)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n          .onClick(() => {\n            testConcurrentFunc();\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}

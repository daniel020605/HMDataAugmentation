HDR Vivid视频播放
开发者可以调用本模块的Native API接口，实现在视频播放中支持HDR Vivid标准。
视频播放的主要流程，是将视频文件“解封装 > 解码 > 送显/播放”。
HDR Vivid视频解析
从视频文件中，可以解析出其是否为HDRVivid视频，如果视频源为HDRVivid视频，可以解析相关的信息，如CuvvBox信息、元数据、Color信息等。
[h2]在 CMake 脚本中链接动态库
target_link_libraries(sample PUBLIC libnative_media_codecbase.so)\ntarget_link_libraries(sample PUBLIC libnative_media_avdemuxer.so)\ntarget_link_libraries(sample PUBLIC libnative_media_avsource.so)\ntarget_link_libraries(sample PUBLIC libnative_media_core.so)
[h2]开发步骤
添加头文件。#include <multimedia/player_framework/native_avdemuxer.h>\n#include <multimedia/player_framework/native_avsource.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <fcntl.h>\n#include <sys/stat.h> 文件解析器。// 创建文件操作符 fd，打开时对文件句柄必须有读权限(filePath 为待解封装文件路径，需预置文件，保证路径指向的文件存在)\nstd::string filePath = \"test.mp4\";\nint fd = open(filePath.c_str(), O_RDONLY);\nstruct stat fileStatus {};\n// 获取fileSize \nsize_t fileSize = 0;\nif (stat(filePath.c_str(), &fileStatus) == 0) {\n   fileSize = static_cast<size_t>(fileStatus.st_size);\n} else {\n    printf(\"get stat failed\");\n    return;\n}\n// 为 fd 资源文件创建 source 资源对象\nOH_AVSource *source = OH_AVSource_CreateWithFD(fd, 0, fileSize);\nif (source == nullptr) {\n   printf(\"create source failed\");\n   return;\n} 获取视频轨道信息，查询文件HDR类型。int32_t trackCount = 0;\nuint32_t audioTrackIndex = 0;\nuint32_t videoTrackIndex = 0;\nint32_t trackType; // 从文件 source 信息获取文件轨道数\nOH_AVFormat *sourceFormat = OH_AVSource_GetSourceFormat(source);\nif (sourceFormat == nullptr) {\n   printf(\"get source format failed\");\n   return;\n}\nOH_AVFormat_GetIntValue(sourceFormat, OH_MD_KEY_TRACK_COUNT, &trackCount);\nOH_AVFormat_Destroy(sourceFormat);\nfor (uint32_t index = 0; index < (static_cast<int32_t>(trackCount)); index++) {\n   // 获取轨道信息\n   OH_AVFormat *format = OH_AVSource_GetTrackFormat(source, index);\n   if (format == nullptr) {\n      printf(\"get track format failed\");\n      return;\n   }\n   // 判断轨道类型\n   static_cast<OH_MediaType>(trackType) == OH_MediaType::MEDIA_TYPE_AUD ? audioTrackIndex = index : videoTrackIndex = index;\n   // 查询文件HDR类型，是否为HDRVivid视频。\n   int32_t isHDRVivid = 0;\n   bool ret = OH_AVFormat_GetIntValue(format, OH_MD_KEY_VIDEO_IS_HDR_VIVID, &isHDRVivid);\n   if (ret == false || isHDRVivid == 0) {\n      printf(\"is not HDRVivid \");\n   }\n   OH_AVFormat_Destroy(format); // 销毁\n} 
HDR Vivid视频解码
应用创建H265解码器，并配置宽、高、format信息。解码器解析码流，生产对应的视频帧数据以及元数据。
仅在Surface模式下支持HDR Vivid视频解码。
[h2]在 CMake 脚本中链接动态库
target_link_libraries(sample PUBLIC libnative_media_codecbase.so)\ntarget_link_libraries(sample PUBLIC libnative_media_core.so)\ntarget_link_libraries(sample PUBLIC libnative_media_vdec.so)
[h2]开发步骤
添加头文件。#include <multimedia/player_framework/native_avcodec_videodecoder.h>\n#include <multimedia/player_framework/native_avcapability.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <fstream> 创建H265解码器实例对象。应用可以通过名称或媒体类型创建解码器。示例中的变量说明如下： videoDec：视频解码器实例的指针。OH_AVCODEC_MIMETYPE_VIDEO_HEVC：HEVC格式视频码流的名称。 // 通过mimetype创建H265解码器\nOH_AVCodec *videoDec = OH_VideoDecoder_CreateByMime(OH_AVCODEC_MIMETYPE_VIDEO_HEVC); 配置异步回调函数。添加头文件：#include <condition_variable>\n#include <queue>\n#include <mutex> struct CodecBufferInfo {\n    uint32_t bufferIndex = 0;\n    OH_AVBuffer *buffer = nullptr;\n    uint8_t *bufferAddr = nullptr;\n    OH_AVCodecBufferAttr attr = {0, 0, 0, AVCODEC_BUFFER_FLAGS_NONE};\n};\nstd::mutex inputMutex_;\nstd::condition_variable inputCond_;\nstd::queue<CodecBufferInfo> inputBufferInfoQueue_;\n\n// 解码输入回调OH_AVCodecOnNeedInputBuffer实现\nvoid OnNeedInputBuffer(OH_AVCodec *codec, uint32_t index, OH_AVBuffer *buffer, void *userData) {\n   (void)codec;\n    std::unique_lock<std::mutex> lock(inputMutex_);\n    inputBufferInfoQueue_.emplace(index, buffer);\n    inputCond_.notify_all();\n}  具体可参考：视频解码Surface模式中的“步骤4：调用OH_VideoDecoder_RegisterCallback()设置回调函数”。 配置解码器。具体可参考：视频解码Surface模式中的“步骤6：调用OH_VideoDecoder_Configure()配置解码器”。 （可选）设置Surface。具体可参考：视频解码Surface模式中的“步骤7：设置Surface”。 调用OH_VideoDecoder_Start()启动解码器。具体可参考：视频解码Surface模式中的“步骤10：调用OH_VideoDecoder_Start()启动解码器”。 
处理视频帧数据
解封装，循环获取帧数据。bool videoIsEnd = false;\n// 为资源对象创建对应的解封装器\nOH_AVDemuxer *demuxer = OH_AVDemuxer_CreateWithSource(source);\n// 取出回调函数OnNeedInputBuffer存到输入队列的帧buffer\nCodecBufferInfo bufferInfo = inputBufferInfoQueue_.front();\ninputBufferInfoQueue_.pop();\n// 解封装帧数据\nint32_t ret = OH_AVDemuxer_ReadSampleBuffer(demuxer, videoTrackIndex, bufferInfo.buffer);\nif (ret == AV_ERR_OK) {\n   // 可通过buffer获取并处理视频帧数据\n    OH_AVBuffer_GetBufferAttr(bufferInfo.buffer, &bufferInfo.attr);\n    if (bufferInfo.attr.flags == OH_AVCodecBufferFlags::AVCODEC_BUFFER_FLAGS_EOS) {\n        videoIsEnd = true;\n    }\n} 将解封装后的视频帧数据送入解码输入队列。// 送入解码输入队列进行解码，index为对应队列下标\nret = OH_VideoDecoder_PushInputBuffer(videoDec, bufferInfo.bufferIndex);\nif (ret != AV_ERR_OK) {\n   // 异常处理\n} 

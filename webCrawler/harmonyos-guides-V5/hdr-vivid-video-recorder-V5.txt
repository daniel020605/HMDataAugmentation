HDR Vivid视频录制
开发者可以调用本模块的Native API接口，实现在视频录制中支持HDR Vivid标准。
视频录制的主要流程是“相机采集 > 编码 > 封装成mp4文件”。
HDR Vivid视频编码
应用创建H265编码器，配置profile(main 10)相机底层包含HDR Vivid的surfacebuffer内容，编码器消费surfacebuffer编码生成对应码流。
仅在Surface模式下支持HDR Vivid视频编码。
[h2]在 CMake 脚本中链接动态库
target_link_libraries(sample PUBLIC libnative_media_codecbase.so)\ntarget_link_libraries(sample PUBLIC libnative_media_avdemuxer.so)\ntarget_link_libraries(sample PUBLIC libnative_media_avsource.so)\ntarget_link_libraries(sample PUBLIC libnative_media_core.so)
[h2]开发步骤
添加头文件。#include <multimedia/player_framework/native_avcodec_videoencoder.h>\n#include <multimedia/player_framework/native_avcapability.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <fstream> 创建编码器实例对象。应用可以通过名称或媒体类型创建编码器。示例中的变量说明如下： videoEnc：视频编码器实例的指针；OH_AVCODEC_MIMETYPE_VIDEO_HEVC：HEVC格式视频码流的名称。 // 通过mimetype创建H265编码器\nOH_AVCodec *videoEnc = OH_VideoEncoder_CreateByMime(OH_AVCODEC_MIMETYPE_VIDEO_HEVC); 配置异步回调函数。添加头文件：#include <condition_variable>\n#include <queue>\n#include <mutex> struct CodecBufferInfo {\n    uint32_t bufferIndex = 0;\n    OH_AVBuffer *buffer = nullptr;\n    uint8_t *bufferAddr = nullptr;\n    OH_AVCodecBufferAttr attr = {0, 0, 0, AVCODEC_BUFFER_FLAGS_NONE};\n};\nstd::mutex outputMutex_;\nstd::condition_variable outputCond_;\nstd::queue<CodecBufferInfo> outputBufferInfoQueue_;\n\n// 设置OH_AVCodecOnNewOutputBuffer回调函数，编码完成帧送入输出队列\nvoid OnNewOutputBuffer(OH_AVCodec *codec, uint32_t index, OH_AVBuffer *buffer, void *userData) {\n    (void)codec;\n    std::unique_lock<std::mutex> lock(outputMutex_);\n    outputBufferInfoQueue_.emplace(index, buffer);\n    outputCond_.notify_all();\n}  具体可参考：视频编码Surface模式中的“步骤3：调用OH_VideoEncoder_RegisterCallback()设置回调函数”。 配置编码器。可选配置视频帧宽度、频帧高度、视频颜色格式。// 配置编码Profile为MAIN10(必须)\nint32_t profile = static_cast<int32_t>(HEVC_PROFILE_MAIN_10);\n// 配置视频原色\nint32_t primary = static_cast<int32_t>(OH_ColorPrimary::COLOR_PRIMARY_BT2020);\n// 配置传输特性\nint32_t transfer = static_cast<int32_t>(OH_TransferCharacteristic::TRANSFER_CHARACTERISTIC_PQ);// PQ或者HLG\n// 配置最大矩阵系数\nint32_t matrix = static_cast<int32_t>(OH_MatrixCoefficient::MATRIX_COEFFICIENT_BT2020_CL);\n// 配置关键帧的间隔，单位为毫秒\nint32_t iFrameInterval = 100;\n\nOH_AVFormat *format = OH_AVFormat_Create();\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_PROFILE, profile);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_COLOR_PRIMARIES, primary);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_TRANSFER_CHARACTERISTICS, transfer);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_MATRIX_COEFFICIENTS, matrix);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_I_FRAME_INTERVAL, iFrameInterval);\nOH_AVFormat_SetIntValue(format, OH_MD_KEY_RANGE_FLAG, 1);\n// 配置编码器\nint32_t ret = OH_VideoEncoder_Configure(videoEnc, format);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n}\nOH_AVFormat_Destroy(format);  获取surface，并设置给相机。具体可参考：视频编码Surface模式中的“步骤7：获取Surface”。 调用OH_VideoEncoder_Start()启动编码器。具体可参考：视频编码Surface模式中的“步骤9：调用OH_VideoEncoder_Start()启动编码器”。 
HDR Vivid视频封装
调用Muxer可以将HDRVivid码流封装成文件，码流格式需指定为hevc码流，并设置宽、高、isHDRVivid信息。Color信息通常需要从编码获取并设置给封装器。
[h2]在 CMake 脚本中链接动态库
target_link_libraries(sample PUBLIC libnative_media_avmuxer.so)\ntarget_link_libraries(sample PUBLIC libnative_media_core.so)
[h2]开发步骤
添加头文件。#include <multimedia/player_framework/native_avmuxer.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <fcntl.h> 调用OH_AVMuxer_Create()创建封装器实例对象。// 设置封装格式为mp4\nOH_AVOutputFormat outputFormat = AV_OUTPUT_FORMAT_MPEG_4;\n// 以读写方式创建fd\nint32_t fd = open(\"test.mp4\", O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR);\nOH_AVMuxer *muxer = OH_AVMuxer_Create(fd, outputFormat); 添加视频轨，并指定类型为HDRVivid类型。int videoTrackId = -1;\nuint8_t *buffer = ...; // 编码config data，如果没有可以不传\nsize_t size = ...;  // 编码config data的长度，根据实际情况配置\n\nOH_AVFormat *formatVideo = OH_AVFormat_Create();\nOH_AVFormat_SetStringValue(formatVideo, OH_MD_KEY_CODEC_MIME, OH_AVCODEC_MIMETYPE_VIDEO_HEVC); // 必填\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_WIDTH, 1280); // 必填\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_HEIGHT, 720); // 必填\n// (可选)HDRVivid视频封装时必填，指定为HDRVivid视频\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_VIDEO_IS_HDR_VIVID, 1);\n// (可不设置，封装器从编码码流xps自动解析) 设置Color信息，如下。\n// 这些信息也可以通过调用OH_VideoEncoder_GetOutputDescription(OH_AVCodec *codec)接口从编码器中获取。\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_RANGE_FLAG, 1);\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_COLOR_PRIMARIES, OH_ColorPrimary::COLOR_PRIMARY_BT2020);\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_TRANSFER_CHARACTERISTICS, OH_TransferCharacteristic::TRANSFER_CHARACTERISTIC_PQ); // PQ或者HLG\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_MATRIX_COEFFICIENTS, OH_MatrixCoefficient::MATRIX_COEFFICIENT_BT2020_CL);\n\nret = OH_AVMuxer_AddTrack(muxer, &videoTrackId, formatVideo);\nif (ret != AV_ERR_OK || videoTrackId < 0) {\n    // 视频轨添加失败\n}\nOH_AVFormat_Destroy(formatVideo); // 销毁 
处理视频帧数据
写入封装数据。// start后，才能开始写入数据\nint trackId = videoTrackId; // 选择写的媒体轨\n// 取出回调函数OnNewOutputBuffer送入输出队列的帧buffer\nCodecBufferInfo bufferInfo = outputBufferInfoQueue_.front();\noutputBufferInfoQueue_.pop();\nret = OH_AVMuxer_WriteSampleBuffer(muxer, trackId, bufferInfo.buffer);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_VideoEncoder_FreeOutputBuffer()释放编码帧。// 释放已完成写入的数据，index为对应输出队列的下标\nret = OH_VideoEncoder_FreeOutputBuffer(videoEnc, bufferInfo.bufferIndex);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 

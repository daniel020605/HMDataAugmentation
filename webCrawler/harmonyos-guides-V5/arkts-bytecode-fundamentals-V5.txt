方舟字节码基本原理
总体设计
[h2]概述
方舟字节码（Ark Bytecode），是由方舟编译器编译ArkTS/TS/JS生成的，提供给方舟运行时解释执行的二进制文件，字节码中的主要内容是方舟字节码指令。
本文旨在介绍方舟字节码指令相关的设计，将在后续章节中对构成指令的重要概念和具体的指令格式及含义进行说明，帮助开发者了解方舟字节码指令，指导开发者进行指令相关的特性开发工作。
一条方舟字节码指令，由操作码（指令的名称）和指令入参列表组成。操作码包含无前缀的操作码和有前缀的操作码两种情况。寄存器、立即数以及string id/method id/literal id，均可以作为指令的入参，除此之外，部分指令中使用累加器作为默认参数。
方舟字节码中，除寄存器和累加器之外，还存在全局变量、模块（module）命名空间和模块变量、词法环境和词法变量、补丁变量4种值存储方式。指令可以使用这4种储值位置中的值作为入参。
[h2]术语和约束
术语
本文涉及的术语清单：
约束
 本文中所有采用代码形式描述的内容均遵循ArkTS语言规范 本文仅适用于版本号为12.0.6.0的方舟字节码（版本号为方舟编译器内部保留字段，开发者无需关注） 
[h2]字节码构成
操作码与前缀
方舟字节码中的操作码通常被编码为一个8位的值，因此至多只能有256个操作码。随着方舟编译器运行时功能的演进，字节码的数量也在逐步增加，已经超过了256个。因此，方舟字节码引入了前缀（prefix），将操作码最大宽度从8位扩展到16位。8位操作码（无前缀的）用于表示频繁出现的指令，16位操作码（有前缀的）用于表示出现频率不高的指令。
带前缀的操作码为小端法存储的16位值，由8位操作码和8位前缀组成，编码规则为：操作码左移8位，再与前缀相或。
方舟编译器不再会产生的指令，仅用于维护运行时兼容性；
本文后续章节中将省略对这些指令的说明
前缀操作码的助记符的形式为前缀助记符.操作码助记符, 例如，wide.stlexvar。stlexvar指令的操作码是0x0d，前缀wide是0xfd，则此带前缀的指令（wide.stlexvar）的操作码是0x0dfd。
寄存器与累加器
方舟虚拟机模型基于寄存器，所有的寄存器均是虚拟寄存器。当寄存器中存放原始类型的值时，寄存器的宽度是64位；当寄存器中存放对象类型的值时，寄存器的宽度适应为足够宽，以存放对该对象的引用。
方舟字节码中，存在一个名为累加器（accumulator，也简称作acc）的不可见寄存器。acc是许多指令的默认目标寄存器，也是许多指令的默认参数。acc不占用编码宽度，有助于产生更为紧凑的字节码。
示例代码：
function foo(): number {\n    return 1;\n}
字节码中的相关指令：
.function any .foo(any a0, any a1, any a2) {\n    ldai 0x1\n    return\n}
指令ldai 0x1：将整型字面量1加载到acc中；
指令return：将acc中的值返回。
立即数
方舟字节码中部分指令采用常数形式来表示整型数值、双精度浮点型数值、跳转偏移量等数据。这类常数被称为立即数，可以是8位、16位、32位或64位。
方法索引、字符串索引、字面量索引
方舟字节码中存放着源文件中使用到的所有方法、字符串和字面量数组的偏移量。其中，字面量数组中存放着各种字面量数据，例如整型数字、字符串偏移量和方法偏移量。在方舟字节码指令中，这些方法、字符串以及字面量数组的索引都是16位的，分别被称作方法索引（method id）、字符串索引（string id）以及字面量索引（literal id）。这些索引被编码在指令中，以引用方法、字符串和字面量数组。
[h2]值存储方式
全局变量
在Script编译模式下，全局变量是一个存储在全局唯一的映射中的变量，其键值为全局变量的名称，值为全局变量的值。全局变量可通过全局（global）相关的指令进行访问。
示例代码：
function foo(): void {\n    a += 2;\n    b = 5;\n}
字节码中的相关指令：
.function any .foo(any a0, any a1, any a2) {\n    tryldglobalbyname 0x0, a\n    sta v4\n    ldai 0x2\n    add2 0x1, v4\n    trystglobalbyname 0x2, a\n    ldai 0x5\n    trystglobalbyname 0x3, b\n    ...\n}
指令tryldglobalbyname 0x0, a：将名称为a的全局变量加载进acc，不存在名称为a的全局变量时，抛出异常；
指令trystglobalbyname 0x2, a：将acc中的值存放到名称为a的全局变量上，不存在名称为a的全局变量时，抛出异常；
指令trystglobalbyname 0x3, b：将acc中的值存放到名称为b的全局变量上，不存在名称为b的全局变量时，抛出异常。
注意：
上述指令中出现的0x0，0x2，0x3是方舟运行时内部使用的保留数字，开发者无需关注。
模块命名空间和模块变量
源文件中所有使用到的模块命名空间（module namespace）都会被编译进一个数组中，指令中使用索引来引用一个模块命名空间。例如，指令getmodulenamespace 0x1引用了索引0x1处的模块命名空间。
源文件中所有使用到的模块变量（module variable）都会被编译进一个数组中，指令中使用索引来引用一个模块变量。例如，指令stmodulevar 0x1引用了索引0x1处的模块变量。
在函数中，如果一个模块变量的声明和这个函数在同一个源文件中，则将这个变量称为局部模块变量；否则称为外部模块变量。例如，指令ldlocalmodulevar和ldexternalmodulevar分别用于加载局部模块变量和外部模块变量。
产生模块指令的相关场景，包括import和export，主要场景列举如下：
 import * as：module namespace import { }：module variable export：local export 
注意：
模块相关的逻辑是编译器的内部实现，随着方舟编译器的后续演进，可能会出现新的涉及模块指令的场景；另一方面，现有的模块命名空间和模块变量指令的相关场景，也可能会随着需求演进和代码重构，不再涉及产生模块相关指令。
示例代码：
import { a, b } from \"./module_foo\"\nimport * as c from \"./module_bar\"\n\nexport let d: number = 3;\n\na + b + d;
字节码中的相关指令：
.function any .func_main_0(any a0, any a1, any a2) {\n    getmodulenamespace 0x1\n    ldai 0x3\n    stmodulevar 0x0\n    ldexternalmodulevar 0x0\n    sta v0\n    throw.undefinedifholewithname a\n    ldexternalmodulevar 0x1\n    sta v1\n    throw.undefinedifholewithname b\n    lda v1\n    add2 0x0, v0\n    sta v0\n    ldlocalmodulevar 0x0\n    sta v1\n    throw.undefinedifholewithname d\n    lda v1\n    add2 0x1, v0\n    ...\n}
指令getmodulenamespace 0x1：获取1号槽位上的模块命名空间（c），存放到acc中；
指令stmodulevar 0x0：将acc中的值存放到当前模块的0号槽位上；
指令ldexternalmodulevar 0x0：加载外部模块的0号槽位上的值（a），存放到acc中；
指令ldlocalmodulevar 0x0：加载当前局部模块的0号槽位上的值（d），存放到acc中。
词法环境和词法变量
方舟字节码中，词法环境（lexical environment）可以看作是一个具有多个槽位的数组，每个槽位对应一个词法变量（lexical variable），一个方法中可能会存在多个词法环境。指令中使用词法环境的相对层级编号和槽位索引，来表示一个词法变量。例如，指令ldlexvar 0x1, 0x2的含义是：将1个层次外的词法环境的2号槽位上的值存放到acc中。
|xxx|xxx|xxx|xxx|   <-- 当前词法环境外的第1个词法环境\n         ^\n         |------------ ldlexvar 0x1, 0x2\n\n|xxx|xxx|xxx|xxx|   <-- 当前词法环境
注意：
lexical相关的逻辑是编译器的内部实现。随着方舟编译器的后续演进，可能会出现新的涉及lexical指令的场景；另一方面，现有的lexical指令的相关场景，也可能会随着需求演进和代码重构，不再涉及产生lexical相关指令。
示例代码：
function foo(): void {\n    let a: number = 1;\n    function bar(): number {\n        return a;\n    }\n}
字节码中的相关指令：
.function any .foo(any a0, any a1, any a2) {\n    newlexenv 0x1\n    ...\n    definefunc 0x0, .bar, 0x0\n    sta v3\n    ldai 0x1 \n    ...\n    stlexvar 0x0, 0x0\n    ...\n}    \n\n.function any .bar(any a0, any a1, any a2) {\n    ...\n    ldlexvar 0x0, 0x0\n    ...\n}
指令newlexenv 0x1：创建一个槽位数为1的词法环境，将其存放到acc中，并进入该词法环境；
指令stlexvar 0x0, 0x0：将acc中的值存放到0个层次外的词法环境的0号槽位上；
指令ldlexvar 0x0, 0x0：将0个层次外的词法环境的0号槽位上的值存放到acc中。
共享词法环境
共享词法环境是一类特殊的词法环境。与一般词法环境的区别在于，共享词法环境中的每个词法变量都是sendable对象。方舟编译器通过共享词法环境实现词法变量在多线程的共享。
示例代码：
@Sendable\nclass A { }\n\n@Sendable\nclass B {\n    u: A = new A()\n}
字节码中的相关指令：
.function any .#~B=#B(any a0, any a1, any a2) {\nlabel_1: \nlabel_0: \n    callruntime.ldsendablevar 0x0, 0x0\n    sta v0\n    throw.undefinedifholewithname A\n    ...\nlabel_2: \n}\n\n.function any .func_main_0(any a0, any a1, any a2) {\nlabel_1: \nlabel_0: \n    callruntime.newsendableenv 0x1\n    ...\n    callruntime.definesendableclass 0x0, .#~A=#A, _3, 0x0, v0\n    callruntime.stsendablevar 0x0, 0x0\n    ...\nlabel_2: \n}
指令callruntime.newsendableenv 0x1：创建一个槽位数为1的共享词法环境，并进入该词法环境；
指令callruntime.stsendablevar 0x0, 0x0：将acc中的值存放到0个层次外的共享词法环境的0号槽位上；
指令callruntime.ldsendablevar 0x0, 0x0：将0个层次外的共享词法环境的0号槽位上的值存放到acc中。
补丁变量
方舟编译器支持补丁模式的编译，当源文件发生修改时，经过补丁模式编译，生成一个补丁字节码，配合原字节码，完成功能的更新。方舟编译器在补丁模式下编译时，产生的补丁变量会被存放在一个特殊的补丁词法环境中。方舟字节码中使用补丁词法环境上的槽位编号来引用补丁变量。例如，指令ldpatchvar 0x1加载的是槽位号为1的补丁变量。
示例代码：
function bar(): void {} // 新增语句，编译补丁\n\nfunction foo(): void {\n    bar(); // 新增语句，编译补丁\n}
字节码中的相关指令：
.function any foo(...) {\n    ...\n    wide.ldpatchvar 0x0\n    sta v4\n    lda v4\n    callarg0 0x0\n    ...\n}\n\n.function any patch_main_0(...) {\n    newlexenv 0x1\n    definefunc 0x1, bar:(any,any,any), 0x0\n    wide.stpatchvar 0x0\n    ...\n}
指令wide.stpatchvar 0x0：将函数bar存放到补丁词法环境的0号槽位；
指令wide.ldpatchvar 0x0：将补丁词法环境上0号槽位的值存放到acc中。
[h2]函数调用规范
对于一个包含了N个形参的方法，该方法所使用的寄存器中的最后N+3个会被用于传递参数。其中，前三个寄存器固定表示函数本身（FunctionObject）、new.target（NewTarget）和函数所在的词法环境中的this（this），后续的N个寄存器依次对应这N个形参。
示例代码：
function foo(a: number, b: number): void {}
字节码中的相关指令：
.function any .foo(any a0, any a1, any a2, any a3, any a4) {\n    // a0: FunctionObject\n    // a1: NewTarget\n    // a2: this \n    // a3: a\n    // a4: b\n}
字节码格式说明
字节码汇总集合
下表中汇总了当前版本的所有方舟字节码，寄存器索引、立即数和id通过每四位宽度使用一个字符替代的形式来描述。
以指令defineclasswithbuffer RR, @AAAA, @BBBB, +CCCC, vDD为例：
 defineclasswithbuffer：指示操作的操作码助记符 RR：方舟运行时内部使用的8位保留数字，此处提及仅为完整展示指令格式，开发者无需关注 @AAAA，@BBBB：16位id +CCCC：16位立即数 vDD：8位寄存器索引 
R：方舟运行时内部使用的8位保留数字
A：16位的literal id
R：方舟运行时内部使用的8位保留数字
A：16位的literal id
R：方舟运行时内部使用的8位保留数字
A：参数数量
B：类对象
B + 1, ..., B + A - 1：传递给构造函数的参数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
A：操作数
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
A：对象
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
A：对象
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
A：对象
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
A：对象
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：参数
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A, B：参数
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A, B, C：参数
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：对象
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：对象
B：参数
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：对象
B, C：参数
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：对象
B, C, D：参数
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：参数数量
B：对象
B + 1, ..., B + A：参数
R：方舟运行时内部使用的8位保留数字
A：参数数量
B, ..., B + A - 1：参数
以B, ..., B + A - 1作为参数, 调用super函数，并将结果存放到acc中。
当A的值是0时，B是undefined。
此指令仅出现在非箭头函数中。
R：方舟运行时内部使用的8位保留数字
A：method id
B：方法A的形参数量
默认入参：acc：类对象或类对象的对象原型，方法为静态方法时，acc中是类对象
R：方舟运行时内部使用的8位保留数字
A：method id
B：方法A的形参数量
R：方舟运行时内部使用的8位保留数字
A：类的构造函数的method id
B：literal id
C：方法A的形参数量
D：父类
默认入参：acc：属性键值
R：方舟运行时内部使用的8位保留数字
A：对象
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：对象
B：属性键值
默认入参：acc：属性键值
R：方舟运行时内部使用的8位保留数字
A：对象
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
A：属性键值
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：对象
B：属性键值
A：词法环境层级
B：槽位号
默认入参：acc：值
A：词法环境层级
B：槽位号
R：方舟运行时内部使用的8位保留数字
A：string id
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：string id
R：方舟运行时内部使用的16位保留数字
A：string id
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
A：string id
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：string id
B：对象
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
A：string id
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：string id
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：string id
R：方舟运行时内部使用的8位保留数字
A：string id
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：string id
默认入参：acc：属性键值
R：方舟运行时内部使用的8位保留数字
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：属性键值
默认入参：acc：值
A：有符号的分支偏移量
默认入参：acc：值
A：有符号的分支偏移量
默认入参：acc：值
A：有符号的分支偏移量
默认入参：acc：值
A：有符号的分支偏移量
计算acc === 0，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc !== 0，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc == null，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc != null，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc === null，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc !== null，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc == undefined，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc != undefined，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc === undefined，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc !== undefined，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：值
B：有符号的分支偏移量
计算acc == A，如果为真，则跳转到分支B。
指令功能未使能，暂不可用。
默认入参：acc：值
A：值
B：有符号的分支偏移量
计算acc != A，如果为真，则跳转到分支B。
指令功能未使能，暂不可用。
默认入参：acc：对象
A：对象
B：有符号的分支偏移量
计算acc === A，如果为真，则跳转到分支B。
指令功能未使能，暂不可用。
默认入参：acc：对象
A：对象
B：有符号的分支偏移量
计算acc !== A，如果为真，则跳转到分支B。
指令功能未使能，暂不可用。
默认入参：acc
A：寄存器索引
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
R：方舟运行时内部使用的8位保留数字
A：对象
将当前函数的隐式参数NewTarget存放到acc中。
指令功能未使能，暂不可用。
R：方舟运行时内部使用的8位保留数字
A：string id
B：指代正则表达式修饰符
使用索引A对应的字符串和B指代的修饰符，创建一个正则表达式，并存放到acc中。
B和所指代的修饰符的对应关系为：0（默认值，无修饰符），1（g），2（i），4（m），8（s），16（u），32（y）；B也可以指代符合语法规范的修饰符的组合，例如3，指代的修饰符是gi。
R：方舟运行时内部使用的16位保留数字
A：string id
B：指代正则表达式修饰符
使用索引A对应的字符串和B指代的修饰符，创建一个正则表达式，并存放到acc中。
B和所指代的修饰符的对应关系为：0（默认值，无修饰符），1（g），2（i），4（m），8（s），16（u），32（y）；B也可以指代符合语法规范的修饰符的组合，例如3，指代的修饰符是gi。
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：参数数量
B,..., B + A - 1：参数
R：方舟运行时内部使用的16位保留数字
A：method id
B：方法A的形参数量
R：方舟运行时内部使用的16位保留数字
A：类的构造函数的method id
B：literal id
C：方法A的形参数量
D：父类
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
A：值
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：对象
B：属性键值
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：对象
B：属性键值
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：string id
B：对象
默认入参：acc：值
A：槽位号
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：string id
R：方舟运行时内部使用的16位保留数字
A：literal id
R：方舟运行时内部使用的16位保留数字
A：literal id
R：方舟运行时内部使用的16位保留数字
A：参数数量
B：类对象
B + 1, ..., B + A - 1：传递给构造函数的参数
默认入参：acc：对象
R：方舟运行时内部使用的16位保留数字
默认入参：acc：属性键值
R：方舟运行时内部使用的16位保留数字
A：对象
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：对象
B：属性键值
默认入参：acc：属性键值
R：方舟运行时内部使用的16位保留数字
A：对象
默认入参：acc：对象
R：方舟运行时内部使用的16位保留数字
A：属性键值
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：对象
B：属性键值
A：词法环境层级
B：槽位号
默认入参：acc：值
A：词法环境层级
B：槽位号
R：方舟运行时内部使用的16位保留数字
A：string id
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：string id
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：string id
B：对象
默认入参：acc：对象
R：方舟运行时内部使用的16位保留数字
A：string id
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：string id
B：对象
默认入参：acc：对象
R：方舟运行时内部使用的16位保留数字
A：string id
R：方舟运行时内部使用的16位保留数字
A：string id
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：string id
默认入参：acc：属性键值
R：方舟运行时内部使用的16位保留数字
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：属性键值
默认入参：acc：异常
A：生成器
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：对象
B：属性键值
默认入参：acc：值
A：有符号的分支偏移量
默认入参：acc：值
A：有符号的分支偏移量
默认入参：acc：值
A：有符号的分支偏移量
默认入参：acc：值
A：有符号的分支偏移量
计算acc === 0，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc !== 0，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc == null，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc != null，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc === null，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc !== null，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc == undefined，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc != undefined，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc === undefined，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：有符号的分支偏移量
计算acc !== undefined，如果为真，则跳转到分支A。
指令功能未使能，暂不可用。
默认入参：acc：值
A：值
B：有符号的分支偏移量
计算acc == A，如果为真，则跳转到分支B。
指令功能未使能，暂不可用。
默认入参：acc：值
A：值
B：有符号的分支偏移量
计算acc != A，如果为真，则跳转到分支B。
指令功能未使能，暂不可用。
默认入参：acc：值
A：值
B：有符号的分支偏移量
计算acc === A，如果为真，则跳转到分支B。
指令功能未使能，暂不可用。
默认入参：acc：值
A：值
B：有符号的分支偏移量
计算acc !== A，如果为真，则跳转到分支B。
指令功能未使能，暂不可用。
默认入参：acc：对象
R：方舟运行时内部使用的16位保留数字
R：方舟运行时内部使用的16位保留数字
A：对象
A：对象
B：布尔值
A：范围寄存器数量
B：对象
C, ..., C + A：属性键值
基于对象B，创建一个排除了键值C, ..., C + A的对象，并将其存放到acc中。
这个指令用于支持使用析构和扩展语法创建对象。
默认入参：acc：参数列表
R：方舟运行时内部使用的8位保留数字
A：类对象
默认入参：acc：参数列表
R：方舟运行时内部使用的16位保留数字
A：类对象
A：词法环境中的槽位数量
B：literal id
A：生成器
B：对象
C：布尔值
默认入参：acc：类对象
R：方舟运行时内部使用的8位保留数字
A：参数列表
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：对象
B：参数列表
默认入参：acc：类对象
R：方舟运行时内部使用的8位保留数字
A：参数数量
B, ..., B + A - 1：参数
以B, ..., B + A - 1作为参数，调用acc中所存类的父类的构造函数，并将结果存放到acc中。
如果A的值为0，则B为undefined。
此指令仅出现在箭头函数中。
默认入参：acc：是否需要为访问器设置名称，是一个布尔值
A：对象
B：属性键值
C：getter函数对象
D：setter函数对象
以getter方法 C和setter方法 D作为参数，定义对象A的键值为B的属性的访问器，并将结果对象存放到acc中。
如果C是undefined，则不会设置getter，如果D是undefined，则不会设置setter。
默认入参：acc：类对象或类对象的对象原型，方法为静态方法时，acc中是类对象
R：方舟运行时内部使用的16位保留数字
A：method id
B：方法A的形参数量
默认入参：acc：对象
R：方舟运行时内部使用的16位保留数字
默认入参：acc：属性键值
A：对象
默认入参：acc：值
A：生成器
默认入参：acc：值
A：函数对象
默认入参：acc：对象
A：目标对象
默认入参：acc：值
A：数组
B：数组索引
默认入参：acc：对象
R：方舟运行时内部使用的16位保留数字
A：值
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：对象
B：属性键值
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：对象
B：属性键值
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：对象
B：属性键值
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：对象
B：属性键值
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：string id
B：对象
默认入参：acc：值
A：异步的函数对象
默认入参：acc：值
A：异步的函数对象
默认入参：acc：值
R：方舟运行时内部使用的8位保留数字
A：string id
B：对象
在当前函数中，将acc中的值存放到super的键值为索引A对应的字符串的属性上。
若该属性为访问器属性，则将B中的对象作为调用该属性setter函数时的this参数。
默认入参：acc：值
R：方舟运行时内部使用的16位保留数字
A：string id
B：对象
在当前函数中，将acc中的值存放到super的键值为索引A对应的字符串的属性上。
若该属性为访问器属性，则将B中的对象作为调用该属性setter函数时的this参数。
默认入参：acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：对象
B：属性键值
默认入参：acc：函数对象
R：方舟运行时内部使用的16位保留数字
A：string id
B：对象
默认入参：acc：生成器对象
A：生成器状态
将acc中存放的generator的状态设置为A (参考：GeneratorState和AsyncGeneratorState)
A可能的值有以下几项：undefined(0x0)、suspendedStart(0x1)、suspendedYield(0x2)、executing(0x3)、completed(0x4)和awaitingReturn(0x5)。
默认入参：acc：对象
R：方舟运行时内部使用的8位保留数字
默认入参：acc：对象
A：词法环境层级
B：槽位号
A：词法环境层级
B：槽位号
C：对象
默认入参：acc：对象
A：词法环境层级
B：槽位号
默认入参：acc：值
A：string id
B：对象
默认入参：acc：值
A：string id
B：对象
将并发函数的返回值通知运行时。
此指令仅出现在并发函数中。
A：范围寄存器数量
B：对象
C, ..., C + A：属性键值
基于对象B，创建一个排除了键值C, ..., C + A的对象，并将其存放到acc中。
这个指令用例支持使用析构和扩展语法创建对象。
默认入参：acc：值
A：属性键值
B：对象
A：参数数量
B：类对象
B + 1, ..., B + A - 1：传递给构造函数的参数
默认入参：acc：值
A：属性键值
B：对象
A：词法环境中的槽位数量
B：literal id
A：要创建的符号数量
B：literal id
创建A个符号；从索引B对应的字面量数组中获取存放的私有方法，如果其中存在私有实例方法，则额外创建一个符号（\"method\"），将所有创建出的符号按照创建顺序，依次放到当前类所在的词法环境的末尾。
此指令仅出现在定义类的时候。
默认入参：acc：函数对象
A：参数数量
B, ..., B + A - 1：参数
默认入参：acc：值
A：词法环境层数
B：槽位号
C：对象
默认入参：acc：函数对象
A：参数数量
B：对象
B + 1, ..., B + A：参数
acc：函数对象
R：方舟运行时内部使用的8位保留数字
A：对象
A：参数数量
B, ..., B + A - 1：参数
以B, ..., B + A - 1作为参数, 调用super函数，并将结果存放到acc中。
当A的值是0时，B是undefined。
此指令仅出现在非箭头函数中。
A：对象
B：对象名称
R：方舟运行时内部使用的16位保留数字
A：sendable class的构造函数的method id
B：literal id
C：方法A的形参数量
D：父类
默认入参：acc：类对象
A：参数数量
B, ..., B + A - 1:参数
以B, ..., B + A - 1作为参数，调用acc中所存类的父类的构造函数，并将结果存放到acc中。
如果A的值为0，则B为undefined。
此指令仅出现在箭头函数中。
默认入参：acc：对象
A：错误种类
默认入参：acc：对象
A：属性键值
默认入参：acc：对象
A：错误种类
默认入参：acc：值
A：对象
B：属性键值
默认入参：acc：对象
A：string id
默认入参：acc：值
A：对象
B：属性键值
A：词法环境层级
B：槽位号
默认入参：acc：值
A：共享词法环境层级
B：槽位号
默认入参：acc：值
A：词法环境层级
B：槽位号
默认入参：acc：值
A：共享词法环境层级
B：槽位号
默认入参：acc：值
A：共享词法环境层级
B：槽位号
默认入参：acc：值
A：槽位号
A：共享词法环境层级
B：槽位号
A：共享词法环境层级
B：槽位号
A：共享词法环境层级
B：槽位号
将槽位号为A的补丁变量加载到acc中。
此指令仅出现在补丁模式编译场景下。
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
默认入参：acc：值
A：补丁变量槽位号
将acc中的值存放进槽位号为A的补丁变量中。
此指令仅出现在补丁模式编译场景下。
默认入参：acc：操作数
R：方舟运行时内部使用的8位保留数字
0x14fc
0x15fc
...
0x2efc

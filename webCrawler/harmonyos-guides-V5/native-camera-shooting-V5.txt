拍照(C/C++)
拍照是相机的最重要功能之一，拍照模块基于相机复杂的逻辑，为了保证用户拍出的照片质量，在中间步骤可以设置分辨率、闪光灯、焦距、照片质量及旋转角度等信息。
开发步骤
详细的API说明请参考Camera API参考。
 导入NDK接口，接口中提供了相机相关的属性和方法，导入方法如下。  // 导入NDK接口头文件\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <string.h>\n#include \"hilog/log.h\"\n#include \"ohcamera/camera.h\"\n#include \"ohcamera/camera_input.h\"\n#include \"ohcamera/capture_session.h\"\n#include \"ohcamera/photo_output.h\"\n#include \"ohcamera/preview_output.h\"\n#include \"ohcamera/video_output.h\"\n#include \"ohcamera/camera_manager.h\"\n#include <multimedia/image_framework/image/image_native.h> 在CMake脚本中链接相关动态库。 target_link_libraries(entry PUBLIC\n    libace_napi.z.so\n    libhilog_ndk.z.so\n    libnative_buffer.so\n    libohcamera.so\n    libohimage.so\n    libohfileuri.so\n) 创建并打开相机设备，参考 设备输入(C/C++)步骤3-5。 选择设备支持的输出流能力，创建拍照输出流。 通过OH_CameraManager_CreatePhotoOutputWithoutSurface()方法创建拍照输出流。 void CreatePhotoOutput() {\n    Camera_Manager *cameraManager = nullptr;\n    Camera_Device *cameras = nullptr;\n    Camera_OutputCapability *cameraOutputCapability = nullptr;\n    Camera_PhotoOutput *photoOutput = nullptr;\n    const Camera_Profile *photoProfile = nullptr;\n    uint32_t size = 0;\n    uint32_t cameraDeviceIndex = 0;\n    Camera_ErrorCode ret = OH_Camera_GetCameraManager(&cameraManager);\n    if (cameraManager == nullptr || ret != CAMERA_OK) {\n        OH_LOG_ERROR(LOG_APP, \"OH_Camera_GetCameraManager failed.\");\n    }\n    ret = OH_CameraManager_GetSupportedCameras(cameraManager, &cameras, &size);\n    if (cameras == nullptr || size < 0 || ret != CAMERA_OK) {\n        OH_LOG_ERROR(LOG_APP, \"OH_CameraManager_GetSupportedCameras failed.\");\n    }\n    ret = OH_CameraManager_GetSupportedCameraOutputCapability(cameraManager, &cameras[cameraDeviceIndex],\n                                                              &cameraOutputCapability);\n    if (cameraOutputCapability == nullptr || ret != CAMERA_OK) {\n        OH_LOG_ERROR(LOG_APP, \"GetSupportedCameraOutputCapability failed.\");\n    }\n    photoProfile = cameraOutputCapability->photoProfiles[0];\n    if (photoProfile == nullptr) {\n        OH_LOG_ERROR(LOG_APP, \"Get photoProfiles failed.\");\n    }\n    // 无需传入surfaceId，直接创建拍照流\n    ret = OH_CameraManager_CreatePhotoOutputWithoutSurface(cameraManager, photoProfile, &photoOutput);\n    if (photoOutput == nullptr || ret != CAMERA_OK) {\n        OH_LOG_ERROR(LOG_APP, \"OH_CameraManager_CreatePhotoOutputWithoutSurface failed.\");\n    }\n} 注册单段式(PhotoAvailable)拍照回调，若应用希望快速得到回图，推荐使用分段式拍照回调(PhotoAssetAvailable)。     如果已经注册了PhotoAssetAvailable回调，并且在Session开始之后又注册了PhotoAvailable回调，PhotoAssetAvailable和PhotoAvailable同时注册，会导致流被重启，仅PhotoAssetAvailable生效。 不建议开发者同时注册PhotoAssetAvailable和PhotoAvailable。   单段式拍照开发流程（PhotoAssetAvailable）：  在会话commitConfig前注册单段式拍照回调。 在单段式拍照回调函数中获取图片信息，解析出buffer数据，做自定义业务处理。 将处理完的buffer通过回调传给ArkTS侧，做图片显示或通过安全控件写文件保存图片。 使用完后解注册单段式拍照回调函数。  // 保存NAPI侧注册的buffer处理回调函数\nstatic void *bufferCb = nullptr;\nCamera_ErrorCode NDKCamera::RegisterBufferCb(void *cb) {\n    OH_LOG_INFO(LOG_APP, \" RegisterBufferCb start\");\n    if (cb == nullptr) {\n        OH_LOG_INFO(LOG_APP, \" RegisterBufferCb invalid error\");\n        return CAMERA_INVALID_ARGUMENT;\n    }\n    bufferCb = cb;\n    return CAMERA_OK;\n}\n\n// 单段式拍照回调函数\nvoid OnPhotoAvailable(Camera_PhotoOutput *photoOutput, OH_PhotoNative *photo) {\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable start!\");\n    OH_ImageNative *imageNative;\n    Camera_ErrorCode errCode = OH_PhotoNative_GetMainImage(photo, &imageNative);\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable errCode:%{public}d imageNative:%{public}p\", errCode, imageNative);\n    // 读取OH_ImageNative的 size 属性\n    Image_Size size;\n    Image_ErrorCode imageErr = OH_ImageNative_GetImageSize(imageNative, &size);\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable imageErr:%{public}d width:%{public}d height:%{public}d\", imageErr,\n                 size.width, size.height);\n    // 读取OH_ImageNative的组件列表的元素个数。\n    size_t componentTypeSize = 0;\n    imageErr = OH_ImageNative_GetComponentTypes(imageNative, nullptr, &componentTypeSize);\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable imageErr:%{public}d componentTypeSize:%{public}zu\", imageErr,\n                 componentTypeSize);\n    // 读取OH_ImageNative的组件列表。\n    uint32_t *components = new uint32_t[componentTypeSize];\n    imageErr = OH_ImageNative_GetComponentTypes(imageNative, &components, &componentTypeSize);\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable OH_ImageNative_GetComponentTypes imageErr:%{public}d\", imageErr);\n    // 读取OH_ImageNative的第一个组件所对应的缓冲区对象\n    OH_NativeBuffer *nativeBuffer = nullptr;\n    imageErr = OH_ImageNative_GetByteBuffer(imageNative, components[0], &nativeBuffer);\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable OH_ImageNative_GetByteBuffer imageErr:%{public}d\", imageErr);\n    // 读取OH_ImageNative的第一个组件所对应的缓冲区大小\n    size_t nativeBufferSize = 0;\n    imageErr = OH_ImageNative_GetBufferSize(imageNative, components[0], &nativeBufferSize);\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable imageErr:%{public}d nativeBufferSize:%{public}zu\", imageErr,\n                 nativeBufferSize);\n    // 读取OH_ImageNative的第一个组件所对应的像素行宽。\n    int32_t rowStride = 0;\n    imageErr = OH_ImageNative_GetRowStride(imageNative, components[0], &rowStride);\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable imageErr:%{public}d rowStride:%{public}d\", imageErr, rowStride);\n    // 读取OH_ImageNative的第一个组件所对应的像素大小。\n    int32_t pixelStride = 0;\n    imageErr = OH_ImageNative_GetPixelStride(imageNative, components[0], &pixelStride);\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable imageErr:%{public}d pixelStride:%{public}d\", imageErr, pixelStride);\n    // 将ION内存映射到进程空间\n    void *virAddr = nullptr; // 指向映射内存的虚拟地址，解除映射后这个指针将不再有效\n    int32_t ret = OH_NativeBuffer_Map(nativeBuffer, &virAddr); // 映射后通过第二个参数virAddr返回内存的首地址\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable OH_NativeBuffer_Map err:%{public}d\", ret);\n    // 调用NAPI层buffer回调\n    auto cb = (void (*)(void *, size_t))(bufferCb);\n    cb(virAddr, nativeBufferSize);\n    // 释放资源\n    delete[] components;\n    OH_ImageNative_Release(imageNative);\n    ret = OH_NativeBuffer_Unmap(nativeBuffer); // 在处理完之后，解除映射并释放缓冲区\n    if (ret != 0) {\n        OH_LOG_ERROR(LOG_APP, \"OnPhotoAvailable OH_NativeBuffer_Unmap error:%{public}d\", ret);\n    }\n    OH_LOG_INFO(LOG_APP, \"OnPhotoAvailable end\");\n}\n\n// 注册单段式拍照回调\nCamera_ErrorCode NDKCamera::PhotoOutputRegisterPhotoAvailableCallback(Camera_PhotoOutput* photoOutput) {\n    OH_LOG_INFO(LOG_APP, \"PhotoOutputRegisterPhotoAvailableCallback start!\");\n    Camera_ErrorCode errCode = OH_PhotoOutput_RegisterPhotoAvailableCallback(photoOutput, OnPhotoAvailable);\n    if (errCode != CAMERA_OK) {\n        OH_LOG_ERROR(LOG_APP, \"PhotoOutputRegisterPhotoAvailableCallback failed.\");\n    }\n    OH_LOG_INFO(LOG_APP, \"PhotoOutputRegisterPhotoAvailableCallback return with ret code: %{public}d!\", errCode);\n    return errCode;\n}\n\n// 解注册单段式拍照回调\nCamera_ErrorCode NDKCamera::PhotoOutputUnRegisterPhotoAvailableCallback(Camera_PhotoOutput* photoOutput) {\n    OH_LOG_INFO(LOG_APP, \"PhotoOutputUnRegisterPhotoAvailableCallback start!\");\n    ret_ = OH_PhotoOutput_UnregisterPhotoAvailableCallback(photoOutput, OnPhotoAvailable);\n    if (ret_ != CAMERA_OK) {\n        OH_LOG_ERROR(LOG_APP, \"PhotoOutputUnRegisterPhotoAvailableCallback failed.\");\n    }\n    OH_LOG_INFO(LOG_APP, \"PhotoOutputUnRegisterPhotoAvailableCallback return with ret code: %{public}d!\", ret_);\n    return ret_;\n} NAPI层buffer回处理参考示例代码： static napi_ref bufferCbRef_ = nullptr;\nstatic napi_env env_;\nsize_t g_size = 0;\n\n// NAPI层buffer回调方法\nstatic void BufferCb(void *buffer, size_t size) {\n    OH_LOG_INFO(LOG_APP, \"BufferCb size:%{public}zu\", size);\n    g_size = size;\n    napi_value asyncResource = nullptr;\n    napi_value asyncResourceName = nullptr;\n    napi_async_work work;\n\n    void *copyBuffer = malloc(size);\n    if (copyBuffer == nullptr) {\n        return;\n    }\n    OH_LOG_INFO(LOG_APP, \"BufferCb copyBuffer:%{public}p\", copyBuffer);\n    // 使用 std::memcpy 复制 buffer 的内容到 copyBuffer\n    std::memcpy(copyBuffer, buffer, size);\n    napi_create_string_utf8(env_, \"BufferCb\", NAPI_AUTO_LENGTH, &asyncResourceName);\n    napi_status status = napi_create_async_work(\n        env_, asyncResource, asyncResourceName, [](napi_env env, void *copyBuffer) {},\n        [](napi_env env, napi_status status, void *copyBuffer) {\n            napi_value retVal;\n            napi_value callback = nullptr;\n            void *data = nullptr;\n            napi_value arrayBuffer = nullptr;\n            size_t bufferSize = g_size;\n            napi_create_arraybuffer(env, bufferSize, &data, &arrayBuffer);\n            std::memcpy(data, copyBuffer, bufferSize);\n            OH_LOG_INFO(LOG_APP, \"BufferCb g_size: %{public}zu\", g_size);\n            napi_get_reference_value(env, bufferCbRef_, &callback);\n            if (callback) {\n                OH_LOG_INFO(LOG_APP, \"BufferCb callback is full\");\n            } else {\n                OH_LOG_ERROR(LOG_APP, \"BufferCb callback is null\");\n            }\n            // 调用ArkTS的buffer处理回调函数，将图片arrayBuffer传给页面做显示或保存\n            napi_call_function(env, nullptr, callback, 1, &arrayBuffer, &retVal);\n            // 清理内存\n            free(data); // 释放在异步工作中分配的内存\n        },\n        copyBuffer, &work);\n\n    // 错误检查：创建异步工作失败时释放内存\n    if (status != napi_ok) {\n        OH_LOG_ERROR(LOG_APP, \"Failed to create async work\");\n        free(copyBuffer); // 释放分配的内存\n        return;\n    }\n    napi_queue_async_work_with_qos(env_, work, napi_qos_user_initiated);\n}\n\n// 保存ArkTS侧传入的buffer处理回调函数\nstatic napi_value SetBufferCb(napi_env env, napi_callback_info info) {\n    OH_LOG_INFO(LOG_APP, \"SetBufferCb start\");\n    napi_value result;\n    napi_get_undefined(env, &result);\n\n    napi_value argValue[1] = {nullptr};\n    size_t argCount = 1;\n    napi_get_cb_info(env, info, &argCount, argValue, nullptr, nullptr);\n\n    env_ = env;\n    napi_create_reference(env, argValue[0], 1, &bufferCbRef_);\n    if (bufferCbRef_) {\n        OH_LOG_INFO(LOG_APP, \"SetBufferCb callbackRef is full\");\n    } else {\n        OH_LOG_ERROR(LOG_APP, \"SetBufferCb callbackRef is null\");\n    }\n    // 注册ArkTS侧buffer回调到NAPI层\n    ndkCamera_->RegisterBufferCb((void *)BufferCb);\n    return result;\n} ArkTS侧buffer处理参考示例代码： /*\n * Copyright (c) 2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { image } from '@kit.ImageKit';\nimport { photoAccessHelper } from '@kit.MediaLibraryKit';\nimport { fileIo } from '@kit.CoreFileKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport cameraDemo from 'libentry.so';\n\ninterface PhotoSettings {\n  quality: number, // Photo quality\n  rotation: number, // Photo direction\n  mirror: boolean, // Mirror Enable\n  latitude: number, // geographic location\n  longitude: number, // geographic location\n  altitude: number // geographic location\n};\n\n@Entry\n@Component\nstruct Index {\n  private mXComponentController: XComponentController = new XComponentController();\n  private surfaceId = '';\n  private file: fileIo.File | undefined;\n  @State imageWidth: number = 1920;\n  @State imageHeight: number = 1080;\n  @State showImage: boolean = false;\n  @State curPixelMap: image.PixelMap | undefined = undefined;\n  photoSettings: PhotoSettings = {\n    quality: 0,\n    rotation: 0,\n    mirror: false,\n    latitude: 12.9698,\n    longitude: 77.7500,\n    altitude: 1000\n  };\n  // ArrayBuffer处理回调函数\n  photoBufferCallback: (arrayBuffer: ArrayBuffer) => void = (arrayBuffer: ArrayBuffer) => {\n    console.info('photoBufferCallback')\n    // 处理方式一：创建PixelMap显示图片\n    let imageSource = image.createImageSource(arrayBuffer);\n    imageSource.createPixelMap((err: BusinessError, data: image.PixelMap) => {\n      this.curPixelMap = data;\n      this.showImage = true;\n    })\n    // 处理方式二：通过安全控件写文件保存图片\n    fileIo.write(this.file?.fd, arrayBuffer)\n      .then(() => {\n        console.info('file write OK');\n        // 关闭文件\n        fileIo.close(this.file);\n      }).catch(() => {\n      console.error('file write failed');\n    })\n  }\n\n  onPageShow(): void {\n  }\n\n  onPageHide(): void {\n    cameraDemo.releaseCamera();\n  }\n\n  build() {\n    Column() {\n      Column() {\n        if (!this.showImage) {\n          XComponent({\n            id: 'componentId',\n            type: 'surface',\n            controller: this.mXComponentController\n          })\n            .onLoad(async () => {\n              console.info('onLoad is called');\n              this.surfaceId = this.mXComponentController.getXComponentSurfaceId();\n              let surfaceRect: SurfaceRect = {\n                surfaceWidth: this.imageHeight,\n                surfaceHeight: this.imageWidth\n              };\n              this.mXComponentController.setXComponentSurfaceRect(surfaceRect);\n              console.info(`onLoad surfaceId: ${this.surfaceId}`);\n              // 调用NDK接口初始化相机\n              await cameraDemo.initCamera(this.surfaceId);\n              // 注册ArkTS侧buffer处理回调\n              cameraDemo.setBufferCb(this.photoBufferCallback);\n            })// The width and height of the surface are opposite to those of the XComponent.\n            .width(px2vp(this.imageHeight))\n            .height(px2vp(this.imageWidth))\n        }\n\n        if (this.showImage) {\n          // 显示拍照得到的图片\n          Image(this.curPixelMap)\n            .width(px2vp(this.imageHeight))\n            .height(px2vp(this.imageWidth))\n        }\n\n      }\n      .justifyContent(FlexAlign.Center)\n      .height('80%')\n\n        // 安全控件，用来保存媒体资源\n        SaveButton({text:SaveDescription.SAVE_IMAGE}).onClick(async (event: ClickEvent, result: SaveButtonOnClickResult) => {\n          if (result == SaveButtonOnClickResult.SUCCESS) {\n            try {\n              const context = getContext(this);\n              let helper = photoAccessHelper.getPhotoAccessHelper(context);\n              // onClick触发后10秒内通过createAsset接口创建图片文件，10秒后createAsset权限收回。\n              let uri = await helper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'jpg');\n              console.error('uri:' + uri);\n              // 使用uri打开文件，可以持续写入内容，写入过程不受时间限制\n              this.file = await fileIo.open(uri, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);\n              // 调用NDK接口拍照，触发PhotoAvailable回调\n              cameraDemo.takePictureWithSettings(this.photoSettings);\n            } catch (error) {\n              console.error(\"error is \" + JSON.stringify(error));\n            }\n          }\n        })\n\n        Text('NdkPhotoAvailableDemo')\n          .fontSize(30)\n    }\n    .justifyContent(FlexAlign.End)\n    .height('100%')\n    .width('100%')\n  }\n} 创建拍照类型会话，参考会话管理(C/C++)，开启会话，准备拍照。 // 创建相机会话\nCamera_CaptureSession* captureSession = nullptr;\nCamera_ErrorCode ret = OH_CameraManager_CreateCaptureSession(cameraManager, &captureSession);\nif (captureSession == nullptr || ret != CAMERA_OK) {\n    OH_LOG_ERROR(LOG_APP, \"OH_CameraManager_CreateCaptureSession failed.\");\n}\n// 设置会话模式为拍照模式\nCamera_SceneMode sceneMode = NORMAL_PHOTO;\nret = OH_CaptureSession_SetSessionMode(captureSession, sceneMode); \n// 配置会话开始\nret = OH_CaptureSession_BeginConfig(captureSession); 配置拍照参数（可选）。 配置相机的参数可以调整拍照的一些功能，包括闪光灯、变焦、焦距等。 // 判断设备是否支持闪光灯\n Camera_FlashMode flashMode = FLASH_MODE_AUTO;\n bool hasFlash = false;\n ret = OH_CaptureSession_HasFlash(captureSession, &hasFlash);\n if (ret != CAMERA_OK) {\n     OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_HasFlash failed.\");\n }\n if (hasFlash) {\n     OH_LOG_INFO(LOG_APP, \"hasFlash success\");\n } else {\n     OH_LOG_ERROR(LOG_APP, \"hasFlash fail\");\n }\n // 检测闪光灯模式是否支持\n bool isSupported = false;\n ret = OH_CaptureSession_IsFlashModeSupported(captureSession, flashMode, &isSupported);\n if (ret != CAMERA_OK) {\n     OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_IsFlashModeSupported failed.\");\n }\n if (isSupported) {\n     OH_LOG_INFO(LOG_APP, \"isFlashModeSupported success\");\n     // 设置闪光灯模式\n     ret = OH_CaptureSession_SetFlashMode(captureSession, flashMode);\n     if (ret == CAMERA_OK) {\n         OH_LOG_INFO(LOG_APP, \"OH_CaptureSession_SetFlashMode success.\");\n     } else {\n         OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_SetFlashMode failed. %{public}d \", ret);\n     }\n     // 获取当前设备的闪光灯模式\n     ret = OH_CaptureSession_GetFlashMode(captureSession, &flashMode);\n     if (ret == CAMERA_OK) {\n         OH_LOG_INFO(LOG_APP, \"OH_CaptureSession_GetFlashMode success. flashMode：%{public}d \", flashMode);\n     } else {\n         OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_GetFlashMode failed. %d \", ret);\n     }\n } else {\n     OH_LOG_ERROR(LOG_APP, \"isFlashModeSupported fail\");\n }\n\n // 判断是否支持连续自动变焦模式\n Camera_FocusMode focusMode = FOCUS_MODE_CONTINUOUS_AUTO;\n bool isFocusModeSupported = false;\n ret = OH_CaptureSession_IsFocusModeSupported(captureSession, focusMode, &isFocusModeSupported);\n if (ret != CAMERA_OK) {\n     OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_IsFocusModeSupported failed.\");\n }\n if (isFocusModeSupported) {\n     OH_LOG_INFO(LOG_APP, \"isFocusModeSupported success\");\n     ret = OH_CaptureSession_SetFocusMode(captureSession, focusMode);\n     if (ret != CAMERA_OK) {\n         OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_SetFocusMode failed. %{public}d \", ret);\n     }\n     ret = OH_CaptureSession_GetFocusMode(captureSession, &focusMode);\n     if (ret == CAMERA_OK) {\n         OH_LOG_INFO(LOG_APP, \"OH_CaptureSession_GetFocusMode success. focusMode%{public}d \", focusMode);\n     } else {\n         OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_GetFocusMode failed. %d \", ret);\n     }\n } else {\n     OH_LOG_ERROR(LOG_APP, \"isFocusModeSupported fail\");\n }\n\n // 获取相机支持的可变焦距比范围\n float minZoom;\n float maxZoom;\n ret = OH_CaptureSession_GetZoomRatioRange(captureSession, &minZoom, &maxZoom);\n if (ret != CAMERA_OK) {\n     OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_GetZoomRatioRange failed.\");\n } else {\n     OH_LOG_INFO(LOG_APP, \"OH_CaptureSession_GetZoomRatioRange success. minZoom: %{public}f, maxZoom:%{public}f\",\n         minZoom, maxZoom);\n }\n // 设置变焦\n ret = OH_CaptureSession_SetZoomRatio(captureSession, maxZoom);\n if (ret == CAMERA_OK) {\n     OH_LOG_INFO(LOG_APP, \"OH_CaptureSession_SetZoomRatio success.\");\n } else {\n     OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_SetZoomRatio failed. %{public}d \", ret);\n }\n // 获取当前设备的变焦值\n ret = OH_CaptureSession_GetZoomRatio(captureSession, &maxZoom);\n if (ret == CAMERA_OK) {\n     OH_LOG_INFO(LOG_APP, \"OH_CaptureSession_GetZoomRatio success. zoom：%{public}f \", maxZoom);\n } else {\n     OH_LOG_ERROR(LOG_APP, \"OH_CaptureSession_GetZoomRatio failed. %{public}d \", ret);\n } 触发拍照。 通过OH_PhotoOutput_Capture()方法，执行拍照任务。  ret = OH_PhotoOutput_Capture(photoOutput);\n if (ret == CAMERA_OK) {\n     OH_LOG_INFO(LOG_APP, \"OH_PhotoOutput_Capture success \");\n } else {\n     OH_LOG_ERROR(LOG_APP, \"OH_PhotoOutput_Capture failed. %d \", ret);\n } 
状态监听
在相机应用开发过程中，可以随时监听拍照输出流状态，包括拍照流开始、拍照帧的开始与结束、拍照输出流的错误。
 通过注册固定的onFrameStart回调函数获取监听拍照开始结果，photoOutput创建成功时即可监听，拍照第一次曝光时触发。   ret = OH_PhotoOutput_RegisterCallback(photoOutput, GetPhotoOutputListener());\n  if (ret != CAMERA_OK) {\n      OH_LOG_ERROR(LOG_APP, \"OH_PhotoOutput_RegisterCallback failed.\");\n  }   void PhotoOutputOnFrameStart(Camera_PhotoOutput* photoOutput)\n  {\n      OH_LOG_INFO(LOG_APP, \"PhotoOutputOnFrameStart\");\n  }\n  void PhotoOutputOnFrameShutter(Camera_PhotoOutput* photoOutput, Camera_FrameShutterInfo* info)\n  {\n      OH_LOG_INFO(LOG_APP, \"PhotoOutputOnFrameShutter\");\n  }\n  PhotoOutput_Callbacks* GetPhotoOutputListener()\n  {\n      static PhotoOutput_Callbacks photoOutputListener = {\n          .onFrameStart = PhotoOutputOnFrameStart,\n          .onFrameShutter = PhotoOutputOnFrameShutter,\n          .onFrameEnd = PhotoOutputOnFrameEnd,\n          .onError = PhotoOutputOnError\n      };\n      return &photoOutputListener;\n  } 通过注册固定的onFrameEnd回调函数获取监听拍照结束结果，photoOutput创建成功时即可监听。   void PhotoOutputOnFrameEnd(Camera_PhotoOutput* photoOutput, int32_t frameCount)\n  {\n      OH_LOG_INFO(LOG_APP, \"PhotoOutput frameCount = %{public}d\", frameCount);\n  } 通过注册固定的onError回调函数获取监听拍照输出流的错误结果。callback返回拍照输出接口使用错误时的对应错误码，错误码类型参见Camera_ErrorCode。   void PhotoOutputOnError(Camera_PhotoOutput* photoOutput, Camera_ErrorCode errorCode)\n  {\n      OH_LOG_INFO(LOG_APP, \"PhotoOutput errorCode = %{public}d\", errorCode);\n  } 

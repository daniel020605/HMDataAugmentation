线性容器
线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、List、LinkedList、Deque、Queue、Stack七种。
线性容器，充分考虑了数据访问的速度，运行时（Runtime）通过一条字节码指令就可以完成增、删、改、查等操作。
各线性容器类型特征对比
ArrayList
ArrayList即动态数组，可用来构造全局的数组对象。 当需要频繁读取集合中的元素时，推荐使用ArrayList。
ArrayList依据泛型定义，要求存储位置是一片连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容大小为原始容量的1.5倍。
ArrayList进行增、删、改、查操作的常用API如下：
List
List可用来构造一个单向链表对象，即只能通过头结点开始访问到尾节点。List依据泛型定义，在内存中的存储位置可以是不连续的。
List和LinkedList相比，LinkedList是双向链表，可以快速地在头尾进行增删，而List是单向链表，无法双向操作。
当需要频繁的插入删除元素，并且需要使用单向链表时，推荐使用List高效操作。
可以通过get/set等接口对存储的元素进行修改，List进行增、删、改、查操作的常用API如下：
LinkedList
LinkedList可用来构造一个双向链表对象，可以在某一节点向前或者向后遍历List。LinkedList依据泛型定义，在内存中的存储位置可以是不连续的。
LinkedList和List相比，LinkedList是双向链表，可以快速地在头尾进行增删，而List是单向链表，无法双向操作。
LinkedList和ArrayList相比，插入数据效率LinkedList优于ArrayList，而查询效率ArrayList优于LinkedList。
当需要频繁的插入删除元素，并且需要使用双向链表时，推荐使用LinkedList高效操作。
可以通过get/set等接口对存储的元素进行修改，LinkedList进行增、删、改、查操作的常用API如下：
Deque
Deque可用来构造双端队列对象，存储元素遵循先进先出以及先进后出的规则，双端队列可以分别从队头或者队尾进行访问。
Deque依据泛型定义，要求存储位置是一片连续的内存空间，其初始容量大小为8，并支持动态扩容，每次扩容大小为原始容量的2倍。Deque底层采用循环队列实现，入队及出队操作效率都比较高。
Deque和Queue相比，Deque允许在两端执行增删元素的操作，Queue只能在头部删除元素，尾部增加元素。
Deque和Vector相比，它们都支持在两端增删元素，但Deque不能进行中间插入的操作。对头部元素的插入删除效率高于Vector，而Vector访问元素的效率高于Deque。
需要频繁在集合两端进行增删元素的操作时，推荐使用Deque。
Deque进行增、删、改、查操作的常用API如下：
Queue
Queue可用来构造队列对象，存储元素遵循先进先出的规则。
Queue依据泛型定义，要求存储位置是一片连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容大小为原始容量的2倍。
Queue底层采用循环队列实现，入队及出队操作效率都比较高。
Queue和Deque相比，Queue只能在一端删除一端增加，Deque可以两端增删。
一般符合先进先出的场景可以使用Queue。
Queue进行增、删、改、查操作的常用API如下：
Stack
Stack可用来构造栈对象，存储元素遵循先进后出的规则。
Stack依据泛型定义，要求存储位置是一片连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容大小为原始容量的1.5倍。Stack底层基于数组实现，入栈出栈均从数组的一端操作。
Stack和Queue相比，Queue基于循环队列实现，只能在一端删除，另一端插入，而Stack都在一端操作。
一般符合先进后出的场景可以使用Stack。
Stack进行增、删、改、查操作的常用API如下：
Vector
API version 9开始，该接口不再维护，推荐使用ArrayList。
Vector是指连续存储结构，可用来构造全局的数组对象。Vector依据泛型定义，要求存储位置是一片连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容大小为原始容量的2倍。
Vector和ArrayList相似，都是基于数组实现，但Vector提供了更多操作数组的接口。Vector在支持操作符访问的基础上，还增加了get/set接口，提供更为完善的校验及容错机制，满足用户不同场景下的需求。
Vector进行增、删、改、查操作的常用API如下：
线性容器的使用
此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改等操作。示例代码如下所示：
// ArrayList\nimport { ArrayList } from '@kit.ArkTS'; // 导入ArrayList模块\n\nlet arrayList1: ArrayList<string> = new ArrayList();\narrayList1.add('a'); // 增加一个值为'a'的元素\nlet arrayList2: ArrayList<number> = new ArrayList();\narrayList2.add(1); // 增加一个值为1的元素\nconsole.info(`result: ${arrayList2[0]}`); // 访问索引为0的元素。输出：result: 1\narrayList1[0] = 'one'; // 修改索引为0的元素\nconsole.info(`result: ${arrayList1[0]}`); // 输出：result: one\n\n// Deque\nimport { Deque } from '@kit.ArkTS'; // 导入Deque模块\n\nlet deque1: Deque<string> = new Deque();\ndeque1.insertFront('a'); // 头部增加一个值为'a'的元素\nlet deque2: Deque<number> = new Deque();\ndeque2.insertFront(1); // 头部增加一个值为1的元素\nconsole.info(`result: ${deque2.getFirst()}`); // 访问队列首部的元素。输出：result: 1\ndeque1.insertEnd('one'); // 尾部增加一个值为'one'的元素\nconsole.info(`result: ${deque1.getLast()}`); // 访问队列尾部的元素。输出：result: one\n\n// Stack\nimport { Stack } from '@kit.ArkTS'; // 导入Stack模块\n\nlet stack1: Stack<string> = new Stack();\nstack1.push('a'); // 向栈里增加一个值为'a'的元素\nlet stack2: Stack<number> = new Stack();\nstack2.push(1); // 向栈里增加一个值为1的元素\nconsole.info(`result: ${stack1.peek()}`); // 访问栈顶元素。输出：result: a\nconsole.info(`result: ${stack2.pop()}`); // 删除栈顶元素并返回该删除元素。输出：result: 1\nconsole.info(`result: ${stack2.length}`); // 输出：result: 0\n\n// List\nimport { List } from '@kit.ArkTS'; // 导入List模块\n\nlet list1: List<string> = new List();\nlist1.add('a'); // 增加一个值为'a'的元素\nlet list2: List<number> = new List();\nlist2.insert(0, 0); // 在0号位置插入（增加）一个值为0的元素\nlet list3: List<Array<number>> = new List();\nlet b2 = [1, 2, 3];\nlist3.add(b2); // 增加一个Array类型的元素\nconsole.info(`result: ${list1[0]}`); // 访问索引为0的元素。输出：result: a\nconsole.info(`result: ${list3.get(0)}`); // 访问索引为0的元素。输出：result: 1,2,3

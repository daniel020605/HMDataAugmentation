使用HKDF进行密钥派生
对应算法规格请查看密钥派生算法规格：HKDF。
开发步骤
 构造HKDFSpec对象，作为密钥派生参数进行密钥派生。 HKDFSpec是KdfSpec的子类，需要指定：  algName：指定算法'HKDF'。 key：原始密钥材料。 如果使用string类型，需要直接传入用于密钥派生的数据，而不是HexString、base64等字符串类型。同时需要确保该字符串为utf-8编码，否则派生结果会有差异。 salt：盐值。 info：可选的上下文与应用相关信息， 可为空，用于拓展短密钥。 keySize：目标密钥的字节长度，需要为正整数。  调用cryptoFramework.createKdf，指定字符串参数'HKDF|SHA256|EXTRACT_AND_EXPAND'，创建密钥派生算法为HKDF、HMAC函数摘要算法为SHA256、模式为提取和拓展的密钥派生函数对象（Kdf）。 输入HKDFSpec对象，调用Kdf.generateSecret进行密钥派生。 Kdf.generateSecret的多种调用形式如表所示。     接口名 返回方式    generateSecret(params: KdfSpec, callback: AsyncCallback<DataBlob>): void callback异步生成   generateSecret(params: KdfSpec): Promise<DataBlob> Promise异步生成   generateSecretSync(params: KdfSpec): DataBlob 同步生成    
 通过await返回结果： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n\nasync function kdfAwait() {\n  let keyData = new Uint8Array(buffer.from(\"012345678901234567890123456789\", \"utf-8\").buffer);\n  let saltData = new Uint8Array(buffer.from(\"0123456789\", \"utf-8\").buffer);\n  let infoData = new Uint8Array(buffer.from(\"infostring\", \"utf-8\").buffer);\n  let spec: cryptoFramework.HKDFSpec = {\n    algName: 'HKDF',\n    key: keyData,\n    salt: saltData,\n    info: infoData,\n    keySize: 32\n  };\n  let kdf = cryptoFramework.createKdf('HKDF|SHA256|EXTRACT_AND_EXPAND');\n  let secret = await kdf.generateSecret(spec);\n  console.info(\"key derivation output is \" + secret.data);\n} 通过Promise返回结果： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { buffer } from '@kit.ArkTS';\n\nfunction kdfPromise() {\n  let keyData = new Uint8Array(buffer.from(\"012345678901234567890123456789\", \"utf-8\").buffer);\n  let saltData = new Uint8Array(buffer.from(\"0123456789\", \"utf-8\").buffer);\n  let infoData = new Uint8Array(buffer.from(\"infostring\", \"utf-8\").buffer);\n  let spec: cryptoFramework.HKDFSpec = {\n    algName: 'HKDF',\n    key: keyData,\n    salt: saltData,\n    info: infoData,\n    keySize: 32\n  };\n  let kdf = cryptoFramework.createKdf('HKDF|SHA256|EXTRACT_AND_EXPAND');\n  let kdfPromise = kdf.generateSecret(spec);\n  kdfPromise.then((secret) => {\n    console.info(\"key derivation output is \" + secret.data);\n  }).catch((error: BusinessError) => {\n    console.error(\"key derivation error.\");\n  });\n} 通过同步方式返回结果： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { buffer } from '@kit.ArkTS';\n\nfunction kdfSync() {\n  let keyData = new Uint8Array(buffer.from(\"012345678901234567890123456789\", \"utf-8\").buffer);\n  let saltData = new Uint8Array(buffer.from(\"0123456789\", \"utf-8\").buffer);\n  let infoData = new Uint8Array(buffer.from(\"infostring\", \"utf-8\").buffer);\n  let spec: cryptoFramework.HKDFSpec = {\n    algName: 'HKDF',\n    key: keyData,\n    salt: saltData,\n    info: infoData,\n    keySize: 32\n  };\n  let kdf = cryptoFramework.createKdf('HKDF|SHA256|EXTRACT_AND_EXPAND');\n  let secret = kdf.generateSecretSync(spec);\n  console.info(\"[Sync]key derivation output is \" + secret.data);\n} 

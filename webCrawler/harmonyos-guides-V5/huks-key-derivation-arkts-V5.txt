密钥派生(ArkTS)
以HKDF和PBKDF为例，完成密钥派生。具体的场景介绍及支持的算法规格，请参考密钥生成支持的算法。
开发步骤
生成密钥
 指定密钥别名。 初始化密钥属性集，可指定参数HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识基于该密钥派生出的密钥是否由HUKS管理。  当TAG设置为HUKS_STORAGE_ONLY_USED_IN_HUKS时，表示基于该密钥派生出的密钥，由HUKS管理，可保证派生密钥全生命周期不出安全环境。 当TAG设置为HUKS_STORAGE_KEY_EXPORT_ALLOWED时，表示基于该密钥派生出的密钥，返回给调用方管理，由业务自行保证密钥安全。 若业务未设置TAG的具体值，表示基于该密钥派生出的密钥，即可由HUKS管理，也可返回给调用方管理，业务可在后续派生时再选择使用何种方式保护密钥。  调用generateKeyItem生成密钥，具体请参考密钥生成。 
除此之外，开发者也可以参考密钥导入，导入已有的密钥。
密钥派生
 获取密钥别名，指定对应的属性参数HuksOptions。 可指定参数HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG（可选），用于标识派生得到的密钥是否由HUKS管理。     生成 派生 规格    HUKS_STORAGE_ONLY_USED_IN_HUKS HUKS_STORAGE_ONLY_USED_IN_HUKS 密钥由HUKS管理   HUKS_STORAGE_KEY_EXPORT_ALLOWED HUKS_STORAGE_KEY_EXPORT_ALLOWED 密钥返回给调用方管理   未指定TAG具体值 HUKS_STORAGE_ONLY_USED_IN_HUKS 密钥由HUKS管理   未指定TAG具体值 HUKS_STORAGE_KEY_EXPORT_ALLOWED 密钥返回给调用方管理   未指定TAG具体值 未指定TAG具体值 密钥返回给调用方管理    注：派生时指定的TAG值，不可与生成时指定的TAG值冲突。表格中仅列举有效的指定方式。 调用initSession初始化密钥会话，并获取会话的句柄handle。 调用updateSession更新密钥会话。 调用finishSession结束密钥会话，完成派生。 
删除密钥
当密钥废弃不用时，需要调用deleteKeyItem删除密钥，具体请参考密钥删除。
开发案例
[h2]HKDF
/*\n * 以下以HKDF密钥的Promise操作使用为例\n */\nimport { huks } from '@kit.UniversalKeystoreKit';\n\n/*\n * 确定密钥别名和封装密钥属性参数集\n */\nlet srcKeyAlias = \"hkdf_Key\";\nlet deriveHkdfInData = \"deriveHkdfTestIndata\";\nlet handle: number;\nlet finishOutData: Uint8Array;\nlet HuksKeyDeriveKeySize = 32;\n/* 集成生成密钥参数集 */\nlet properties: Array<huks.HuksParam> = [\n  {\n    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n    value: huks.HuksKeyAlg.HUKS_ALG_AES,\n  }, {\n  tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_DIGEST,\n  value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n  value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n  value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,\n}];\n\nlet huksOptions: huks.HuksOptions = {\n  properties: properties,\n  inData: new Uint8Array(new Array())\n}\n/* 集成init时密钥参数集 */\nlet initProperties: Array<huks.HuksParam> = [{\n  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n  value: huks.HuksKeyAlg.HUKS_ALG_HKDF,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_DIGEST,\n  value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_DERIVE_KEY_SIZE,\n  value: HuksKeyDeriveKeySize,\n}];\n\nlet initOptions: huks.HuksOptions = {\n  properties: initProperties,\n  inData: new Uint8Array(new Array())\n}\n/* 集成finish时密钥参数集 */\nlet finishProperties: Array<huks.HuksParam> = [{\n  tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n  value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS,\n  value: true,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n  value: huks.HuksKeyAlg.HUKS_ALG_AES,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n  value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n  value:\n  huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |\n  huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_DIGEST,\n  value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,\n  value: StringToUint8Array(srcKeyAlias),\n}, {\n  tag: huks.HuksTag.HUKS_TAG_PADDING,\n  value: huks.HuksKeyPadding.HUKS_PADDING_NONE,\n}, {\n  tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n  value: huks.HuksCipherMode.HUKS_MODE_ECB,\n}];\nlet finishOptions: huks.HuksOptions = {\n  properties: finishProperties,\n  inData: new Uint8Array(new Array())\n}\n\nfunction StringToUint8Array(str: String) {\n  let arr: number[] = new Array();\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  return new Uint8Array(arr);\n}\n\nclass throwObject {\n  isThrow = false;\n}\n\nfunction generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise generateKeyItem`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await generateKeyItem(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: generateKeyItem failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: generateKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nfunction initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksSessionHandle>((resolve, reject) => {\n    try {\n      huks.initSession(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doInit`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await initSession(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);\n        handle = data.handle;\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doInit failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nfunction updateSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksOptions>((resolve, reject) => {\n    try {\n      huks.updateSession(handle, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicUpdateFunc(handle: number, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doUpdate`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await updateSession(handle, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nfunction finishSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksReturnResult>((resolve, reject) => {\n    try {\n      huks.finishSession(handle, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicFinishFunc(handle: number, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doFinish`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await finishSession(handle, huksOptions, throwObject)\n      .then((data) => {\n        finishOutData = data.outData as Uint8Array;\n        console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doFinish failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doFinish input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nfunction deleteKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      huks.deleteKeyItem(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicDeleteKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise deleteKeyItem`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await deleteKeyItem(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: deleteKeyItem failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nasync function testDerive() {\n  /* 生成密钥 */\n  await publicGenKeyFunc(srcKeyAlias, huksOptions);\n  /* 进行派生操作 */\n  await publicInitFunc(srcKeyAlias, initOptions);\n  initOptions.inData = StringToUint8Array(deriveHkdfInData);\n  await publicUpdateFunc(handle, initOptions);\n  await publicFinishFunc(handle, finishOptions);\n  await publicDeleteKeyFunc(srcKeyAlias, huksOptions);\n}
[h2]PBKDF2
/*\n * 以下以PBKDF2密钥的Promise操作使用为例\n */\nimport { huks } from '@kit.UniversalKeystoreKit';\n\n/*\n * 确定密钥别名和封装密钥属性参数集\n */\nlet srcKeyAlias = \"pbkdf2_Key\";\nlet salt = \"mySalt\";\nlet iterationCount = 10000;\nlet derivedKeySize = 32;\nlet handle: number;\nlet finishOutData: Uint8Array;\n\n/* 集成生成密钥参数集 */\nlet properties: Array<huks.HuksParam> = [\n  {\n    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n    value: huks.HuksKeyAlg.HUKS_ALG_AES,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_DIGEST,\n    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n    value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,\n  }\n];\n\nlet huksOptions: huks.HuksOptions = {\n  properties: properties,\n  inData: new Uint8Array(new Array())\n}\n\n/* 集成init时密钥参数集 */\nlet initProperties: Array<huks.HuksParam> = [\n  {\n    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n    value: huks.HuksKeyAlg.HUKS_ALG_PBKDF2,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_DIGEST,\n    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_DERIVE_KEY_SIZE,\n    value: derivedKeySize,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_ITERATION,\n    value: iterationCount,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_SALT,\n    value: StringToUint8Array(salt),\n  }\n];\n\nlet initOptions: huks.HuksOptions = {\n  properties: initProperties,\n  inData: new Uint8Array(new Array())\n}\n\n/* 集成finish时密钥参数集 */\nlet finishProperties: Array<huks.HuksParam> = [\n  {\n    tag: huks.HuksTag.HUKS_TAG_DERIVED_AGREED_KEY_STORAGE_FLAG,\n    value: huks.HuksKeyStorageType.HUKS_STORAGE_ONLY_USED_IN_HUKS,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS,\n    value: true,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,\n    value: huks.HuksKeyAlg.HUKS_ALG_AES,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,\n    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_PURPOSE,\n    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_DIGEST,\n    value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,\n    value: StringToUint8Array(srcKeyAlias),\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_PADDING,\n    value: huks.HuksKeyPadding.HUKS_PADDING_NONE,\n  }, {\n    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,\n    value: huks.HuksCipherMode.HUKS_MODE_ECB,\n  }\n];\n\nlet finishOptions: huks.HuksOptions = {\n  properties: finishProperties,\n  inData: new Uint8Array(new Array())\n}\n\nfunction StringToUint8Array(str: String) {\n  let arr: number[] = new Array();\n  for (let i = 0, j = str.length; i < j; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  return new Uint8Array(arr);\n}\n\nclass throwObject {\n  isThrow = false;\n}\n\nfunction generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      huks.generateKeyItem(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise generateKeyItem`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await generateKeyItem(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: generateKeyItem success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: generateKeyItem failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: generateKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nfunction initSession(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksSessionHandle>((resolve, reject) => {\n    try {\n      huks.initSession(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicInitFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doInit`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await initSession(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: doInit success, data = ${JSON.stringify(data)}`);\n        handle = data.handle;\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doInit failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doInit input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nfunction updateSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksOptions>((resolve, reject) => {\n    try {\n      huks.updateSession(handle, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicUpdateFunc(handle: number, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doUpdate`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await updateSession(handle, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: doUpdate success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doUpdate failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doUpdate input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nfunction finishSession(handle: number, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<huks.HuksReturnResult>((resolve, reject) => {\n    try {\n      huks.finishSession(handle, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicFinishFunc(handle: number, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise doFinish`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await finishSession(handle, huksOptions, throwObject)\n      .then((data) => {\n        finishOutData = data.outData as Uint8Array;\n        console.info(`promise: doFinish success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: doFinish failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: doFinish input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nfunction deleteKeyItem(keyAlias: string, huksOptions: huks.HuksOptions, throwObject: throwObject) {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      huks.deleteKeyItem(keyAlias, huksOptions, (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data);\n        }\n      });\n    } catch (error) {\n      throwObject.isThrow = true;\n      throw (error as Error);\n    }\n  });\n}\n\nasync function publicDeleteKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {\n  console.info(`enter promise deleteKeyItem`);\n  let throwObject: throwObject = { isThrow: false };\n  try {\n    await deleteKeyItem(keyAlias, huksOptions, throwObject)\n      .then((data) => {\n        console.info(`promise: deleteKeyItem key success, data = ${JSON.stringify(data)}`);\n      })\n      .catch((error: Error) => {\n        if (throwObject.isThrow) {\n          throw (error as Error);\n        } else {\n          console.error(`promise: deleteKeyItem failed, ${JSON.stringify(error)}`);\n        }\n      });\n  } catch (error) {\n    console.error(`promise: deleteKeyItem input arg invalid, ${JSON.stringify(error)}`);\n  }\n}\n\nasync function testDerive() {\n  /* 生成密钥 */\n  await publicGenKeyFunc(srcKeyAlias, huksOptions);\n  /* 进行派生操作 */\n  await publicInitFunc(srcKeyAlias, initOptions);\n  await publicUpdateFunc(handle, initOptions);\n  await publicFinishFunc(handle, finishOptions);\n  await publicDeleteKeyFunc(srcKeyAlias, huksOptions);\n}

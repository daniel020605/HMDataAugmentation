使用AudioCapturer开发音频录制功能
AudioCapturer是音频采集器，用于录制PCM（Pulse Code Modulation）音频数据，适合有音频开发经验的开发者实现更灵活的录制功能。
开发指导
使用AudioCapturer录制音频涉及到AudioCapturer实例的创建、音频采集参数的配置、采集的开始与停止、资源的释放等。本开发指导将以一次录制音频数据的过程为例，向开发者讲解如何使用AudioCapturer进行音频录制，建议搭配AudioCapturer的API说明阅读。
下图展示了AudioCapturer的状态变化，在创建实例后，调用对应的方法可以进入指定的状态实现对应的行为。需要注意的是在确定的状态执行不合适的方法可能导致AudioCapturer发生错误，建议开发者在调用状态转换的方法前进行状态检查，避免程序运行产生预期以外的结果。
图1 AudioCapturer状态变化示意图
使用on('stateChange')方法可以监听AudioCapturer的状态变化，每个状态对应值与说明见AudioState。
[h2]开发步骤及注意事项
 配置音频采集参数并创建AudioCapturer实例，音频采集参数的详细信息可以查看AudioCapturerOptions。     当设置Mic音频源（即SourceType为SOURCE_TYPE_MIC、SOURCE_TYPE_VOICE_RECOGNITION、SOURCE_TYPE_VOICE_COMMUNICATION、SOURCE_TYPE_VOICE_MESSAGE）时，需要申请麦克风权限ohos.permission.MICROPHONE，申请方式参考：向用户申请授权。    import { audio } from '@kit.AudioKit';\n \n let audioStreamInfo: audio.AudioStreamInfo = {\n   samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_48000, // 采样率\n   channels: audio.AudioChannel.CHANNEL_2, // 通道\n   sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式\n   encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式\n };\n \n let audioCapturerInfo: audio.AudioCapturerInfo = {\n   source: audio.SourceType.SOURCE_TYPE_MIC,\n   capturerFlags: 0\n };\n \n let audioCapturerOptions: audio.AudioCapturerOptions = {\n   streamInfo: audioStreamInfo,\n   capturerInfo: audioCapturerInfo\n };\n \n audio.createAudioCapturer(audioCapturerOptions, (err, data) => {\n   if (err) {\n     console.error(`Invoke createAudioCapturer failed, code is ${err.code}, message is ${err.message}`);\n   } else {\n     console.info('Invoke createAudioCapturer succeeded.');\n     let audioCapturer = data;\n   }\n }); 调用on('readData')方法，订阅监听音频数据读入回调。  import { BusinessError } from '@kit.BasicServicesKit';\n import { fileIo as fs } from '@kit.CoreFileKit';\n\n class Options {\n   offset?: number;\n   length?: number;\n }\n\n let bufferSize: number = 0;\n let path = getContext().cacheDir;\n let filePath = path + '/StarWars10s-2C-48000-4SW.pcm';\n let file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\n let readDataCallback = (buffer: ArrayBuffer) => {\n   let options: Options = {\n     offset: bufferSize,\n     length: buffer.byteLength\n   }\n   fs.writeSync(file.fd, buffer, options);\n   bufferSize += buffer.byteLength;\n };\n\n audioCapturer.on('readData', readDataCallback); 调用start()方法进入running状态，开始录制音频。  import { BusinessError } from '@kit.BasicServicesKit';\n\n audioCapturer.start((err: BusinessError) => {\n   if (err) {\n     console.error(`Capturer start failed, code is ${err.code}, message is ${err.message}`);\n   } else {\n     console.info('Capturer start success.');\n   }\n }); 调用stop()方法停止录制。  import { BusinessError } from '@kit.BasicServicesKit';\n\n audioCapturer.stop((err: BusinessError) => {\n   if (err) {\n     console.error(`Capturer stop failed, code is ${err.code}, message is ${err.message}`);\n   } else {\n     console.info('Capturer stopped.');\n   }\n }); 调用release()方法销毁实例，释放资源。  import { BusinessError } from '@kit.BasicServicesKit';\n\n audioCapturer.release((err: BusinessError) => {\n   if (err) {\n     console.error(`capturer release failed, code is ${err.code}, message is ${err.message}`);\n   } else {\n     console.info('capturer released.');\n   }\n }); 
[h2]完整示例
下面展示了使用AudioCapturer录制音频的完整示例代码。
import { audio } from '@kit.AudioKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\n\nconst TAG = 'AudioCapturerDemo';\n\nclass Options {\n  offset?: number;\n  length?: number;\n}\n\nlet bufferSize: number = 0;\nlet audioCapturer: audio.AudioCapturer | undefined = undefined;\nlet audioStreamInfo: audio.AudioStreamInfo = {\n  samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_48000, // 采样率\n  channels: audio.AudioChannel.CHANNEL_2, // 通道\n  sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式\n  encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式\n};\nlet audioCapturerInfo: audio.AudioCapturerInfo = {\n  source: audio.SourceType.SOURCE_TYPE_MIC, // 音源类型\n  capturerFlags: 0 // 音频采集器标志\n};\nlet audioCapturerOptions: audio.AudioCapturerOptions = {\n  streamInfo: audioStreamInfo,\n  capturerInfo: audioCapturerInfo\n};\nlet path = getContext().cacheDir;\nlet filePath = path + '/StarWars10s-2C-48000-4SW.pcm';\nlet file: fs.File = fs.openSync(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\nlet readDataCallback = (buffer: ArrayBuffer) => {\n   let options: Options = {\n      offset: bufferSize,\n      length: buffer.byteLength\n   }\n   fs.writeSync(file.fd, buffer, options);\n   bufferSize += buffer.byteLength;\n};\n\n// 初始化，创建实例，设置监听事件\nfunction init() {\n  audio.createAudioCapturer(audioCapturerOptions, (err, capturer) => { // 创建AudioCapturer实例\n    if (err) {\n      console.error(`Invoke createAudioCapturer failed, code is ${err.code}, message is ${err.message}`);\n      return;\n    }\n    console.info(`${TAG}: create AudioCapturer success`);\n    audioCapturer = capturer;\n    if (audioCapturer !== undefined) {\n       (audioCapturer as audio.AudioCapturer).on('readData', readDataCallback);\n    }\n  });\n}\n\n// 开始一次音频采集\nfunction start() {\n  if (audioCapturer !== undefined) {\n    let stateGroup = [audio.AudioState.STATE_PREPARED, audio.AudioState.STATE_PAUSED, audio.AudioState.STATE_STOPPED];\n    if (stateGroup.indexOf((audioCapturer as audio.AudioCapturer).state.valueOf()) === -1) { // 当且仅当状态为STATE_PREPARED、STATE_PAUSED和STATE_STOPPED之一时才能启动采集\n      console.error(`${TAG}: start failed`);\n      return;\n    }\n\n    // 启动采集\n    (audioCapturer as audio.AudioCapturer).start((err: BusinessError) => {\n      if (err) {\n        console.error('Capturer start failed.');\n      } else {\n        console.info('Capturer start success.');\n      }\n    });\n  }\n}\n\n// 停止采集\nfunction stop() {\n  if (audioCapturer !== undefined) {\n    // 只有采集器状态为STATE_RUNNING或STATE_PAUSED的时候才可以停止\n    if ((audioCapturer as audio.AudioCapturer).state.valueOf() !== audio.AudioState.STATE_RUNNING && (audioCapturer as audio.AudioCapturer).state.valueOf() !== audio.AudioState.STATE_PAUSED) {\n      console.info('Capturer is not running or paused');\n      return;\n    }\n\n    //停止采集\n    (audioCapturer as audio.AudioCapturer).stop((err: BusinessError) => {\n      if (err) {\n        console.error('Capturer stop failed.');\n      } else {\n        fs.close(file);\n        console.info('Capturer stop success.');\n      }\n    });\n  }\n}\n\n// 销毁实例，释放资源\nfunction release() {\n  if (audioCapturer !== undefined) {\n    // 采集器状态不是STATE_RELEASED或STATE_NEW状态，才能release\n    if ((audioCapturer as audio.AudioCapturer).state.valueOf() === audio.AudioState.STATE_RELEASED || (audioCapturer as audio.AudioCapturer).state.valueOf() === audio.AudioState.STATE_NEW) {\n      console.info('Capturer already released');\n      return;\n    }\n\n    //释放资源\n    (audioCapturer as audio.AudioCapturer).release((err: BusinessError) => {\n      if (err) {\n        console.error('Capturer release failed.');\n      } else {\n        console.info('Capturer release success.');\n      }\n    });\n  }\n}

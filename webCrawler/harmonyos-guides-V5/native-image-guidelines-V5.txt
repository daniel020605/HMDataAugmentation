NativeImage开发指导 (C/C++)
场景介绍
NativeImage是提供Surface关联OpenGL外部纹理的模块，表示图形队列的消费者端。开发者可以通过NativeImage接口接收和使用Buffer，并将Buffer关联输出到OpenGL外部纹理。
针对NativeImage，常见的开发场景如下：
 通过NativeImage提供的Native API接口创建NativeImage实例作为消费者端，获取与该实例对应的NativeWindow作为生产者端。NativeWindow相关接口可用于填充Buffer内容并提交，NativeImage将Buffer内容更新到OpenGL外部纹理上。本模块需要配合NativeWindow、NativeBuffer、EGL、GLES3模块一起使用。 
接口说明
详细的接口说明请参考native_image。
开发步骤
以下步骤描述了如何使用NativeImage提供的Native API接口，创建OH_NativeImage实例作为消费者端，将数据内容更新到OpenGL外部纹理上。
添加动态链接库
CMakeLists.txt中添加以下lib。
libEGL.so\nlibGLESv3.so\nlibnative_image.so\nlibnative_window.so\nlibnative_buffer.so
头文件
#include <iostream>\n#include <string>\n#include <EGL/egl.h>\n#include <EGL/eglext.h>\n#include <GLES3/gl3.h>\n#include <GLES2/gl2ext.h>\n#include <sys/mman.h>\n#include <native_image/native_image.h>\n#include <native_window/external_window.h>\n#include <native_buffer/native_buffer.h>
 初始化EGL环境。 这里提供一份初始化EGL环境的代码示例。XComponent模块的具体使用方法请参考XComponent开发指导。 using GetPlatformDisplayExt = PFNEGLGETPLATFORMDISPLAYEXTPROC;\nconstexpr const char *EGL_EXT_PLATFORM_WAYLAND = \"EGL_EXT_platform_wayland\";\nconstexpr const char *EGL_KHR_PLATFORM_WAYLAND = \"EGL_KHR_platform_wayland\";\nconstexpr int32_t EGL_CONTEXT_CLIENT_VERSION_NUM = 2;\nconstexpr char CHARACTER_WHITESPACE = ' ';\nconstexpr const char *CHARACTER_STRING_WHITESPACE = \" \";\nconstexpr const char *EGL_GET_PLATFORM_DISPLAY_EXT = \"eglGetPlatformDisplayEXT\";\nEGLContext eglContext_ = EGL_NO_CONTEXT;\nEGLDisplay eglDisplay_ = EGL_NO_DISPLAY;\nstatic inline EGLConfig config_;\nstatic inline EGLSurface eglSurface_;\n// 从XComponent中获取到的OHNativeWindow\nOHNativeWindow *eglNativeWindow_;\n\n// 检查egl扩展\nstatic bool CheckEglExtension(const char *extensions, const char *extension) {\n    size_t extlen = strlen(extension);\n    const char *end = extensions + strlen(extensions);\n\n    while (extensions < end) {\n        size_t n = 0;\n        if (*extensions == CHARACTER_WHITESPACE) {\n            extensions++;\n            continue;\n        }\n        n = strcspn(extensions, CHARACTER_STRING_WHITESPACE);\n        if (n == extlen && strncmp(extension, extensions, n) == 0) {\n            return true;\n        }\n        extensions += n;\n    }\n    return false;\n}\n\n// 获取当前的显示设备\nstatic EGLDisplay GetPlatformEglDisplay(EGLenum platform, void *native_display, const EGLint *attrib_list) {\n    static GetPlatformDisplayExt eglGetPlatformDisplayExt = NULL;\n\n    if (!eglGetPlatformDisplayExt) {\n        const char *extensions = eglQueryString(EGL_NO_DISPLAY, EGL_EXTENSIONS);\n        if (extensions && (CheckEglExtension(extensions, EGL_EXT_PLATFORM_WAYLAND) ||\n                           CheckEglExtension(extensions, EGL_KHR_PLATFORM_WAYLAND))) {\n            eglGetPlatformDisplayExt = (GetPlatformDisplayExt)eglGetProcAddress(EGL_GET_PLATFORM_DISPLAY_EXT);\n        }\n    }\n\n    if (eglGetPlatformDisplayExt) {\n        return eglGetPlatformDisplayExt(platform, native_display, attrib_list);\n    }\n\n    return eglGetDisplay((EGLNativeDisplayType)native_display);\n}\n\nstatic void InitEGLEnv() {\n    // 获取当前的显示设备\n    eglDisplay_ = GetPlatformEglDisplay(EGL_PLATFORM_OHOS_KHR, EGL_DEFAULT_DISPLAY, NULL);\n    if (eglDisplay_ == EGL_NO_DISPLAY) {\n        std::cout << \"Failed to create EGLDisplay gl errno : \" << eglGetError() << std::endl;\n    }\n\n    EGLint major, minor;\n    // 初始化EGLDisplay\n    if (eglInitialize(eglDisplay_, &major, &minor) == EGL_FALSE) {\n        std::cout << \"Failed to initialize EGLDisplay\" << std::endl;\n    }\n\n    // 绑定图形绘制的API为OpenGLES\n    if (eglBindAPI(EGL_OPENGL_ES_API) == EGL_FALSE) {\n        std::cout << \"Failed to bind OpenGL ES API\" << std::endl;\n    }\n\n    unsigned int glRet;\n    EGLint count;\n    EGLint config_attribs[] = {EGL_SURFACE_TYPE,\n                               EGL_WINDOW_BIT,\n                               EGL_RED_SIZE,\n                               8,\n                               EGL_GREEN_SIZE,\n                               8,\n                               EGL_BLUE_SIZE,\n                               8,\n                               EGL_ALPHA_SIZE,\n                               8,\n                               EGL_RENDERABLE_TYPE,\n                               EGL_OPENGL_ES3_BIT,\n                               EGL_NONE};\n\n    // 获取一个有效的系统配置信息\n    glRet = eglChooseConfig(eglDisplay_, config_attribs, &config_, 1, &count);\n    if (!(glRet && static_cast<unsigned int>(count) >= 1)) {\n        std::cout << \"Failed to eglChooseConfig\" << std::endl;\n    }\n\n    static const EGLint context_attribs[] = {EGL_CONTEXT_CLIENT_VERSION, EGL_CONTEXT_CLIENT_VERSION_NUM, EGL_NONE};\n\n    // 创建上下文\n    eglContext_ = eglCreateContext(eglDisplay_, config_, EGL_NO_CONTEXT, context_attribs);\n    if (eglContext_ == EGL_NO_CONTEXT) {\n        std::cout << \"Failed to create egl context, error:\" << eglGetError() << std::endl;\n    }\n\n    // 创建eglSurface\n    eglSurface_ = eglCreateWindowSurface(eglDisplay_, config_, reinterpret_cast<EGLNativeWindowType>(eglNativeWindow_), context_attribs);\n    if (eglSurface_ == EGL_NO_SURFACE) {\n        std::cout << \"Failed to create egl surface, error:\" << eglGetError() << std::endl;\n    }\n\n    // 关联上下文\n    eglMakeCurrent(eglDisplay_, eglSurface_, eglSurface_, eglContext_);\n\n    // EGL环境初始化完成\n    std::cout << \"Create EGL context successfully, version\" << major << \".\" << minor << std::endl;\n} 创建OH_NativeImage实例。 // 创建 OpenGL 纹理\nGLuint textureId;\nglGenTextures(1, &textureId);\n// 创建 NativeImage 实例，关联 OpenGL 纹理\nOH_NativeImage* image = OH_NativeImage_Create(textureId, GL_TEXTURE_EXTERNAL_OES); 获取对应的数据生产者端NativeWindow。 // 获取生产者NativeWindow\nOHNativeWindow* nativeWindow = OH_NativeImage_AcquireNativeWindow(image); 设置NativeWindow的宽高。 int code = SET_BUFFER_GEOMETRY;\nint32_t width = 800;\nint32_t height = 600;\nint32_t ret = OH_NativeWindow_NativeWindowHandleOpt(nativeWindow, code, width, height); 将生产的内容写入OHNativeWindowBuffer。  从NativeWindow中获取OHNativeWindowBuffer。 OHNativeWindowBuffer *buffer = nullptr;\nint fenceFd;\n// 通过 OH_NativeWindow_NativeWindowRequestBuffer 获取 OHNativeWindowBuffer 实例\nOH_NativeWindow_NativeWindowRequestBuffer(nativeWindow, &buffer, &fenceFd);\n \nBufferHandle *handle = OH_NativeWindow_GetBufferHandleFromNative(buffer); 将生产的内容写入OHNativeWindowBuffer。 // 使用系统mmap接口拿到bufferHandle的内存虚拟地址\nvoid *mappedAddr = mmap(handle->virAddr, handle->size, PROT_READ | PROT_WRITE, MAP_SHARED, handle->fd, 0);\nif (mappedAddr == MAP_FAILED) {\n    // mmap failed\n}\nstatic uint32_t value = 0x00;\nvalue++;\nuint32_t *pixel = static_cast<uint32_t *>(mappedAddr);\nfor (uint32_t x = 0; x < width; x++) {\n    for (uint32_t y = 0; y < height; y++) {\n        *pixel++ = value;\n    }\n}\n// 内存使用完记得去掉内存映射\nint result = munmap(mappedAddr, handle->size);\nif (result == -1) {\n    // munmap failed\n} 将OHNativeWindowBuffer提交到NativeWindow。 // 设置刷新区域，如果Region中的Rect数组为nullptr,或者rectNumber为0，则认为OHNativeWindowBuffer全部内容有更改。\nRegion region{nullptr, 0};\n// 通过OH_NativeWindow_NativeWindowFlushBuffer 提交给消费者使用，例如：显示在屏幕上。\nOH_NativeWindow_NativeWindowFlushBuffer(nativeWindow, buffer, fenceFd, region); 用完需要销毁NativeWindow。 OH_NativeWindow_DestroyNativeWindow(nativeWindow);  更新内容到OpenGL纹理。 // 更新内容到OpenGL纹理。\nret = OH_NativeImage_UpdateSurfaceImage(image);\nif (ret != 0) {\n    std::cout << \"OH_NativeImage_UpdateSurfaceImage failed\" << std::endl;\n}\n// 获取最近调用OH_NativeImage_UpdateSurfaceImage的纹理图像的时间戳和变化矩阵。\nint64_t timeStamp = OH_NativeImage_GetTimestamp(image);\nfloat matrix[16];\nret = OH_NativeImage_GetTransformMatrix(image, matrix);\nif (ret != 0) {\n    std::cout << \"OH_NativeImage_GetTransformMatrix failed\" << std::endl;\n}\n\n// 对update绑定到对应textureId的纹理做对应的opengl后处理后，将纹理上屏\nEGLBoolean eglRet = eglSwapBuffers(eglDisplay_, eglSurface_);\nif (eglRet == EGL_FALSE) {\n    std::cout << \"eglSwapBuffers failed\" << std::endl;\n} 解绑OpenGL纹理，绑定到新的外部纹理上。 // 将OH_NativeImage实例从当前OpenGL ES上下文分离\nret = OH_NativeImage_DetachContext(image);\nif (ret != 0) {\n    std::cout << \"OH_NativeImage_DetachContext failed\" << std::endl;\n}\n// 将OH_NativeImage实例附加到当前OpenGL ES上下文, 且该OpenGL ES纹理会绑定到 GL_TEXTURE_EXTERNAL_OES, 并通过OH_NativeImage进行更新\nGLuint textureId2;\nglGenTextures(1, &textureId2);\nret = OH_NativeImage_AttachContext(image, textureId2); OH_NativeImage实例使用完需要销毁掉。 // 销毁OH_NativeImage实例\nOH_NativeImage_Destroy(&image); 

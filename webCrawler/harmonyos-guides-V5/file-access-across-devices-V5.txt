跨设备文件访问
分布式文件系统为应用提供了跨设备文件访问的能力，开发者在两个设备安装同一应用时，通过基础文件接口，可跨设备读写另一个设备该应用分布式文件路径（/data/storage/el2/distributedfiles/）下的文件。例如：多设备数据流转的场景，设备组网互联之后，设备A上的应用可访问设备B同应用分布式路径下的文件，当期望应用文件被其他设备访问时，只需将文件移动到分布式文件路径即可。
开发步骤
 完成分布式组网。 将需要跨设备访问的两个设备登录同一账号，保证设备蓝牙和Wi-Fi功能开启，蓝牙无需互连，Wi-Fi无需接入同一个局域网。 访问跨设备文件。 同一应用不同设备之间实现跨设备文件访问，只需要将对应的文件放在应用沙箱的分布式文件路径即可。 设备A上在分布式路径下创建测试文件，并写入内容。示例中的context的获取方式请参见获取UIAbility的上下文信息。 import { fileIo as fs } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet context = getContext(this) as common.UIAbilityContext; // 获取设备A的UIAbilityContext信息\nlet pathDir: string = context.distributedFilesDir;\n// 获取分布式目录的文件路径\nlet filePath: string = pathDir + '/test.txt';\n\ntry {\n  // 在分布式目录下创建文件\n  let file = fs.openSync(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\n  console.info('Succeeded in createing.');\n  // 向文件中写入内容\n  fs.writeSync(file.fd, 'content');\n  // 关闭文件\n  fs.closeSync(file.fd);\n} catch (error) {\n  let err: BusinessError = error as BusinessError;\n  console.error(`Failed to openSync / writeSync / closeSync. Code: ${err.code}, message: ${err.message}`);\n}  设备B主动向设备A发起建链，建链成功后设备B可在分布式路径下读取测试文件。     这里通过分布式设备管理的接口获取设备networkId，详见设备管理接口。   import { fileIo as fs } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { buffer } from '@kit.ArkTS';\nimport { distributedDeviceManager } from '@kit.DistributedServiceKit'\n\n// 通过分布式设备管理的接口获取设备A的networkId信息\nlet dmInstance = distributedDeviceManager.createDeviceManager(\"com.example.hap\");\nlet deviceInfoList: Array<distributedDeviceManager.DeviceBasicInfo> = dmInstance.getAvailableDeviceListSync();\nlet networkId = deviceInfoList[0].networkId;\n\n// 定义访问公共文件目录的回调\nlet listeners : fs.DfsListeners = {\n  onStatus: (networkId: string, status: number): void => {\n    console.info('Failed to access public directory');\n  }\n}\n\n// 访问并挂载公共文件目录\nfs.connectDfs(networkId, listeners).then(() => {\n  console.info(\"Success to connectDfs\");\n  let context = getContext(); // 获取设备B的UIAbilityContext信息\n  let pathDir: string = context.distributedFilesDir;\n  // 获取分布式目录的文件路径\n  let filePath: string = pathDir + '/test.txt';\n\n  try {\n    // 打开分布式目录下的文件\n    let file = fs.openSync(filePath, fs.OpenMode.READ_WRITE);\n    // 定义接收读取数据的缓存\n    let arrayBuffer = new ArrayBuffer(4096);\n    // 读取文件的内容，返回值是读取到的字节个数\n    class Option {\n        public offset: number = 0;\n        public length: number = 0;\n    }\n    let option = new Option();\n    option.length = arrayBuffer.byteLength;\n    let num = fs.readSync(file.fd, arrayBuffer, option);\n    // 打印读取到的文件数据\n    let buf = buffer.from(arrayBuffer, 0, num);\n    console.info('read result: ' + buf.toString());\n  } catch (error) {\n    let err: BusinessError = error as BusinessError;\n    console.error(`Failed to openSync / readSync. Code: ${err.code}, message: ${err.message}`);\n  }\n}).catch((error: BusinessError) => {\n  let err: BusinessError = error as BusinessError;\n  console.error(`Failed to connectDfs Code: ${err.code}, message: ${err.message}`);\n}); B设备访问跨设备文件完成，断开链路。 import { BusinessError } from '@kit.BasicServicesKit';\nimport { distributedDeviceManager } from '@kit.DistributedServiceKit'\nimport { fileIo as fs } from '@kit.CoreFileKit';\n\n// 获取设备A的networkId\nlet dmInstance = distributedDeviceManager.createDeviceManager(\"com.example.hap\");\nlet deviceInfoList: Array<distributedDeviceManager.DeviceBasicInfo> = dmInstance.getAvailableDeviceListSync();\nlet networkId = deviceInfoList[0].networkId;\n\n// 取消公共文件目录挂载\nfs.disconnectDfs(networkId).then(() => {\n  console.info(\"Success to disconnectDfs\");\n}).catch((error: BusinessError) => {\n  let err: BusinessError = error as BusinessError;\n  console.error(`Failed to disconnectDfs Code: ${err.code}, message: ${err.message}`)\n}) 

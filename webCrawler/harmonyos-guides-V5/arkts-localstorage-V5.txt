LocalStorage：页面级UI状态存储
LocalStorage是页面级的UI状态存储，通过@Entry装饰器接收的参数可以在页面内共享同一个LocalStorage实例。LocalStorage支持UIAbility实例内多个页面间状态共享。
本文仅介绍LocalStorage使用场景和相关的装饰器：@LocalStorageProp和@LocalStorageLink。
在阅读本文档前，建议开发者对状态管理框架有基本的了解。建议提前阅读：状态管理概述。
LocalStorage还提供了API接口，可以让开发者通过接口在自定义组件外手动触发Storage对应key的增删改查，建议配合LocalStorage API文档阅读。
LocalStorage从API version 9开始支持。
概述
LocalStorage是ArkTS为构建页面级别状态变量提供存储的内存内的“数据库”。
 应用程序可以创建多个LocalStorage实例，LocalStorage实例可以在页面内共享，也可以通过getShared接口，实现跨页面、UIAbility实例内共享。 组件树的根节点，即被@Entry装饰的@Component，可以被分配一个LocalStorage实例，此组件的所有子组件实例将自动获得对该LocalStorage实例的访问权限。 @Component装饰的组件既可以自动继承来自父组件的LocalStorage实例，也可以传入指定的LocalStorage的实例，详见：自定义组件接收LocalStorage实例。 LocalStorage中的所有属性都是可变的。 
应用程序决定LocalStorage对象的生命周期。当应用释放最后一个指向LocalStorage的引用时，比如销毁最后一个自定义组件，LocalStorage将被JS Engine垃圾回收。
LocalStorage根据与@Component装饰的组件的同步类型不同，提供了两个装饰器：
 @LocalStorageProp：@LocalStorageProp装饰的变量与LocalStorage中给定属性建立单向同步关系。 @LocalStorageLink：@LocalStorageLink装饰的变量与LocalStorage中给定属性建立双向同步关系。 
@LocalStorageProp
在上文中已经提到，如果要建立LocalStorage和自定义组件的联系，需要使用@LocalStorageProp和@LocalStorageLink装饰器。使用@LocalStorageProp(key)/@LocalStorageLink(key)装饰组件内的变量，key标识了LocalStorage的属性。
当自定义组件初始化的时候，@LocalStorageProp(key)/@LocalStorageLink(key)装饰的变量会通过给定的key，绑定LocalStorage对应的属性，完成初始化。本地初始化是必要的，因为无法保证LocalStorage一定存在给定的key（这取决于应用逻辑是否在组件初始化之前在LocalStorage实例中存入对应的属性）。
从API version 9开始，该装饰器支持在ArkTS卡片中使用。
从API version 11开始，该装饰器支持在元服务中使用。
@LocalStorageProp(key)是和LocalStorage中key对应的属性建立单向数据同步，ArkUI框架支持修改@LocalStorageProp(key)在本地的值，但是对本地值的修改不会同步回LocalStorage中。相反，如果LocalStorage中key对应的属性值发生改变，例如通过set接口对LocalStorage中的值进行修改，改变会同步给@LocalStorageProp(key)，并覆盖掉本地的值。
[h2]装饰器使用规则说明
Object、class、string、number、boolean、enum类型，以及这些类型的数组。
API12及以上支持Map、Set、Date类型。嵌套类型的场景请参考观察变化和行为表现。
类型必须被指定，建议和LocalStorage中对应属性类型相同，否则会发生类型隐式转换，从而导致应用行为异常。
不支持any，API12及以上支持undefined和null类型。
API12及以上支持上述支持类型的联合类型，比如string | number, string | undefined 或者 ClassA | null，示例见LocalStorage支持联合类型。
注意
当使用undefined和null的时候，建议显式指定类型，遵循TypeScript类型校验，比如：@LocalStorageProp(\"AA\") a: number | null = null是推荐的，不推荐@LocalStorageProp(\"AA\") a: number = null。
[h2]变量的传递/访问规则说明
图1 @LocalStorageProp初始化规则图示
[h2]观察变化和行为表现
观察变化
 当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。 当装饰的数据类型为class或者Object时，可以观察到对象整体赋值和对象属性变化（详见从ui内部使用localstorage）。 当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。 当装饰的对象是Date时，可以观察到Date整体的赋值，同时可通过调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 更新Date的属性。详见装饰Date类型变量。 当装饰的变量是Map时，可以观察到Map整体的赋值，同时可通过调用Map的接口set, clear, delete 更新Map的值。详见装饰Map类型变量。 当装饰的变量是Set时，可以观察到Set整体的赋值，同时可通过调用Set的接口add, clear, delete 更新Set的值。详见装饰Set类型变量。 
框架行为
 被@LocalStorageProp装饰的变量的值的变化不会同步回LocalStorage里。 @LocalStorageProp装饰的变量变化会使当前自定义组件中关联的组件刷新。 LocalStorage(key)中值的变化会引发所有被@LocalStorageProp对应key装饰的变量的变化，会覆盖@LocalStorageProp本地的改变。 
@LocalStorageLink
从API version 11开始，该装饰器支持在元服务中使用。
如果我们需要将自定义组件的状态变量的更新同步回LocalStorage，就需要用到@LocalStorageLink。
@LocalStorageLink(key)是和LocalStorage中key对应的属性建立双向数据同步：
 本地修改发生，该修改会被写回LocalStorage中。 LocalStorage中的修改发生后，该修改会被同步到所有绑定LocalStorage对应key的属性上，包括单向（@LocalStorageProp和通过prop创建的单向绑定变量）、双向（@LocalStorageLink和通过link创建的双向绑定变量）变量。 
[h2]装饰器使用规则说明
Object、class、string、number、boolean、enum类型，以及这些类型的数组。
API12及以上支持Map、Set、Date类型。嵌套类型的场景请参考观察变化和行为表现。
类型必须被指定，建议和LocalStorage中对应属性类型相同，否则会发生类型隐式转换，从而导致应用行为异常。
不支持any，API12及以上支持undefined和null类型。
API12及以上支持上述支持类型的联合类型，比如string | number, string | undefined 或者 ClassA | null，示例见LocalStorage支持联合类型。
注意
当使用undefined和null的时候，建议显式指定类型，遵循TypeScript类型校验，比如：@LocalStorageLink(\"AA\") a: number | null = null是推荐的，不推荐@LocalStorageLink(\"AA\") a: number = null。
[h2]变量的传递/访问规则说明
图2 @LocalStorageLink初始化规则图示
[h2]观察变化和行为表现
观察变化
 当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。 当装饰的数据类型为class或者Object时，可以观察到对象整体赋值和对象属性变化（详见从ui内部使用localstorage）。 当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。 当装饰的对象是Date时，可以观察到Date整体的赋值，同时可通过调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 更新Date的属性。详见装饰Date类型变量。 当装饰的变量是Map时，可以观察到Map整体的赋值，同时可通过调用Map的接口set, clear, delete 更新Map的值。详见装饰Map类型变量。 当装饰的变量是Set时，可以观察到Set整体的赋值，同时可通过调用Set的接口add, clear, delete 更新Set的值。详见装饰Set类型变量。 
框架行为
 当@LocalStorageLink(key)装饰的数值改变被观察到时，修改将被同步回LocalStorage对应属性键值key的属性中。 LocalStorage中属性键值key对应的数据一旦改变，属性键值key绑定的所有的数据（包括双向@LocalStorageLink和单向@LocalStorageProp）都将同步修改。 当@LocalStorageLink(key)装饰的数据本身是状态变量，它的改变不仅仅会同步回LocalStorage中，还会引起所属的自定义组件的重新渲染。 
限制条件
 @LocalStorageProp/@LocalStorageLink的参数必须为string类型，否则编译期会报错。 let storage = new LocalStorage();\nstorage.setOrCreate('PropA', 48);\n\n// 错误写法，编译报错\n@LocalStorageProp() localStorageProp: number = 1;\n@LocalStorageLink() localStorageLink: number = 2;\n\n// 正确写法\n@LocalStorageProp('PropA') localStorageProp: number = 1;\n@LocalStorageLink('PropA') localStorageLink: number = 2; @StorageProp与@StorageLink不支持装饰Function类型的变量，框架会抛出运行时错误。 LocalStorage创建后，命名属性的类型不可更改。后续调用Set时必须使用相同类型的值。 LocalStorage是页面级存储，getShared接口仅能获取当前Stage通过windowStage.loadContent传入的LocalStorage实例，否则返回undefined。例子可见将LocalStorage实例从UIAbility共享到一个或多个视图。 
使用场景
[h2]应用逻辑使用LocalStorage
let para: Record<string,number> = { 'PropA': 47 };\nlet storage: LocalStorage = new LocalStorage(para); // 创建新实例并使用给定对象初始化\nlet propA: number | undefined = storage.get('PropA'); // propA == 47\nlet link1: SubscribedAbstractProperty<number> = storage.link('PropA'); // link1.get() == 47\nlet link2: SubscribedAbstractProperty<number> = storage.link('PropA'); // link2.get() == 47\nlet prop: SubscribedAbstractProperty<number> = storage.prop('PropA'); // prop.get() == 47\nlink1.set(48); // 双向同步: link1.get() == link2.get() == prop.get() == 48\nprop.set(1); // 单向同步: prop.get() == 1; 但 link1.get() == link2.get() == 48\nlink1.set(49); // 双向同步: link1.get() == link2.get() == prop.get() == 49
[h2]从UI内部使用LocalStorage
除了应用程序逻辑使用LocalStorage，还可以借助LocalStorage相关的两个装饰器@LocalStorageProp和@LocalStorageLink，在UI组件内部获取到LocalStorage实例中存储的状态变量。
本示例以@LocalStorageLink为例，展示了：
 使用构造函数创建LocalStorage实例storage。 使用@Entry装饰器将storage添加到Parent顶层组件中。 @LocalStorageLink绑定LocalStorage对给定的属性，建立双向数据同步。 
class Data {\n code: number;\n\n constructor(code: number) {\n   this.code = code;\n }\n}\n// 创建新实例并使用给定对象初始化\nlet para: Record<string, number> = { 'PropA': 47 };\nlet storage: LocalStorage = new LocalStorage(para);\nstorage.setOrCreate('PropB', new Data(50));\n\n@Component\nstruct Child {\n // @LocalStorageLink变量装饰器与LocalStorage中的'PropA'属性建立双向绑定\n @LocalStorageLink('PropA') childLinkNumber: number = 1;\n // @LocalStorageLink变量装饰器与LocalStorage中的'PropB'属性建立双向绑定\n @LocalStorageLink('PropB') childLinkObject: Data = new Data(0);\n\n build() {\n   Column({ space: 15 }) {\n     Button(`Child from LocalStorage ${this.childLinkNumber}`) // 更改将同步至LocalStorage中的'PropA'以及Parent.parentLinkNumber\n       .onClick(() => {\n         this.childLinkNumber += 1;\n       })\n\n     Button(`Child from LocalStorage ${this.childLinkObject.code}`) // 更改将同步至LocalStorage中的'PropB'以及Parent.parentLinkObject.code\n       .onClick(() => {\n         this.childLinkObject.code += 1;\n       })\n   }\n }\n}\n// 使LocalStorage可从@Component组件访问\n@Entry(storage)\n@Component\nstruct Parent {\n // @LocalStorageLink变量装饰器与LocalStorage中的'PropA'属性建立双向绑定\n @LocalStorageLink('PropA') parentLinkNumber: number = 1;\n // @LocalStorageLink变量装饰器与LocalStorage中的'PropB'属性建立双向绑定\n @LocalStorageLink('PropB') parentLinkObject: Data = new Data(0);\n\n build() {\n   Column({ space: 15 }) {\n     Button(`Parent from LocalStorage ${this.parentLinkNumber}`) // 由于LocalStorage中PropA已经被初始化，因此this.parentLinkNumber的值为47\n       .onClick(() => {\n         this.parentLinkNumber += 1;\n       })\n\n     Button(`Parent from LocalStorage ${this.parentLinkObject.code}`) // 由于LocalStorage中PropB已经被初始化，因此this.parentLinkObject.code的值为50\n       .onClick(() => {\n         this.parentLinkObject.code += 1;\n       })\n     // @Component子组件自动获得对Parent LocalStorage实例的访问权限。\n     Child()\n   }\n }\n}
[h2]@LocalStorageProp和LocalStorage单向同步的简单场景
在下面的示例中，Parent 组件和Child组件分别在本地创建了与storage的'PropA'对应属性的单向同步的数据，我们可以看到：
 Parent中对this.storageProp1的修改，只会在Parent中生效，并没有同步回storage。 Child组件中，Text绑定的storageProp2 依旧显示47。 
// 创建新实例并使用给定对象初始化\nlet para: Record<string, number> = { 'PropA': 47 };\nlet storage: LocalStorage = new LocalStorage(para);\n// 使LocalStorage可从@Component组件访问\n@Entry(storage)\n@Component\nstruct Parent {\n  // @LocalStorageProp变量装饰器与LocalStorage中的'PropA'属性建立单向绑定\n  @LocalStorageProp('PropA') storageProp1: number = 1;\n\n  build() {\n    Column({ space: 15 }) {\n      // 点击后从47开始加1，只改变当前组件显示的storageProp1，不会同步到LocalStorage中\n      Button(`Parent from LocalStorage ${this.storageProp1}`)\n        .onClick(() => {\n          this.storageProp1 += 1;\n        })\n      Child()\n    }\n  }\n}\n\n@Component\nstruct Child {\n  // @LocalStorageProp变量装饰器与LocalStorage中的'PropA'属性建立单向绑定\n  @LocalStorageProp('PropA') storageProp2: number = 2;\n\n  build() {\n    Column({ space: 15 }) {\n      // 当Parent改变时，当前storageProp2不会改变，显示47\n      Text(`Parent from LocalStorage ${this.storageProp2}`)\n    }\n  }\n}
[h2]@LocalStorageLink和LocalStorage双向同步的简单场景
下面的示例展示了@LocalStorageLink装饰的数据和LocalStorage双向同步的场景：
// 构造LocalStorage实例\nlet para: Record<string, number> = { 'PropA': 47 };\nlet storage: LocalStorage = new LocalStorage(para);\n// 调用link（api9以上）接口构造'PropA'的双向同步数据，linkToPropA 是全局变量\nlet linkToPropA: SubscribedAbstractProperty<object> = storage.link('PropA');\n\n@Entry(storage)\n@Component\nstruct Parent {\n\n  // @LocalStorageLink('PropA')在Parent自定义组件中创建'PropA'的双向同步数据，初始值为47，因为在构造LocalStorage已经给“PropA”设置47\n  @LocalStorageLink('PropA') storageLink: number = 1;\n\n  build() {\n    Column() {\n      Text(`incr @LocalStorageLink variable`)\n        // 点击“incr @LocalStorageLink variable”，this.storageLink加1，改变同步回storage，全局变量linkToPropA也会同步改变\n\n        .onClick(() => {\n          this.storageLink += 1;\n        })\n\n      // 并不建议在组件内使用全局变量linkToPropA.get()，因为可能会有生命周期不同引起的错误。\n      Text(`@LocalStorageLink: ${this.storageLink} - linkToPropA: ${linkToPropA.get()}`)\n    }\n  }\n}
[h2]兄弟组件之间同步状态变量
下面的示例展示了通过@LocalStorageLink双向同步兄弟组件之间的状态。
先看Parent自定义组件中发生的变化：
 点击“playCount ${this.playCount} dec by 1”，this.playCount减1，修改同步回LocalStorage中，Child组件中的playCountLink绑定的组件会同步刷新。 点击“countStorage ${this.playCount} incr by 1”，调用LocalStorage的set接口，更新LocalStorage中“countStorage”对应的属性，Child组件中的playCountLink绑定的组件会同步刷新。 Text组件“playCount in LocalStorage for debug ${storage.get<number>('countStorage')}”没有同步刷新，因为storage.get<number>('countStorage')返回的是常规变量，常规变量的更新并不会引起Text组件的重新渲染。 
Child自定义组件中的变化：
 playCountLink的刷新会同步回LocalStorage，并且引起兄弟组件和父组件相应的刷新。 
let count: Record<string, number> = { 'countStorage': 1 };\nlet storage: LocalStorage = new LocalStorage(count);\n\n@Component\nstruct Child {\n  // 子组件实例的名字\n  label: string = 'no name';\n  // 和LocalStorage中“countStorage”的双向绑定数据\n  @LocalStorageLink('countStorage') playCountLink: number = 0;\n\n  build() {\n    Row() {\n      Text(this.label)\n        .width(50).height(60).fontSize(12)\n      Text(`playCountLink ${this.playCountLink}: inc by 1`)\n        .onClick(() => {\n          this.playCountLink += 1;\n        })\n        .width(200).height(60).fontSize(12)\n    }.width(300).height(60)\n  }\n}\n\n@Entry(storage)\n@Component\nstruct Parent {\n  @LocalStorageLink('countStorage') playCount: number = 0;\n\n  build() {\n    Column() {\n      Row() {\n        Text('Parent')\n          .width(50).height(60).fontSize(12)\n        Text(`playCount ${this.playCount} dec by 1`)\n          .onClick(() => {\n            this.playCount -= 1;\n          })\n          .width(250).height(60).fontSize(12)\n      }.width(300).height(60)\n\n      Row() {\n        Text('LocalStorage')\n          .width(50).height(60).fontSize(12)\n        Text(`countStorage ${this.playCount} incr by 1`)\n          .onClick(() => {\n            storage.set<number | undefined>('countStorage', Number(storage.get<number>('countStorage')) + 1);\n          })\n          .width(250).height(60).fontSize(12)\n      }.width(300).height(60)\n\n      Child({ label: 'ChildA' })\n      Child({ label: 'ChildB' })\n\n      Text(`playCount in LocalStorage for debug ${storage.get<number>('countStorage')}`)\n        .width(300).height(60).fontSize(12)\n    }\n  }\n}
[h2]将LocalStorage实例从UIAbility共享到一个或多个视图
上面的实例中，LocalStorage的实例仅仅在一个@Entry装饰的组件和其所属的子组件（一个页面）中共享，如果希望其在多个视图中共享，可以在所属UIAbility中创建LocalStorage实例，并调用windowStage.loadContent。
// EntryAbility.ets\nimport { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\n\nexport default class EntryAbility extends UIAbility {\n  para: Record<string, number> = {\n    'PropA': 47\n  };\n  storage: LocalStorage = new LocalStorage(this.para);\n\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    windowStage.loadContent('pages/Index', this.storage);\n  }\n}
在UI页面通过getShared接口获取通过loadContent共享的LocalStorage实例。
LocalStorage.getShared()只在模拟器或者实机上才有效，在Previewer预览器中使用不生效。
在下面的用例中，Index页面中的propA通过getShared()方法获取到共享的LocalStorage实例。点击Button跳转到Page页面，点击Change propA改变propA的值，back回Index页面后，页面中propA的值也同步修改。
// index.ets\n\n// 通过getShared接口获取stage共享的LocalStorage实例\n@Entry({ storage: LocalStorage.getShared() })\n@Component\nstruct Index {\n  // 可以使用@LocalStorageLink/Prop与LocalStorage实例中的变量建立联系\n  @LocalStorageLink('PropA') propA: number = 1;\n  pageStack: NavPathStack = new NavPathStack();\n\n  build() {\n    Navigation(this.pageStack) {\n      Row(){\n        Column() {\n          Text(`${this.propA}`)\n            .fontSize(50)\n            .fontWeight(FontWeight.Bold)\n          Button(\"To Page\")\n            .onClick(() => {\n              this.pageStack.pushPathByName('Page', null);\n            })\n        }\n        .width('100%')\n      }\n      .height('100%')\n    }\n  }\n}
// Page.ets\n\n@Builder\nexport function PageBuilder() {\n  Page()\n}\n\n// Page组件获得了父亲Index组件的LocalStorage实例\n@Component\nstruct Page {\n  @LocalStorageLink('PropA') propA: number = 2;\n  pathStack: NavPathStack = new NavPathStack();\n\n  build() {\n    NavDestination() {\n      Row(){\n        Column() {\n          Text(`${this.propA}`)\n            .fontSize(50)\n            .fontWeight(FontWeight.Bold)\n\n          Button(\"Change propA\")\n            .onClick(() => {\n              this.propA = 100;\n            })\n\n          Button(\"Back Index\")\n            .onClick(() => {\n              this.pathStack.pop();\n            })\n        }\n        .width('100%')\n      }\n    }\n    .onReady((context: NavDestinationContext) => {\n      this.pathStack = context.pathStack;\n    })\n  }\n}
使用Navigation时，需要添加配置系统路由表文件src/main/resources/base/profile/route_map.json，并替换pageSourceFile为Page页面的路径，并且在module.json5中添加：\"routerMap\": \"$profile:route_map\"。
{\n  \"routerMap\": [\n    {\n      \"name\": \"Page\",\n      \"pageSourceFile\": \"src/main/ets/pages/Page.ets\",\n      \"buildFunction\": \"PageBuilder\",\n      \"data\": {\n        \"description\" : \"LocalStorage example\"\n      }\n    }\n  ]\n}
对于开发者更建议使用这个方式来构建LocalStorage的实例，并且在创建LocalStorage实例的时候就写入默认值，因为默认值可以作为运行异常的备份，也可以用作页面的单元测试。
[h2]自定义组件接收LocalStorage实例
除了根节点可通过@Entry来接收LocalStorage实例，自定义组件（子节点）也可以通过构造参数来传递LocalStorage实例。
本示例以@LocalStorageLink为例，展示了：
 父组件中的Text，显示LocalStorage实例localStorage1中PropA的值为“PropA”。 Child组件中，Text绑定的PropB，显示LocalStorage实例localStorage2中PropB的值为“PropB”。 
从API version 12开始，自定义组件支持接收LocalStorage实例。
当自定义组件作为子节点，定义了成员属性时，LocalStorage实例必须要放在第二个参数位置传递，否则会报类型不匹配的编译问题。
当在自定义组件中定义了属性时，暂时不支持只有一个LocalStorage实例作为入参。如果没定义属性，可以只传入一个LocalStorage实例作为入参。
如果定义的属性不需要从父组件初始化变量，则第一个参数需要传{}。
作为构造参数传给子组件的LocalStorage实例在初始化时就会被决定，可以通过@LocalStorageLink或者LocalStorage的API修改LocalStorage实例中保存的属性值，但LocalStorage实例自身不能被动态修改。
let localStorage1: LocalStorage = new LocalStorage();\nlocalStorage1.setOrCreate('PropA', 'PropA');\n\nlet localStorage2: LocalStorage = new LocalStorage();\nlocalStorage2.setOrCreate('PropB', 'PropB');\n\n@Entry(localStorage1)\n@Component\nstruct Index {\n  // 'PropA'，和localStorage1中'PropA'的双向同步\n  @LocalStorageLink('PropA') PropA: string = 'Hello World';\n  @State count: number = 0;\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.PropA)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n        // 使用LocalStorage 实例localStorage2\n        Child({ count: this.count }, localStorage2)\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}\n\n\n@Component\nstruct Child {\n  @Link count: number;\n  //  'Hello World'，和localStorage2中'PropB'的双向同步，如果localStorage2中没有'PropB'，则使用默认值'Hello World'\n  @LocalStorageLink('PropB') PropB: string = 'Hello World';\n\n  build() {\n    Text(this.PropB)\n      .fontSize(50)\n      .fontWeight(FontWeight.Bold)\n  }\n}
 当自定义组件没有定义属性时，可以只传入一个LocalStorage实例作为入参。 let localStorage1: LocalStorage = new LocalStorage();\nlocalStorage1.setOrCreate('PropA', 'PropA');\n\nlet localStorage2: LocalStorage = new LocalStorage();\nlocalStorage2.setOrCreate('PropB', 'PropB');\n\n@Entry(localStorage1)\n@Component\nstruct Index {\n  // 'PropA'，和localStorage1中'PropA'的双向同步\n  @LocalStorageLink('PropA') PropA: string = 'Hello World';\n  @State count: number = 0;\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.PropA)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n        // 使用LocalStorage 实例localStorage2\n        Child(localStorage2)\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}\n\n\n@Component\nstruct Child {\n  build() {\n    Text(\"hello\")\n      .fontSize(50)\n      .fontWeight(FontWeight.Bold)\n  }\n} 当定义的属性不需要从父组件初始化变量时，第一个参数需要传{}。 let localStorage1: LocalStorage = new LocalStorage();\nlocalStorage1.setOrCreate('PropA', 'PropA');\n\nlet localStorage2: LocalStorage = new LocalStorage();\nlocalStorage2.setOrCreate('PropB', 'PropB');\n\n@Entry(localStorage1)\n@Component\nstruct Index {\n  // 'PropA'，和localStorage1中'PropA'的双向同步\n  @LocalStorageLink('PropA') PropA: string = 'Hello World';\n  @State count: number = 0;\n\n  build() {\n    Row() {\n      Column() {\n        Text(this.PropA)\n          .fontSize(50)\n          .fontWeight(FontWeight.Bold)\n        // 使用LocalStorage 实例localStorage2\n        Child({}, localStorage2)\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}\n\n\n@Component\nstruct Child {\n  @State count: number = 5;\n  // 'Hello World'，和localStorage2中'PropB'的双向同步，如果localStorage2中没有'PropB'，则使用默认值'Hello World'\n  @LocalStorageLink('PropB') PropB: string = 'Hello World';\n\n  build() {\n    Text(this.PropB)\n      .fontSize(50)\n      .fontWeight(FontWeight.Bold)\n  }\n} 
[h2]Navigation组件和LocalStorage联合使用
可以通过传递不同的LocalStorage实例给自定义组件，从而实现在navigation跳转到不同的页面时，绑定不同的LocalStorage实例，显示对应绑定的值。
本示例以@LocalStorageLink为例，展示了：
 点击父组件中的Button \"Next Page\",创建并跳转到name为\"pageOne\"的子页面，Text显示信息为LocalStorage实例localStorageA中绑定的PropA的值，为\"PropA\"。 继续点击页面上的Button \"Next Page\",创建并跳转到name为\"pageTwo\"的子页面，Text显示信息为LocalStorage实例localStorageB中绑定的PropB的值，为\"PropB\"。 继续点击页面上的Button \"Next Page\",创建并跳转到name为\"pageTree\"的子页面，Text显示信息为LocalStorage实例localStorageC中绑定的PropC的值，为\"PropC\"。 继续点击页面上的Button \"Next Page\",创建并跳转到name为\"pageOne\"的子页面，Text显示信息为LocalStorage实例localStorageA中绑定的PropA的值，为\"PropA\"。 NavigationContentMsgStack自定义组件中的Text组件，共享对应自定义组件树上LocalStorage实例绑定的PropA的值。 
let localStorageA: LocalStorage = new LocalStorage();\nlocalStorageA.setOrCreate('PropA', 'PropA');\n\nlet localStorageB: LocalStorage = new LocalStorage();\nlocalStorageB.setOrCreate('PropB', 'PropB');\n\nlet localStorageC: LocalStorage = new LocalStorage();\nlocalStorageC.setOrCreate('PropC', 'PropC');\n\n@Entry\n@Component\nstruct MyNavigationTestStack {\n  @Provide('pageInfo') pageInfo: NavPathStack = new NavPathStack();\n\n  @Builder\n  PageMap(name: string) {\n    if (name === 'pageOne') {\n      // 传递不同的LocalStorage实例\n      pageOneStack({}, localStorageA)\n    } else if (name === 'pageTwo') {\n      pageTwoStack({}, localStorageB)\n    } else if (name === 'pageThree') {\n      pageThreeStack({}, localStorageC)\n    }\n  }\n\n  build() {\n    Column({ space: 5 }) {\n      Navigation(this.pageInfo) {\n        Column() {\n          Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n            .width('80%')\n            .height(40)\n            .margin(20)\n            .onClick(() => {\n              this.pageInfo.pushPath({ name: 'pageOne' }); //将name指定的NavDestination页面信息入栈\n            })\n        }\n      }.title('NavIndex')\n      .navDestination(this.PageMap)\n      .mode(NavigationMode.Stack)\n      .borderWidth(1)\n    }\n  }\n}\n\n@Component\nstruct pageOneStack {\n  @Consume('pageInfo') pageInfo: NavPathStack;\n  @LocalStorageLink('PropA') PropA: string = 'Hello World';\n\n  build() {\n    NavDestination() {\n      Column() {\n        NavigationContentMsgStack()\n        // 显示绑定的LocalStorage中PropA的值'PropA'\n        Text(`${this.PropA}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageTwo', null);\n          })\n      }.width('100%').height('100%')\n    }.title('pageOne')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@Component\nstruct pageTwoStack {\n  @Consume('pageInfo') pageInfo: NavPathStack;\n  @LocalStorageLink('PropB') PropB: string = 'Hello World';\n\n  build() {\n    NavDestination() {\n      Column() {\n        NavigationContentMsgStack()\n        // 如果绑定的LocalStorage中没有PropB,显示本地初始化的值 'Hello World'\n        Text(`${this.PropB}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageThree', null);\n          })\n\n      }.width('100%').height('100%')\n    }.title('pageTwo')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@Component\nstruct pageThreeStack {\n  @Consume('pageInfo') pageInfo: NavPathStack;\n  @LocalStorageLink('PropC') PropC: string = 'pageThreeStack';\n\n  build() {\n    NavDestination() {\n      Column() {\n        NavigationContentMsgStack()\n\n        // 如果绑定的LocalStorage中没有PropC,显示本地初始化的值 'pageThreeStack'\n        Text(`${this.PropC}`)\n        Button('Next Page', { stateEffect: true, type: ButtonType.Capsule })\n          .width('80%')\n          .height(40)\n          .margin(20)\n          .onClick(() => {\n            this.pageInfo.pushPathByName('pageOne', null);\n          })\n\n      }.width('100%').height('100%')\n    }.title('pageThree')\n    .onBackPressed(() => {\n      this.pageInfo.pop();\n      return true;\n    })\n  }\n}\n\n@Component\nstruct NavigationContentMsgStack {\n  @LocalStorageLink('PropA') PropA: string = 'Hello';\n\n  build() {\n    Column() {\n      Text(`${this.PropA}`)\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold)\n    }\n  }\n}
[h2]LocalStorage支持联合类型
在下面的示例中，变量A的类型为number | null，变量B的类型为number | undefined。Text组件初始化分别显示为null和undefined，点击切换为数字，再次点击切换回null和undefined。
@Component\nstruct LocalStorLink {\n  @LocalStorageLink(\"LinkA\") LinkA: number | null = null;\n  @LocalStorageLink(\"LinkB\") LinkB: number | undefined = undefined;\n\n  build() {\n    Column() {\n      Text(\"@LocalStorageLink接口初始化，@LocalStorageLink取值\")\n      Text(this.LinkA + \"\").fontSize(20).onClick(() => {\n        this.LinkA ? this.LinkA = null : this.LinkA = 1;\n      })\n      Text(this.LinkB + \"\").fontSize(20).onClick(() => {\n        this.LinkB ? this.LinkB = undefined : this.LinkB = 1;\n      })\n    }\n    .borderWidth(3).borderColor(Color.Green)\n\n  }\n}\n\n@Component\nstruct LocalStorProp {\n  @LocalStorageProp(\"PropA\") PropA: number | null = null;\n  @LocalStorageProp(\"PropB\") PropB: number | undefined = undefined;\n\n  build() {\n    Column() {\n      Text(\"@LocalStorageProp接口初始化，@LocalStorageProp取值\")\n      Text(this.PropA + \"\").fontSize(20).onClick(() => {\n        this.PropA ? this.PropA = null : this.PropA = 1;\n      })\n      Text(this.PropB + \"\").fontSize(20).onClick(() => {\n        this.PropB ? this.PropB = undefined : this.PropB = 1;\n      })\n    }\n    .borderWidth(3).borderColor(Color.Yellow)\n\n  }\n}\n\nlet storage: LocalStorage = new LocalStorage();\n\n@Entry(storage)\n@Component\nstruct Index {\n  build() {\n    Row() {\n      Column() {\n        LocalStorLink()\n        LocalStorProp()\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]装饰Date类型变量
从API version 12开始，LocalStorage支持Date类型。
在下面的示例中，@LocalStorageLink装饰的selectedDate类型为Date，点击Button改变selectedDate的值，视图会随之刷新。
@Entry\n@Component\nstruct LocalDateSample {\n  @LocalStorageLink(\"date\") selectedDate: Date = new Date('2021-08-08');\n\n  build() {\n    Column() {\n      Button('set selectedDate to 2023-07-08')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate = new Date('2023-07-08');\n        })\n      Button('increase the year by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setFullYear(this.selectedDate.getFullYear() + 1);\n        })\n      Button('increase the month by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setMonth(this.selectedDate.getMonth() + 1);\n        })\n      Button('increase the day by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setDate(this.selectedDate.getDate() + 1);\n        })\n      DatePicker({\n        start: new Date('1970-1-1'),\n        end: new Date('2100-1-1'),\n        selected: $$this.selectedDate\n      })\n    }.width('100%')\n  }\n}
[h2]装饰Map类型变量
从API version 12开始，LocalStorage支持Map类型。
在下面的示例中，@LocalStorageLink装饰的message类型为Map<number, string>，点击Button改变message的值，视图会随之刷新。
@Entry\n@Component\nstruct LocalMapSample {\n  @LocalStorageLink(\"map\") message: Map<number, string> = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.message.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`).fontSize(30)\n          Text(`${item[1]}`).fontSize(30)\n          Divider()\n        })\n        Button('init map').onClick(() => {\n          this.message = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n        })\n        Button('set new one').onClick(() => {\n          this.message.set(4, \"d\");\n        })\n        Button('clear').onClick(() => {\n          this.message.clear();\n        })\n        Button('replace the existing one').onClick(() => {\n          this.message.set(0, \"aa\");\n        })\n        Button('delete the existing one').onClick(() => {\n          this.message.delete(0);\n        })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]装饰Set类型变量
从API version 12开始，LocalStorage支持Set类型。
在下面的示例中，@LocalStorageLink装饰的memberSet类型为Set<number>，点击Button改变memberSet的值，视图会随之刷新。
@Entry\n@Component\nstruct LocalSetSample {\n  @LocalStorageLink(\"set\") memberSet: Set<number> = new Set([0, 1, 2, 3, 4]);\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.memberSet.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`)\n            .fontSize(30)\n          Divider()\n        })\n        Button('init set')\n          .onClick(() => {\n            this.memberSet = new Set([0, 1, 2, 3, 4]);\n          })\n        Button('set new one')\n          .onClick(() => {\n            this.memberSet.add(5);\n          })\n        Button('clear')\n          .onClick(() => {\n            this.memberSet.clear();\n          })\n        Button('delete the first one')\n          .onClick(() => {\n            this.memberSet.delete(0);\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]自定义组件外改变状态变量
let storage = new LocalStorage();\nstorage.setOrCreate('count', 47);\n\nclass Model {\n  storage: LocalStorage = storage;\n\n  call(propName: string, value: number) {\n    this.storage.setOrCreate<number>(propName, value);\n  }\n}\n\nlet model: Model = new Model();\n\n@Entry({ storage: storage })\n@Component\nstruct Test {\n  @LocalStorageLink('count') count: number = 0;\n\n  build() {\n    Column() {\n      Text(`count值: ${this.count}`)\n      Button('change')\n        .onClick(() => {\n          model.call('count', this.count + 1);\n        })\n    }\n  }\n}

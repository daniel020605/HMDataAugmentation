UDMF开发指导 (C/C++)
场景介绍
统一数据管理框架（UDMF）：提供了数据跨应用、跨设备交互标准，定义了跨应用、跨设备数据交互过程中的数据语言，提升数据交互效率。提供安全、标准化数据流通通路，支持不同级别的数据访问权限与生命周期管理策略，实现高效的数据跨应用、跨设备共享。
基本概念
 标准化数据类型：Uniform Type Descriptor，简称UTD。主要针对同一种数据类型，提供统一定义，即标准数据类型描述符，定义了包括标识数据类型的ID、类型归属关系等相关信息，用于解决HarmonyOS系统中的类型模糊问题。一般用于过滤或者识别某一种数据类型的场景，比如文件预览、文件分享等。 标准化数据结构：Uniform Type Structure，简称UDS。主要针对部分标准化数据类型定义了统一的数据内容结构，并明确了对应的描述信息。应用间使用标准化数据结构进行数据交互后，将遵从统一的解析标准，可有效减少适配相关的工作量。一般用于跨应用跨设备间的数据交互，比如拖拽。 统一数据记录： Unified Record，对UDMF支持的数据内容的抽象定义，例如一条文本记录、一条图片记录等。 统一数据对象： Unified Data，用于封装一组数据记录UnifiedRecord。 
约束限制
 UDMF支持批量数据记录的分组管理，每个分组整体大小不超过200MB，其中PlainText、Hyperlink、HTML内单个属性值数据上限20M。 向统一数据记录中添加用户自定义数据时，所添加的数据大小不超过4KB。 向UDMF数据库中写入数据时，定义的唯一标识符的内存大小不小于512字节。 
接口说明
详细的接口说明请参考UDMF接口文档。
添加动态链接库
CMakeLists.txt中添加以下lib。
libudmf.so
引用头文件
#include <cstdio>\n#include <cstring>\n#include <database/udmf/utd.h>\n#include <database/udmf/uds.h>\n#include <database/udmf/udmf.h>\n#include <database/udmf/udmf_meta.h>\n#include <database/udmf/udmf_err_code.h>
通过不同方式获取纯文本类型数据
下面以获取纯文本数据的查询场景为例，说明如何使用UTD
 通过后缀名“.txt”获取UTD的typeId。 通过MIME类型“text/plain”获取UTD的typeId。 使用以上两个步骤获取到的typeId创建UTD实例对象。 比较UTD实例对象是否相等。 使用结束后，删除上述步骤中产生的指针。 
// 1. 通过文件后缀名获取纯文本类型的UTD的typeId\nunsigned int typeIds1Count = 0;\nconst char** typeIds1 = OH_Utd_GetTypesByFilenameExtension(\".txt\", &typeIds1Count);\nprintf(\"the count of typeIds1 is %u\", typeIds1Count);\n// 2. 通过MIME类型获取typeId\nunsigned int typeIds2Count = 0;\nconst char** typeIds2 = OH_Utd_GetTypesByMimeType(\"text/plain\", &typeIds2Count);\nprintf(\"the count of typeIds2 is %u\", typeIds2Count);\n// 3. 使用以上两个步骤获取到的typeId创建UTD实例对象。\nOH_Utd* utd1 = OH_Utd_Create(typeIds1[0]);\nOH_Utd* utd2 = OH_Utd_Create(typeIds2[0]);\n// 4. 比较两种方式获取到的typeId对应的UTD是否相同\nbool isEquals = OH_Utd_Equals(utd1, utd2);\nif (isEquals) {\n    printf(\"utd1 == utd2\");\n} else {\n    printf(\"utd1 != utd2\");\n}\n// 5. 销毁OH_Utd_GetTypesByFilenameExtension与OH_Utd_GetFilenameExtensions函数获取到的指针，同时销毁UTD指针\nOH_Utd_DestroyStringList(typeIds1, typeIds1Count);\nOH_Utd_DestroyStringList(typeIds2, typeIds2Count);\nOH_Utd_Destroy(utd1);\nOH_Utd_Destroy(utd2);
使用UDMF来发送UDS数据
下面以发送超链接hyperlink类型数据场景为例，说明如何使用UDS与UDMF。
 创建超链接hyperlink数据的UDS数据结构。 设置hyperlink中的URL和描述信息。 将hyperlink数据放入数据记录OH_UdmfRecord中。 将数据记录OH_UdmfRecord添加到统一数据OH_UdmfData中。 保存以上数据至数据库中，得到返回的key值。 使用结束后，删除上述步骤中产生的指针。 
// 1. 创建超链接hyperlink数据的UDS数据结构。\nOH_UdsHyperlink* hyperlink = OH_UdsHyperlink_Create();\n// 2. 设置hyperlink中的URL和描述信息。\nif (OH_UdsHyperlink_SetUrl(hyperlink, \"www.demo.com\") != Udmf_ErrCode::UDMF_E_OK) {\n    printf(\"Hyperlink set url error!\");\n}\nif (OH_UdsHyperlink_SetDescription(hyperlink, \"This is the description.\") != Udmf_ErrCode::UDMF_E_OK) {\n    printf(\"Hyperlink set description error!\");\n}\n// 3. 创建OH_UdmfRecord对象，并向OH_UdmfRecord中添加超链接类型数据。\nOH_UdmfRecord* record = OH_UdmfRecord_Create();\nif (OH_UdmfRecord_AddHyperlink(record, hyperlink) != Udmf_ErrCode::UDMF_E_OK) {\n    printf(\"Add hyperlink to record error!\");\n}\n// 4. 创建OH_UdmfData对象，并向OH_UdmfData中添加OH_UdmfRecord。\nOH_UdmfData* data = OH_UdmfData_Create();\nif (OH_UdmfData_AddRecord(data, record) != Udmf_ErrCode::UDMF_E_OK) {\n    printf(\"Add record to data error!\");\n}\n// 5. 构建数据，将数据写入数据库中，得到返回的key值。\nchar key[UDMF_KEY_BUFFER_LEN] = {0};\nif (OH_Udmf_SetUnifiedData(Udmf_Intention::UDMF_INTENTION_DRAG, data, key, sizeof(key)) != Udmf_ErrCode::UDMF_E_OK) {\n    printf(\"Set data error!\");\n}\nprintf(\"key = %s\", key);\n// 6. 使用完成后销毁指针。\nOH_UdsHyperlink_Destroy(hyperlink);\nOH_UdmfRecord_Destroy(record);\nOH_UdmfData_Destroy(data);
使用UDMF来接收UDS数据
下面继续以获取超链接hyperlink类型数据场景为例，说明如何使用UDS与UDMF。
 创建统一数据OH_UdmfData，用来承载数据库中读取的数据。 通过key值从数据库中获取到数据。 判断数据中是否有hyperlink类型的数据。 获取OH_UdmfData中的数据记录，并从数据记录中获取hyperlink数据。 读取hyperlink数据中的各项信息。 使用结束后，删除上述步骤中产生的指针。 
// 1. 创建统一数据OH_UdmfData。\nOH_UdmfData* readData = OH_UdmfData_Create();\n// 此处key为示例，不可直接使用，其值应与OH_Udmf_SetUnifiedData接口中获取到的key值保持一致。\nchar key[] = {\"udmf://Drag/com.ohos.test/0123456789\"};\n// 2. 通过key值从数据库中获取到数据。\nif (OH_Udmf_GetUnifiedData(key, Udmf_Intention::UDMF_INTENTION_DRAG, readData) != Udmf_ErrCode::UDMF_E_OK) {\n    printf(\"Failed to get data.\");\n    return;\n}\n// 3. 判断OH_UdmfData是否有对应的类型。\nif (!OH_UdmfData_HasType(readData, UDMF_META_HYPERLINK)) {\n    printf(\"There is no hyperlink type in data.\");\n    return;\n}\n// 4. 获取数据记录和hyperlink数据。\nunsigned int recordsCount = 0;\nOH_UdmfRecord** records = OH_UdmfData_GetRecords(readData, &recordsCount);\nprintf(\"the count of records count is %u\", recordsCount);\n// 创建hyperlink的UDS，用来承载record中读取出来的hyperlink数据。\nOH_UdsHyperlink* hyperlink = OH_UdsHyperlink_Create();\n// 获取records中的元素。\nfor (int i = 0; i < recordsCount; i++) {\n    // 获取OH_UdmfRecord类型列表。\n    unsigned int recordTypeIdCount = 0;\n    char** typeIdsFromRecord = OH_UdmfRecord_GetTypes(records[i], &recordTypeIdCount);\n    for (unsigned int j = 0; j < recordTypeIdCount; j++) {\n        // 从OH_UdmfRecord中获取超链接类型数据。\n        if (strcmp(typeIdsFromRecord[j], UDMF_META_HYPERLINK) == 0) {\n            // 获取hyperlink数据。\n            if (OH_UdmfRecord_GetHyperlink(records[i], hyperlink) != Udmf_ErrCode::UDMF_E_OK) {\n                printf(\"Fail get hyperlink from record!\");\n            }\n        }\n    }\n}\n// 5. 读取OH_UdsHyperlink中的各项信息。\nprintf(\"The hyperlink type id is : %s\", OH_UdsHyperlink_GetType(hyperlink));\nprintf(\"The hyperlink url is : %s\", OH_UdsHyperlink_GetUrl(hyperlink));\nprintf(\"The hyperlink description is : %s\", OH_UdsHyperlink_GetDescription(hyperlink));\n// 6. 销毁指针。\nOH_UdsHyperlink_Destroy(hyperlink);\nOH_UdmfData_Destroy(readData);

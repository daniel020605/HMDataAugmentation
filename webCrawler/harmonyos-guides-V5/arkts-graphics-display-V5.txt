显示图片 (Image)
开发者经常需要在应用中显示一些图片，例如：按钮中的icon、网络图片、本地图片等。在应用中显示图片需要使用Image组件实现，Image支持多种图片格式，包括png、jpg、bmp、svg、gif和heif，具体用法请参考Image组件。
Image通过调用接口来创建，接口调用形式如下：
Image(src: PixelMap | ResourceStr | DrawableDescriptor)
该接口通过图片数据源获取图片，支持本地图片和网络图片的渲染展示。其中，src是图片的数据源，加载方式请参考加载图片资源。
加载图片资源
Image支持加载存档图、多媒体像素图两种类型。
[h2]存档图类型数据源
存档图类型的数据源可以分为本地资源、网络资源、Resource资源、媒体库资源和base64。
 本地资源 创建文件夹，将本地图片放入ets文件夹下的任意位置。 Image组件引入本地图片路径，即可显示图片（根目录为ets文件夹）。 Image('images/view.jpg')\n.width(200) 网络资源 引入网络图片需申请权限ohos.permission.INTERNET，具体申请方式请参考声明权限。此时，Image组件的src参数为网络图片的链接。 当前Image组件仅支持加载简单网络图片。 Image组件首次加载网络图片时，需要请求网络资源，非首次加载时，默认从缓存中直接读取图片，更多图片缓存设置请参考setImageCacheCount、setImageRawDataCacheSize、setImageFileCacheSize。但是，这三个图片缓存接口并不灵活，且后续不继续演进，对于复杂情况，更推荐使用ImageKnife。 Image('https://www.example.com/example.JPG') // 实际使用时请替换为真实地址 Resource资源 使用资源格式可以跨包/跨模块引入图片，resources文件夹下的图片都可以通过$r资源接口读取到并转换到Resource格式。 图1 resources  调用方式： Image($r('app.media.icon')) 还可以将图片放在rawfile文件夹下。 图2 rawfile  调用方式： Image($rawfile('example1.png')) 媒体库file://data/storage 支持file://路径前缀的字符串，用于访问通过选择器提供的图片路径。  调用接口获取图库的照片url。 import { photoAccessHelper } from '@kit.MediaLibraryKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n@Entry\n@Component\nstruct Index {\n  @State imgDatas: string[] = [];\n  // 获取照片url集\n  getAllImg() {\n    try {\n      let PhotoSelectOptions:photoAccessHelper.PhotoSelectOptions = new photoAccessHelper.PhotoSelectOptions();\n      PhotoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE;\n      PhotoSelectOptions.maxSelectNumber = 5;\n      let photoPicker:photoAccessHelper.PhotoViewPicker = new photoAccessHelper.PhotoViewPicker();\n      photoPicker.select(PhotoSelectOptions).then((PhotoSelectResult:photoAccessHelper.PhotoSelectResult) => {\n        this.imgDatas = PhotoSelectResult.photoUris;\n        console.info('PhotoViewPicker.select successfully, PhotoSelectResult uri: ' + JSON.stringify(PhotoSelectResult));\n      }).catch((err:Error) => {\n        let message = (err as BusinessError).message;\n        let code = (err as BusinessError).code;\n        console.error(`PhotoViewPicker.select failed with. Code: ${code}, message: ${message}`);\n      });\n    } catch (err) {\n      let message = (err as BusinessError).message;\n      let code = (err as BusinessError).code;\n      console.error(`PhotoViewPicker failed with. Code: ${code}, message: ${message}`);    }\n  }\n\n  // aboutToAppear中调用上述函数，获取图库的所有图片url，存在imgDatas中\n  async aboutToAppear() {\n    this.getAllImg();\n  }\n  // 使用imgDatas的url加载图片。\n  build() {\n    Column() {\n      Grid() {\n        ForEach(this.imgDatas, (item:string) => {\n          GridItem() {\n            Image(item)\n              .width(200)\n          }\n        }, (item:string):string => JSON.stringify(item))\n      }\n    }.width('100%').height('100%')\n  }\n} 从媒体库获取的url格式通常如下。 Image('file://media/Photos/5')\n.width(200)  base64 路径格式为data:image/[png|jpeg|bmp|webp|heif];base64,[base64 data]，其中[base64 data]为Base64字符串数据。 Base64格式字符串可用于存储图片的像素数据，在网页上使用较为广泛。 
[h2]多媒体像素图
PixelMap是图片解码后的像素图，具体用法请参考图片开发指导。以下示例将加载的网络图片返回的数据解码成PixelMap格式，再显示在Image组件上。
 创建PixelMap状态变量。 @State image: PixelMap | undefined = undefined; 引用多媒体。 (1) 引用网络权限与媒体库权限。 import { http } from '@kit.NetworkKit';\nimport { image } from '@kit.ImageKit';\nimport { BusinessError } from '@kit.BasicServicesKit'; (2) 填写网络图片地址。 let OutData: http.HttpResponse\nhttp.createHttp().request(\"https://www.example.com/xxx.png\",\n  (error: BusinessError, data: http.HttpResponse) => {\n    if (error) {\n      console.error(`http request failed with. Code: ${error.code}, message: ${error.message}`);\n    } else {\n      OutData = data\n    }\n  }\n) 将网络地址成功返回的数据，编码转码成pixelMap的图片格式。 let code: http.ResponseCode | number = OutData.responseCode\nif (http.ResponseCode.OK === code) {\n  let imageData: ArrayBuffer = OutData.result as ArrayBuffer;\n  let imageSource: image.ImageSource = image.createImageSource(imageData);\n\n  class tmp {\n    height: number = 100\n    width: number = 100\n  }\n\n  let si: tmp = new tmp()\n  let options: Record<string, number | boolean | tmp> = {\n    'alphaType': 0, // 透明度\n    'editable': false, // 是否可编辑\n    'pixelFormat': 3, // 像素格式\n    'scaleMode': 1, // 缩略值\n    'size': { height: 100, width: 100 }\n  } // 创建图片大小\n\n  class imagetmp {\n    image: PixelMap | undefined = undefined\n    set(val: PixelMap) {\n      this.image = val\n    }\n  }\n\n  imageSource.createPixelMap(options).then((pixelMap: PixelMap) => {\n    let im = new imagetmp()\n    im.set(pixelMap)\n  })\n} 显示图片。 class htp{\n  httpRequest: Function | undefined = undefined\n  set(){\n    if(this.httpRequest){\n      this.httpRequest()\n    }\n  }\n}\nButton(\"获取网络图片\")\n  .onClick(() => {\n    let sethtp = new htp()\n    sethtp.set()\n  })\nImage(this.image).height(100).width(100) 同时，也可以传入pixelMap创建PixelMapDrawableDescriptor对象，用来显示图片。 import { DrawableDescriptor, PixelMapDrawableDescriptor } from '@kit.ArkUI'\nclass htp{\n  httpRequest: Function | undefined = undefined\n  set(){\n    if(this.httpRequest){\n      this.httpRequest()\n    }\n  }\n}\nButton(\"获取网络图片\")\n  .onClick(() => {\n    let sethtp = new htp()\n    sethtp.set()\n    this.drawablePixelMap = new PixelMapDrawableDescriptor(this.image)\n  })\nImage(this.drawablePixelMap).height(100).width(100) 
显示矢量图
Image组件可显示矢量图（svg格式的图片），svg标签文档请参考svg说明。
svg格式的图片可以使用fillColor属性改变图片的绘制颜色。
Image($r('app.media.cloud'))\n  .width(50)\n  .fillColor(Color.Blue) 
图3 原始图片
图4 设置绘制颜色后的svg图片
[h2]矢量图引用位图
如果Image加载的Svg图源中包含对本地位图的引用，则Svg图源的路径应当设置为以ets为根目录的工程路径，同时，本地位图的路径应设置为与Svg图源同级的相对路径。
Image加载的Svg图源路径设置方法如下所示：
Image(\"images/icon.svg\")\n  .width(50)\n  .height(50)
Svg图源通过<image>标签的xlink:href属性指定本地位图路径，本地位图路径设置为跟Svg图源同级的相对路径：
<svg width=\"200\" height=\"200\">\n  <image width=\"200\" height=\"200\" xlink:href=\"sky.png\"></image>\n</svg>
文件工程路径示例如图：
添加属性
给Image组件设置属性可以使图片显示更灵活，达到一些自定义的效果。以下是几个常用属性的使用示例，完整属性信息详见Image。
[h2]设置图片缩放类型
通过objectFit属性使图片缩放到高度和宽度确定的框内。
@Entry\n@Component\nstruct MyComponent {\n  scroller: Scroller = new Scroller()\n\n  build() {\n    Scroll(this.scroller) {\n      Column() {\n        Row() {\n          Image($r('app.media.img_2'))\n            .width(200)\n            .height(150)\n            .border({ width: 1 })\n              // 保持宽高比进行缩小或者放大，使得图片完全显示在显示边界内。\n            .objectFit(ImageFit.Contain)\n            .margin(15)\n            .overlay('Contain', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n          Image($r('app.media.ic_img_2'))\n            .width(200)\n            .height(150)\n            .border({ width: 1 })\n              // 保持宽高比进行缩小或者放大，使得图片两边都大于或等于显示边界。\n            .objectFit(ImageFit.Cover)\n            .margin(15)\n            .overlay('Cover', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n          Image($r('app.media.img_2'))\n            .width(200)\n            .height(150)\n            .border({ width: 1 })\n              // 自适应显示。\n            .objectFit(ImageFit.Auto)\n            .margin(15)\n            .overlay('Auto', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n        }\n\n        Row() {\n          Image($r('app.media.img_2'))\n            .width(200)\n            .height(150)\n            .border({ width: 1 })\n              // 不保持宽高比进行放大缩小，使得图片充满显示边界。\n            .objectFit(ImageFit.Fill)\n            .margin(15)\n            .overlay('Fill', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n          Image($r('app.media.img_2'))\n            .width(200)\n            .height(150)\n            .border({ width: 1 })\n              // 保持宽高比显示，图片缩小或者保持不变。\n            .objectFit(ImageFit.ScaleDown)\n            .margin(15)\n            .overlay('ScaleDown', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n          Image($r('app.media.img_2'))\n            .width(200)\n            .height(150)\n            .border({ width: 1 })\n              // 保持原有尺寸显示。\n            .objectFit(ImageFit.None)\n            .margin(15)\n            .overlay('None', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n        }\n      }\n    }\n  }\n}
[h2]图片插值
当原图分辨率较低并且放大显示时，图片会模糊出现锯齿。这时可以使用interpolation属性对图片进行插值，使图片显示得更清晰。
@Entry\n@Component\nstruct Index {\n  build() {\n    Column() {\n      Row() {\n        Image($r('app.media.grass'))\n          .width('40%')\n          .interpolation(ImageInterpolation.None)\n          .borderWidth(1)\n          .overlay(\"Interpolation.None\", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n          .margin(10)\n        Image($r('app.media.grass'))\n          .width('40%')\n          .interpolation(ImageInterpolation.Low)\n          .borderWidth(1)\n          .overlay(\"Interpolation.Low\", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n          .margin(10)\n      }.width('100%')\n      .justifyContent(FlexAlign.Center)\n\n      Row() {\n        Image($r('app.media.grass'))\n          .width('40%')\n          .interpolation(ImageInterpolation.Medium)\n          .borderWidth(1)\n          .overlay(\"Interpolation.Medium\", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n          .margin(10)\n        Image($r('app.media.grass'))\n          .width('40%')\n          .interpolation(ImageInterpolation.High)\n          .borderWidth(1)\n          .overlay(\"Interpolation.High\", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n          .margin(10)\n      }.width('100%')\n      .justifyContent(FlexAlign.Center)\n    }\n    .height('100%')\n  }\n}
[h2]设置图片重复样式
通过objectRepeat属性设置图片的重复样式方式，重复样式请参考ImageRepeat枚举说明。
@Entry\n@Component\nstruct MyComponent {\n  build() {\n    Column({ space: 10 }) {\n      Row({ space: 5 }) {\n        Image($r('app.media.ic_public_favor_filled_1'))\n          .width(110)\n          .height(115)\n          .border({ width: 1 })\n          .objectRepeat(ImageRepeat.XY)\n          .objectFit(ImageFit.ScaleDown)\n          // 在水平轴和竖直轴上同时重复绘制图片\n          .overlay('ImageRepeat.XY', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n        Image($r('app.media.ic_public_favor_filled_1'))\n          .width(110)\n          .height(115)\n          .border({ width: 1 })\n          .objectRepeat(ImageRepeat.Y)\n          .objectFit(ImageFit.ScaleDown)\n          // 只在竖直轴上重复绘制图片\n          .overlay('ImageRepeat.Y', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n        Image($r('app.media.ic_public_favor_filled_1'))\n          .width(110)\n          .height(115)\n          .border({ width: 1 })\n          .objectRepeat(ImageRepeat.X)\n          .objectFit(ImageFit.ScaleDown)\n          // 只在水平轴上重复绘制图片\n          .overlay('ImageRepeat.X', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n      }\n    }.height(150).width('100%').padding(8)\n  }\n}
[h2]设置图片渲染模式
通过renderMode属性设置图片的渲染模式为原色或黑白。
@Entry\n@Component\nstruct MyComponent {\n  build() {\n    Column({ space: 10 }) {\n      Row({ space: 50 }) {\n        Image($r('app.media.example'))\n          // 设置图片的渲染模式为原色 \n          .renderMode(ImageRenderMode.Original)\n          .width(100)\n          .height(100)\n          .border({ width: 1 })\n            // overlay是通用属性，用于在组件上显示说明文字\n          .overlay('Original', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n        Image($r('app.media.example'))\n          // 设置图片的渲染模式为黑白\n          .renderMode(ImageRenderMode.Template)\n          .width(100)\n          .height(100)\n          .border({ width: 1 })\n          .overlay('Template', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })\n      }\n    }.height(150).width('100%').padding({ top: 20,right: 10 })\n  }\n}
[h2]设置图片解码尺寸
通过sourceSize属性设置图片解码尺寸，降低图片的分辨率。
原图尺寸为1280*960，该示例将图片解码为40*40和90*90。
@Entry\n@Component\nstruct Index {\n  build() {\n    Column() {\n      Row({ space: 50 }) {\n        Image($r('app.media.example'))\n          .sourceSize({\n            width: 40,\n            height: 40\n          })\n          .objectFit(ImageFit.ScaleDown)\n          .aspectRatio(1)\n          .width('25%')\n          .border({ width: 1 })\n          .overlay('width:40 height:40', { align: Alignment.Bottom, offset: { x: 0, y: 40 } })\n        Image($r('app.media.example'))\n          .sourceSize({\n            width: 90,\n            height: 90\n          })\n          .objectFit(ImageFit.ScaleDown)\n          .width('25%')\n          .aspectRatio(1)\n          .border({ width: 1 })\n          .overlay('width:90 height:90', { align: Alignment.Bottom, offset: { x: 0, y: 40 } })\n      }.height(150).width('100%').padding(20)\n    }\n  }\n}
[h2]为图片添加滤镜效果
通过colorFilter修改图片的像素颜色，为图片添加滤镜。
@Entry\n@Component\nstruct Index {\n  build() {\n    Column() {\n      Row() {\n        Image($r('app.media.example'))\n          .width('40%')\n          .margin(10)\n        Image($r('app.media.example'))\n          .width('40%')\n          .colorFilter(\n            [1, 1, 0, 0, 0,\n             0, 1, 0, 0, 0,\n             0, 0, 1, 0, 0,\n             0, 0, 0, 1, 0])\n          .margin(10)\n      }.width('100%')\n      .justifyContent(FlexAlign.Center)\n    }\n  }\n}
[h2]同步加载图片
一般情况下，图片加载流程会异步进行，以避免阻塞主线程，影响UI交互。但是特定情况下，图片刷新时会出现闪烁，这时可以使用syncLoad属性，使图片同步加载，从而避免出现闪烁。不建议图片加载较长时间时使用，会导致页面无法响应。
Image($r('app.media.icon'))\n  .syncLoad(true)
事件调用
通过在Image组件上绑定onComplete事件，图片加载成功后可以获取图片的必要信息。如果图片加载失败，也可以通过绑定onError回调来获得结果。
@Entry\n@Component\nstruct MyComponent {\n  @State widthValue: number = 0\n  @State heightValue: number = 0\n  @State componentWidth: number = 0\n  @State componentHeight: number = 0\n\n  build() {\n    Column() {\n      Row() {\n        Image($r('app.media.ic_img_2'))\n          .width(200)\n          .height(150)\n          .margin(15)\n          .onComplete(msg => {\n            if(msg){\n              this.widthValue = msg.width\n              this.heightValue = msg.height\n              this.componentWidth = msg.componentWidth\n              this.componentHeight = msg.componentHeight\n            }\n          })\n            // 图片获取失败，打印结果\n          .onError(() => {\n            console.info('load image fail')\n          })\n          .overlay('\\nwidth: ' + String(this.widthValue) + ', height: ' + String(this.heightValue) + '\\ncomponentWidth: ' + String(this.componentWidth) + '\\ncomponentHeight: ' + String(this.componentHeight), {\n            align: Alignment.Bottom,\n            offset: { x: 0, y: 60 }\n          })\n      }\n    }\n  }\n}

数据库备份与恢复
场景介绍
当应用在处理一项重要的操作，显然是不能被打断的。例如：写入多个表关联的事务。此时，每个表的写入都是单独的，但是表与表之间的事务关联性不能被分割。
如果操作的过程中出现问题，开发者可以使用恢复功能，将数据库恢复到之前的状态，重新对数据库进行操作。
在数据库被篡改、删除、或者设备断电场景下，数据库可能会因为数据丢失、数据损坏、脏数据等而不可用，可以通过数据库的备份恢复能力将数据库恢复至可用状态。
键值型数据库和关系型数据库均支持对数据库的备份和恢复。另外，键值型数据库还支持删除数据库备份，以释放本地存储空间。
键值型数据库备份、恢复与删除
键值型数据库，通过backup接口实现数据库备份，通过restore接口实现数据库恢复，通过deletebackup接口删除数据库备份。具体接口及功能，可见分布式键值数据库。
 创建数据库。 (1) 创建kvManager。 (2) 配置数据库参数。 (3) 创建kvStore。 import { distributedKVStore } from '@kit.ArkData';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet kvManager: distributedKVStore.KVManager;\nlet kvStore: distributedKVStore.SingleKVStore | undefined = undefined;\nlet context = getContext(this);\nconst kvManagerConfig: distributedKVStore.KVManagerConfig = {\n  context: context,\n  bundleName: 'com.example.datamanagertest'\n}\ntry {\n  kvManager = distributedKVStore.createKVManager(kvManagerConfig);\n  console.info('Succeeded in creating KVManager.');\n  try {\n    const options: distributedKVStore.Options = {\n      createIfMissing: true,\n      encrypt: true,\n      backup: false,\n      autoSync: false,\n      kvStoreType: distributedKVStore.KVStoreType.SINGLE_VERSION,\n      securityLevel: distributedKVStore.SecurityLevel.S1\n    };\n    kvManager.getKVStore<distributedKVStore.SingleKVStore>('storeId', options, (err, store: distributedKVStore.SingleKVStore) => {\n      if (err) {\n        console.error(`Failed to get KVStore. Code:${err.code},message:${err.message}`);\n        return;\n      }\n      console.info('Succeeded in getting KVStore.');\n      kvStore = store;\n    });\n  } catch (e) {\n    let error = e as BusinessError;\n    console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n  }\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`Failed to create KVManager. Code:${error.code},message:${error.message}`);\n}\n\nif (kvStore !== undefined) {\n  kvStore = kvStore as distributedKVStore.SingleKVStore;\n  //进行后续操作\n  //...\n} 使用put()方法插入数据。 const KEY_TEST_STRING_ELEMENT = 'key_test_string';\nconst VALUE_TEST_STRING_ELEMENT = 'value_test_string';\ntry {\n  kvStore.put(KEY_TEST_STRING_ELEMENT, VALUE_TEST_STRING_ELEMENT, (err) => {\n    if (err !== undefined) {\n      console.error(`Fail to put data. Code:${err.code},message:${err.message}`);\n      return;\n    }\n    console.info('Succeeded in putting data.');\n  });\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n} 使用backup()方法备份数据。 let backupFile = 'BK001';\ntry {\n  kvStore.backup(backupFile, (err) => {\n    if (err) {\n      console.error(`Fail to backup data.code:${err.code},message:${err.message}`);\n    } else {\n      console.info('Succeeded in backupping data.');\n    }\n  });\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n} 使用delete()方法删除数据（模拟意外删除、篡改场景）。 try {\n  kvStore.delete(KEY_TEST_STRING_ELEMENT, (err) => {\n    if (err !== undefined) {\n      console.error(`Fail to delete data. Code:${err.code},message:${err.message}`);\n      return;\n    }\n    console.info('Succeeded in deleting data.');\n  });\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n} 使用restore()方法恢复数据。 try {\n  kvStore.restore(backupFile, (err) => {\n    if (err) {\n      console.error(`Fail to restore data. Code:${err.code},message:${err.message}`);\n    } else {\n      console.info('Succeeded in restoring data.');\n    }\n  });\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n} 当本地设备存储空间有限或需要重新备份时，还可使用deleteBackup()方法删除备份，释放存储空间。 let files = [backupFile];\ntry {\n  kvStore.deleteBackup(files).then((data) => {\n    console.info(`Succeed in deleting Backup. Data:filename is ${data[0]},result is ${data[1]}.`);\n  }).catch((err: BusinessError) => {\n    console.error(`Fail to delete Backup. Code:${err.code},message:${err.message}`);\n  })\n} catch (e) {\n  let error = e as BusinessError;\n  console.error(`An unexpected error occurred. Code:${error.code},message:${error.message}`);\n} 
关系型数据库备份
数据库操作或者存储过程中，有可能会因为各种原因发生非预期的数据库异常的情况，可以根据需要使用关系型数据库的备份能力，以便在数据库异常时，可靠高效地恢复数据保证业务数据正常使用。
关系型数据库支持两种手动备份和自动备份（仅系统应用可用）两种方式。
[h2]手动备份
手动备份：通过调用backup接口实现数据库手动备份。示例如下：
import { relationalStore } from '@kit.ArkData';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { fileIo } from '@kit.CoreFileKit';\n\nlet store: relationalStore.RdbStore | undefined = undefined;\n\nlet context = getContext(this);\n\nconst STORE_CONFIG: relationalStore.StoreConfig = {\n  name: 'RdbTest.db',\n  securityLevel: relationalStore.SecurityLevel.S3,\n  allowRebuild: true\n};\nrelationalStore.getRdbStore(context, STORE_CONFIG, (err, rdbStore) => {\n  store = rdbStore;\n  if (err) {\n    console.error(`Failed to get RdbStore. Code:${err.code},message:${err.message}`);\n    return;\n  }\n  store.executeSql('CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INTEGER, SALARY REAL, CODES BLOB)', (err) => {\n  })\n  console.info('Succeeded in getting RdbStore.');\n\n  // \"Backup.db\"为备份数据库文件名，默认在RdbStore同路径下备份。也可指定路径：customDir + \"backup.db\"\n  (store as relationalStore.RdbStore).backup(\"Backup.db\", (err: BusinessError) => {\n    if (err) {\n      console.error(`Failed to backup RdbStore. Code:${err.code}, message:${err.message}`);\n        return;\n     }\n     console.info(`Succeeded in backing up RdbStore.`);\n  })\n})
关系型数据库异常重建
在创建或使用关系型数据库的过程中，抛出14800011异常错误码说明数据库出现异常，可以删除数据库后恢复数据。
需要通过在StoreConfig中配置allowRebuild参数为true以设置数据库在出现异常时自动删库。数据库重建成功后为空库，需要开发者重新建表并且使用提前备份好的数据进行数据恢复，备份操作可见关系型数据库备份，数据恢复可见关系型数据库恢复。
若数据库异常前已配置StoreConfig中的allowRebuild为true，则数据库出现异常时将自动删库。
若数据库异常前未配置StoreConfig中的allowRebuild或allowRebuild配置为false，则需将其配置为true再次进行开库。具体示例如下：
import { relationalStore } from '@kit.ArkData';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet store: relationalStore.RdbStore | undefined = undefined;\n\nlet context = getContext(this);\n\nconst STORE_CONFIG: relationalStore.StoreConfig = {\n  name: 'RdbTest.db',\n  securityLevel: relationalStore.SecurityLevel.S3,\n  allowRebuild: true\n};\nrelationalStore.getRdbStore(context, STORE_CONFIG, (err, rdbStore) => {\n  store = rdbStore;\n  if (err) {\n    console.error(`Failed to get RdbStore. Code:${err.code},message:${err.message}`);\n    return;\n  }\n  store.executeSql('CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INTEGER, SALARY REAL, CODES BLOB)', (err) => {\n  })\n  console.info('Succeeded in getting RdbStore.');\n})
关系型数据库数据恢复
针对数据库出现异常的情况，在数据库重建成功后，需要用提前备份好的数据进行数据恢复。
恢复方式分以下两种，手动备份恢复和自动备份恢复（仅系统应用可用）。
[h2]恢复手动备份数据
关系型数据库通过调用backup接口可以实现手动备份数据库，通过restore接口可以实现手动恢复数据库。
具体恢复过程和关键示例代码片段如下，完整示例代码请结合关系型数据库的备份、重建等上下文进行实现。
 抛出数据库异常错误码。 let predicates = new relationalStore.RdbPredicates(\"EMPLOYEE\");\nif (store != undefined) {\n  (store as relationalStore.RdbStore).query(predicates, [\"ID\", \"NAME\", \"AGE\", \"SALARY\", \"CODES\"]).then((result: relationalStore.ResultSet) => {\n    let resultSet = result;\n    try {\n      /* ...\n         业务的增删改逻辑\n         ...\n      */\n      // 抛出异常\n      if (resultSet?.rowCount == -1) {\n        resultSet ?.isColumnNull(0);\n      }\n      // todo resultSet.goToFirstRow(), resultSet.count等其它接口也会抛异常\n      while (resultSet.goToNextRow()) {\n        console.info(JSON.stringify(resultSet.getRow()))\n      }\n      resultSet.close();\n    } catch (err) {\n        if (err.code === 14800011) {\n           // 执行下文的步骤，即关闭结果集之后进行数据的恢复\n        }\n        console.error(JSON.stringify(err));\n    }\n  })\n} 关闭所有打开着的结果集。 // 获取所有打开着的结果集\nlet resultSets: Array<relationalStore.ResultSet> = [];\n// 使用resultSet.close()方法关闭所有打开着的结果集\nfor (let resultSet of resultSets) {\n  try {\n    resultSet.close();\n  } catch (e) {\n      if (e.code !== 14800014) {\n        console.error(`Code:${e.code}, message:${e.message}`);\n      }\n  }\n} 调用restore接口恢复数据。 try {\n  let context = getContext();\n  // \"Backup.db\"为备份数据库文件名，默认在RdbStore同路径下备份。也可指定路径：customDir + \"backup.db\"\n  let backup = context.databaseDir + '/backup/test_backup.db';\n  if(!fileIo.access(backup)) {\n    console.info(\"no backup file\");\n    try {\n      (store as relationalStore.RdbStore).close;\n      store = undefined;\n    } catch (e) {\n        if (e.code != 14800014) {\n          console.info(JSON.stringify(e));\n        }\n    }\n    let storeConfig: relationalStore.StoreConfig = {\n      name: \"BackupResotreTest.db\",\n      securityLevel: relationalStore.SecurityLevel.S3,\n      allowRebuild: true\n    }\n    // todo 开库建表\n    // todo 自行生成数据\n    return\n  }\n  // 调用restore接口恢复数据\n  (store as relationalStore.RdbStore).restore(backup);\n} catch (e) {\n    console.error(`Code:${e.code}, message:${e.message}`);\n} 

自定义属性动画
属性动画是可动画属性的参数值发生变化时，引起UI上产生的连续视觉效果。当参数值发生连续变化，且设置到可以引起UI发生变化的属性接口上时，就可以实现属性动画。
ArkUI提供@AnimatableExtend装饰器，用于自定义可动画属性接口。由于参数的数据类型必须具备一定程度的连续性，自定义可动画属性接口的参数类型仅支持number类型和实现AnimatableArithmetic<T>接口的自定义类型。通过自定义可动画属性接口和可动画数据类型，在使用animateTo或animation执行动画时，通过逐帧回调函数修改不可动画属性接口的值，能够让不可动画属性接口实现动画效果。也可通过逐帧回调函数每帧修改可动画属性的值，实现逐帧布局的效果。
使用number数据类型和@AnimatableExtend装饰器改变Text组件宽度实现逐帧布局的效果
// 第一步：使用@AnimatableExtend装饰器，自定义可动画属性接口\n@AnimatableExtend(Text)\nfunction animatableWidth(width: number) {\n  .width(width) // 调用系统属性接口，逐帧回调函数每帧修改可动画属性的值，实现逐帧布局的效果。\n}\n\n@Entry\n@Component\nstruct AnimatablePropertyExample {\n  @State textWidth: number = 80;\n\n  build() {\n    Column() {\n      Text(\"AnimatableProperty\")\n        .animatableWidth(this.textWidth)// 第二步：将自定义可动画属性接口设置到组件上\n        .animation({ duration: 2000, curve: Curve.Ease }) // 第三步:为自定义可动画属性接口绑定动画\n      Button(\"Play\")\n        .onClick(() => {\n          this.textWidth = this.textWidth == 80 ? 160 : 80; // 第四步：改变自定义可动画属性的参数，产生动画\n        })\n    }.width(\"100%\")\n    .padding(10)\n  }\n}
使用自定义数据类型和@AnimatableExtend装饰器改变图形形状
declare type Point = number[];\n\n// 定义可动画属性接口的参数类型，实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数\nclass PointClass extends Array<number> {\n  constructor(value: Point) {\n    super(value[0], value[1])\n  }\n\n  add(rhs: PointClass): PointClass {\n    let result: Point = new Array<number>() as Point;\n    for (let i = 0; i < 2; i++) {\n      result.push(rhs[i] + this[i])\n    }\n    return new PointClass(result);\n  }\n\n  subtract(rhs: PointClass): PointClass {\n    let result: Point = new Array<number>() as Point;\n    for (let i = 0; i < 2; i++) {\n      result.push(this[i] - rhs[i]);\n    }\n    return new PointClass(result);\n  }\n\n  multiply(scale: number): PointClass {\n    let result: Point = new Array<number>() as Point;\n    for (let i = 0; i < 2; i++) {\n      result.push(this[i] * scale)\n    }\n    return new PointClass(result);\n  }\n}\n\n// 定义可动画属性接口的参数类型，实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数\n// 模板T支持嵌套实现AnimatableArithmetic<T>的类型\nclass PointVector extends Array<PointClass> implements AnimatableArithmetic<Array<Point>> {\n  constructor(initialValue: Array<Point>) {\n    super();\n    if (initialValue.length) {\n      initialValue.forEach((p: Point) => this.push(new PointClass(p)))\n    }\n  }\n\n  // implement the IAnimatableArithmetic interface\n  plus(rhs: PointVector): PointVector {\n    let result = new PointVector([]);\n    const len = Math.min(this.length, rhs.length)\n    for (let i = 0; i < len; i++) {\n      result.push(this[i].add(rhs[i]))\n    }\n    return result;\n  }\n\n  subtract(rhs: PointVector): PointVector {\n    let result = new PointVector([]);\n    const len = Math.min(this.length, rhs.length)\n    for (let i = 0; i < len; i++) {\n      result.push(this[i].subtract(rhs[i]))\n    }\n    return result;\n  }\n\n  multiply(scale: number): PointVector {\n    let result = new PointVector([]);\n    for (let i = 0; i < this.length; i++) {\n      result.push(this[i].multiply(scale))\n    }\n    return result;\n  }\n\n  equals(rhs: PointVector): boolean {\n    if (this.length !== rhs.length) {\n      return false;\n    }\n    for (let index = 0, size = this.length; index < size; ++index) {\n      if (this[index][0] !== rhs[index][0] || this[index][1] !== rhs[index][1]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n// 自定义可动画属性接口\n@AnimatableExtend(Polyline)\nfunction animatablePoints(points: PointVector) {\n  .points(points)\n}\n\n@Entry\n@Component\nstruct AnimatedShape {\n  squareStartPointX: number = 75;\n  squareStartPointY: number = 25;\n  squareWidth: number = 150;\n  squareEndTranslateX: number = 50;\n  squareEndTranslateY: number = 50;\n  @State pointVec1: PointVector = new PointVector([\n    [this.squareStartPointX, this.squareStartPointY],\n    [this.squareStartPointX + this.squareWidth, this.squareStartPointY],\n    [this.squareStartPointX + this.squareWidth, this.squareStartPointY + this.squareWidth],\n    [this.squareStartPointX, this.squareStartPointY + this.squareWidth]\n  ]);\n  @State pointVec2: PointVector = new PointVector([\n    [this.squareStartPointX + this.squareEndTranslateX, this.squareStartPointY + this.squareStartPointY],\n    [this.squareStartPointX + this.squareWidth + this.squareEndTranslateX,\n      this.squareStartPointY + this.squareStartPointY],\n    [this.squareStartPointX + this.squareWidth, this.squareStartPointY + this.squareWidth],\n    [this.squareStartPointX, this.squareStartPointY + this.squareWidth]\n  ]);\n  @State color: Color = Color.Green;\n  @State fontSize: number = 20.0;\n  @State polyline1Vec: PointVector = this.pointVec1;\n  @State polyline2Vec: PointVector = this.pointVec2;\n\n  build() {\n    Row() {\n      Polyline()\n        .width(300)\n        .height(200)\n        .backgroundColor(\"#0C000000\")\n        .fill('#317AF7')\n        .animatablePoints(this.polyline1Vec)\n        .animation({ duration: 2000, delay: 0, curve: Curve.Ease })\n        .onClick(() => {\n\n          if (this.polyline1Vec.equals(this.pointVec1)) {\n            this.polyline1Vec = this.pointVec2;\n          } else {\n            this.polyline1Vec = this.pointVec1;\n          }\n        })\n    }\n    .width('100%').height('100%').justifyContent(FlexAlign.Center)\n  }\n}

拦截Web组件发起的网络请求
通过网络拦截接口(arkweb_scheme_handler.h)对Web组件发出的请求进行拦截，并可以为被拦截的请求提供自定义的响应头以及响应体。
为Web组件设置网络拦截器
为指定的Web组件或者ServiceWorker设置ArkWeb_SchemeHandler，当Web内核发出相应scheme请求的时候，会触发ArkWeb_SchemeHandler的回调。需要在Web组件初始化之后设置网络拦截器。
当请求开始的时候会回调ArkWeb_OnRequestStart，请求结束的时候会回调ArkWeb_OnRequestStop。
如果想要拦截Web组件发出的第一个请求，可以通过initializeWebEngine对Web组件提前进行初始化，然后设置拦截器进行拦截。
  // 创建一个ArkWeb_SchemeHandler对象。\n  ArkWeb_SchemeHandler *schemeHandler;\n  OH_ArkWeb_CreateSchemeHandler(&schemeHandler);\n\n  // 为ArkWeb_SchemeHandler设置ArkWeb_OnRequestStart与ArkWeb_OnRequestStop回调。\n  OH_ArkWebSchemeHandler_SetOnRequestStart(schemeHandler, OnURLRequestStart);\n  OH_ArkWebSchemeHandler_SetOnRequestStop(schemeHandler, OnURLRequestStop);\n\n  // 拦截webTag为“scheme-handler”的Web组件发出的scheme为“https”的请求。\n  OH_ArkWeb_SetSchemeHandler(\"https\", \"scheme-handler\", schemeHandler);\n  OH_ArkWebServiceWorker_SetSchemeHandler(\"https\", schemeHandler);
也可以拦截非Web组件内置scheme的请求。
  // 创建一个ArkWeb_SchemeHandler对象。\n  ArkWeb_SchemeHandler *schemeHandler;\n  OH_ArkWeb_CreateSchemeHandler(&schemeHandler);\n\n  // 为ArkWeb_SchemeHandler设置ArkWeb_OnRequestStart与ArkWeb_OnRequestStop回调。\n  OH_ArkWebSchemeHandler_SetOnRequestStart(schemeHandler, OnURLRequestStart);\n  OH_ArkWebSchemeHandler_SetOnRequestStop(schemeHandler, OnURLRequestStop);\n\n  // 拦截webTag为“scheme-handler”的Web组件发出的scheme为“custom”的请求。\n  OH_ArkWeb_SetSchemeHandler(\"custom\", \"scheme-handler\", schemeHandler);\n  OH_ArkWebServiceWorker_SetSchemeHandler(\"custom\", schemeHandler);
设置自定义scheme需要遵循的规则
如果要拦截自定义scheme的请求，需要提前将自定义scheme注册到Web内核。需要在Web组件初始化之前进行注册，Web组件初始化后再注册会失败。
  // 注册“custom“ scheme到Web组件，并指定该scheme需要遵循标准的scheme规则，允许该scheme发出跨域请求。\n  OH_ArkWeb_RegisterCustomSchemes(\"custom\", ARKWEB_SCHEME_OPTION_STANDARD | ARKWEB_SCHEME_OPTION_CORS_ENABLED);\n  // 注册“custom-local” scheme到Web组件，并指定该scheme需要遵循与“file” scheme一样的规则。\n  OH_ArkWeb_RegisterCustomSchemes(\"custom-local\", ARKWEB_SCHEME_OPTION_LOCAL);\n  // 注册“custom-csp-bypassing”到Web组件，并指定该scheme需要遵循标准的scheme规则，允许忽略CSP检查。\n  OH_ArkWeb_RegisterCustomSchemes(\"custom-csp-bypassing\", ARKWEB_SCHEME_OPTION_CSP_BYPASSING | ARKWEB_SCHEME_OPTION_STANDARD);\n  // 注册“custom-isolated”到Web组件，并指定该scheme的请求必须从相同scheme加载的网页中发起。\n  OH_ArkWeb_RegisterCustomSchemes(\"custom-isolated\", ARKWEB_SCHEME_OPTION_DISPLAY_ISOLATED);
由于注册scheme需要在Web组件初始化之前进行注册，而网络拦截器需要在Web组件初始化之后设置，建议在EntryAbility的onCreate中调用c++接口注册scheme。
scheme注册完毕后，通过initializeWebEngine对Web组件进行初始化，初始化完成后再设置网络拦截器。
  export default class EntryAbility extends UIAbility {\n      onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n          // 注册scheme的配置。\n          testNapi.registerCustomSchemes();\n          // 初始化Web组件内核，该操作会初始化Browser进程以及创建BrowserContext。\n          webview.WebviewController.initializeWebEngine();\n          // 创建并设置ArkWeb_SchemeHandler。\n          testNapi.setSchemeHandler();\n      }\n      ...\n  };
获取被拦截请求的请求信息
通过OH_ArkWebResourceRequest_*接口获取被拦截请求的信息。可以获取url、method、referrer、headers、resourceType等信息。
  char* url;\n  OH_ArkWebResourceRequest_GetUrl(resourceRequest_, &url);\n  OH_ArkWeb_ReleaseString(url);\n\n  char* method;\n  OH_ArkWebResourceRequest_GetMethod(resourceRequest_, &method);\n  OH_ArkWeb_ReleaseString(method);\n\n  int32_t resourceType = OH_ArkWebResourceRequest_GetResourceType(resourceRequest_);\n\n  char* frameUrl;\n  OH_ArkWebResourceRequest_GetFrameUrl(resourceRequest_, &frameUrl);\n  OH_ArkWeb_ReleaseString(frameUrl);\n  ...
支持获取PUT/POST类请求的上传数据。数据类型支持BYTES、FILE、BLOB和CHUNKED。
  // 获取被拦截请求的上传数据。\n  OH_ArkWebResourceRequest_GetHttpBodyStream(resourceRequest(), &stream_);\n  // 设置读取上传数据的读回调。\n  OH_ArkWebHttpBodyStream_SetReadCallback(stream_, ReadCallback);\n  // 初始化ArkWeb_HttpBodyStream，其它OH_ArkWebHttpBodyStream*函数需要在初始化进行调用。\n  OH_ArkWebHttpBodyStream_Init(stream_, InitCallback);
为被拦截的请求提供自定义的响应体
Web组件的网络拦截支持在worker线程以流的方式为被拦截的请求提供自定义的响应体。也可以以特定的网络错误码(arkweb_net_error_list.h)结束当前被拦截的请求。
  // 为被拦截的请求创建一个响应头。\n  ArkWeb_Response *response;\n  OH_ArkWeb_CreateResponse(&response);\n\n  // 设置HTTP状态码为200。\n  OH_ArkWebResponse_SetStatus(response, 200);\n  // 设置响应体的编码格式。\n  OH_ArkWebResponse_SetCharset(response, \"UTF-8\");\n  // 设置响应体的大小。\n  OH_ArkWebResponse_SetHeaderByName(response, \"content-length\", \"1024\", false);\n  // 将为被拦截的请求创建的响应头传递给Web组件。\n  OH_ArkWebResourceHandler_DidReceiveResponse(resourceHandler, response);\n\n  // 该函数可以调用多次，数据可以分多份来传递给Web组件。\n  OH_ArkWebResourceHandler_DidReceiveData(resourceHandler, buffer, bufLen);\n\n  // 读取响应体结束，当然如果希望该请求失败的话也可以通过调用OH_ArkWebResourceHandler_DidFailWithError(resourceHandler_, errorCode);\n  // 传递给Web组件一个错误码并结束该请求。\n  OH_ArkWebResourceHandler_DidFinish(resourceHandler);
完整示例
使用DevEco Studio创建一个默认的Native C++工程，需要提前准备一个mp4文件，命名为test.mp4，将test.mp4放到main/resources/rawfile下。
main/ets/pages/index.ets
import testNapi from 'libentry.so';\nimport { webview } from '@kit.ArkWeb';\nimport { resourceManager } from '@kit.LocalizationKit';\n\n@Entry\n@Component\nstruct Index {\n  mycontroller: webview.WebviewController = new webview.WebviewController(\"scheme-handler\");\n\n  build() {\n    Row() {\n      Column() {\n        Button(\"goback\").onClick( event => {\n          this.mycontroller.backward();\n        })\n\n        Web({ src: $rawfile(\"test.html\"), controller: this.mycontroller})\n          .javaScriptAccess(true)\n          .width('100%')\n          .height('100%')\n          .databaseAccess(true)\n          .fileAccess(false)\n          .domStorageAccess(true)\n          .cacheMode(CacheMode.Default)\n          .onPageBegin( event => {\n            testNapi.initResourceManager(getContext().resourceManager);\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
main/ets/entryability/EntryAbility.ets
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\nimport { window } from '@kit.ArkUI';\nimport testNapi from 'libentry.so';\nimport { webview } from '@kit.ArkWeb';\n\nexport default class EntryAbility extends UIAbility {\n    onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n        // 注册三方协议的配置。\n        testNapi.registerCustomSchemes();\n        // 初始化Web组件内核，该操作会初始化Browser进程以及创建BrowserContext。\n        webview.WebviewController.initializeWebEngine();\n        // 设置SchemeHandler。\n        testNapi.setSchemeHandler();\n    }\n\n    onDestroy(): void {\n\n    }\n\n    onWindowStageCreate(windowStage: window.WindowStage): void {\n        windowStage.loadContent('pages/Index', (err, data) => {\n            if (err.code) {\n                return;\n            }\n        });\n    }\n\n    onWindowStageDestroy(): void {\n\n    }\n\n    onForeground(): void {\n\n    }\n\n    onBackground(): void {\n\n    }\n};
main/cpp/hello.cpp
#include \"hilog/log.h\"\n#include \"napi/native_api.h\"\n#include \"rawfile_request.h\"\n#include \"rawfile/raw_file_manager.h\"\n#include \"web/arkweb_scheme_handler.h\"\n#include \"web/arkweb_net_error_list.h\"\n\n#undef LOG_TAG\n#define LOG_TAG \"ss-handler\"\n\nArkWeb_SchemeHandler *g_schemeHandler;\nArkWeb_SchemeHandler *g_schemeHandlerForSW;\nNativeResourceManager *g_resourceManager;\n\n// 注册三方协议的配置，需要在Web内核初始化之前调用，否则会注册失败。\nstatic napi_value RegisterCustomSchemes(napi_env env, napi_callback_info info)\n{\n    OH_LOG_INFO(LOG_APP, \"register custom schemes\");\n    OH_ArkWeb_RegisterCustomSchemes(\"custom\", ARKWEB_SCHEME_OPTION_STANDARD | ARKWEB_SCHEME_OPTION_CORS_ENABLED);\n    OH_ArkWeb_RegisterCustomSchemes(\"custom-local\", ARKWEB_SCHEME_OPTION_LOCAL);\n    OH_ArkWeb_RegisterCustomSchemes(\"custom-csp-bypassing\", ARKWEB_SCHEME_OPTION_CSP_BYPASSING | ARKWEB_SCHEME_OPTION_STANDARD);\n    OH_ArkWeb_RegisterCustomSchemes(\"custom-isolated\", ARKWEB_SCHEME_OPTION_DISPLAY_ISOLATED);\n    return nullptr;\n}\n\n// 请求开始的回调，在该函数中我们创建一个RawfileRequest来实现对Web内核请求的拦截。\nvoid OnURLRequestStart(const ArkWeb_SchemeHandler *schemeHandler,\n                       ArkWeb_ResourceRequest *resourceRequest,\n                       const ArkWeb_ResourceHandler *resourceHandler,\n                       bool *intercept)\n{\n    *intercept = true;\n    RawfileRequest* request = new RawfileRequest(resourceRequest, resourceHandler, g_resourceManager);\n    OH_ArkWebResourceRequest_SetUserData(resourceRequest, request);\n    request->Start();\n}\n\n// 请求结束的回调，在该函数中我们需要标记RawfileRequest已经结束了，内部不应该再使用ResourceHandler。\nvoid OnURLRequestStop(const ArkWeb_SchemeHandler *schemeHandler,\n                      const ArkWeb_ResourceRequest *request)\n{\n    if (!request) {\n        OH_LOG_ERROR(LOG_APP, \"on request stop request is nullptr.\");\n        return;\n    }\n\n    RawfileRequest *rawfileRequest = (RawfileRequest *)OH_ArkWebResourceRequest_GetUserData(request);\n    if (rawfileRequest) {\n        rawfileRequest->Stop();\n    }\n}\n\nvoid OnURLRequestStartForSW(const ArkWeb_SchemeHandler *schemeHandler,\n                            ArkWeb_ResourceRequest *resourceRequest,\n                            const ArkWeb_ResourceHandler *resourceHandler,\n                            bool *intercept)\n{\n    *intercept = true;\n    RawfileRequest* request = new RawfileRequest(resourceRequest, resourceHandler, g_resourceManager);\n    OH_ArkWebResourceRequest_SetUserData(resourceRequest, request);\n    request->Start();\n}\n\nvoid OnURLRequestStopForSW(const ArkWeb_SchemeHandler *schemeHandler,\n                           const ArkWeb_ResourceRequest *request)\n{\n    if (!request) {\n        OH_LOG_ERROR(LOG_APP, \"on request stop request is nullptr.\");\n        return;\n    }\n\n    RawfileRequest *rawfileRequest = (RawfileRequest *)OH_ArkWebResourceRequest_GetUserData(request);\n    if (rawfileRequest) {\n        rawfileRequest->Stop();\n    }\n}\n\n// 设置SchemeHandler。\nstatic napi_value SetSchemeHandler(napi_env env, napi_callback_info info)\n{\n    OH_LOG_INFO(LOG_APP, \"set scheme handler\");\n    OH_ArkWeb_CreateSchemeHandler(&g_schemeHandler);\n    OH_ArkWeb_CreateSchemeHandler(&g_schemeHandlerForSW);\n\n    OH_ArkWebSchemeHandler_SetOnRequestStart(g_schemeHandler, OnURLRequestStart);\n    OH_ArkWebSchemeHandler_SetOnRequestStop(g_schemeHandler, OnURLRequestStop);\n\n    OH_ArkWebSchemeHandler_SetOnRequestStart(g_schemeHandlerForSW, OnURLRequestStart);\n    OH_ArkWebSchemeHandler_SetOnRequestStop(g_schemeHandlerForSW, OnURLRequestStop);\n\n    OH_ArkWeb_SetSchemeHandler(\"custom\", \"scheme-handler\", g_schemeHandler);\n    OH_ArkWeb_SetSchemeHandler(\"custom-csp-bypassing\", \"scheme-handler\", g_schemeHandler);\n    OH_ArkWeb_SetSchemeHandler(\"custom-isolated\", \"scheme-handler\", g_schemeHandler);\n    OH_ArkWeb_SetSchemeHandler(\"custom-local\", \"scheme-handler\", g_schemeHandler);\n    OH_ArkWeb_SetSchemeHandler(\"https\", \"scheme-handler\", g_schemeHandler);\n    OH_ArkWeb_SetSchemeHandler(\"http\", \"scheme-handler\", g_schemeHandler);\n\n    OH_ArkWebServiceWorker_SetSchemeHandler(\"https\", g_schemeHandlerForSW);\n    return nullptr;\n}\n\nstatic napi_value InitResourceManager(napi_env env, napi_callback_info info)\n{\n    size_t argc = 2;\n    napi_value argv[2] = {nullptr};\n    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);\n    g_resourceManager = OH_ResourceManager_InitNativeResourceManager(env, argv[0]);\n    return nullptr;\n}\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        {\"setSchemeHandler\", nullptr, SetSchemeHandler, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"initResourceManager\", nullptr, InitResourceManager, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"registerCustomSchemes\", nullptr, RegisterCustomSchemes, nullptr, nullptr, nullptr, napi_default, nullptr}\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void*)0),\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void)\n{\n    napi_module_register(&demoModule);\n}
main/cpp/CMakeLists.txt
# the minimum version of CMake.\ncmake_minimum_required(VERSION 3.4.1)\nproject(schemehandler)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n\nif(DEFINED PACKAGE_INFO_FILE)\n    include(${PACKAGE_INFO_FILE})\nendif()\n\ninclude_directories(${NATIVERENDER_ROOT_PATH}\n                    ${NATIVERENDER_ROOT_PATH}/include)\n\nadd_library(entry SHARED rawfile_request.cpp hello.cpp)\ntarget_link_libraries(entry PUBLIC librawfile.z.so libace_napi.z.so libohweb.so libhilog_ndk.z.so)
main/cpp/types/index.d.ts
export const registerCustomSchemes: () => void;\nexport const setSchemeHandler: () => void;\nexport const initResourceManager: (resmgr: resourceManager.ResourceManager) => void;
main/cpp/rawfile_request.h
#ifndef RAWFILE_REQUEST_H\n#define RAWFILE_REQUEST_H\n\n#include <mutex>\n#include <string>\n\n#include <rawfile/raw_file_manager.h>\n#include \"web/arkweb_scheme_handler.h\"\n#include \"web/arkweb_net_error_list.h\"\n\nclass RawfileRequest {\npublic:\n    RawfileRequest(const ArkWeb_ResourceRequest *resourceRequest,\n                   const ArkWeb_ResourceHandler *resourceHandler,\n                   const NativeResourceManager* resourceManager);\n    ~RawfileRequest();\n\n    void Start();\n    void Stop();\n    void ReadRawfileDataOnWorkerThread();\n\n    const ArkWeb_ResourceHandler *resourceHandler() { return resourceHandler_; }\n    const ArkWeb_ResourceRequest *resourceRequest() { return resourceRequest_; }\n    const NativeResourceManager *resourceManager() { return resourceManager_; }\n    ArkWeb_Response *response() { return response_; }\n    ArkWeb_HttpBodyStream *stream() { return stream_; }\n    const std::string rawfilePath() { return rawfilePath_; }\n\n    void DidReceiveResponse();\n    void DidReceiveData(const uint8_t *buffer, int64_t bufLen);\n    void DidFinish();\n    void DidFailWithError(ArkWeb_NetError errorCode);\n\nprivate:\n    const ArkWeb_ResourceRequest *resourceRequest_{nullptr};\n    const ArkWeb_ResourceHandler *resourceHandler_{nullptr};\n    const NativeResourceManager *resourceManager_{nullptr};\n    ArkWeb_Response *response_;\n    bool stopped_{false};\n    std::string rawfilePath_;\n    ArkWeb_HttpBodyStream *stream_{nullptr};\n    std::mutex mutex_;\n};\n\n#endif  // RAWFILE_REQUEST_H
main/cpp/rawfile_request.cpp
#include \"rawfile_request.h\"\n\n#include \"threads.h\"\n\n#include \"hilog/log.h\"\n#include \"rawfile/raw_file.h\"\n#include \"rawfile/raw_file_manager.h\"\n\n#undef LOG_TAG\n#define LOG_TAG \"ss-handler\"\n\nnamespace {\n\nuint8_t buffer[1024];\ncnd_t http_body_cnd;\nmtx_t http_body_mtx;\n\n// HttpBodyStream的读回调。\nvoid ReadCallback(const ArkWeb_HttpBodyStream  *httpBodyStream, uint8_t* buffer, int bytesRead)\n{\n    OH_LOG_INFO(LOG_APP, \"read http body back.\");\n    bool isEof = OH_ArkWebHttpBodyStream_IsEof(httpBodyStream);\n    if (!isEof && bytesRead != 0) {\n        memset(buffer, 0, 1000);\n        OH_ArkWebHttpBodyStream_Read(httpBodyStream, buffer, 1000);\n    } else {\n        RawfileRequest *rawfileRequest = (RawfileRequest *)OH_ArkWebHttpBodyStream_GetUserData(httpBodyStream);\n        if (rawfileRequest) {\n            rawfileRequest->ReadRawfileDataOnWorkerThread();\n            cnd_signal(&http_body_cnd);\n        }\n    }\n}\n\nint ReadHttpBodyOnWorkerThread(void* userData)\n{\n    memset(buffer, 0, 1000);\n    ArkWeb_HttpBodyStream *httpBodyStream = (ArkWeb_HttpBodyStream *)userData;\n    OH_ArkWebHttpBodyStream_Read(httpBodyStream, buffer, 1000);\n    cnd_init(&http_body_cnd);\n    mtx_init(&http_body_mtx, mtx_plain);\n    cnd_wait(&http_body_cnd, &http_body_mtx);\n    return 0;\n}\n\nint ReadRawfileOnWorkerThread(void* userData)\n{\n    RawfileRequest * rawfileRequest = (RawfileRequest *)userData;\n    if (rawfileRequest) {\n        rawfileRequest->ReadRawfileDataOnWorkerThread();\n    }\n    return 0;\n}\n\n// ArkWeb_HttpBodyStream的初始化回调。\nvoid InitCallback(const ArkWeb_HttpBodyStream *httpBodyStream, ArkWeb_NetError result)\n{\n    OH_LOG_INFO(LOG_APP, \"init http body stream done %{public}d.\", result);\n    bool isChunked = OH_ArkWebHttpBodyStream_IsChunked(httpBodyStream);\n    OH_LOG_INFO(LOG_APP, \"http body stream is chunked %{public}d.\", isChunked);\n    thrd_t th;\n    if (thrd_create(&th, ReadHttpBodyOnWorkerThread, (void *)httpBodyStream) != thrd_success) {\n        OH_LOG_ERROR(LOG_APP, \"create thread failed.\");\n        return;\n    }\n\n    if (thrd_detach(th) != thrd_success) {\n        OH_LOG_ERROR(LOG_APP, \"detach thread failed.\");\n    }\n}\n\nconst int blockSize = 1024 * 8;\n\n}  // namespace\n\nRawfileRequest::RawfileRequest(const ArkWeb_ResourceRequest *resourceRequest,\n                               const ArkWeb_ResourceHandler *resourceHandler,\n                               const NativeResourceManager* resourceManager)\n        : resourceRequest_(resourceRequest),\n          resourceHandler_(resourceHandler),\n          resourceManager_(resourceManager) {}\n\nRawfileRequest::~RawfileRequest() {}\n\nvoid RawfileRequest::Start()\n{\n    OH_LOG_INFO(LOG_APP, \"start a rawfile request.\");\n    char* url;\n    OH_ArkWebResourceRequest_GetUrl(resourceRequest_, &url);\n    std::string urlStr(url);\n    std::size_t position = urlStr.rfind('/');\n    if (position != std::string::npos) {\n        rawfilePath_ = urlStr.substr(position + 1);\n    }\n    OH_ArkWeb_ReleaseString(url);\n\n    OH_ArkWeb_CreateResponse(&response_);\n    OH_ArkWebResourceRequest_GetHttpBodyStream(resourceRequest(), &stream_);\n    if (stream_) {\n        OH_LOG_ERROR(LOG_APP, \"have http body stream\");\n        OH_ArkWebHttpBodyStream_SetUserData(stream_, this);\n        OH_ArkWebHttpBodyStream_SetReadCallback(stream_, ReadCallback);\n        OH_ArkWebHttpBodyStream_Init(stream_, InitCallback);\n    } else {\n        thrd_t th;\n        if (thrd_create(&th, ReadRawfileOnWorkerThread, (void *)this) != thrd_success) {\n            OH_LOG_ERROR(LOG_APP, \"create thread failed.\");\n            return;\n        }\n\n        if (thrd_detach(th) != thrd_success) {\n            OH_LOG_ERROR(LOG_APP, \"detach thread failed.\");\n        }\n    }\n}\n\n// 在worker线程中读取rawfile，并通过ResourceHandler返回给Web内核。\nvoid RawfileRequest::ReadRawfileDataOnWorkerThread()\n{\n    OH_LOG_INFO(LOG_APP, \"read rawfile in worker thread.\");\n    const struct UrlInfo {\n        std::string resource;\n        std::string mimeType;\n    } urlInfos[] = {\n        {\"test.html\", \"text/html\"},\n        {\"video.html\", \"text/html\"},\n        {\"isolated.html\", \"text/html\"},\n        {\"csp_bypassing.html\", \"text/html\"},\n        {\"post_data.html\", \"text/html\"},\n        {\"chunked_post_stream.html\", \"text/html\"},\n        {\"local.html\", \"text/html\"},\n        {\"service_worker.html\", \"text/html\"},\n        {\"csp_script.js\", \"text/javascript\"},\n        {\"sw.js\", \"text/javascript\"},\n        {\"isolated_script.js\", \"text/javascript\"},\n        {\"local_script.js\", \"text/javascript\"},\n        {\"test.mp4\", \"video/mp4\"},\n        {\"xhr\", \"application/json\"}\n    };\n\n    if (!resourceManager()) {\n        OH_LOG_ERROR(LOG_APP, \"read rawfile error, resource manager is nullptr.\");\n        return;\n    }\n\n    RawFile *rawfile = OH_ResourceManager_OpenRawFile(resourceManager(), rawfilePath().c_str());\n    if (!rawfile) {\n        OH_ArkWebResponse_SetStatus(response(), 404);\n    } else {\n        OH_ArkWebResponse_SetStatus(response(), 200);\n    }\n\n    for (auto &urlInfo : urlInfos) {\n        if (urlInfo.resource == rawfilePath()) {\n            OH_ArkWebResponse_SetMimeType(response(), urlInfo.mimeType.c_str());\n            break;\n        }\n    }\n    OH_ArkWebResponse_SetCharset(response(), \"UTF-8\");\n\n    long len = OH_ResourceManager_GetRawFileSize(rawfile);\n    OH_ArkWebResponse_SetHeaderByName(response(), \"content-length\", std::to_string(len).c_str(), false);\n    DidReceiveResponse();\n\n    long consumed = 0;\n    uint8_t buffer[blockSize];\n    while (true) {\n        int ret = OH_ResourceManager_ReadRawFile(rawfile, buffer, blockSize);\n        OH_LOG_INFO(LOG_APP, \"read rawfile %{public}d bytes.\", ret);\n        if (ret == 0) {\n            break;\n        }\n        consumed += ret;\n        OH_ResourceManager_SeekRawFile(rawfile, consumed, 0);\n        DidReceiveData(buffer, ret);\n        memset(buffer, 0, blockSize);\n    }\n\n    OH_ResourceManager_CloseRawFile(rawfile);\n    DidFinish();\n}\n\nvoid RawfileRequest::Stop()\n{\n    OH_LOG_INFO(LOG_APP, \"stop the rawfile request.\");\n    std::lock_guard<std::mutex> guard(mutex_);\n    stopped_ = true;\n    if (response_) {\n        OH_ArkWeb_DestroyResponse(response_);\n    }\n    OH_ArkWebResourceRequest_Destroy(resourceRequest_);\n    OH_ArkWebResourceHandler_Destroy(resourceHandler_);\n}\n\nvoid RawfileRequest::DidReceiveResponse()\n{\n    OH_LOG_INFO(LOG_APP, \"did receive response.\");\n    std::lock_guard<std::mutex> guard(mutex_);\n    if (!stopped_) {\n        OH_ArkWebResourceHandler_DidReceiveResponse(resourceHandler_, response_);\n    }\n}\n\nvoid RawfileRequest::DidReceiveData(const uint8_t *buffer, int64_t bufLen)\n{\n    OH_LOG_INFO(LOG_APP, \"did receive data.\");\n    std::lock_guard<std::mutex> guard(mutex_);\n    if (!stopped_) {\n        OH_ArkWebResourceHandler_DidReceiveData(resourceHandler_, buffer, bufLen);\n    }\n}\n\nvoid RawfileRequest::DidFinish()\n{\n    OH_LOG_INFO(LOG_APP, \"did finish.\");\n    std::lock_guard<std::mutex> guard(mutex_);\n    if (!stopped_) {\n        OH_ArkWebResourceHandler_DidFinish(resourceHandler_);\n    }\n}\n\nvoid RawfileRequest::DidFailWithError(ArkWeb_NetError errorCode)\n{\n    OH_LOG_INFO(LOG_APP, \"did finish with error %{public}d.\", errorCode);\n    if (!stopped_) {\n        OH_ArkWebResourceHandler_DidFailWithError(resourceHandler_, errorCode);\n    }\n}
main/resources/rawfile/test.html
<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n</head>\n\n<body>\n<h1> 网络拦截测试demo</h1>\n<a href=\"https://www.example.com/video.html\">拦截视频资源请求，读取本地mp4文件</a><br/>\n<a href=\"https://www.example.com/csp_bypassing.html\">测试三方协议忽略csp检查，并成功拦截</a><br/>\n<a href=\"https://www.example.com/isolated.html\">测试拦截设置ISOLATED属性的三方协议</a><br/>\n<a href=\"https://www.example.com/local.html\">测试拦截设置LOCAL属性的三方协议</a><br/>\n<a href=\"https://www.example.com/service_worker.html\">测试拦截service worker触发的请求</a><br/>\n<a href=\"https://www.example.com/post_data.html\">测试读取blob类型http body stream</a><br/>\n<a href=\"https://www.example.com/chunked_post_stream.html\">测试读取chunked类型http body stream</a>\n</body>\n</html>
main/resources/rawfile/cat.svg
<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 13.37 10.79\"><path d=\"M12.8 10.18l-.8-.8c-.98-.8-.86-1.92-.87-2.04-.02-.1-.02-.58.02-.74.04-.15 0-.32 0-.32.28-1.18 1.2-.85 1.2-.85.38.04.4-.33.4-.33.25-.13.2-.4.2-.4l-.47-.48c-.18-.48-.7-.6-.7-.6.08-.48-.17-.78-.17-.78-.03.14-.58.72-.62.73-.63.15-.43.26-.83.55-.4.28-1.26.63-1.64.43-.37-.2-3.5-.5-4.86-.5-.4 0-.7.1-.95.2-.23-.16-.52-.52-.73-1.02-.3-.74-.36-1.48-.12-1.98.13-.27.28-.42.44-.45.23-.05.52.16.6.24.17.14.42.13.56-.03.15-.15.14-.4-.02-.55C3.38.4 2.8-.1 2.14.02c-.42.08-.76.38-1 .9-.34.7-.3 1.66.1 2.6.18.44.47.93.83 1.25-.1.13-.13.23-.13.23-.12.27-.44.9-.33 1.45.13.56-.22.82-.3.88-.05.07-.73.47-.73.47L0 9.78c-.08.38.43.6.43.6.18-.03.2-.63.2-.63l.44-1.04 1.66-.6s0 .7-.02.83-.1.35-.1.35c.08.46 1.2 1.5 1.2 1.5h.85v-.26c-.07-.3-.5-.16-.5-.16l-.62-.95c.66-.5.93-1.38.93-1.38.3.26 1.8-.22 1.8-.22l.9.1-.25 2.1c-.07.5.05.68.05.68h.4c.3 0 .48.03.48-.27 0-.28-.4-.23-.4-.23l1-1.95c.93-.58 1.53.26 1.53.26l.05.3c.37.53 2.38 1.9 2.38 1.9h1v-.3c-.18-.32-.6-.2-.6-.2z\"/></svg>
main/resources/rawfile/csp_bypassing.html
<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; media-src 'self'\">\n</head>\n<body>\n<p>scheme: custom-csp-bypassing</p>\n<p>options: ARKWEB_SCHEME_OPTION_CSP_BYPASSING | ARKWEB_SCHEME_OPTION_STANDARD</p>\n<script src=\"custom-csp-bypassing://www.example.com/csp_script.js\"></script>\n</body>\n</html>
main/resources/rawfile/csp_script.js
const body = document.body;\nconst element = document.createElement('div');\nelement.textContent = 'csp_script.js bypass the csp rules';\nbody.appendChild(element);
main/resources/rawfile/isolated_script.js
const element = document.getElementById('isolated_test');\nelement.textContent = 'isolated_script.js not blocked';
main/resources/rawfile/isolated.html
<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n</head>\n<body>\n<p>scheme: custom-isolated</p>\n<p>options: ARKWEB_SCHEME_OPTION_DISPLAY_ISOLATED</p>\n<div id=\"isolated_test\">isolated_script.js 被拦截</div>\n<script src=\"custom-isolated://www.example.com/isolated_script.js\"></script>\n</body>\n</html>
main/resources/rawfile/local_script.js
const element = document.getElementById('local_test');\nelement.textContent = 'local_script.js not blocked.';
main/resources/rawfile/local.html
<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n</head>\n<body>\n<p>scheme: custom-local</p>\n<p>options: ARKWEB_SCHEME_OPTION_LOCAL</p>\n<div id=\"local_test\">local_script.js 被拦截</div>\n<script src=\"custom-local://www.example.com/local_script.js\"></script>\n</body>\n</html>
main/resources/rawfile/post_data.html
<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<script>\n    function textPostXhr(url) {\n        var formData = new FormData();\n        var myBlob = new Blob([\"This is my blob content\"], {type : \"text/plain\"});\n        formData.append(\"upload\", myBlob);\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST', url, true);\n        xhr.send(formData);\n        xhr.onreadystatechange = function (err) {\n            console.log(err.target.status);\n        }\n    }\n    function textPutXhr(url) {\n        var formData = new FormData();\n        var myBlob = new Blob([\"This is my blob content\"], {type : \"text/plain\"});\n        formData.append(\"upload\", myBlob);\n        var xhr = new XMLHttpRequest();\n        xhr.open('PUT', url, true);\n        xhr.send(formData);\n        xhr.onreadystatechange = function (err) {\n            console.log(err.target.status);\n        }\n    }\n</script>\n</head>\n<body>\n<div onclick=\"textPostXhr('https://www.example.com/xhr')\">test xhr post</div>\n<div onclick=\"textPutXhr('https://www.example.com/xhr')\">test xhr put</div>\n</body>\n</html>
main/resources/rawfile/service_worker.html
<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<script>\nfunction registerSuccess() {\n    const body = document.body;\n    const element = document.createElement('div');\n    element.textContent = 'register sw successful.';\n    body.appendChild(element);\n}\n\nnavigator.serviceWorker.register('/sw.js')\n    .then(reg => registerSuccess())\n    .catch(error => console.log('failed!', error))\n</script>\n</head>\n<body>\n</body>\n</html>
main/resources/rawfile/sw.js
self.addEventListener('install', event => {\n    console.log('v1 installing');\n    event.waitUntil(\n        caches.open('static-v1').then(cache => cache.add('/cat.svg'))\n    );\n});\n\nself.addEventListener('activate', event => {\n    console.log(\"v1 now redy to handle fetches.\");\n});
main/resources/rawfile/video.html
<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n</head>\n<body>\n<video width=\"400\" height=\"400\" controls>\n    <source src=\"https://www.example.com/test.mp4\" type=\"video/mp4\">\n</video>\n</body>\n</html>
main/resources/rawfile/chunked_post_stream.html
<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n</head>\n<script>\nlet uploaded = 0;\nlet buf = new Uint8Array(1024 * 50);\nlet start = Date.now();\nvar rs = new ReadableStream({\n    pull(ctrl) {\n        uploaded += buf.byteLength;\n        crypto.getRandomValues(buf);\n        ctrl.enqueue(buf);\n        if ((start + 1000) < Date.now()) ctrl.close();\n    }\n});\n\nfunction test() {\n    fetch('https://www.example.com/xhr', {\n        method: 'POST',\n        body: rs,\n        duplex: 'half'\n    }).then(r => r.json()).then(console.log);\n}\n</script>\n<body>\n<div onclick=\"test()\">test post chunked http body.</div>\n</body>\n</html>
main/resources/rawfile/xhr
{}

使用JSVM-API接口进行任务队列相关开发
简介
在虚拟机内部启动任务队列的运行，检查是否有微任务在队列中等待，这个任务队列可以由外部事件循环执行。
基本概念
任务队列：管理异步任务的调度和执行，确保任务按顺序处理。微任务：微任务是一种任务调度机制，主要用于处理那些需要尽快执行的较小任务，它们通常具有较高的优先级。
接口说明
使用示例
JSVM-API接口开发流程参考使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应C++相关代码进行展示。
[h2]OH_JSVM_PumpMessageLoop && OH_JSVM_PerformMicrotaskCheckpoint
启动任务队列，执行任务。
cpp代码
#include <chrono>\n#include <string.h>\n\n\n// 待执行的js代码\nstatic const char *STR_TASK = R\"JS( \n    // wasm 字节码 (以add 模块为例)\n    // 以下 wasmBuffer 对应的 wasm 字节码文本格式如下所示，只包含了一个函数 add\n    // (module\n    //   (func $add (param $lhs i32) (param $rhs i32) (result i32)\n    //     local.get $lhs\n    //     local.get $rhs\n    //     i32.add\n    //   )\n    //   (export \"add\" (func $add))\n    // )\n    var wasmBytes = new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01,\n                                       0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07,\n                                       0x07, 0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00, 0x0a, 0x09, 0x01,\n                                       0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b]);    \n\n    var p = WebAssembly.instantiate(wasmBytes, {});\n    p.then((result) => {\n        consoleinfo(\"Called with instance \" + result);\n    });\n    p.finally(() => {\n       consoleinfo(\"Called Finally\");\n    });\n)JS\";\n\n// 保证js代码中的打印信息可以正常输出\nstatic JSVM_Value ConsoleInfo(JSVM_Env env, JSVM_CallbackInfo info) {\n    size_t argc = 1;\n    JSVM_Value args[1];\n    char log[256] = \"\";\n    size_t logLength;\n    JSVM_CALL(OH_JSVM_GetCbInfo(env, info, &argc, args, NULL, NULL));\n\n    OH_JSVM_GetValueStringUtf8(env, args[0], log, 255, &logLength);\n    log[255] = 0;\n    OH_LOG_INFO(LOG_APP, \"JSVM API TEST: %{public}s\", log);\n    return nullptr;\n}\n\n// 注册consoleinfo的方法\nJSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = ConsoleInfo},\n};\nJSVM_PropertyDescriptor descriptor[] = {\n    {\"consoleinfo\", NULL, &param[0], NULL, NULL, NULL, JSVM_DEFAULT},\n};\n\nstatic int32_t TestJSVM() {\n    JSVM_InitOptions init_options;\n    memset(&init_options, 0, sizeof(init_options));\n    if (g_aa == 0) {\n        OH_JSVM_Init(&init_options);\n        g_aa++;\n    }\n    // 创建JavaScript虚拟机实例,打开虚拟机作用域\n    JSVM_VM vm;\n    JSVM_CreateVMOptions options;\n    memset(&options, 0, sizeof(options));\n    CHECK(OH_JSVM_CreateVM(&options, &vm));\n    JSVM_VMScope vm_scope;\n    CHECK(OH_JSVM_OpenVMScope(vm, &vm_scope));\n    \n    JSVM_Env env;\n    CHECK(OH_JSVM_CreateEnv(vm, sizeof(descriptor) / sizeof(descriptor[0]), descriptor, &env));\n    JSVM_EnvScope envScope;\n    CHECK_RET(OH_JSVM_OpenEnvScope(env, &envScope));\n    JSVM_HandleScope handlescope;\n    CHECK_RET(OH_JSVM_OpenHandleScope(env, &handlescope));\n    JSVM_Value sourcecodevalue;\n    CHECK_RET(OH_JSVM_CreateStringUtf8(env, STR_TASK, strlen(STR_TASK), &sourcecodevalue));\n    JSVM_Script script;\n    CHECK_RET(OH_JSVM_CompileScript(env, sourcecodevalue, nullptr, 0, true, nullptr, &script));\n    JSVM_Value result;\n    CHECK_RET(OH_JSVM_RunScript(env, script, &result));\n    bool rst = false;\n    auto start = std::chrono::system_clock::now();\n    while (true) {\n        // 如果任务队列中没有任务启动，则rst设置为false\n        CHECK_RET(OH_JSVM_PumpMessageLoop(vm, &rst)); \n        CHECK_RET(OH_JSVM_PerformMicrotaskCheckpoint(vm));\n        // 定时退出\n        auto now = std::chrono::system_clock::now();\n        auto cost = std::chrono::duration_cast<std::chrono::milliseconds>(now - start).count();\n        if (cost > 100) {\n            break;\n        }\n    }\n\n    // 关闭并销毁环境和虚拟机\n    CHECK_RET(OH_JSVM_CloseHandleScope(env, handlescope));\n    CHECK_RET(OH_JSVM_CloseEnvScope(env, envScope));\n    CHECK(OH_JSVM_DestroyEnv(env));\n    CHECK(OH_JSVM_CloseVMScope(vm, vm_scope));\n    CHECK(OH_JSVM_DestroyVM(vm));\n    return 0;\n}
预期输出结果
JSVM API TEST: Called with instance [object Object]\nJSVM API TEST: Called Finally
[h2]OH_JSVM_SetMicrotaskPolicy
修改微任务执行策略,通过该接口，用户可以将策略设置为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT 或 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。默认模式下，微任务的执行策略为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。
微任务策略：
JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT ： 微任务在用户调用 OH_JSVM_PerformMicrotaskCheckpoint 后执行JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO： 微任务在 JS 调用栈为空时自动执行
cpp 部分代码
// OH_JSVM_SetMicrotaskPolicy的样例方法\nstatic int SetMicrotaskPolicy(JSVM_VM vm, JSVM_Env env) {\n    // 默认或将策略设置为 JSVM_MICROTASK_AUTO 的行为\n    const char *scriptEvalMicrotask = R\"JS(\n        evaluateMicrotask = false;\n        Promise.resolve().then(()=>{\n            evaluateMicrotask = true;\n        });\n    )JS\";\n    JSVM_Script script;\n    JSVM_Value jsSrc;\n    JSVM_Value result;\n    CHECK_RET(OH_JSVM_CreateStringUtf8(env, scriptEvalMicrotask, JSVM_AUTO_LENGTH, &jsSrc));\n    CHECK_RET(OH_JSVM_CompileScript(env, jsSrc, nullptr, 0, true, nullptr, &script));\n    CHECK_RET(OH_JSVM_RunScript(env, script, &result));\n    JSVM_Value global;\n    CHECK_RET(OH_JSVM_GetGlobal(env, &global));\n    JSVM_Value hasEvaluateMicrotask;\n    CHECK_RET(OH_JSVM_GetNamedProperty(env, global, \"evaluateMicrotask\", &hasEvaluateMicrotask));\n    bool val;\n    CHECK_RET(OH_JSVM_GetValueBool(env, hasEvaluateMicrotask, &val));\n\n    OH_LOG_INFO(LOG_APP, \"Policy :JSVM_MICROTASK_AUTO, evaluateMicrotask : %{public}d\", val);\n\n    // 策略设置为 JSVM_MICROTASK_EXPLICIT 的行为\n    CHECK_RET(OH_JSVM_SetMicrotaskPolicy(vm, JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT));\n    CHECK_RET(OH_JSVM_RunScript(env, script, &result));\n    CHECK_RET(OH_JSVM_GetNamedProperty(env, global, \"evaluateMicrotask\", &hasEvaluateMicrotask));\n    CHECK_RET(OH_JSVM_GetValueBool(env, hasEvaluateMicrotask, &val));\n    OH_LOG_INFO(\n        LOG_APP,\n        \"Policy :JSVM_MICROTASK_AUTO, evaluateMicrotask before calling OH_JSVM_PerformMicrotaskCheckpoint: %{public}d\",\n        val);\n\n    CHECK_RET(OH_JSVM_PerformMicrotaskCheckpoint(vm));\n    CHECK_RET(OH_JSVM_GetNamedProperty(env, global, \"evaluateMicrotask\", &hasEvaluateMicrotask));\n    CHECK_RET(OH_JSVM_GetValueBool(env, hasEvaluateMicrotask, &val));\n    OH_LOG_INFO(\n        LOG_APP,\n        \"Policy :JSVM_MICROTASK_AUTO, evaluateMicrotask after calling OH_JSVM_PerformMicrotaskCheckpoint: %{public}d\",\n        val);\n\n    return 0;\n}\n\nstatic void RunDemo(JSVM_VM vm, JSVM_Env env) {\n    if (SetMicrotaskPolicy(vm, env) != 0) {\n        OH_LOG_INFO(LOG_APP, \"Run Microtask Policy failed\");\n    }\n}\n\nstatic int32_t TestJSVM() {\n    JSVM_InitOptions initOptions = {0};\n    JSVM_VM vm;\n    JSVM_Env env = nullptr;\n    JSVM_VMScope vmScope;\n    JSVM_EnvScope envScope;\n    JSVM_HandleScope handleScope;\n    JSVM_Value result;\n    // 初始化JavaScript引擎实例\n    if (g_aa == 0) {\n        g_aa++;\n        CHECK(OH_JSVM_Init(&initOptions));\n    }\n    // 创建JSVM环境\n    CHECK(OH_JSVM_CreateVM(nullptr, &vm));\n    CHECK(OH_JSVM_CreateEnv(vm, 0, nullptr, &env));\n    CHECK(OH_JSVM_OpenVMScope(vm, &vmScope));\n    CHECK_RET(OH_JSVM_OpenEnvScope(env, &envScope));\n    CHECK_RET(OH_JSVM_OpenHandleScope(env, &handleScope));\n\n    // 通过script调用测试函数\n    RunDemo(vm, env);\n\n    // 销毁JSVM环境\n    CHECK_RET(OH_JSVM_CloseHandleScope(env, handleScope));\n    CHECK_RET(OH_JSVM_CloseEnvScope(env, envScope));\n    CHECK(OH_JSVM_CloseVMScope(vm, vmScope));\n    CHECK(OH_JSVM_DestroyEnv(env));\n    CHECK(OH_JSVM_DestroyVM(vm));\n    return 0;\n}
预期输出结果
Policy :JSVM_MICROTASK_AUTO, evaluateMicrotask : 1\nPolicy :JSVM_MICROTASK_AUTO, evaluateMicrotask before calling OH_JSVM_PerformMicrotaskCheckpoint: 0\nPolicy :JSVM_MICROTASK_AUTO, evaluateMicrotask after calling OH_JSVM_PerformMicrotaskCheckpoint: 1

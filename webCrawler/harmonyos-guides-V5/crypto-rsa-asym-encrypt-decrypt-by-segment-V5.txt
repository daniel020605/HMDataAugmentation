使用RSA非对称密钥分段加解密
对应的算法规格请查看非对称密钥加解密算法规格：RSA。
加密
 调用cryptoFramework.createAsyKeyGenerator、AsyKeyGenerator.generateKeyPair，生成RSA密钥类型为RSA1024、素数个数为2（不填默认）的非对称密钥对（KeyPair）。KeyPair对象中包括公钥PubKey、私钥PriKey。 如何生成RSA非对称密钥对，开发者可参考下文示例，并结合非对称密钥生成和转换规格：RSA和随机生成非对称密钥对理解，参考文档与当前示例可能存在入参差异，请在阅读时注意区分。 调用cryptoFramework.createCipher，指定字符串参数'RSA1024|PKCS1'，创建非对称密钥类型为RSA1024、填充模式为PKCS1的Cipher实例，用于完成加解密操作。 调用Cipher.init，设置模式为加密（CryptoMode.ENCRYPT_MODE），指定加密密钥（KeyPair.PubKey），初始化加密Cipher实例。 多次调用Cipher.doFinal，传入明文，获取加密后的数据。 doFinal输出结果可能为null，在访问具体数据前，需要先判断结果是否为null，避免产生异常。 此处将明文按64个字节一组拆分，多次加密。使用1024位密钥，每次将生成128字节密文。 
解密
 由于RSA算法的Cipher实例不支持重复init操作，需要调用cryptoFramework.createCipher，重新生成Cipher实例。 调用Cipher.init，设置模式为解密（CryptoMode.DECRYPT_MODE），指定解密密钥（KeyPair.PriKey）初始化解密Cipher实例。PKCS1模式无加密参数，直接传入null。 多次调用Cipher.doFinal，传入密文，获取解密后的数据。 
 异步方法示例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n// 分段加密消息\nasync function rsaEncryptBySegment(pubKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) {\n  let cipher = cryptoFramework.createCipher('RSA1024|PKCS1');\n  await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, pubKey, null);\n  let plainTextSplitLen = 64;\n  let cipherText = new Uint8Array();\n  for (let i = 0; i < plainText.data.length; i += plainTextSplitLen ) {\n    let updateMessage = plainText.data.subarray(i, i + plainTextSplitLen );\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    // 将原文按64字符进行拆分，循环调用doFinal进行加密，使用1024bit密钥时，每次加密生成128字节长度的密文\n    let updateOutput = await cipher.doFinal(updateMessageBlob);\n    let mergeText = new Uint8Array(cipherText.length + updateOutput.data.length);\n    mergeText.set(cipherText);\n    mergeText.set(updateOutput.data, cipherText.length);\n    cipherText = mergeText;\n  }\n  let cipherBlob: cryptoFramework.DataBlob = { data: cipherText };\n  return cipherBlob;\n}\n// 分段解密消息\nasync function rsaDecryptBySegment(priKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {\n  let decoder = cryptoFramework.createCipher('RSA1024|PKCS1');\n  await decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, priKey, null);\n  let cipherTextSplitLen = 128; // RSA密钥每次加密生成的密文字节长度计算方式：密钥位数/8\n  let decryptText = new Uint8Array();\n  for (let i = 0; i < cipherText.data.length; i += cipherTextSplitLen) {\n    let updateMessage = cipherText.data.subarray(i, i + cipherTextSplitLen);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    // 将密文按128字节进行拆分解密，得到原文后进行拼接\n    let updateOutput = await decoder.doFinal(updateMessageBlob);\n    let mergeText = new Uint8Array(decryptText.length + updateOutput.data.length);\n    mergeText.set(decryptText);\n    mergeText.set(updateOutput.data, decryptText.length);\n    decryptText = mergeText;\n  }\n  let decryptBlob: cryptoFramework.DataBlob = { data: decryptText };\n  return decryptBlob;\n}\nasync function rsaEncryptLongMessage() {\n  let message = \"This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\";\n  let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator(\"RSA1024\"); // 创建非对称密钥生成器对象\n  let keyPair = await asyKeyGenerator.generateKeyPair(); // 随机生成RSA密钥\n  let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };\n  let encryptText = await rsaEncryptBySegment(keyPair.pubKey, plainText);\n  let decryptText = await rsaDecryptBySegment(keyPair.priKey, encryptText);\n  if (plainText.data.toString() === decryptText.data.toString()) {\n    console.info('decrypt ok');\n    console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));\n  } else {\n    console.error('decrypt failed');\n  }\n} 同步方法示例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { buffer } from '@kit.ArkTS';\n// 分段加密消息\nfunction rsaEncryptBySegment(pubKey: cryptoFramework.PubKey, plainText: cryptoFramework.DataBlob) {\n  let cipher = cryptoFramework.createCipher('RSA1024|PKCS1');\n  cipher.initSync(cryptoFramework.CryptoMode.ENCRYPT_MODE, pubKey, null);\n  let plainTextSplitLen = 64;\n  let cipherText = new Uint8Array();\n  for (let i = 0; i < plainText.data.length; i += plainTextSplitLen ) {\n    let updateMessage = plainText.data.subarray(i, i + plainTextSplitLen );\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    // 将原文按64字符进行拆分，循环调用doFinal进行加密，使用1024bit密钥时，每次加密生成128字节长度的密文\n    let updateOutput = cipher.doFinalSync(updateMessageBlob);\n    let mergeText = new Uint8Array(cipherText.length + updateOutput.data.length);\n    mergeText.set(cipherText);\n    mergeText.set(updateOutput.data, cipherText.length);\n    cipherText = mergeText;\n  }\n  let cipherBlob: cryptoFramework.DataBlob = { data: cipherText };\n  return cipherBlob;\n}\n// 分段解密消息\nfunction rsaDecryptBySegment(priKey: cryptoFramework.PriKey, cipherText: cryptoFramework.DataBlob) {\n  let decoder = cryptoFramework.createCipher('RSA1024|PKCS1');\n  decoder.initSync(cryptoFramework.CryptoMode.DECRYPT_MODE, priKey, null);\n  let cipherTextSplitLen = 128; // RSA密钥每次加密生成的密文字节长度计算方式：密钥位数/8\n  let decryptText = new Uint8Array();\n  for (let i = 0; i < cipherText.data.length; i += cipherTextSplitLen) {\n    let updateMessage = cipherText.data.subarray(i, i + cipherTextSplitLen);\n    let updateMessageBlob: cryptoFramework.DataBlob = { data: updateMessage };\n    // 将密文按128字节进行拆分解密，得到原文后进行拼接\n    let updateOutput = decoder.doFinalSync(updateMessageBlob);\n    let mergeText = new Uint8Array(decryptText.length + updateOutput.data.length);\n    mergeText.set(decryptText);\n    mergeText.set(updateOutput.data, decryptText.length);\n    decryptText = mergeText;\n  }\n  let decryptBlob: cryptoFramework.DataBlob = { data: decryptText };\n  return decryptBlob;\n}\nfunction main() {\n  let message = \"This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\" +\n    \"This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!\";\n  let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator(\"RSA1024\"); // 创建非对称密钥生成器对象\n  let keyPair = asyKeyGenerator.generateKeyPairSync(); // 随机生成RSA密钥\n  let plainText: cryptoFramework.DataBlob = { data: new Uint8Array(buffer.from(message, 'utf-8').buffer) };\n  let encryptText = rsaEncryptBySegment(keyPair.pubKey, plainText);\n  let decryptText = rsaDecryptBySegment(keyPair.priKey, encryptText);\n  if (plainText.data.toString() === decryptText.data.toString()) {\n    console.info('decrypt ok');\n    console.info('decrypt plainText: ' + buffer.from(decryptText.data).toString('utf-8'));\n  } else {\n    console.error('decrypt failed');\n  }\n} 

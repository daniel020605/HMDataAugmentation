XML解析
对于以XML作为载体传递的数据，实际使用中需要对相关的节点进行解析，一般包括解析XML标签和标签值、解析XML属性和属性值、解析XML事件类型和元素深度三类操作。如在Web服务中，XML是SOAP（Simple Object Access Protocol）协议的基础，SOAP消息通常以XML格式封装，包含请求和响应参数，通过解析这些XML消息，Web服务可以处理来自客户端的请求并生成相应的响应。
XML模块提供XmlPullParser类对XML文件解析，输入为含有XML文本的ArrayBuffer或DataView，输出为解析得到的信息。
表1 XML解析选项，其详细介绍请参见ParseOptions。
注意事项
 XML解析及转换需要确保传入的XML数据符合标准格式。 XML解析目前不支持按指定节点解析对应的节点值。 
解析XML标签和标签值
 引入模块。 import { xml, util } from '@kit.ArkTS'; // 需要使用util模块函数对文件编码 对XML文件编码后调用XmlPullParser。 可以基于ArrayBuffer构造XmlPullParser对象， 也可以基于DataView构造XmlPullParser对象（两种构造方式返回结果无区别可任选一种）。 let strXml: string =\n'<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n  '<note importance=\"high\" logged=\"true\">' +\n  '<title>Play</title>' +\n  '<lens>Work</lens>' +\n  '</note>';\nlet textEncoder: util.TextEncoder = new util.TextEncoder();\nlet arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据编码，防止包含中文字符乱码\n// 方式1：基于ArrayBuffer构造XmlPullParser对象\nlet that: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');\n\n// 方式2：基于DataView构造XmlPullParser对象\n// let dataView: DataView = new DataView(arrBuffer.buffer as object as ArrayBuffer);\n// let that: xml.XmlPullParser = new xml.XmlPullParser(dataView, 'UTF-8'); 自定义回调函数，本例直接打印出标签及标签值。 function func(name: string, value: string): boolean {\n  if (name == 'note') {\n    console.info(name);\n  }\n  if (value == 'Play' || value == 'Work') {\n    console.info('    ' + value);\n  }\n  if (name == 'title' || name == 'lens') {\n    console.info('  ' + name);\n  }\n  return true; //true:继续解析 false:停止解析\n} 设置解析选项，调用parse函数。 let options: xml.ParseOptions = {supportDoctype:true, ignoreNameSpace:true, tagValueCallbackFunction:func};\nthat.parse(options); 输出结果如下所示： note\n  title\n    Play\n  title\n  lens\n    Work\n  lens\nnote 
解析XML属性和属性值
 引入模块。 import { xml, util } from '@kit.ArkTS'; // 需要使用util模块函数对文件编码 对XML文件编码后调用XmlPullParser。 let strXml: string =\n  '<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n    '<note importance=\"high\" logged=\"true\">' +\n    '    <title>Play</title>' +\n    '    <title>Happy</title>' +\n    '    <lens>Work</lens>' +\n    '</note>';\nlet textEncoder: util.TextEncoder = new util.TextEncoder();\nlet arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据编码，防止包含中文字符乱码\nlet that: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8'); 自定义回调函数，本例直接打印出属性及属性值。 let str: string = '';\nfunction func(name: string, value: string): boolean {\n  str += name + ' ' + value + ' ';\n  return true; // true:继续解析 false:停止解析\n} 设置解析选项，调用parse函数。 let options: xml.ParseOptions = {supportDoctype:true, ignoreNameSpace:true, attributeValueCallbackFunction:func};\nthat.parse(options);\nconsole.info(str); // 一次打印出所有的属性及其值 输出结果如下所示： importance high logged true // note节点的属性及属性值 
解析XML事件类型和元素深度
 引入模块。 import { xml, util } from '@kit.ArkTS'; // 需要使用util模块函数对文件编码 对XML文件编码后调用XmlPullParser。 let strXml: string =\n  '<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n  '<note importance=\"high\" logged=\"true\">' +\n  '<title>Play</title>' +\n  '</note>';\nlet textEncoder: util.TextEncoder = new util.TextEncoder();\nlet arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据编码，防止包含中文字符乱码\nlet that: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8'); 自定义回调函数，本例直接打印元素事件类型及元素深度。 let str: string  = '';\nfunction func(name: xml.EventType, value: xml.ParseInfo): boolean {\n  str = name + ' ' + value.getDepth(); // getDepth 获取元素的当前深度\n  console.info(str)\n  return true; //true:继续解析 false:停止解析\n} 设置解析选项，调用parse函数。 let options: xml.ParseOptions = {supportDoctype:true, ignoreNameSpace:true, tokenValueCallbackFunction:func};\nthat.parse(options); 输出结果如下所示：  0 0 // 0：<?xml version=\"1.0\" encoding=\"utf-8\"?> 对应事件类型\t\tSTART_DOCUMENT值为0  0：起始深度为0\n 2 1 // 2：<note importance=\"high\" logged=\"true\"> 对应事件类型START_TAG值为2       1：深度为1\n 2 2 // 2：<title>对应事件类型START_TAG值为2                                       2：深度为2\n 4 2 // 4：Play对应事件类型TEXT值为4                                               2：深度为2\n 3 2 // 3：</title>对应事件类型END_TAG值为3                                        2：深度为2\n 3 1 // 3：</note>对应事件类型END_TAG值为3                                         1：深度为1（与<note对应>）\n 1 0 // 1：对应事件类型END_DOCUMENT值为1                                           0：深度为0 
场景示例
此处以调用所有解析选项为例，提供解析XML标签、属性和事件类型的开发示例。
import { xml, util } from '@kit.ArkTS';\n\nlet strXml: string =\n  '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\n    '<book category=\"COOKING\">' +\n    '<title lang=\"en\">Everyday</title>' +\n    '<author>Giana</author>' +\n    '</book>';\nlet textEncoder: util.TextEncoder = new util.TextEncoder();\nlet arrBuffer: Uint8Array = textEncoder.encodeInto(strXml);\nlet that: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');\nlet str: string = '';\n\nfunction tagFunc(name: string, value: string): boolean {\n  str = name + value;\n  console.info('tag-' + str);\n  return true;\n}\n\nfunction attFunc(name: string, value: string): boolean {\n  str = name + ' ' + value;\n  console.info('attri-' + str);\n  return true;\n}\n\nfunction tokenFunc(name: xml.EventType, value: xml.ParseInfo): boolean {\n  str = name + ' ' + value.getDepth();\n  console.info('token-' + str);\n  return true;\n}\n\nlet options: xml.ParseOptions = {\n  supportDoctype: true,\n  ignoreNameSpace: true,\n  tagValueCallbackFunction: tagFunc,\n  attributeValueCallbackFunction: attFunc,\n  tokenValueCallbackFunction: tokenFunc\n};\nthat.parse(options);
输出结果如下所示：
tag-\ntoken-0 0\ntag-book\nattri-category COOKING\ntoken-2 1\ntag-title\nattri-lang en\ntoken-2 2\ntag-Everyday\ntoken-4 2\ntag-title\ntoken-3 2\ntag-author\ntoken-2 2\ntag-Giana\ntoken-4 2\ntag-author\ntoken-3 2\ntag-book\ntoken-3 1\ntag-\ntoken-1 0

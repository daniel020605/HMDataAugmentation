使用Display实现屏幕属性查询及状态监听 (ArkTS)
场景介绍
Display屏幕属性提供管理设备屏幕的一些基础能力，例如获取默认显示设备的相关信息、获取全部显示设备的信息，此外还能对显示设备的插拔行为进行监听。应用可以根据对应的屏幕信息、屏幕状态变化、屏幕折叠状态等适配不同的UI界面显示。
屏幕属性的常见使用场景有以下几种：
 查询屏幕信息：包括屏幕的分辨率、物理像素密度、逻辑像素密度、刷新率、屏幕尺寸、屏幕旋转方向、屏幕旋转角度等，具体可见Display属性。 监听屏幕状态变化，包括屏幕旋转变化，屏幕分辨率变化、屏幕刷新率变化等。 查询当前设备是否为可折叠设备，同时支持折叠状态（展开/折叠）变化的监听。 
接口说明
屏幕属性的常用接口如下表所示，更多功能及接口说明和使用请见@ohos.display (屏幕属性)。
获取Display对象
Display对象，即屏幕实例，提供屏幕相关属性及监听变化的接口。目前有以下几种不同获取Display的方式，开发者可根据具体场景需要选择使用。
 获取当前默认的Display对象：使用getDefaultDisplaySync()接口获取。 获取当前所有Display对象：使用getAllDisplays()获取。 根据屏幕Id获取对应的Display对象：使用getDisplayByIdSync()接口获取。 
此处，以使用getDefaultDisplaySync()获取当前默认Display对象为例，示例如下：
import { display } from '@kit.ArkUI';\n\nlet displayClass: display.Display | null = null;\ndisplayClass = display.getDefaultDisplaySync();\n// 确保获取到Display对象，即displayClass，再进行后续相关屏幕属性信息查询和事件/状态变化监听
获取屏幕相关属性
 确保获取到Display对象之后（具体可见获取Display对象），可以通过相关属性查询屏幕的一些基础信息。 import { display } from '@kit.ArkUI';\n\nlet displayClass: display.Display | null = null;\ndisplayClass = display.getDefaultDisplaySync();\n\n// 获取屏幕Id\nconsole.info(`The scree Id is ${displayClass.id}.`);\n// 获取屏幕刷新率\nconsole.info(`The screen is ${displayClass.refreshRate}.`);\n// 获取屏幕宽度\nconsole.info(`The screen width is ${displayClass.width}.`);\n// 获取屏幕高度\nconsole.info(`The screen height is ${displayClass.height}.`);\n// ... 还可以通过getCutoutInfo()获取挖孔屏、刘海屏、瀑布屏等不可用的屏幕区域信息，以在UI布局时更好地规避该区域。也可以通过getAvailableArea()获取当前设备屏幕的可用区域。 import { BusinessError } from '@kit.BasicServicesKit';\n\ndisplayClass.getCutoutInfo().then((cutoutInfo: display.CutoutInfo) => {\n  console.info('Succeeded in getting cutoutInfo. Data: ' + JSON.stringify(cutoutInfo));\n}).catch((err: BusinessError) => {\n  console.error(`Failed to obtain all the display objects. Code: ${err.code}, message: ${err.message}`);\n});\n\ndisplayClass.getAvailableArea().then((availableArea) => {\n  console.info('Succeeded get the available area in this display. data: ' + JSON.stringify(availableArea));\n}).catch((err: BusinessError) => {\n  console.error(`Failed to get the available area in this display. Code: ${err.code}, message: ${err.message}`);\n}); 此外，还可以通过display.isCaptured()判断当前设备是都正在截屏、投屏或录屏。 console.info(`The sceeen is captured or not : ${display.isCaptured()}`); 
监听屏幕状态变化
 可以通过display.on('add'|'remove'|'change')监听设备屏幕变化，支持监听屏幕设备的增加、移除和改变等，可以通过display.off('add'|'remove'|'change')关闭对应的监听。 import { display } from '@kit.ArkUI';\nimport { Callback } from '@kit.BasicServicesKit';\n\nlet callback1: Callback<number> = (data: number) => {\n  console.info('Listening enabled. Data: ' + JSON.stringify(data));\n};\n// 此处以监听显示设备的增加为例\ndisplay.on(\"add\", callback1);\n\n// 如果通过on注册多个callback，同时关闭所有callback监听\ndisplay.off(\"add\");\n// 关闭单个callback监听\ndisplay.off('add', callback1); 可以通过display.on('captureStatusChange')开启屏幕截屏、投屏或录屏状态变化的监听；可以通过display.off('captureStatusChange')关闭对应的监听。 let callback2: Callback<boolean> = (captureStatus: boolean) => {\n    // captureStatus为true表示显示设备开始截屏、投屏或录屏，false表示结束截屏、投屏或录屏\n  console.info('Listening capture status: ' + captureStatus);\n};\n// 开启屏幕截屏、投屏、录屏状态变化的监听\ndisplay.on('captureStatusChange', callback2);\n\ndisplay.off('captureStatusChange', callback2); 此外，还可以通过on('availableAreaChange')监听当前屏幕对象（Display对象）的可用区域变化；可通过on('availableAreaChange')关闭对应的监听。 import { Callback } from '@kit.BasicServicesKit';\nimport { display } from '@kit.ArkUI';\n\nlet callback3: Callback<display.Rect> = (data: display.Rect) => {\n  console.info('Listening enabled. Data: ' + JSON.stringify(data));\n};\nlet displayClass: display.Display | null = null;\ntry {\n  displayClass = display.getDefaultDisplaySync();\n  // 开启当前屏幕可用区域变化的监听\n  displayClass.on(\"availableAreaChange\", callback3);\n} catch (exception) {\n  console.error(`Failed to register callback. Code: ${exception.code}, message: ${exception.message}`);\n}\n// 关闭当前监听\ndisplayClass.off(\"availableAreaChange\", callback3); 
监听折叠设备状态变化
 可以通过display.isFoldable()接口查询当前设备是不是折叠设备。 import { display } from '@kit.ArkUI';\n\nlet ret: boolean = false;\nret = display.isFoldable(); 若当前设备为折叠设备，可以通过display.on('foldStatusChange')开启折叠设备折叠状态变化的监听；可通过display.on('foldStatusChange')关闭对应的监听。 import { Callback } from '@kit.BasicServicesKit';\n\n/**\n * 注册监听的callback参数要采用对象传递.\n * 若使用匿名函数注册，每次调用会创建一个新的底层对象，引起内存泄漏问题。\n*/\nlet callback: Callback<display.FoldStatus> = (data: display.FoldStatus) => {\n  console.info('Listening enabled. Data: ' + JSON.stringify(data));\n};\ndisplay.on('foldStatusChange', callback);\n\n// 如果通过on注册多个callback，同时关闭所有callback监听\ndisplay.off('foldStatusChange');\n// 关闭单个callback监听\ndisplay.off('foldStatusChange', callback); 

嵌入ArkTS组件
ArkUI在Native侧提供的能力作为ArkTS的子集，部分能力不会在Native侧提供，如声明式UI语法，自定义struct组件，UI高级组件。
针对需要使用ArkTS侧独立能力的场景，ArkUI开发框架提供了Native侧嵌入ArkTS组件的能力，该能力依赖ComponentContent机制，通过ComponentContent完成对ArkTS组件的封装，然后将封装对象转递到Native侧，通过Native侧的OH_ArkUI_GetNodeHandleFromNapiValue接口转化为ArkUI_NodeHandle对象用于Native侧组件挂载使用。
 通过OH_ArkUI_GetNodeHandleFromNapiValue接口获得的ArkUI_NodeHandle对象只能作为子组件参数使用，如addChild接口的第二个参数，将该对象使用在其他场景下，如setAttribute设置属性将不生效并返回错误码。 针对Native侧修改ArkTS组件的场景，需要在Native侧通过Node-API方式构建ArkTS侧的更新数据，再通过ComponentContent的update接口更新。 构建自定义组件时，相关函数如measureNode等无法对ArkTS模块内部的组件进行调用。 
以下示例代码在接入ArkTS页面章节基础上引入ArkTS的Refresh组件。
图1 Refresh组件挂载文本列表
 注册ArkTS组件创建函数给Native侧，以便Native侧调用，创建函数使用ComponentContent能力进行封装。 // MixedModule.ets\n// 使用ComponentContent能力创建ArkTS组件\n\nimport { NodeContent,  UIContext, RefreshModifier, ComponentContent } from '@kit.ArkUI';\n\n// 定义Native侧和ArkTS进行交互的数据对象。\ninterface NativeRefreshAttribute {\n  isRefreshing: boolean;\n  width?: number;\n  height?: number;\n  backgroundColor?: number;\n  refreshOffset?: number;\n  pullToRefresh?: boolean\n  onRefreshing?: () => void;\n  onOffsetChange?: (offset: number) => void;\n}\n\n// 定义@Builder函数的入参格式。\ninterface RefreshAttribute {\n  isRefreshing: boolean;\n  // 属性设置通过Modifier优化性能\n  modifier?: RefreshModifier;\n  slot?: NodeContent;\n  onRefreshing?: () => void;\n  onOffsetChange?: (offset: number) => void;\n}\n\n// ComponentContent封装ArkTS组件依赖全局@Builder函数，涉及复杂自定义组件场景，可以在@Builder函数中嵌套@Component自定义组件。\n// @Builder函数提供入参方式，方便后续通过ComponentContent的update接口进行参数更新。\n@Builder\nfunction mixedRefresh(attribute: RefreshAttribute) {\n  Refresh({ refreshing: attribute.isRefreshing }) {\n    // Refresh作为容器组件，需要使用ContentSlot机制预留子组件占位\n    ContentSlot(attribute.slot)\n  }.attributeModifier(attribute.modifier)\n  .onRefreshing(() => {\n    console.info(\"on onRefreshing\");\n    if (attribute.onRefreshing) {\n      console.info(\"on native onRefreshing\");\n      attribute.onRefreshing();\n    }\n  })\n  .onOffsetChange((value: number) => {\n    console.info(\"on offset change: \" + value);\n    if (attribute.onOffsetChange) {\n      console.info(\"on native onOffsetChange\");\n      attribute.onOffsetChange(value);\n    }\n  })\n}\n\n// 定义创建函数的返回值，用于ArkTS侧和Native侧的交互。\ninterface MixedModuleResult {\n  // 定义针对Refresh构建函数的封装对象，用于Native侧转化为ArkUI_NodeHandle对象。\n  content?: ComponentContent<RefreshAttribute>;\n  // Refresh作为容器组件，需要使用ContentSlot机制挂载Native侧的子组件。\n  childSlot?: NodeContent;\n}\n\n// 提供创建ArkTS组件的入口函数。\nexport function createMixedRefresh(value: NativeRefreshAttribute): MixedModuleResult {\n  console.info(\"createMixedRefresh\");\n  // 通过AppStorage对象在Ability启动的时候保持UI上下文对象。\n  let uiContent = AppStorage.get<UIContext>(\"context\");\n  let modifier = new RefreshModifier();\n  if (value.width) {\n    modifier.width(value.width)\n  }\n  if (value.height) {\n    modifier.height(value.height)\n  }\n  if (value.backgroundColor) {\n    modifier.backgroundColor(value.backgroundColor)\n  }\n  if (value.pullToRefresh) {\n    modifier.pullToRefresh(value.pullToRefresh)\n  }\n  if (value.refreshOffset) {\n    modifier.refreshOffset(value.refreshOffset)\n  }\n  // 创建NodeContent插槽对象用于Refresh子组件挂载。\n  let nodeSlot = new NodeContent();\n  // 通过ComponentContent创建Refresh组件并将它封装起来。\n  let content = new ComponentContent<RefreshAttribute>(uiContent!, wrapBuilder<[RefreshAttribute]>(mixedRefresh),\n    {\n      isRefreshing: value.isRefreshing,\n      modifier: modifier,\n      slot: nodeSlot,\n      onRefreshing: value.onRefreshing,\n      onOffsetChange: value.onOffsetChange\n    });\n  // 将Refresh组件的封装对象及其子组件插槽对象传递给Native侧。\n  return { content: content, childSlot: nodeSlot };\n}\n\n// 定义Refresh组件的更新函数，用于Native侧更新。\n// 在更新场景下，需要将Refresh组件的封装对象及其子组件插槽对象返回，防止组件重新创建。\nexport function updateMixedRefresh(refresh: ComponentContent<RefreshAttribute>, childSlot: NodeContent,\n  value: NativeRefreshAttribute): void {\n  let modifier = new RefreshModifier();\n  if (value.width) {\n    modifier.width(value.width)\n  }\n  if (value.height) {\n    modifier.height(value.height)\n  }\n  if (value.backgroundColor) {\n    modifier.backgroundColor(value.backgroundColor)\n  }\n  if (value.pullToRefresh) {\n    modifier.pullToRefresh(value.pullToRefresh)\n  }\n  if (value.refreshOffset) {\n    modifier.refreshOffset(value.refreshOffset)\n  }\n  // 调用ComponentContent的update接口进行更新。\n  refresh.update({\n    isRefreshing: value.isRefreshing,\n    modifier: modifier,\n    slot: childSlot,\n    onRefreshing: value.onRefreshing,\n    onOffsetChange: value.onOffsetChange\n  })\n} 将创建和更新函数注册给Native侧。 // entry.ets\nimport nativeNode from 'libentry.so';\nimport { NodeContent } from '@kit.ArkUI';\nimport { createMixedRefresh, updateMixedRefresh } from './MixedModule'\n\n@Entry\n@Component\nstruct Index {\n  private rootSlot = new NodeContent();\n  @State @Watch('changeNativeFlag') showNative: boolean = false;\n\n  aboutToAppear(): void {\n    // 设置uiContext;\n    AppStorage.setOrCreate<UIContext>(\"context\", this.getUIContext());\n    // 设置混合模式下的builder函数。\n    nativeNode.registerCreateMixedRefreshNode(createMixedRefresh);\n    nativeNode.registerUpdateMixedRefreshNode(updateMixedRefresh);\n  }\n\n  changeNativeFlag(): void {\n    if (this.showNative) {\n      // 创建NativeModule组件挂载\n      nativeNode.createNativeRoot(this.rootSlot)\n    } else {\n      // 销毁NativeModule组件\n      nativeNode.destroyNativeRoot()\n    }\n  }\n\n  build() {\n    Column() {\n      Button(this.showNative ? \"HideNativeUI\" : \"ShowNativeUI\").onClick(() => {\n        this.showNative = !this.showNative\n      })\n      Row() {\n        // ArkTS插入Native组件。\n        ContentSlot(this.rootSlot)\n      }.layoutWeight(1)\n    }\n    .width('100%')\n    .height('100%')\n  }\n} // native_init.cpp\n#include \"napi/native_api.h\"\n#include \"ArkUIMixedRefresh.h\"\n#include \"NativeEntry.h\"\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports) {\n    napi_property_descriptor desc[] = {\n        {\"createNativeRoot\", nullptr, NativeModule::CreateNativeRoot, nullptr, nullptr, nullptr, napi_default, nullptr},\n        // 注册混合模式创建方法。\n        {\"registerCreateMixedRefreshNode\", nullptr, NativeModule::ArkUIMixedRefresh::RegisterCreateRefresh, nullptr,\n         nullptr, nullptr, napi_default, nullptr},\n        // 注册混合模式更新方法。\n        {\"registerUpdateMixedRefreshNode\", nullptr, NativeModule::ArkUIMixedRefresh::RegisterUpdateRefresh, nullptr,\n         nullptr, nullptr, napi_default, nullptr},\n        {\"destroyNativeRoot\", nullptr, NativeModule::DestroyNativeRoot, nullptr, nullptr, nullptr, napi_default,\n         nullptr}};\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void *)0),\n    .reserved = {0},\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void) { napi_module_register(&demoModule); } Native侧通过Node-API保存创建和更新函数，用于后续调用。 // ArkUIMixedRefresh.h\n// 混合模式交互类。\n\n#ifndef MYAPPLICATION_ARKUIMIXEDREFRESH_H\n#define MYAPPLICATION_ARKUIMIXEDREFRESH_H\n\n#include \"ArkUIMixedNode.h\"\n\n#include <optional>\n\n#include <arkui/native_node_napi.h>\n#include <js_native_api_types.h>\n\nnamespace NativeModule {\n\nclass ArkUIMixedRefresh : public ArkUIMixedNode {\npublic:\n    static napi_value RegisterCreateRefresh(napi_env env, napi_callback_info info);\n    static napi_value RegisterUpdateRefresh(napi_env env, napi_callback_info info);\n};\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUIMIXEDREFRESH_H // ArkUIMixedRefresh.cpp\n// 混合模式交互类。\n\n#include \"ArkUIMixedRefresh.h\"\n#include <hilog/log.h>\n\nnamespace NativeModule {\nnamespace {\nnapi_env g_env;\nnapi_ref g_createRefresh;\nnapi_ref g_updateRefresh;\n} // namespace\n\nnapi_value ArkUIMixedRefresh::RegisterCreateRefresh(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    g_env = env;\n    napi_ref refer;\n    // 创建引用之后保存，防止释放。\n    napi_create_reference(env, args[0], 1, &refer);\n\n    g_createRefresh = refer;\n    return nullptr;\n}\n\nnapi_value ArkUIMixedRefresh::RegisterUpdateRefresh(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    g_env = env;\n    napi_ref refer;\n    // 创建引用之后保存，防止释放。\n    napi_create_reference(env, args[0], 1, &refer);\n\n    g_updateRefresh = refer;\n    return nullptr;\n}\n\n} // namespace NativeModule 抽象混合模式下组件的基类，用于通用逻辑管理。 // ArkUIMixedNode.h\n// 混合模式基类。\n\n#ifndef MYAPPLICATION_ARKUIMIXEDNODE_H\n#define MYAPPLICATION_ARKUIMIXEDNODE_H\n\n#include <js_native_api.h>\n#include <js_native_api_types.h>\n\n#include \"ArkUIBaseNode.h\"\n#include \"NativeModule.h\"\n\nnamespace NativeModule {\n\n// Wrap ArkTS Node\nclass ArkUIMixedNode : public ArkUIBaseNode {\npublic:\n    ArkUIMixedNode(ArkUI_NodeHandle handle, napi_env env, napi_ref componentContent)\n        : ArkUIBaseNode(handle), env_(env), componentContent_(componentContent) {}\n\n    // 在基类析构的时候需要把混合模式在ArkTS侧的对象释放掉。\n    ~ArkUIMixedNode() override { napi_delete_reference(env_, componentContent_); }\n\nprotected:\n    napi_env env_;\n    napi_ref componentContent_;\n};\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUIMIXEDNODE_H 实现Refresh组件的混合模式封装对象。 // ArkUIMixedRefresh.h\n// Refresh混合模式在Native侧的封装对象。\n\n#ifndef MYAPPLICATION_ARKUIMIXEDREFRESH_H\n#define MYAPPLICATION_ARKUIMIXEDREFRESH_H\n\n#include \"ArkUIMixedNode.h\"\n#include \"ArkUIBaseNode.h\"\n\n#include <optional>\n\n#include <arkui/native_node_napi.h>\n#include <js_native_api_types.h>\n\nnamespace NativeModule {\n\n// 定义Native侧和ArkTS侧的交互数据结构。\nstruct NativeRefreshAttribute {\n    std::optional<bool> isRefreshing;\n    std::optional<float> width;\n    std::optional<float> height;\n    std::optional<uint32_t> backgroundColor;\n    std::optional<float> refreshOffset;\n    std::optional<bool> pullToRefresh;\n    std::function<void()> onRefreshing;\n    std::function<void(float)> onOffsetChange;\n};\n\nclass ArkUIMixedRefresh : public ArkUIMixedNode {\npublic:\n    // 调用ArkTS的方法创建Refresh组件。\n    static const std::shared_ptr<ArkUIMixedRefresh> Create(const NativeRefreshAttribute &attribute);\n\n    ArkUIMixedRefresh(ArkUI_NodeHandle handle, ArkUI_NodeContentHandle contentHandle, napi_env env,\n                      napi_ref componentContent, napi_ref nodeContent)\n        : ArkUIMixedNode(handle, env, componentContent), contentHandle_(contentHandle), nodeContent_(nodeContent) {}\n\n    ArkUIMixedRefresh() : ArkUIMixedNode(nullptr, nullptr, nullptr) {}\n\n    ~ArkUIMixedRefresh() override { napi_delete_reference(env_, nodeContent_); } // 释放子节点占位组件插槽对象。\n\n    void SetWidth(float width) { attribute_.width = width; }\n\n    void SetHeight(float height) { attribute_.height = height; }\n\n    void SetBackgroundColor(uint32_t color) { attribute_.backgroundColor = color; }\n\n    void SetRefreshState(bool isRefreshing) { attribute_.isRefreshing = isRefreshing; }\n\n    void SetPullToRefresh(bool pullToRefresh) { attribute_.pullToRefresh = pullToRefresh; }\n\n    void SetRefreshOffset(float offset) { attribute_.refreshOffset = offset; }\n\n    void SetRefreshCallback(const std::function<void()> &callback) { attribute_.onRefreshing = callback; }\n\n    void SetOnOffsetChange(const std::function<void(float)> &callback) { attribute_.onOffsetChange = callback; }\n\n    // 避免频繁跨语言，在Native侧缓存属性事件，批量通知。\n    void FlushMixedModeCmd();\n\n    static napi_value RegisterCreateRefresh(napi_env env, napi_callback_info info);\n    static napi_value RegisterUpdateRefresh(napi_env env, napi_callback_info info);\n\nprotected:\n    void OnAddChild(const std::shared_ptr<ArkUIBaseNode> &child) override {\n        assert(contentHandle_);\n        // 使用NodeContent挂载组件（可以使用ArkTS在Native侧通过ComponentContent的转化对象，也可以是纯Native组件）到ArkTS组件下面。\n        OH_ArkUI_NodeContent_AddNode(contentHandle_, child->GetHandle());\n    }\n\n    void OnRemoveChild(const std::shared_ptr<ArkUIBaseNode> &child) override {\n        assert(contentHandle_);\n        // 使用NodeContent卸载组件。\n        OH_ArkUI_NodeContent_RemoveNode(contentHandle_, child->GetHandle());\n    }\n\n    void OnInsertChild(const std::shared_ptr<ArkUIBaseNode> &child, int32_t index) override {\n        assert(contentHandle_);\n        // 使用NodeContent插入组件。\n        OH_ArkUI_NodeContent_InsertNode(contentHandle_, child->GetHandle(), index);\n    }\n\nprivate:\n    // 使用napi接口创建ArkTS侧的数据结构。\n    static napi_value CreateRefreshAttribute(const NativeRefreshAttribute &attribute, void *userData);\n\n    ArkUI_NodeContentHandle contentHandle_;\n    napi_ref nodeContent_;\n    NativeRefreshAttribute attribute_;\n};\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUIMIXEDREFRESH_H 相关实现类说明： #include \"ArkUIMixedRefresh.h\"\n#include <hilog/log.h>\n\nnamespace NativeModule {\nnamespace {\nnapi_env g_env;\nnapi_ref g_createRefresh;\nnapi_ref g_updateRefresh;\n} // namespace\n\n// 使用Napi接口创建与ArkTS侧交互的数据结构，用于Refresh组件的创建和更新。\nnapi_value ArkUIMixedRefresh::CreateRefreshAttribute(const NativeRefreshAttribute &attribute, void *userData) {\n    napi_property_descriptor desc[] = {\n        {\"width\", nullptr, nullptr, nullptr, nullptr, nullptr, napi_default, userData},\n        {\"height\", nullptr, nullptr, nullptr, nullptr, nullptr, napi_default, userData},\n        {\"backgroundColor\", nullptr, nullptr, nullptr, nullptr, nullptr, napi_default, userData},\n        {\"pullToRefresh\", nullptr, nullptr, nullptr, nullptr, nullptr, napi_default, userData},\n        {\"isRefreshing\", nullptr, nullptr, nullptr, nullptr, nullptr, napi_default, userData},\n        {\"refreshOffset\", nullptr, nullptr, nullptr, nullptr, nullptr, napi_default, userData},\n        {\"onRefreshing\", nullptr, nullptr, nullptr, nullptr, nullptr, napi_default, userData},\n        {\"onOffsetChange\", nullptr, nullptr, nullptr, nullptr, nullptr, napi_default, userData},\n    };\n    if (attribute.width) {\n        napi_value width;\n        napi_create_double(g_env, attribute.width.value(), &width);\n        desc[0].value = width;\n    }\n    if (attribute.height) {\n        napi_value height;\n        napi_create_double(g_env, attribute.height.value(), &height);\n        desc[1].value = height;\n    }\n    if (attribute.backgroundColor) {\n        napi_value backgroundColor;\n        napi_create_uint32(g_env, attribute.backgroundColor.value(), &backgroundColor);\n        desc[2].value = backgroundColor;\n    }\n    if (attribute.pullToRefresh) {\n        napi_value pullToRefresh;\n        napi_create_int32(g_env, attribute.pullToRefresh.value(), &pullToRefresh);\n        desc[3].value = pullToRefresh;\n    }\n    if (attribute.isRefreshing) {\n        napi_value isRefreshing;\n        napi_create_int32(g_env, attribute.isRefreshing.value(), &isRefreshing);\n        desc[4].value = isRefreshing;\n    }\n    if (attribute.refreshOffset) {\n        napi_value refreshOffset;\n        napi_create_double(g_env, attribute.refreshOffset.value(), &refreshOffset);\n        desc[5].value = refreshOffset;\n    }\n    if (attribute.onRefreshing) {\n        OH_LOG_INFO(LOG_APP, \"onRefreshing start\");\n        desc[6].method = [](napi_env env, napi_callback_info info) -> napi_value {\n            OH_LOG_INFO(LOG_APP, \"onRefreshing callback\");\n            size_t argc = 0;\n            napi_value args[0];\n            void *data;\n            napi_get_cb_info(env, info, &argc, args, nullptr, &data);\n            auto refresh = reinterpret_cast<ArkUIMixedRefresh *>(data);\n            if (refresh && refresh->attribute_.onRefreshing) {\n                refresh->attribute_.onRefreshing();\n            }\n            return nullptr;\n        };\n    }\n    if (attribute.onOffsetChange) {\n        OH_LOG_INFO(LOG_APP, \"onOffsetChange start\");\n        desc[7].method = [](napi_env env, napi_callback_info info) -> napi_value {\n            OH_LOG_INFO(LOG_APP, \"onOffsetChange callback\");\n            size_t argc = 1;\n            napi_value args[1] = {nullptr};\n            void *data;\n            napi_get_cb_info(env, info, &argc, args, nullptr, &data);\n            double offset = 0.0;\n            napi_get_value_double(env, args[0], &offset);\n            auto refresh = reinterpret_cast<ArkUIMixedRefresh *>(data);\n            if (refresh && refresh->attribute_.onOffsetChange) {\n                refresh->attribute_.onOffsetChange(offset);\n            }\n            return nullptr;\n        };\n    }\n    napi_value refreshAttribute = nullptr;\n    auto result = napi_create_object_with_properties(g_env, &refreshAttribute, sizeof(desc) / sizeof(desc[0]), desc);\n    if (result != napi_ok) {\n        return nullptr;\n    }\n    return refreshAttribute;\n}\n\n// 创建ArkTS侧的组件并保存在Native侧的封装对象中。\nconst std::shared_ptr<ArkUIMixedRefresh> ArkUIMixedRefresh::Create(const NativeRefreshAttribute &attribute) {\n    napi_handle_scope scope;\n    napi_open_handle_scope(g_env, &scope);\n    auto refresh = std::make_shared<ArkUIMixedRefresh>();\n    auto refreshAttribute = CreateRefreshAttribute(attribute, refresh.get());\n    if (refreshAttribute == nullptr) {\n        napi_close_handle_scope(g_env, scope);\n        return nullptr;\n    }\n    napi_value result = nullptr;\n    napi_value argv[1] = {refreshAttribute};\n    napi_value createRefresh = nullptr;\n    napi_get_reference_value(g_env, g_createRefresh, &createRefresh);\n    // 调用ArkTS的Create函数创建ArkTS的ComponentContent。\n    napi_call_function(g_env, nullptr, createRefresh, 1, argv, &result);\n\n    // 获取ArkTS的Refresh组件。\n    napi_value componentContent = nullptr;\n    napi_get_named_property(g_env, result, \"content\", &componentContent);\n    ArkUI_NodeHandle handle;\n    OH_ArkUI_GetNodeHandleFromNapiValue(g_env, componentContent, &handle);\n    assert(handle);\n    // 获取ArkTS的Refresh组件的子组件插槽。\n    napi_value nodeContent = nullptr;\n    napi_get_named_property(g_env, result, \"childSlot\", &nodeContent);\n    ArkUI_NodeContentHandle contentHandle;\n    OH_ArkUI_GetNodeContentFromNapiValue(g_env, nodeContent, &contentHandle);\n    assert(contentHandle);\n    // 保存ArkTS的ComponentContent用于防止ArkTS侧对象释放以及后续的更新。\n    napi_ref componentContentRef;\n    napi_create_reference(g_env, componentContent, 1, &componentContentRef);\n    // 保存ArkTS的NodeContent用于防止ArkTS侧对象释放以及后续的更新。\n    napi_ref nodeContentRef;\n    napi_create_reference(g_env, nodeContent, 1, &nodeContentRef);\n    // 更新Refresh组件相关参数。\n    refresh->handle_ = handle;\n    refresh->env_ = g_env;\n    refresh->componentContent_ = componentContentRef;\n    refresh->nodeContent_ = nodeContentRef;\n    refresh->contentHandle_ = contentHandle;\n    refresh->attribute_ = attribute;\n    return refresh;\n}\n// 更新函数实现。\nvoid ArkUIMixedRefresh::FlushMixedModeCmd() {\n    napi_handle_scope scope;\n    napi_open_handle_scope(g_env, &scope);\n    // 创建调用ArkTS接口入参。\n    auto refreshAttribute = CreateRefreshAttribute(attribute_, this);\n    if (refreshAttribute == nullptr) {\n        napi_close_handle_scope(g_env, scope);\n        return;\n    }\n    // 获取更新接口的剩余两个接口参数。\n    napi_value componentContent = nullptr;\n    napi_get_reference_value(g_env, componentContent_, &componentContent);\n    napi_value nodeContent = nullptr;\n    napi_get_reference_value(g_env, nodeContent_, &nodeContent);\n\n    napi_value argv[3] = {componentContent, nodeContent, refreshAttribute};\n    napi_value updateRefresh = nullptr;\n    napi_get_reference_value(g_env, g_updateRefresh, &updateRefresh);\n    // 调用ArkTS的Update函数进行更新。\n    napi_value result = nullptr;\n    napi_call_function(g_env, nullptr, updateRefresh, 3, argv, &result);\n}\n\nnapi_value ArkUIMixedRefresh::RegisterCreateRefresh(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    g_env = env;\n    napi_ref refer;\n    napi_create_reference(env, args[0], 1, &refer);\n\n    g_createRefresh = refer;\n    return nullptr;\n}\n\nnapi_value ArkUIMixedRefresh::RegisterUpdateRefresh(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    g_env = env;\n    napi_ref refer;\n    napi_create_reference(env, args[0], 1, &refer);\n\n    g_updateRefresh = refer;\n    return nullptr;\n}\n\n} // namespace NativeModule 使用接入ArkTS页面章节的页面结构，并沿用定时器模块相关简单实现，将Refresh组件作为文本列表的父组件。 // MixedRefreshExample.h\n// 混合模式示例代码。\n\n#ifndef MYAPPLICATION_MIXEDREFRESHEXAMPLE_H\n#define MYAPPLICATION_MIXEDREFRESHEXAMPLE_H\n\n#include \"ArkUIBaseNode.h\"\n#include \"ArkUIMixedRefresh.h\"\n#include \"TextListExample.h\"\n#include \"UITimer.h\"\n\n#include <js_native_api_types.h>\n\nnamespace NativeModule {\n\nstd::shared_ptr<ArkUIBaseNode> CreateMixedRefreshList(napi_env env) {\n    auto list = CreateTextListExample();\n    // 混合模式创建Refresh组件并挂载List组件。\n    NativeRefreshAttribute nativeRefreshAttribute{\n        .backgroundColor = 0xFF89CFF0, .refreshOffset = 64, .pullToRefresh = true};\n    auto refresh = ArkUIMixedRefresh::Create(nativeRefreshAttribute);\n    refresh->AddChild(list);\n\n    // 设置混合模式下的事件。\n    refresh->SetOnOffsetChange(\n        [](float offset) { OH_LOG_INFO(LOG_APP, \"on refresh offset changed: %{public}f\", offset); });\n    refresh->SetRefreshCallback([refreshPtr = refresh.get(), env]() {\n        OH_LOG_INFO(LOG_APP, \"on refreshing\");\n        // 启动定时器，模拟数据获取。\n        CreateNativeTimer(env, refreshPtr, 1, [](void *userData, int32_t count) {\n            // 数据获取后关闭刷新。\n            auto refresh = reinterpret_cast<ArkUIMixedRefresh *>(userData);\n            refresh->SetRefreshState(false);\n            refresh->FlushMixedModeCmd();\n        });\n    });\n\n    // 更新事件到ArkTS侧。\n    refresh->FlushMixedModeCmd();\n    return refresh;\n}\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_MIXEDREFRESHEXAMPLE_H 替换入口组件创建为下拉刷新文本列表。 #include \"NativeEntry.h\"\n\n#include \"ArkUIMixedRefresh.h\"\n#include \"MixedRefreshExample.h\"\n#include \"TextListExample.h\"\n\n#include <arkui/native_node_napi.h>\n#include <arkui/native_type.h>\n#include <js_native_api.h>\n#include <uv.h>\n\nnamespace NativeModule {\n\nnapi_value CreateNativeRoot(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    // 获取NodeContent\n    ArkUI_NodeContentHandle contentHandle;\n    OH_ArkUI_GetNodeContentFromNapiValue(env, args[0], &contentHandle);\n    NativeEntry::GetInstance()->SetContentHandle(contentHandle);\n\n    // 创建Refresh文本列表\n    auto refresh = CreateMixedRefreshList(env);\n\n    // 保持Native侧对象到管理类中，维护生命周期。\n    NativeEntry::GetInstance()->SetRootNode(refresh);\n    return nullptr;\n}\n\nnapi_value DestroyNativeRoot(napi_env env, napi_callback_info info) {\n    // 从管理类中释放Native侧对象。\n    NativeEntry::GetInstance()->DisposeRootNode();\n    return nullptr;\n}\n\n} // namespace NativeModule 

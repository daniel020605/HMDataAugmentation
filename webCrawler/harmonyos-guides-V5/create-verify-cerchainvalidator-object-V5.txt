证书链校验器对象的创建和校验
证书链是由一组证书组成的证书集合，以图中样例证书文件为例，即可放在一个证书链中。
样例中可以看到GlobalSign自签名了证书，GlobalSign也签发了GlobalSign RSA OV SSL CA 2018的证书，GlobalSign RSA OV SSL CA 2018又签发了第三级证书。
开发者可以参考示例将已有的多个证书构建出证书链数据。
开发步骤
 导入证书算法库框架模块。 import { cert } from '@kit.DeviceCertificateKit'; cert.createCertChainValidator创建证书链校验器对象。 基于已有的证书数据，创建证书链数据对象CertChainData。 证书算法库框架提供了证书链校验器对象可用于校验证书链，以验证信任链根源，但待校验的证书链数据对象应符合如下的数据结构定义。     名称 类型 可读 可写 说明    data Uint8Array 是 是 证书数据，按照长度(2字节)-数据的形式传入。如08ABCDEFGH07ABCDEFG：第一本证书，前2个字节表示证书的长度为8字节，后面附加8字节的证书数据；第2本证书前2个字节表示证书的长度为7字节，后面附加7字节的证书数据。   count number 是 是 传入的数据中，包含的证书数量。   encodingFormat EncodingFormat 是 是 指明证书编码格式。    调用CertChainValidator.validate校验证书链数据。 
import { cert } from '@kit.DeviceCertificateKit';\nimport { util } from '@kit.ArkTS';\n\n// CA数据，这只是一个示例，需要根据具体业务来赋值\nlet caCertData = '-----BEGIN CERTIFICATE-----\\n' +\n  '...\\n' +\n  '...\\n' +\n  '...\\n' +\n  '-----END CERTIFICATE-----\\n';\n\n// 二级CA证书数据，这只是一个示例，需要根据具体业务来赋值\nlet secondCaCertData = '-----BEGIN CERTIFICATE-----\\n' +\n  '...\\n' +\n  '...\\n' +\n  '...\\n' +\n  '-----END CERTIFICATE-----\\n';\n\n// 证书链校验器示例。在这个示例中，验证了一个二级证书链\nfunction certChainValidatorSample(): void {\n  let textEncoder = new util.TextEncoder();\n  // 证书链校验器算法。目前仅支持PKIX\n  let algorithm = 'PKIX';\n\n  // 创建一个证书链校验器实例\n  let validator = cert.createCertChainValidator(algorithm);\n\n  // CA证书数据\n  let uint8ArrayOfCaCertData = textEncoder.encodeInto(caCertData);\n\n  // CA证书数据的长度\n  let uint8ArrayOfCaCertDataLen = new Uint8Array(new Uint16Array([uint8ArrayOfCaCertData.byteLength]).buffer);\n\n  // 二级CA证书数据\n  let uint8ArrayOf2ndCaCertData =  textEncoder.encodeInto(secondCaCertData);\n\n  // 二级CA证书数据的长度\n  let uint8ArrayOf2ndCaCertDataLen = new Uint8Array(new Uint16Array([uint8ArrayOf2ndCaCertData.byteLength]).buffer);\n\n  // 证书链二进制数据：二级CA证书数据长度+二级CA证书数据+CA证书数据长度+CA证书数据（L-V格式）\n  let encodingData = new Uint8Array(uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length +\n  uint8ArrayOfCaCertDataLen.length + uint8ArrayOfCaCertData.length);\n  for (let i = 0; i < uint8ArrayOf2ndCaCertDataLen.length; i++) {\n    encodingData[i] = uint8ArrayOf2ndCaCertDataLen[i];\n  }\n  for (let i = 0; i < uint8ArrayOf2ndCaCertData.length; i++) {\n    encodingData[uint8ArrayOf2ndCaCertDataLen.length + i] = uint8ArrayOf2ndCaCertData[i];\n  }\n  for (let i = 0; i < uint8ArrayOfCaCertDataLen.length; i++) {\n    encodingData[uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length + i] = uint8ArrayOfCaCertDataLen[i];\n  }\n  for (let i = 0; i < uint8ArrayOfCaCertData.length; i++) {\n    encodingData[uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length +\n    uint8ArrayOfCaCertDataLen.length + i] = uint8ArrayOfCaCertData[i];\n  }\n\n  let certChainData: cert.CertChainData = {\n    // Uint8Array类型：L-V格式（证书数据长度-证书数据）\n    data: encodingData,\n    // 证书的数量。本例中为2\n    count: 2,\n    // 证书格式。仅支持 PEM 和 DER。在此示例中，证书为 PEM 格式\n    encodingFormat: cert.EncodingFormat.FORMAT_PEM\n  };\n\n  // 验证证书链\n  validator.validate(certChainData, (err, data) => {\n    if (err != null) {\n      // 校验失败\n      console.error(`validate failed, errCode: ${err.code}, errMsg: ${err.message}`);\n    } else {\n      // 校验成功\n      console.log('validate success');\n    }\n  });\n}

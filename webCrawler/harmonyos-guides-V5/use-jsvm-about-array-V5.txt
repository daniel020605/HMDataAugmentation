使用JSVM-API接口进行array相关开发
简介
使用 JSVM-API 接口进行数组（array）相关开发时，调用相关接口可以在 JSVM 模块中直接操作和处理 JavaScript 中的数组。
基本概念
使用 JSVM-API 接口进行数组（array）相关开发时，涉及的基本概念主要包括数组的创建、访问、修改、遍历以及与数组相关的操作。这些概念对于理解在 JSVM 模块中如何与 JavaScript 数组交互非常重要。以下是一些关键概念：
数组的创建：若在 JSVM 模块中需要创建一个新的 JavaScript 数组，可以使用提供的 OH_JSVM_CreateArray 接口创建数组，将数组传递给 JavaScript 层。数组相关操作：在 JSVM 模块中通过对应的接口获取 JavaScript 数组的长度、检索指定索引处的元素以及设置指定索引处的元素值，从而实现 JSVM 模块与 JavaScript 数组的交互。TypedArray：JavaScript 中的 TypedArray 是一种用来描述二进制数据的类数组数据视图，可以简单理解为一种指定元素类型的数组，TypedArray 没有直接构造器，但是可以用它的子类构造器构造 TypedArray 类型的数据。TypedArray 的子类有：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Int32Array 等。ArrayBuffer：ArrayBuffer 是固定长度的二进制数据缓冲区。DataView：DataView 是 JavaScript 中的一种视图，是可以从 ArrayBuffer 对象中读写多种数值类型的底层接口。
接口说明
使用示例
JSVM-API 接口开发流程参考使用 JSVM-API 实现 JS 与 C/C++ 语言交互开发流程，本文仅对接口对应 C++ 相关代码进行展示。
[h2]OH_JSVM_CreateArray
创建一个新的 JavaScript 数组对象。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// CreateArray注册回调\nstatic int DIFF_VALUE_FIVE = 5;\n// OH_JSVM_CreateArray的样例方法\nstatic JSVM_Value CreateArray(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 创建一个空数组\n    JSVM_Value array = nullptr;\n    JSVM_Status status = OH_JSVM_CreateArray(env, &array);\n    // 对创建的数组进行赋值\n    for (int i = 0; i < DIFF_VALUE_FIVE; i++) {\n        JSVM_Value element;\n        OH_JSVM_CreateInt32(env, i, &element);\n        OH_JSVM_SetElement(env, array, i, element);\n    }\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM CreateArray fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM CreateArray success\");\n    }\n    return array;\n}\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = CreateArray},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateArray方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"createArray\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\n  function testCreateArray() {\n    return createArray();\n  }\n  testCreateArray();\n)JS\";
[h2]OH_JSVM_CreateArrayWithLength
创建一个指定长度的 JavaScript 数组对象。
cpp 部分代码：
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_CreateArrayWithLength的样例方法\nstatic JSVM_Value CreateArrayWithLength(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value argv[1] = {nullptr};\n    JSVM_Value result = nullptr;\n    // 解析传递的参数OH_JSVM_GetCbInfo\n    OH_JSVM_GetCbInfo(env, info, &argc, argv, nullptr, nullptr);\n    // 获取传递的数组长度\n    int32_t length;\n    OH_JSVM_GetValueInt32(env, argv[0], &length);\n    // 使用OH_JSVM_CreateArrayWithLength创建传递固定长度的数组\n    JSVM_Status status = OH_JSVM_CreateArrayWithLength(env, length, &result);\n    if (status == JSVM_OK) {\n        // 给创建的数组设置值\n        for (int32_t i = 0; i < length; i++) {\n            JSVM_Value value;\n            OH_JSVM_CreateInt32(env, i, &value);\n            OH_JSVM_SetElement(env, result, i, value);\n        }\n        OH_LOG_INFO(LOG_APP, \"JSVM CreateArrayWithLength success\");\n    } else {\n        OH_LOG_ERROR(LOG_APP, \"JSVM CreateArrayWithLength fail\");\n    }\n    return result;\n}\n// CreateArrayWithLength注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = CreateArrayWithLength},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateArrayWithLength方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"createArrayWithLength\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nlet num = 7;\nfunction testCreateArrayWithLength(num){\n    return createArrayWithLength(num);\n}\ntestCreateArrayWithLength(num);\n)JS\";
[h2]OH_JSVM_CreateTypedarray
在现有的 ArrayBuffer上 创建一个 JavaScript TypedArray 对象,TypedArray 对象在底层数据缓冲区上提供类似数组的视图，其中每个元素都具有相同的底层二进制标量数据类型。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_CreateTypedarray的样例方法\nstatic int DIFF_VALUE_THREE = 3;\nstatic JSVM_Value CreateTypedArray(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    int32_t typeNum;\n    OH_JSVM_GetValueInt32(env, args[0], &typeNum);\n    JSVM_TypedarrayType arrayType;\n    // 用于存储每个元素的大小\n    size_t elementSize = 0;\n    // 转换为JSVM_TypedarrayType类型\n    arrayType = static_cast<JSVM_TypedarrayType>(typeNum);\n    switch (typeNum) {\n    case JSVM_INT8_ARRAY:\n    case JSVM_UINT8_ARRAY:\n    case JSVM_UINT8_CLAMPED_ARRAY:\n        elementSize = sizeof(int8_t);\n        break;\n    case JSVM_INT16_ARRAY:\n    case JSVM_UINT16_ARRAY:\n        elementSize = sizeof(int16_t);\n        break;\n    case JSVM_INT32_ARRAY:\n    case JSVM_UINT32_ARRAY:\n        elementSize = sizeof(int32_t);\n        break;\n    case JSVM_FLOAT32_ARRAY:\n        elementSize = sizeof(float);\n        break;\n    case JSVM_FLOAT64_ARRAY:\n        elementSize = sizeof(double);\n        break;\n    case JSVM_BIGINT64_ARRAY:\n    case JSVM_BIGUINT64_ARRAY:\n        elementSize = sizeof(int64_t);\n        break;\n    default:\n        // 默认创建JSVM_INT8_ARRAY类型\n        arrayType = JSVM_INT8_ARRAY;\n        elementSize = sizeof(int8_t);\n        break;\n    }\n    size_t length = DIFF_VALUE_THREE;\n    JSVM_Value arrayBuffer = nullptr;\n    JSVM_Value typedArray = nullptr;\n    void *data;\n    // 创建一个ArrayBuffer\n    OH_JSVM_CreateArraybuffer(env, length * elementSize, (void **)&data, &arrayBuffer);\n    // 根据给定类型创建TypedArray\n    JSVM_Status status = OH_JSVM_CreateTypedarray(env, arrayType, length, arrayBuffer, 0, &typedArray);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM CreateTypedArray fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM CreateTypedArray success\");\n    }\n    return typedArray;\n}\n// CreateTypedArray注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = CreateTypedArray},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateTypedArray方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"createTypedArray\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nconst type = {\n    INT8_ARRAY: 0,\n    UINT8_ARRAY: 1,\n    UINT8_CLAMPED_ARRAY: 2,\n    INT16_ARRAY: 3,\n    UINT16_ARRAY: 4,\n    INT32_ARRAY: 5,\n    UINT32_ARRAY: 6,\n    FLOAT32_ARRAY: 7,\n    FLOAT64_ARRAY: 8,\n    BIGINT64_ARRAY: 9,\n    BIGUINT64_ARRAY: 10\n};\ncreateTypedArray(type.INT8_ARRAY);\ncreateTypedArray(type.INT32_ARRAY);\n)JS\";
[h2]OH_JSVM_CreateDataview
在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象，DataView 对象在底层数据缓冲区上提供类似数组的视图。
cpp部分代码
static int DIFF_VALUE_FOUR = 4;\nstatic int DIFF_VALUE_TWELVE = 12;\n// OH_JSVM_CreateDataview的样例方法\nstatic JSVM_Value CreateDataView(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 获取js侧传入的两个参数\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    JSVM_Value arrayBuffer = nullptr;\n    JSVM_Value result = nullptr;\n    // DataView的字节长度\n    size_t byteLength = DIFF_VALUE_TWELVE;\n    // 字节偏移量\n    size_t byteOffset = DIFF_VALUE_FOUR;\n    // 获取回调函数的参数信息\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 将参数转换为对象类型\n    OH_JSVM_CoerceToObject(env, args[0], &arrayBuffer);\n    // 创建一个数据视图对象，并指定字节长度和字节偏移量\n    JSVM_Status status = OH_JSVM_CreateDataview(env, byteLength, arrayBuffer, byteOffset, &result);\n    // 获取DataView的指针和长度信息\n    uint8_t *data = nullptr;\n    size_t length = 0;\n    // 为DataView赋值\n    for (size_t i = 0; i < length; i++) {\n        data[i] = static_cast<uint8_t>(i + 1);\n    }\n    int32_t infoType;\n    OH_JSVM_GetValueInt32(env, args[1], &infoType);\n    size_t returnLength;\n    JSVM_Value returnArrayBuffer = nullptr;\n    size_t returnOffset;\n    enum InfoType { BYTE_LENGTHE, ARRAY_BUFFERE, BYTE_OFFSET };\n    // 获取dataview信息\n    OH_JSVM_GetDataviewInfo(env, result, &returnLength, (void **)&data, &returnArrayBuffer, &returnOffset);\n    JSVM_Value returnResult = nullptr;\n    switch (infoType) {\n    case BYTE_LENGTHE:\n        JSVM_Value len;\n        OH_JSVM_CreateInt32(env, returnLength, &len);\n        returnResult = len;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM CreateDataView fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM CreateDataView success, returnLength: %{public}d\", returnLength);\n        }\n        break;\n    case ARRAY_BUFFERE:\n        bool isArraybuffer;\n        OH_JSVM_IsArraybuffer(env, returnArrayBuffer, &isArraybuffer);\n        JSVM_Value isArray;\n        OH_JSVM_GetBoolean(env, isArraybuffer, &isArray);\n        returnResult = isArray;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM CreateDataView fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM CreateDataView success, isArraybuffer: %{public}d\", isArraybuffer);\n        }\n        break;\n    case BYTE_OFFSET:\n        JSVM_Value offset;\n        OH_JSVM_CreateInt32(env, returnOffset, &offset);\n        returnResult = offset;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM CreateDataView fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM CreateDataView success, returnOffset: %{public}d\", returnOffset);\n        }\n        break;\n    default:\n        break;\n    }\n    return returnResult;\n}\n// CreateDataView注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = CreateDataView},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateDataView方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"createDataView\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\n let BYTE_LENGTH = 0;\n createDataView(new ArrayBuffer(16), BYTE_LENGTH);\n let IS_ARRAYBUFFER = 1;\n createDataView(new ArrayBuffer(16), IS_ARRAYBUFFER);\n let BYTE_OFFSET = 2;\n createDataView(new ArrayBuffer(16), BYTE_OFFSET);\n)JS\";
[h2]OH_JSVM_GetArrayLength
返回 Array 对象的长度。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_GetArrayLength的样例方法\nstatic JSVM_Value GetArrayLength(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    JSVM_Value result = nullptr;\n    uint32_t length;\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 检查参数是否为数组\n    bool isArray = false;\n    OH_JSVM_IsArray(env, args[0], &isArray);\n    if (!isArray) {\n        OH_LOG_INFO(LOG_APP, \"JSVM Argument must be an array\");\n        return nullptr;\n    }\n    OH_JSVM_GetArrayLength(env, args[0], &length);\n    // 创建返回值\n    OH_JSVM_CreateInt32(env, length, &result);\n    OH_LOG_INFO(LOG_APP, \"JSVM length: %{public}d\", length);\n    return result;\n}\n// GetArrayLength注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = GetArrayLength},\n};\nstatic JSVM_CallbackStruct *method = param;\n// GetArrayLength方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"getArrayLength\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nlet data = [0, 1, 2, 3, 4, 5];\ngetArrayLength(data);\n)JS\";
[h2]OH_JSVM_GetTypedarrayInfo
获取 TypedArray（类型化数组）对象的信息。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_GetTypedarrayInfo的样例方法\nstatic JSVM_Value GetTypedArrayInfo(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 获取并解析参数，第一个参数为需要获得的信息的TypedArray类型数据，第二个参数为需要获得的信息类型的枚举值\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n\n    // 将第二个参数转为int32类型便于比较\n    int32_t infoTypeParam;\n    OH_JSVM_GetValueInt32(env, args[1], &infoTypeParam);\n    // 定义枚举类型与ArkTS侧枚举类型infoType顺序含义一致\n    enum InfoType { INFO_TYPE, INFO_LENGTH, INFO_ARRAY_BUFFER, INFO_BYTE_OFFSET };\n    void *data;\n    JSVM_TypedarrayType type;\n    size_t byteOffset, length;\n    JSVM_Value arrayBuffer = nullptr;\n    // 调用接口OH_JSVM_GetTypedarrayInfo获得TypedArray类型数据的信息\n    JSVM_Status status = OH_JSVM_GetTypedarrayInfo(env, args[0], &type, &length, &data, &arrayBuffer, &byteOffset);\n    JSVM_Value result = nullptr;\n    // 根据属性名，返回TypedArray对应的属性值\n    switch (infoTypeParam) {\n    case INFO_TYPE:\n        // 如果传入的参数是int8类型的TypedArray数据，它的类型（type）为JSVM_INT8_ARRAY\n        JSVM_Value int8_type;\n        OH_JSVM_GetBoolean(env, type == JSVM_INT8_ARRAY, &int8_type);\n        result = int8_type;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM GetTypedArrayInfo fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM GetTypedArrayInfo success, JSVM_INT8_ARRAY: %{public}d\", type == JSVM_INT8_ARRAY);\n        }\n        break;\n    case INFO_LENGTH:\n        // TypedArray中的元素数\n        JSVM_Value jsvmLength;\n        OH_JSVM_CreateInt32(env, length, &jsvmLength);\n        result = jsvmLength;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM GetTypedArrayInfo fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM GetTypedArrayInfo success, length: %{public}d\", length);\n        }\n        break;\n    case INFO_BYTE_OFFSET:\n        // TypedArray数组的第一个元素所在的基础原生数组中的字节偏移量\n        JSVM_Value jsvmOffset;\n        OH_JSVM_CreateInt32(env, byteOffset, &jsvmOffset);\n        result = jsvmOffset;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM GetTypedArrayInfo fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM GetTypedArrayInfo success, byteOffset: %{public}d\", byteOffset);\n        }\n        break;\n    case INFO_ARRAY_BUFFER:\n        // TypedArray下的ArrayBuffer\n        bool isArrayBuffer;\n        OH_JSVM_IsArraybuffer(env, arrayBuffer, &isArrayBuffer);\n        JSVM_Value isArray;\n        OH_JSVM_GetBoolean(env, isArrayBuffer, &isArray);\n        result = isArray;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM GetTypedArrayInfo fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM GetTypedArrayInfo success, isArrayBuffer: %{public}d\", isArrayBuffer);\n        }\n        break;\n    default:\n        break;\n    }\n    return result;\n}\n// GetTypedArrayInfo注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = GetTypedArrayInfo},\n};\nstatic JSVM_CallbackStruct *method = param;\n// GetTypedArrayInfo方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"getTypedArrayInfo\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\n// is JSVM_INT8_ARRAY\ngetTypedArrayInfo(new Int8Array(3), 0);\n// length\ngetTypedArrayInfo(new Int8Array(5), 1);\n// is_arraybuffer\ngetTypedArrayInfo(new Int8Array(5), 2);\n// byteoffset\ngetTypedArrayInfo(new Int8Array(1), 3);\n)JS\";
[h2]OH_JSVM_GetDataviewInfo
获取 Dataview 对象的信息。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_GetDataviewInfo的样例方法\nstatic JSVM_Value GetDataViewInfo(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 获取并解析参数，第一个参数为需要获得的信息的DataView类型数据，第二个参数为需要获得的信息类型的枚举值\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 将第二个参数转为int32类型的数字\n    int32_t infoType;\n    OH_JSVM_GetValueInt32(env, args[1], &infoType);\n    size_t byteLength;\n    void *data;\n    JSVM_Value arrayBuffer = nullptr;\n    size_t byteOffset;\n    // 定义枚举类型与ArkTS侧枚举类型infoType顺序含义一致\n    enum infoTypeEnum { BYTE_LENGTHE, ARRAY_BUFFERE, BYTE_OFFSET };\n    // 获取dataview信息\n    JSVM_Status status = OH_JSVM_GetDataviewInfo(env, args[0], &byteLength, &data, &arrayBuffer, &byteOffset);\n    JSVM_Value result = nullptr;\n    switch (infoType) {\n    case BYTE_LENGTHE:\n        // 返回查询DataView的长度\n        JSVM_Value len;\n        OH_JSVM_CreateInt32(env, byteLength, &len);\n        result = len;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM GetDataViewInfo fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM GetDataViewInfo success, byteLength: %{public}d\", byteLength);\n        }\n        break;\n    case ARRAY_BUFFERE:\n        // 判断DataView的Info里的arraybuffer是否为arraybuffer\n        bool isArrayBuffer;\n        OH_JSVM_IsArraybuffer(env, arrayBuffer, &isArrayBuffer);\n        JSVM_Value isArray;\n        OH_JSVM_GetBoolean(env, isArrayBuffer, &isArray);\n        result = isArray;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM GetDataViewInfo fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM GetDataViewInfo success, isArrayBuffer: %{public}d\", isArrayBuffer);\n        }\n        break;\n    case BYTE_OFFSET:\n        // 返回查询DataView的偏移量\n        JSVM_Value offset;\n        OH_JSVM_CreateInt32(env, byteOffset, &offset);\n        result = offset;\n        if (status != JSVM_OK) {\n            OH_LOG_ERROR(LOG_APP, \"JSVM GetDataViewInfo fail\");\n        } else {\n            OH_LOG_INFO(LOG_APP, \"JSVM GetDataViewInfo success, byteOffset: %{public}d\", byteOffset);\n        }\n        break;\n    default:\n        break;\n    }\n    return result;\n}\n// GetDataViewInfo注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = GetDataViewInfo},\n};\nstatic JSVM_CallbackStruct *method = param;\n// GetDataViewInfo方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"getDataViewInfo\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\n// bytelength\ngetDataViewInfo(new DataView(new Int8Array([2,5]).buffer), 0);\n// is arraybuffer\nlet data = 'a';\nlet isarraybuffer = 1;\ngetDataViewInfo(data, isarraybuffer);\n// is arraybuffer\ndata = new DataView(new Int8Array([2,5,3]).buffer);\nisarraybuffer = 1;\ngetDataViewInfo(data, isarraybuffer);\n// byte_offset\ndata = new DataView(new Int8Array([2,5,3]).buffer);\nisarraybuffer = 2;\ngetDataViewInfo(data, isarraybuffer);\n)JS\";
[h2]OH_JSVM_IsArray
判断一个 JavaScript 对象是否为 Array 类型对象。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_IsArray的样例方法\nstatic JSVM_Value IsArray(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    bool result = false;\n    JSVM_Status status = OH_JSVM_IsArray(env, args[0], &result);\n    JSVM_Value returnValue = nullptr;\n    OH_JSVM_GetBoolean(env, result, &returnValue);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM IsArray fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM IsArray success, IsArray: %{public}d\", result);\n    }\n    return returnValue;\n}\n// IsArray注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = IsArray},\n};\nstatic JSVM_CallbackStruct *method = param;\n// IsArray方法别名，TS侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"isArray\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nlet data = [1, 2, 3, 4, 5];\nisArray(data);\n)JS\";
[h2]OH_JSVM_SetElement
在给定对象的指定索引处设置元素。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_SetElement的样例方法\nstatic int DIFF_VALUE_THREE = 3;\nstatic JSVM_Value SetElement(JSVM_Env env, JSVM_CallbackInfo info) {\n    size_t argc = DIFF_VALUE_THREE;\n    JSVM_Value args[3] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    int32_t index = 0;\n    OH_JSVM_GetValueInt32(env, args[1], &index);\n    JSVM_Status status = OH_JSVM_SetElement(env, args[0], index, args[2]);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM SetElement fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM SetElement success\");\n    }\n    return args[0];\n}\n// SetElement注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = SetElement},\n};\nstatic JSVM_CallbackStruct *method = param;\n// SetElement方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"setElement\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nsetElement(3);\n)JS\";
[h2]OH_JSVM_GetElement
获取给定对象指定索引处的元素。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_GetElement的样例方法\nstatic JSVM_Value GetElement(JSVM_Env env, JSVM_CallbackInfo info) {\n    // 获取js侧传入的两个参数\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 获取请求元素的索引值\n    uint32_t index;\n    OH_JSVM_GetValueUint32(env, args[1], &index);\n    // 获取请求索引位置的元素值并存储在result中\n    JSVM_Value result = nullptr;\n    JSVM_Status status = OH_JSVM_GetElement(env, args[0], index, &result);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM GetElement fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM GetElement success\");\n    }\n    return result;\n}\n// GetElement注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = GetElement},\n};\nstatic JSVM_CallbackStruct *method = param;\n// GetElement方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"getElement\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nlet arr = [10, 'hello', null, true];\ngetElement(arr, 3);\n)JS\";
[h2]OH_JSVM_HasElement
若给定对象的指定索引处拥有属性，获取该元素。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_HasElement的样例方法\nstatic JSVM_Value HasElement(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    // 获取js侧传入的两个参数\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 获取要判断的元素的索引\n    uint32_t index;\n    OH_JSVM_GetValueUint32(env, args[1], &index);\n    // 判断指定索引位置的元素是否存在\n    bool hasElement = true;\n    JSVM_Status status = OH_JSVM_HasElement(env, args[0], index, &hasElement);\n    // 将boolean结果转换为JSVM_Value并返回\n    JSVM_Value result = nullptr;\n    OH_JSVM_GetBoolean(env, hasElement, &result);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM hasElement fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM hasElement: %{public}d\", hasElement);\n    }\n    return result;\n}\n// HasElement注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = HasElement},\n};\nstatic JSVM_CallbackStruct *method = param;\n// HasElement方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"hasElement\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nlet arr = [10, 'hello', null, true];\nhasElement(arr, 0);\nhasElement(arr, 4);\n)JS\";
[h2]OH_JSVM_DeleteElement
尝试删除给定对象的指定索引处的元素。
cpp部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_DeleteElement的样例方法\nstatic JSVM_Value DeleteElement(JSVM_Env env, JSVM_CallbackInfo info) {\n    // 获取js侧传入的两个参数\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 获取要删除的元素的索引\n    uint32_t index;\n    OH_JSVM_GetValueUint32(env, args[1], &index);\n    // 尝试删除请求索引位置的元素\n    bool deleted = true;\n    JSVM_Status status = OH_JSVM_DeleteElement(env, args[0], index, &deleted);\n    // 将boolean结果转换为JSVM_Value并返回\n    JSVM_Value result = nullptr;\n    OH_JSVM_GetBoolean(env, deleted, &result);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM DeleteElement fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM DeleteElement: %{public}d\", deleted);\n    }\n    return result;\n}\n// DeleteElement注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = DeleteElement},\n};\nstatic JSVM_CallbackStruct *method = param;\n// DeleteElement方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"deleteElement\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nlet arr = [10, 'hello', null, true];\ndeleteElement(arr, 0);\n)JS\";
[h2]OH_JSVM_IsDataview
判断一个 JavaScript 对象是否为 Dataview类型对象。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_IsDataview的样例方法\nstatic JSVM_Value IsDataView(JSVM_Env env, JSVM_CallbackInfo info) {\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 调用OH_JSVM_IsDataview接口判断给定入参是否为DataView数据。\n    bool result = false;\n    JSVM_Status status = OH_JSVM_IsDataview(env, args[0], &result);\n    JSVM_Value isDateView = nullptr;\n    OH_JSVM_GetBoolean(env, result, &isDateView);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM IsDataView fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM IsDataView: %{public}d\", result);\n    }\n    return isDateView;\n}\n// IsDataView注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = IsDataView},\n};\nstatic JSVM_CallbackStruct *method = param;\n// IsDataView方法别名，TS侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"isDataView\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nlet buffer = new ArrayBuffer(16);\nlet dataView = new DataView(buffer);\nisDataView(dataView);\n)JS\";
[h2]OH_JSVM_IsTypedarray
判断一个 JavaScript 对象是否为 Typedarray 类型对象。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_IsTypedarray的样例方法\nstatic JSVM_Value IsTypedarray(JSVM_Env env, JSVM_CallbackInfo info) {\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    bool result = false;\n    JSVM_Status status = OH_JSVM_IsTypedarray(env, args[0], &result);\n    JSVM_Value isTypedArray = nullptr;\n    OH_JSVM_GetBoolean(env, result, &isTypedArray);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM IsTypedarray fail\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM IsTypedarray: %{public}d\", result);\n    }\n    return isTypedArray;\n}\n// IsTypedarray注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = IsTypedarray},\n};\nstatic JSVM_CallbackStruct *method = param;\n// IsTypedarray方法别名，TS侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"isTypedarray\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nisTypedarray(new Uint16Array([1, 2, 3, 4]));\n)JS\";

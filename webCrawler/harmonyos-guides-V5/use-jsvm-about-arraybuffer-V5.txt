使用JSVM-API接口进行ArrayBuffer相关开发
简介
ArrayBuffer 是 JavaScript 中的一种数据类型，用于表示通用的、固定长度的原始二进制数据缓冲区。它提供了一种在 JavaScript 中有效地表示和操作原始二进制数据的方式。
基本概念
ArrayBuffer：ArrayBuffer 对象用来表示一个通用的、固定长度的原始二进制数据缓冲区。不能直接操作 ArrayBuffer 的内容，而是需要通过包装成 TypedArray 对象或 DataView 对象来读写。ArrayBuffer 常用于处理大量的二进制数据，如文件、网络数据包等。生命周期和内存管理：在使用 JSVM 处理 ArrayBuffer 时，需要特别注意生命周期和内存管理。
接口说明
使用示例
JSVM-API 接口开发流程参考使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应 C++ 相关代码进行展示。
[h2]OH_JSVM_GetArraybufferInfo
检索 ArrayBuffer 的底层数据缓冲区及其长度。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_GetArraybufferInfo的样例方法\nstatic JSVM_Value GetArraybufferInfo(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    // 解析传递的参数\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 检查参数是否为ArrayBuffer\n    bool isArrayBuffer = false;\n    OH_JSVM_IsArraybuffer(env, args[0], &isArrayBuffer);\n    if (!isArrayBuffer) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM GetArraybufferInfo isArrayBuffer:false\");\n    }\n    void *data;\n    size_t byteLength;\n    // 获取ArrayBuffer的底层数据缓冲区和长度\n    JSVM_Status status = OH_JSVM_GetArraybufferInfo(env, args[0], &data, &byteLength);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM GetArraybufferInfo: failed\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM GetArraybufferInfo: success\");\n    }\n    return args[0];\n}\n// GetArraybufferInfo注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = GetArraybufferInfo},\n};\nstatic JSVM_CallbackStruct *method = param;\n// GetArraybufferInfo方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"getArraybufferInfo\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\ngetArraybufferInfo(new ArrayBuffer(10));\n)JS\";
[h2]OH_JSVM_IsArraybuffer
判断一个 JavaScript 对象是否为 Arraybuffer 类型对象。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_IsArraybuffer的样例方法\nstatic JSVM_Value IsArrayBuffer(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    // 调用OH_JSVM_IsArraybuffer接口判断给定入参是否为ArrayBuffer数据\n    bool isArrayBuffer = false;\n    JSVM_Status status = OH_JSVM_IsArraybuffer(env, args[0], &isArrayBuffer);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM IsArrayBuffer: failed\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM IsArrayBuffer: success\");\n        OH_LOG_INFO(LOG_APP, \"JSVM IsArrayBuffer: %{public}d\", isArrayBuffer);\n    }\n    JSVM_Value boolean = nullptr;\n    OH_JSVM_GetBoolean(env, isArrayBuffer, &boolean);\n    return boolean;\n}\n// IsArrayBuffer注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = IsArrayBuffer},\n};\nstatic JSVM_CallbackStruct *method = param;\n// IsArrayBuffer方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"isArrayBuffer\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nisArrayBuffer(new ArrayBuffer(8));\n)JS\";
[h2]OH_JSVM_DetachArraybuffer
调用 ArrayBuffer 对象的 Detach 操作。
[h2]OH_JSVM_IsDetachedArraybuffer
检查给定的 ArrayBuffer 是否已被分离。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_DetachArraybuffer、OH_JSVM_IsDetachedArraybuffer的样例方法\nstatic JSVM_Value DetachArraybuffer(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    JSVM_Value arraybuffer = args[0];\n    JSVM_Status status = OH_JSVM_DetachArraybuffer(env, arraybuffer);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM DetachArraybuffer: failed\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM DetachArraybuffer: success\");\n    }\n    return arraybuffer;\n}\nstatic JSVM_Value IsDetachedArraybuffer(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value args[1] = {nullptr};\n    OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr);\n    JSVM_Value arraybuffer = args[0];\n    OH_JSVM_DetachArraybuffer(env, arraybuffer);\n    bool result = false;\n    JSVM_Status status = OH_JSVM_IsDetachedArraybuffer(env, arraybuffer, &result);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM IsDetachedArraybuffer: failed\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM IsDetachedArraybuffer: success\");\n        OH_LOG_INFO(LOG_APP, \"JSVM IsArrayBuffer: %{public}d\", result);\n    }\n    JSVM_Value isDetached = nullptr;\n    OH_JSVM_GetBoolean(env, result, &isDetached);\n    return isDetached;\n}\n// DetachArraybuffer、IsDetachedArraybuffer注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = DetachArraybuffer},\n    {.data = nullptr, .callback = IsDetachedArraybuffer},\n};\nstatic JSVM_CallbackStruct *method = param;\n// DetachArraybuffer、IsDetachedArraybuffer方法别名，TS侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"detachArraybuffer\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n    {\"isDetachedArraybuffer\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\nlet arrayBuffer = new ArrayBuffer(10);\ndetachArraybuffer(arrayBuffer);\nisDetachedArraybuffer(arrayBuffer);\n)JS\";
[h2]OH_JSVM_CreateArraybuffer
创建一个指定大小的 ArrayBuffer 对象。
cpp 部分代码
// hello.cpp\n#include \"napi/native_api.h\"\n#include \"ark_runtime/jsvm.h\"\n#include <hilog/log.h>\n// OH_JSVM_CreateArraybuffer的样例方法\nstatic JSVM_Value CreateArraybuffer(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    size_t argc = 1;\n    JSVM_Value argv[1] = {nullptr};\n    JSVM_Value result = nullptr;\n    // 解析传递的参数\n    OH_JSVM_GetCbInfo(env, info, &argc, argv, nullptr, nullptr);\n    int32_t value;\n    size_t length;\n    OH_JSVM_GetValueInt32(env, argv[0], &value);\n    length = size_t(value);\n    void *data;\n    // 创建一个新的ArrayBuffer\n    JSVM_Status status = OH_JSVM_CreateArraybuffer(env, length, &data, &result);\n    if (status != JSVM_OK) {\n        OH_LOG_ERROR(LOG_APP, \"JSVM CreateArraybuffer: failed\");\n    } else {\n        OH_LOG_INFO(LOG_APP, \"JSVM CreateArraybuffer: success\");\n        OH_LOG_INFO(LOG_APP, \"JSVM ArrayBuffer length: %{public}d\", length);\n    }\n    // 返回创建好的ArrayBuffer\n    return result;\n}\n// CreateArraybuffer注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = CreateArraybuffer},\n};\nstatic JSVM_CallbackStruct *method = param;\n// CreateArraybuffer方法别名，供TS侧调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"createArraybuffer\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};\n// 样例测试js\nconst char *srcCallNative = R\"JS(\ncreateArraybuffer(8);\n)JS\";

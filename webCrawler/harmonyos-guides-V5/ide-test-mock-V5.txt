Mock能力
在测试场景中，调用部分接口无法获取到有效的返回值，这样开发者在测试时无法覆盖查询不同返回值的场景，此时，可以使用mock功能。当前Instrument Test和Local Test均支持mock能力，有两种实现方式，一是使用hamock或者hypium插件包的mock接口，二是使用import mock。
仅API 11及以上版本的Stage工程支持。
使用hamock/hypium插件包的mock接口
以下例子通过mock接口模拟类的某个方法，关于mock的更多说明可以参考mock能力。
在src/main/ets目录下新建一个ArkTS文件，例如ClassForMock.ets，并在其中导出一个类。export class ClassForMock {\n  constructor() {\n  }\n  method_1(arg: string) {\n    return '888888';\n  }\n  method_2(arg: string) {\n    return '999999';\n  }\n} 在测试文件中编写如下代码。import { describe, expect, it, MockKit, when } from '@ohos/hypium';\nimport { ClassForMock } from '../../../main/ets/ClassForMock';\n\nexport default function afterReturnTest() {\n  describe('afterReturnTest', () => {\n    it('afterReturnTest', 0, () => {\n      console.info(\"it begin\");\n      // 1.创建一个mock能力的对象MockKit\n      let mocker: MockKit = new MockKit();\n      // 2.定义类ClassForMock，里面两个函数，然后创建一个对象classForMock\n      let classForMock: ClassForMock = new ClassForMock();\n      // 3.进行mock操作,比如需要对ClassForMock类的method_1函数进行mock\n      let mockFunc: Function = mocker.mockFunc(classForMock, classForMock.method_1);\n      // 4.期望classForMock.method_1函数被mock后, 以'test'为入参时调用函数返回结果'1'\n      when(mockFunc)('test').afterReturn('1');\n      // 5.对mock后的函数进行断言，看是否符合预期\n      // 执行成功案例，参数为'test'\n      expect(classForMock.method_1('test')).assertEqual('1'); // 执行通过\n    })\n  })\n} 执行测试，用例通过。
使用import mock
在mock-config.json5配置文件中定义目标module和mock文件的映射关系，运行时import目标module都将指向mock实现代码。以系统API bluetoothManager为例，具体实现如下。
在src/mock目录下新建一个ArkTS文件，例如bluetooth_manager.mock.ets，在这个文件内定义目标Module的Mock实现。enum BluetoothState {\n  /** Indicates the local Bluetooth is off */\n  STATE_OFF = 0,\n  /** Indicates the local Bluetooth is turning on */\n  STATE_TURNING_ON = 1,\n  /** Indicates the local Bluetooth is on, and ready for use */\n  STATE_ON = 2,\n  /** Indicates the local Bluetooth is turning off */\n  STATE_TURNING_OFF = 3,\n  /** Indicates the local Bluetooth is turning LE mode on */\n  STATE_BLE_TURNING_ON = 4,\n  /** Indicates the local Bluetooth is in LE only mode */\n  STATE_BLE_ON = 5,\n  /** Indicates the local Bluetooth is turning off LE only mode */\n  STATE_BLE_TURNING_OFF = 6\n}\ninterface BluetoothInfo {\n  state: number\n}\nconst MockBluetoothManager: Record<string, Object> = {\n  'getBluetoothInfo': () => {\n    return { state : BluetoothState.STATE_BLE_TURNING_ON } as BluetoothInfo;\n  },\n};\nexport default MockBluetoothManager; 在Mock配置文件src/mock/mock-config.json5中定义目标Module与Mock实现的映射关系。\"@ohos.enterprise.bluetoothManager\": {  // 待替换的moduleName\n  \"source\": \"src/mock/bluetooth_manager.mock.ets\"  // mock代码的路径，相对于模块根目录\n} 在测试文件中编写如下代码。import { describe, it, expect } from '@ohos/hypium';\nimport { bluetoothManager } from '@kit.MDMKit';\n\nexport default function mock_system_api() {\n  describe('mock_system_api', () => {\n    /* mock系统API */\n    it('mock_system_api', 0, () => {\n      let bluetoothInfo = bluetoothManager.getBluetoothInfo({\n        bundleName: \"com.example.myapplication\"\n      })\n      expect(bluetoothInfo.state).assertEqual(4)\n    });\n  });\n} 执行测试，用例通过。

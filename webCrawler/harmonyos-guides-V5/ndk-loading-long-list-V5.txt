使用懒加载开发长列表界面
针对List、Grid、WaterFlow、Swiper组件，提供NodeAdapter对象替代ArkTS侧的LazyForEach功能，用于按需生成子组件，其中List组件的属性枚举值为NODE_LIST_NODE_ADAPTER，Grid组件的属性枚举值为NODE_GRID_NODE_ADAPTER，WaterFlow组件的属性枚举值为NODE_WATER_FLOW_NODE_ADAPTER，Swiper组件的属性枚举值为NODE_SWIPER_NODE_ADAPTER。
虽然都用于按需生成组件，但不同于ArkTS的LazyForEach，NodeAdapter对象的规格如下：
 设置了NodeAdapter属性的节点，不再支持addChild等直接添加子组件的接口。子组件完全由NodeAdapter管理，使用属性方法设置NodeAdapter时，会判断父组件是否已经存在子节点，如果父组件已经存在子节点，则设置NodeAdapter操作失败，返回错误码。 NodeApdater通过相关事件通知开发者按需生成组件，类似组件事件机制，开发者使用NodeAdapter时要注册事件监听器，在监听器事件中处理逻辑，相关事件通过ArkUI_NodeAdapterEventType定义。另外NodeAdapter不会主动释放不在屏幕内显示的组件对象，开发者需要在NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER事件中进行组件对象的释放，或者进行缓存复用。下图展示了典型列表滑动场景下的事件触发机制：  
以下示例代码针对接入ArkTS页面章节代码进行优化，引入懒加载机制实现文本列表：
 接入ArkTS，参考接入ArkTS页面。 懒加载适配器相关功能实现。 // ArkUIListItemAdapter\n// 用于文本列表懒加载功能代码。\n\n#ifndef MYAPPLICATION_ARKUILISTITEMADAPTER_H\n#define MYAPPLICATION_ARKUILISTITEMADAPTER_H\n\n#include <arkui/native_node.h>\n#include <stack>\n#include <string>\n#include <unordered_set>\n\n#include \"ArkUIListItemNode.h\"\n#include \"ArkUITextNode.h\"\n#include \"nativeModule.h\"\n\nnamespace NativeModule {\n\nclass ArkUIListItemAdapter {\npublic:\n    ArkUIListItemAdapter()\n        : module_(NativeModuleInstance::GetInstance()->GetNativeNodeAPI()), handle_(OH_ArkUI_NodeAdapter_Create()) { // 使用NodeAdapter创建函数。\n        // 初始化懒加载数据。\n        for (int32_t i = 0; i < 1000; i++) {\n            data_.emplace_back(std::to_string(i));\n        }\n        // 设置懒加载数据。\n        OH_ArkUI_NodeAdapter_SetTotalNodeCount(handle_, data_.size());\n        // 设置懒加载回调事件。\n        OH_ArkUI_NodeAdapter_RegisterEventReceiver(handle_, this, OnStaticAdapterEvent);\n    }\n\n    ~ArkUIListItemAdapter() {\n        // 释放创建的组件。\n        while (!cachedItems_.empty()) {\n            cachedItems_.pop();\n        }\n        items_.clear();\n        // 释放Adapter相关资源。\n        OH_ArkUI_NodeAdapter_UnregisterEventReceiver(handle_);\n        OH_ArkUI_NodeAdapter_Dispose(handle_);\n    }\n\n    ArkUI_NodeAdapterHandle GetHandle() const { return handle_; }\n\n    void RemoveItem(int32_t index) {\n        // 删除第index个数据。\n        data_.erase(data_.begin() + index);\n        // 如果index会导致可视区域元素发生可见性变化，则会回调NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER事件删除元素，\n        // 根据是否有新增元素回调NODE_ADAPTER_EVENT_ON_GET_NODE_ID和NODE_ADAPTER_EVENT_ON_ADD_NODE_TO_ADAPTER事件。\n        OH_ArkUI_NodeAdapter_RemoveItem(handle_, index, 1);\n        // 更新新的数量。\n        OH_ArkUI_NodeAdapter_SetTotalNodeCount(handle_, data_.size());\n    }\n\n    void InsertItem(int32_t index, const std::string &value) {\n        data_.insert(data_.begin() + index, value);\n        // 如果index会导致可视区域元素发生可见性变化，则会回调NODE_ADAPTER_EVENT_ON_GET_NODE_ID和NODE_ADAPTER_EVENT_ON_ADD_NODE_TO_ADAPTER事件，\n        // 根据是否有删除元素回调NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER事件。\n        OH_ArkUI_NodeAdapter_InsertItem(handle_, index, 1);\n        // 更新新的数量。\n        OH_ArkUI_NodeAdapter_SetTotalNodeCount(handle_, data_.size());\n    }\n\n    void MoveItem(int32_t oldIndex, int32_t newIndex) {\n        auto temp = data_[oldIndex];\n        data_.insert(data_.begin() + newIndex, temp);\n        data_.erase(data_.begin() + oldIndex);\n        // 移到位置如果未发生可视区域内元素的可见性变化，则不回调事件，反之根据新增和删除场景回调对应的事件。\n        OH_ArkUI_NodeAdapter_MoveItem(handle_, oldIndex, newIndex);\n    }\n\n    void ReloadItem(int32_t index, const std::string &value) {\n        data_[index] = value;\n        // 如果index位于可视区域内，先回调NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER删除老元素，\n        // 再回调NODE_ADAPTER_EVENT_ON_GET_NODE_ID和NODE_ADAPTER_EVENT_ON_ADD_NODE_TO_ADAPTER事件。\n        OH_ArkUI_NodeAdapter_ReloadItem(handle_, index, 1);\n    }\n\n    void ReloadAllItem() {\n        std::reverse(data_.begin(), data_.end());\n        // 全部重新加载场景下，会回调NODE_ADAPTER_EVENT_ON_GET_NODE_ID接口获取新的组件ID，\n        // 根据新的组件ID进行对比，ID不发生变化的进行复用，\n        // 针对新增ID的元素，调用NODE_ADAPTER_EVENT_ON_ADD_NODE_TO_ADAPTER事件创建新的组件，\n        // 然后判断老数据中遗留的未使用ID，调用NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER删除老元素。\n        OH_ArkUI_NodeAdapter_ReloadAllItems(handle_);\n    }\n\nprivate:\n    static void OnStaticAdapterEvent(ArkUI_NodeAdapterEvent *event) {\n        // 获取实例对象，回调实例事件。\n        auto itemAdapter = reinterpret_cast<ArkUIListItemAdapter *>(OH_ArkUI_NodeAdapterEvent_GetUserData(event));\n        itemAdapter->OnAdapterEvent(event);\n    }\n\n    void OnAdapterEvent(ArkUI_NodeAdapterEvent *event) {\n        auto type = OH_ArkUI_NodeAdapterEvent_GetType(event);\n        switch (type) {\n        case NODE_ADAPTER_EVENT_ON_GET_NODE_ID:\n            OnNewItemIdCreated(event);\n            break;\n        case NODE_ADAPTER_EVENT_ON_ADD_NODE_TO_ADAPTER:\n            OnNewItemAttached(event);\n            break;\n        case NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER:\n            OnItemDetached(event);\n            break;\n        default:\n            break;\n        }\n    }\n\n    // 分配ID给需要显示的Item，用于ReloadAllItems场景的元素diff。\n    void OnNewItemIdCreated(ArkUI_NodeAdapterEvent *event) {\n        auto index = OH_ArkUI_NodeAdapterEvent_GetItemIndex(event);\n        static std::hash<std::string> hashId = std::hash<std::string>();\n        auto id = hashId(data_[index]);\n        OH_ArkUI_NodeAdapterEvent_SetNodeId(event, id);\n    }\n\n    // 需要新的Item显示在可见区域。\n    void OnNewItemAttached(ArkUI_NodeAdapterEvent *event) {\n        auto index = OH_ArkUI_NodeAdapterEvent_GetItemIndex(event);\n        ArkUI_NodeHandle handle = nullptr;\n        if (!cachedItems_.empty()) {\n            // 使用并更新回收复用的缓存。\n            auto recycledItem = cachedItems_.top();\n            auto textItem = std::dynamic_pointer_cast<ArkUITextNode>(recycledItem->GetChildren().back());\n            textItem->SetTextContent(data_[index]);\n            handle = recycledItem->GetHandle();\n            // 释放缓存池的引用。\n            cachedItems_.pop();\n        } else {\n            // 创建新的元素。\n            auto listItem = std::make_shared<ArkUIListItemNode>();\n            auto textNode = std::make_shared<ArkUITextNode>();\n            textNode->SetTextContent(data_[index]);\n            textNode->SetFontSize(16);\n            textNode->SetPercentWidth(1);\n            textNode->SetHeight(100);\n            textNode->SetBackgroundColor(0xFFfffacd);\n            textNode->SetTextAlign(ARKUI_TEXT_ALIGNMENT_CENTER);\n            listItem->AddChild(textNode);\n            listItem->RegisterOnClick([index]() { OH_LOG_INFO(LOG_APP, \"on %{public}d list item click\", index); });\n            handle = listItem->GetHandle();\n            // 保持文本列表项的引用。\n            items_.emplace(handle, listItem);\n        }\n        // 设置需要展示的元素。\n        OH_ArkUI_NodeAdapterEvent_SetItem(event, handle);\n    }\n\n    // Item从可见区域移除。\n    void OnItemDetached(ArkUI_NodeAdapterEvent *event) {\n        auto item = OH_ArkUI_NodeAdapterEvent_GetRemovedNode(event);\n        // 放置到缓存池中进行回收复用。\n        cachedItems_.emplace(items_[item]);\n    }\n\n\n    std::vector<std::string> data_;\n    ArkUI_NativeNodeAPI_1 *module_ = nullptr;\n    ArkUI_NodeAdapterHandle handle_ = nullptr;\n\n    // 管理NodeAdapter生成的元素。\n    std::unordered_map<ArkUI_NodeHandle, std::shared_ptr<ArkUIListItemNode>> items_;\n\n    // 管理回收复用组件池。\n    std::stack<std::shared_ptr<ArkUIListItemNode>> cachedItems_;\n};\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUILISTITEMADAPTER_H 针对接入ArkTS页面章节使用的列表封装类对象，添加额外懒加载能力。 // ArkUIListNode.h\n// 列表封装对象。\n\n#ifndef MYAPPLICATION_ARKUILISTNODE_H\n#define MYAPPLICATION_ARKUILISTNODE_H\n\n#include \"ArkUIListItemAdapter.h\"\n#include \"ArkUINode.h\"\n#include <hilog/log.h>\n\nnamespace NativeModule {\nclass ArkUIListNode : public ArkUINode {\npublic:\n    ArkUIListNode()\n        : ArkUINode((NativeModuleInstance::GetInstance()->GetNativeNodeAPI())->createNode(ARKUI_NODE_LIST)) {}\n\n    ~ArkUIListNode() override {\n        nativeModule_->unregisterNodeEvent(handle_, NODE_LIST_ON_SCROLL_INDEX);\n        if (adapter_) {\n            // 析构的时候卸载adapter下的UI组件。\n            nativeModule_->resetAttribute(handle_, NODE_LIST_NODE_ADAPTER);\n            adapter_.reset();\n        }\n    }\n\n    void SetScrollBarState(bool isShow) {\n        assert(handle_);\n        ArkUI_ScrollBarDisplayMode displayMode =\n            isShow ? ARKUI_SCROLL_BAR_DISPLAY_MODE_ON : ARKUI_SCROLL_BAR_DISPLAY_MODE_OFF;\n        ArkUI_NumberValue value[] = {{.i32 = displayMode}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_SCROLL_BAR_DISPLAY_MODE, &item);\n    }\n\n    void RegisterOnScrollIndex(const std::function<void(int32_t index)> &onScrollIndex) {\n        assert(handle_);\n        onScrollIndex_ = onScrollIndex;\n        nativeModule_->registerNodeEvent(handle_, NODE_LIST_ON_SCROLL_INDEX, 0, nullptr);\n    }\n    // 引入懒加载模块。\n    void SetLazyAdapter(const std::shared_ptr<ArkUIListItemAdapter> &adapter) {\n        assert(handle_);\n        ArkUI_AttributeItem item{nullptr, 0, nullptr, adapter->GetHandle()};\n        nativeModule_->setAttribute(handle_, NODE_LIST_NODE_ADAPTER, &item);\n        adapter_ = adapter;\n    }\n\nprotected:\n    void OnNodeEvent(ArkUI_NodeEvent *event) override {\n        auto eventType = OH_ArkUI_NodeEvent_GetEventType(event);\n        switch (eventType) {\n        case NODE_LIST_ON_SCROLL_INDEX: {\n            auto index = OH_ArkUI_NodeEvent_GetNodeComponentEvent(event)->data[0];\n            if (onScrollIndex_) {\n                onScrollIndex_(index.i32);\n            }\n        }\n        default: {\n        }\n        }\n    }\n\nprivate:\n    std::function<void(int32_t index)> onScrollIndex_;\n\n    std::shared_ptr<ArkUIListItemAdapter> adapter_;\n};\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUILISTNODE_H 创建列表懒加载的示例代码。 // ArkUILazyTextListExample\n// 懒加载列表示例代码。\n\n#ifndef MYAPPLICATION_LAZYTEXTLISTEXAMPLE_H\n#define MYAPPLICATION_LAZYTEXTLISTEXAMPLE_H\n\n#include \"ArkUIBaseNode.h\"\n#include \"ArkUIListNode.h\"\n#include \"UITimer.h\"\n#include <thread>\n#include <uv.h>\n\nnamespace NativeModule {\n\nstd::shared_ptr<ArkUIBaseNode> CreateLazyTextListExample(napi_env env) {\n    // 创建组件并挂载\n    // 1：创建List组件。\n    auto list = std::make_shared<ArkUIListNode>();\n    list->SetPercentWidth(1);\n    list->SetPercentHeight(1);\n    // 2：创建ListItem懒加载组件并挂载到List上。\n    auto adapter = std::make_shared<ArkUIListItemAdapter>();\n    list->SetLazyAdapter(adapter);\n\n    // 3：模拟相关懒加载操作。\n    CreateNativeTimer(env, adapter.get(), 4, [](void *userdata, int32_t count) {\n        auto adapter = reinterpret_cast<ArkUIListItemAdapter *>(userdata);\n        switch (count) {\n        case 0: {\n            // 删除第0个元素。\n            adapter->RemoveItem(0);\n            break;\n        }\n        case 1: {\n            // 插入第0个元素。\n            adapter->InsertItem(0, \"0\");\n            break;\n        }\n        case 2: {\n            // 移到元素位置。\n            adapter->MoveItem(0, 2);\n            break;\n        }\n        case 3: {\n            // 重载元素。\n            adapter->ReloadItem(0, \"1112\");\n            break;\n        }\n        case 4: {\n            // 全量重载。\n            adapter->ReloadAllItem();\n            break;\n        }\n        default: {\n        }\n        }\n    });\n\n    // 3：注册List相关监听事件.\n    list->RegisterOnScrollIndex([](int32_t index) { OH_LOG_INFO(LOG_APP, \"on list scroll index: %{public}d\", index); });\n    // 4: 注册挂载事件。\n    list->RegisterOnAppear([]() { OH_LOG_INFO(LOG_APP, \"on list mount to tree\"); });\n    // 4: 注册卸载事件。\n    list->RegisterOnDisappear([]() { OH_LOG_INFO(LOG_APP, \"on list unmount from tree\"); });\n    return list;\n}\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_LAZYTEXTLISTEXAMPLE_H 定时器模块相关简单实现。 // UITimer.h\n// 定时器模块。\n\n#ifndef MYAPPLICATION_UITIMER_H\n#define MYAPPLICATION_UITIMER_H\n\n#include <hilog/log.h>\n#include <js_native_api.h>\n#include <js_native_api_types.h>\n#include <node_api.h>\n#include <node_api_types.h>\n#include <string>\n#include <thread>\n#include <uv.h>\n\nnamespace NativeModule {\n\nstruct UIData {\n    void *userData = nullptr;\n    int32_t count = 0;\n    int32_t totalCount = 0;\n    void (*func)(void *userData, int32_t count) = nullptr;\n};\n\nnapi_threadsafe_function threadSafeFunction = nullptr;\n\nvoid CreateNativeTimer(napi_env env, void *userData, int32_t totalCount, void (*func)(void *userData, int32_t count)) {\n    napi_value name;\n    std::string str = \"UICallback\";\n    napi_create_string_utf8(env, str.c_str(), str.size(), &name);\n    // UI主线程回调函数。\n    napi_create_threadsafe_function(\n        env, nullptr, nullptr, name, 0, 1, nullptr, nullptr, nullptr,\n        [](napi_env env, napi_value value, void *context, void *data) {\n            auto userdata = reinterpret_cast<UIData *>(data);\n            userdata->func(userdata->userData, userdata->count);\n            delete userdata;\n        },\n        &threadSafeFunction);\n    // 启动定时器，模拟数据变化。\n    std::thread timerThread([data = userData, totalCount, func]() {\n        uv_loop_t *loop = uv_loop_new();\n        uv_timer_t *timer = new uv_timer_t();\n        uv_timer_init(loop, timer);\n        timer->data = new UIData{data, 0, totalCount, func};\n        uv_timer_start(\n            timer,\n            [](uv_timer_t *handle) {\n                OH_LOG_INFO(LOG_APP, \"on timeout\");\n                napi_acquire_threadsafe_function(threadSafeFunction);\n                auto *customData = reinterpret_cast<UIData *>(handle->data);\n                // 创建回调数据。\n                auto *callbackData =\n                    new UIData{customData->userData, customData->count, customData->totalCount, customData->func};\n                napi_call_threadsafe_function(threadSafeFunction, callbackData, napi_tsfn_blocking);\n                customData->count++;\n                if (customData->count > customData->totalCount) {\n                    uv_timer_stop(handle);\n                    delete handle;\n                    delete customData;\n                }\n            },\n            4000, 4000);\n        uv_run(loop, UV_RUN_DEFAULT);\n        uv_loop_delete(loop);\n    });\n    timerThread.detach();\n}\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_UITIMER_H 按照接入ArkTS页面章节将懒加载相关示例代码挂载到ContentSlot上显示。 // NDK接口入口挂载文件。\n\n#include \"NativeEntry.h\"\n\n#include \"ArkUIMixedRefresh.h\"\n#include \"LazyTextListExample.h\"\n#include \"MixedRefreshExample.h\"\n#include \"TextListExample.h\"\n\n#include <arkui/native_node_napi.h>\n#include <arkui/native_type.h>\n#include <js_native_api.h>\n#include <uv.h>\n\nnamespace NativeModule {\nnamespace {\nnapi_env g_env;\n}\n\nnapi_env GetNapiEnv() { return g_env; }\n\nnapi_value CreateNativeRoot(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    // 获取NodeContent\n    ArkUI_NodeContentHandle contentHandle;\n    OH_ArkUI_GetNodeContentFromNapiValue(env, args[0], &contentHandle);\n    NativeEntry::GetInstance()->SetContentHandle(contentHandle);\n\n    // 创建懒加载文本列表\n    auto node = CreateLazyTextListExample(env);\n\n    // 保持Native侧对象到管理类中，维护生命周期。\n    NativeEntry::GetInstance()->SetRootNode(node);\n    g_env = env;\n    return nullptr;\n}\n\nnapi_value DestroyNativeRoot(napi_env env, napi_callback_info info) {\n    // 从管理类中释放Native侧对象。\n    NativeEntry::GetInstance()->DisposeRootNode();\n    return nullptr;\n}\n\n} // namespace NativeModule 

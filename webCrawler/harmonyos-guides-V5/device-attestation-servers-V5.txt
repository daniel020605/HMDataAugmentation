服务器端开发
对密钥证明证书链进行校验
密钥证明证书链采用X509标准格式，证书链（证书数组）中的第一本证书为密钥证明证书，最后一本证书为根CA证书，中间的为子CA证书。
应用服务器对密钥证明证书链的校验处理过程：
使用Universal Keystore Kit官网提供的根CA证书对证书链合法性进行校验。（根CA证书下载地址） 请勿在应用服务器中使用子CA证书对密钥证明证书链进行校验，子CA证书可能会因为有效期结束、证书被吊销等发生变化。  解析密钥证明证书获取应用公钥、挑战值Challenge、应用ID、密钥管理部件ID。其中应用公钥直接从密钥证明证书的subjectPublicKeyInfo字段获取； 其他字段从密钥证明证书的扩展域段（Extensions）中获取，扩展域段的OID为1.3.6.1.4.1.2011.2.376.1.3（密钥证明扩展域段）。 校验挑战值Challenge是否有效。校验应用ID是否与预期的取值一致。根据应用ID判断请求是否来自预期的HarmonyOS应用。校验密钥来源是否与预期的取值一致。
密钥证明证书格式说明：
密钥证明扩展域段为Asn.1 DER标准编码格式，数据结构定义如下：
HuaweiAttestation ::= SEQUENCE {\n version             AttestationVersion DEFAULT v1,\n claim1             AttestationClaim,\n claim2             AttestationClaim,\n claim3             AttestationClaim,\n ... ...\n}\n\nAttestationVersion ::= INTEGER { v1(0) }\n\nAttestationClaim ::= SEQUENCE {\n   securityLevel       SecurityLevel,\n   type             AttestationType,\n   value            AttestationValue\n}\n\nSecurityLevel ::= INTEGER\nAttestationType ::= OBJECT IDENTIFIER\nAttestationValue ::= ANY -- DEFINED BY AttestationType\n\nApplicationIDType ::= SEQUENCE {\n   type                         OBJECT IDENTIFIER,\n   value                        OCT_STR\n}
AttestationClaim类型取值说明：
序号
type（OID）取值
value的数据类型
securityLevel
Claim说明
1
1.3.6.1.4.1.2011.2.376.2.1.4
OCT_STR
保留字段，暂不使用
应用输入的挑战字Challenge
2
1.3.6.1.4.1.2011.2.376.2.1.3
ApplicationIDType
保留字段，暂不使用
应用ID。
3
1.3.6.1.4.1.2011.2.376.2.2.2.6
OCT_STR
保留字段，暂不使用
密钥管理部件ID。取值固定为：0x28c4fb4944afec11b9090242ac120002
ApplicationIDType类型取值说明：
type（OID）取值
value取值说明
1.3.6.1.4.1.2011.2.376.2.1.3.1
HarmonyOS Hap应用ID，包含bundleName和签名证书公钥的hash。
value为json字符串，样例如下：
{
\"appId\":\"com.example.attesthcts_BDmjsOezxRmguzlYRVhQavW22Eswi5sX61wOAysWPOGS8TZ5tY1u1A9EcvarzyrfOEj5zT8BCGkfFkVjn0m5wzo=\",
\"bundleName\":\"com.example.attesthcts\"
}
1.3.6.1.4.1.2011.2.376.2.1.3.2
系统服务（Service Ability）的ID，样例：
{processName: \"huawei_share\"}
样例代码：
import org.bouncycastle.asn1.*;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.FileOutputStream;\nimport java.security.PublicKey;\nimport java.security.Security;\nimport java.security.cert.CertPath;\nimport java.security.cert.CertPathValidator;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.PKIXCertPathValidatorResult;\nimport java.security.cert.PKIXParameters;\nimport java.security.cert.TrustAnchor;\nimport java.security.cert.X509Certificate;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class ParseAttestation {\n    static {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    //HarmonyOS Hap应用通过anonAttestKeyItem接口获取到的 “密钥证明证书链”数据。\n    static String[] g_attestCertStr = new String[]{\"-----BEGIN CERTIFICATE-----\\nMIIDCTCCAq+gAwIBAgIOCfq2SGImV3KTZ4HAOOUwCgYIKoZIzj0EAwIwXTE5MDcGA1UEAwwwSHVhd2VpIENCRyBFQ0MgRGV2aWNlIEFub255bW91cyBBdHRlc3RhdGlvbiBDQSAxMRMwEQYDVQQKDApIdWF3ZWkgQ0JHMQswCQYDVQQGEwJDTjAeFw0yNDA1MTQwODM5MzdaFw0yNDA1MjEwODM5MzdaMCwxKjAoBgNVBAMMIURldmljZSBDZXJ0aWZpY2F0ZSBNYW5hZ2VtZW50IEtleTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABF1cCJeIlyW6XmNK2awRQyCQm3L+qlDNGY8YONqeLKI/cOrNipUlggyRAqkG+L+b59U3zxjl1HiDo+Bw9yN47dOjggGCMIIBfjAMBgNVHRMBAf8EAjAAMB8GA1UdIwQYMBaAFOMsy/92hzsS+0MiPz/7AgaB3yenMB0GA1UdDgQWBBRvhNZr2s9vp/ekndec4jmeawrZkDCCASwGDCsGAQQBj1sCgngBAwSCARowggEWAgEAMIHFAgECBg0rBgEEAY9bAoJ4AgEDMIGwBg4rBgEEAY9bAoJ4AgEDAQSBnXsiYXBwSWQiOiJjb20uZXhhbXBsZS5teXdhbmdlbl9CQUNabzJGNlB4MXM3RHhjL3psT3NWSTNpRUlNSnhNS3NoMlhPaW1ad01TNmJoWWg2ZG1iSC94bU9HaU1SMTdaSG93ZkI5dHBiQVVRVWtzTFJqSm0zMzA9IiwiYnVuZGxlTmFtZSI6ImNvbS5leGFtcGxlLm15d2FuZ2VuIn0wIgIBAAYNKwYBBAGPWwKCeAIBBAQOY2hhbGxlbmdlX2RhdGEwJQIBAwYOKwYBBAGPWwKCeAICAgYEECjE+0lEr+wRuQkCQqwSAAIwCgYIKoZIzj0EAwIDSAAwRQIgdIgfLZN86bDY+KyHbzpedXTFp7LIQYVY1p5Xurdy40oCIQDqDQGxzk5VE1xPZtSm4AzWBzBccfvpc58EiV0N1eZqxg==\\n-----END CERTIFICATE-----\", \"-----BEGIN CERTIFICATE-----\\nMIICyjCCAlCgAwIBAgIREj5jzbLehL8yzkDm5uwcSJUwCgYIKoZIzj0EAwMwSzETMBEGA1UEChMKSHVhd2VpIENCRzE0MDIGA1UEAxMrSHVhd2VpIENCRyBFQ0MgRGV2aWNlIEF0dGVzdGF0aW9uIFJvb3QgQ0EgMTAeFw0yMzEyMDUwMzE4MDRaFw0zMzEyMDUwMzE4MDRaMF0xOTA3BgNVBAMMMEh1YXdlaSBDQkcgRUNDIERldmljZSBBbm9ueW1vdXMgQXR0ZXN0YXRpb24gQ0EgMTETMBEGA1UECgwKSHVhd2VpIENCRzELMAkGA1UEBhMCQ04wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATYjeQrfijuZ/9HJPLlsfJ4/wnXbQXaxy5f5fEcMN+pTZ5RekpY7PnDp2zEdibvkSzjv1MuRs8JzORyGatSOrYFo4IBATCB/jAfBgNVHSMEGDAWgBTaRGLD5yvof1E6XEuPQ3w5JMPOrDAdBgNVHQ4EFgQU4yzL/3aHOxL7QyI/P/sCBoHfJ6cwRgYDVR0gBD8wPTA7BgRVHSAAMDMwMQYIKwYBBQUHAgEWJWh0dHA6Ly9wa2kuY29uc3VtZXIuaHVhd2VpLmNvbS9jYS9jcHMwEgYDVR0TAQH/BAgwBgEB/wIBATAOBgNVHQ8BAf8EBAMCAQYwUAYDVR0fBEkwRzBFoEOgQYY/aHR0cDovL3BraS5jb25zdW1lci5odWF3ZWkuY29tL2NhL2NybC9yb290X2RldmljZUF0dGVzdF9jcmwuY3JsMAoGCCqGSM49BAMDA2gAMGUCMQCE9qqNREq3AvCuznKeBl8biwC5GpV/Z1B0rsU4RqeTqNJ0Gvyz3g8Noaf4SpWzsLUCMBm5nr39UEOq89kx7QQjgYWLEWKcuSsgw2/6MckKP/6zrxjVld2SMtqiphKnrv1EkA==\\n-----END CERTIFICATE-----\", \"-----BEGIN CERTIFICATE-----\\nMIICCTCCAY6gAwIBAgIDVxAsMAoGCCqGSM49BAMDMEsxEzARBgNVBAoTCkh1YXdlaSBDQkcxNDAyBgNVBAMTK0h1YXdlaSBDQkcgRUNDIERldmljZSBBdHRlc3RhdGlvbiBSb290IENBIDEwIBcNMjMxMTMwMDIwNjU1WhgPMjA3MzExMzAwMjA2NTVaMEsxEzARBgNVBAoTCkh1YXdlaSBDQkcxNDAyBgNVBAMTK0h1YXdlaSBDQkcgRUNDIERldmljZSBBdHRlc3RhdGlvbiBSb290IENBIDEwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATDJzRdruaBeMoQBbdqCe51ezvkQn3OPYBoRmpL5KPktdFtD0b97FRp8jGLiUhPKyo8M15fxW5Ams4s80E8I1BSXoovDnkKllFfUadD8URgwEfOk5qttYNKzJcULavOhbijQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTaRGLD5yvof1E6XEuPQ3w5JMPOrDAKBggqhkjOPQQDAwNpADBmAjEA2zDQREvORPqcZyjwKDltu0T9zN8Cd3/hi4DQZvuRJdJOY57yIIO/LKxezzEcGiMMAjEAkX7r0U4Mcaw4uURMh+7tLMyvyxnlW8yJqBEOnZfqS8I8t0bQIY2r/5TQAPC0JhBm\\n-----END CERTIFICATE-----\"};\n\n    //从HarmonyOS官网下载的根CA证书。\n    static String g_rootCertStr = \"-----BEGIN CERTIFICATE-----\\n\" +\n            \"MIICCTCCAY6gAwIBAgIDVxAsMAoGCCqGSM49BAMDMEsxEzARBgNVBAoTCkh1YXdl\\n\" +\n            \"aSBDQkcxNDAyBgNVBAMTK0h1YXdlaSBDQkcgRUNDIERldmljZSBBdHRlc3RhdGlv\\n\" +\n            \"biBSb290IENBIDEwIBcNMjMxMTMwMDIwNjU1WhgPMjA3MzExMzAwMjA2NTVaMEsx\\n\" +\n            \"EzARBgNVBAoTCkh1YXdlaSBDQkcxNDAyBgNVBAMTK0h1YXdlaSBDQkcgRUNDIERl\\n\" +\n            \"dmljZSBBdHRlc3RhdGlvbiBSb290IENBIDEwdjAQBgcqhkjOPQIBBgUrgQQAIgNi\\n\" +\n            \"AATDJzRdruaBeMoQBbdqCe51ezvkQn3OPYBoRmpL5KPktdFtD0b97FRp8jGLiUhP\\n\" +\n            \"Kyo8M15fxW5Ams4s80E8I1BSXoovDnkKllFfUadD8URgwEfOk5qttYNKzJcULavO\\n\" +\n            \"hbijQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQW\\n\" +\n            \"BBTaRGLD5yvof1E6XEuPQ3w5JMPOrDAKBggqhkjOPQQDAwNpADBmAjEA2zDQREvO\\n\" +\n            \"RPqcZyjwKDltu0T9zN8Cd3/hi4DQZvuRJdJOY57yIIO/LKxezzEcGiMMAjEAkX7r\\n\" +\n            \"0U4Mcaw4uURMh+7tLMyvyxnlW8yJqBEOnZfqS8I8t0bQIY2r/5TQAPC0JhBm\\n\" +\n            \"-----END CERTIFICATE-----\\n\";\n\n    //保存HarmonyOS Hap应用生成的证书公钥的文件名\n    static String g_publicKeyFileName = \"d:\\\\attestPublicKey.pem\";\n\n    public static void main(String[] args) {\n        ParseAttestation parseAttestation = new ParseAttestation();\n        parseAttestation.parseAndValidateAttestCertChain(g_attestCertStr, g_rootCertStr, g_publicKeyFileName);\n    }\n\n    void parseAndValidateAttestCertChain(String[] attestCertStr, String rootCertStr, String publicKeyFileName) {\n        try {\n            //解析密钥证明证书链\n            List<X509Certificate> attestCerts = parseAttestationCerts(attestCertStr);\n\n            //校验密钥证明证书链\n            Date curDate = new Date();\n            validateAttestationCertChain(attestCerts, rootCertStr, curDate);\n\n            //解析密钥证明证书\n            AttestationInfo attestInfo = extractAttestaionField(attestCerts.get(0));\n\n            //校验密钥证明信息是否正确\n            if (!checkAttestInfo(attestInfo)) {\n                //todo： 进行异常处理\n            }\n\n            //保存HarmonyOS Hap应用生成的公钥\n            saveAttestPublicKey(attestInfo.publicKey, publicKeyFileName);\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    List<X509Certificate> parseAttestationCerts(String[] certStr) throws Exception {\n        List<X509Certificate> certificateList = new ArrayList<>(certStr.length);\n        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\", \"BC\");\n\n        for (int i = 0; i < certStr.length; i++) {\n            certificateList.add((X509Certificate) certificateFactory.generateCertificate(\n                    new ByteArrayInputStream(certStr[i].getBytes())));\n        }\n        return certificateList;\n    }\n\n    void validateAttestationCertChain(List<X509Certificate> certs, String trustCAStr, Date date) throws Exception {\n        //构造证书链\n        CertificateFactory factory = CertificateFactory.getInstance(\"X.509\", \"BC\");\n        CertPath certPath = factory.generateCertPath(certs);\n\n        //读取信任根证书和构建trustAnchor对象\n        X509Certificate trustCA = (X509Certificate) factory.generateCertificate(\n                new ByteArrayInputStream(trustCAStr.getBytes()));\n\n        TrustAnchor trustAnchor = new TrustAnchor(trustCA, null);\n        HashSet trustAnchorSet = new HashSet<TrustAnchor>();\n        trustAnchorSet.add(trustAnchor);\n\n        //构建validator和对应的参数\n        PKIXParameters params = new PKIXParameters(trustAnchorSet);\n        params.setDate(date);\n        //密钥证明证书有效期比较短，不需要进行证书的吊销验证。\n        params.setRevocationEnabled(false);\n\n        CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\", \"BC\");\n        try {\n            PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) validator.validate(certPath, params);\n            System.out.println(\"Cert Chain validate success!\");\n        } catch (Exception e) {\n            System.out.println(\"Cert Chain validate fail!\" + e.getMessage());\n        }\n\n    }\n\n    int getInteger(ASN1Encodable value) {\n        if (value instanceof ASN1Integer) {\n            return ((ASN1Integer) value).getValue().intValue();\n        } else if (value instanceof ASN1Enumerated) {\n            return ((ASN1Enumerated) value).getValue().intValue();\n        } else {\n            throw new IllegalArgumentException(\n                    \"expected Integer value ; found \" + value.getClass().getName() + \" instead.\");\n        }\n    }\n\n    byte[] getOctetString(ASN1Encodable value) {\n        if (value instanceof ASN1OctetString) {\n            return ((ASN1OctetString) value).getOctets();\n        } else {\n            throw new RuntimeException(\n                    \"expected OctetString value ; found \" + value.getClass().getName() + \" instead.\");\n        }\n    }\n\n    void printBytes(byte[] byteArray) {\n        for (int i = 0; i < byteArray.length; i++) {\n            System.out.printf(\"%02X \", byteArray[i]);\n        }\n        System.out.println();\n    }\n\n    AttestationInfo extractAttestaionField(X509Certificate certificate) {\n        AttestationInfo attestInfo = new AttestationInfo();\n\n        //获取应用公钥\n        attestInfo.publicKey = certificate.getPublicKey();\n\n        //从密钥证明证书中获取 “密钥证明扩展域段”\n        byte[] attestationValue = certificate.getExtensionValue(\"1.3.6.1.4.1.2011.2.376.1.3\");\n        if (attestationValue == null || attestationValue.length == 0) {\n            throw new IllegalArgumentException(\"Cann't found the attestation extension!\");\n        }\n        ASN1Sequence attestSequence = ASN1Sequence.getInstance(\n                ASN1OctetString.getInstance(attestationValue).getOctets());\n\n        //获取Attestation Version\n        attestInfo.version = getInteger(attestSequence.getObjectAt(0));\n\n        for (int i = 1; i < attestSequence.size(); i++) {\n            ASN1Sequence attestClaim = ASN1Sequence.getInstance(attestSequence.getObjectAt(i));\n            //获取Claim的oid\n            ASN1ObjectIdentifier attestClaimOid = (ASN1ObjectIdentifier) attestClaim.getObjectAt(1);\n\n            if (\"1.3.6.1.4.1.2011.2.376.2.1.4\".equalsIgnoreCase(attestClaimOid.getId())) {\n                //读取Challenge\n                attestInfo.challenge = getOctetString(attestClaim.getObjectAt(2));\n            } else if (\"1.3.6.1.4.1.2011.2.376.2.1.3\".equalsIgnoreCase(attestClaimOid.getId())) {\n                //读取appid\n\n                ASN1Sequence appidAsn1 = (ASN1Sequence) attestClaim.getObjectAt(2);\n                //获取appid的oid\n                ASN1ObjectIdentifier appidOid = (ASN1ObjectIdentifier) appidAsn1.getObjectAt(0);\n                if (!\"1.3.6.1.4.1.2011.2.376.2.1.3.1\".equalsIgnoreCase(appidOid.getId())) {\n                    throw new IllegalArgumentException(\"the appid oid is not expected value!\" + appidOid.getId());\n                }\n\n                attestInfo.appid = new String(getOctetString(appidAsn1.getObjectAt(1)));\n            } else if (\"1.3.6.1.4.1.2011.2.376.2.2.2.6\".equalsIgnoreCase(attestClaimOid.getId())) {\n                //读取密钥管理部件id，应该取值为0x28c4fb4944afec11b9090242ac120002\n                attestInfo.keyManagerId = getOctetString(attestClaim.getObjectAt(2));\n            } else {\n                System.out.println(\"unknow oid :\" + attestClaimOid.getId());\n            }\n        }\n\n        return attestInfo;\n    }\n\n    boolean checkAttestInfo(AttestationInfo attestInfo) {\n        //todo: 校验Challenge\n        System.out.println(\"challenge is:\");\n        printBytes(attestInfo.challenge);\n\n        //todo: 校验appid中的bundleName字段\n        System.out.println(\"appid is:\\n \" + attestInfo.appid);\n\n        //todo: 校验keyManagerId，固定为：0x28c4fb4944afec11b9090242ac120002\n        System.out.println(\"key manager id is:\");\n        printBytes(attestInfo.keyManagerId);\n\n        return true;\n    }\n\n    void saveAttestPublicKey(PublicKey publicKey, String publicKeyFileName) throws Exception {\n        //todo: 把attestInfo.publicKey.getEncoded()保存到数据库\n        FileOutputStream file = new FileOutputStream(publicKeyFileName);\n        file.write(publicKey.getEncoded());\n        file.close();\n\n        System.out.println(\"the app public key: \\n\" + publicKey);\n    }\n\n    class AttestationInfo {\n        public PublicKey publicKey;\n        public int version;\n        public byte[] challenge;\n        public String appid;\n        public byte[] keyManagerId;\n    }\n}
保存应用公钥到数据库
应用服务器对密钥证明证书链校验通过后，把密钥证明证书中的应用公钥保存到服务器的数据库中（“对密钥证明证书链进行校验”的样例代码中已包含公钥保存的示例代码），以便对后续的业务请求进行验证。在保存应用公钥前应确保公钥的唯一性，系统中不应该存在多个相同的公钥。
安全建议：对于有用户登录的应用场景，为了提高安全性，建议为终端设备中登录的每个用户生成不同的密钥对，并在应用服务器绑定用户与应用公钥之间的关系。
实现提示： 对业务请求进行验签时需要先查找到应用公钥，建议对应用公钥计算密钥ID（如：对应用公钥计算Hash）并存储密钥ID与应用公钥的关系，通过密钥ID来查找应用公钥。
使用应用公钥对业务请求进行验签
应用服务器首先校验挑战值Challenge，然后根据应用公钥的密钥ID到数据库查找应用公钥。
安全建议：对于有用户登录且应用公钥绑定用户ID的应用场景，应该根据应用公钥的密钥ID+当前登录的用户ID查找应用公钥。
应用服务器再使用应用公钥对请求中的签名进行验签。
样例代码：
import org.bouncycastle.jce.provider.BouncyCastleProvider;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PublicKey;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class VerifySignature {\n    static {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    //保存HarmonyOS Hap应用生成的证书公钥的文件名\n    static String g_publicKeyFileName = \"d:\\\\attestPublicKey.pem\";\n    //HarmonyOS Hap应用使用私钥生成的签名数据，base64编码\n    static String g_signedData = \"MEUCIQDtlrQa7HQccprCkR0nWTL7N6HEKY9PKN3DTk3aeN0/fQIgeqTrQ+7exiJhwTY3LwT7XhRHV1emOfTYho5qxyektho=\";\n    //待签名的数据\n    static String g_plaintext = \"123456\";\n    //签名算法，与应用端采用的算法保持一致，取值样例：SM3WITHSM2，SHA256withECDSA\n    static String g_signAlg = \"SHA256withECDSA\";\n\n    public static void main(String[] args) {\n        VerifySignature verifySignature = new VerifySignature();\n        verifySignature.verifySignature(g_publicKeyFileName, g_plaintext, g_signedData, g_signAlg);\n    }\n\n    void verifySignature(String publicKeyFile, String plainText, String signedData, String signAlg) {\n        try {\n            PublicKey publicKey = readAttestPublicKey(publicKeyFile);\n            byte[] signedDataByte = Base64.getDecoder().decode(signedData);\n            System.out.println(\"signedDataByte len=\" + signedDataByte.length);\n            printBytes(signedDataByte);\n            byte[] plainTextBytes = plainText.getBytes();\n            System.out.println(\"plainTextBytes len=\" + plainTextBytes.length);\n            printBytes(plainTextBytes);\n            boolean result = doVerify(publicKey, plainTextBytes, signedDataByte, signAlg);\n            System.out.println(\"Verify signature result: \" + result);\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    PublicKey readAttestPublicKey(String publicKeyFileName) throws Exception {\n        //todo: 从数据库中读取证明公钥\n        KeyFactory keyFactory = KeyFactory.getInstance(\"EC\", \"BC\");\n        X509EncodedKeySpec spec = new X509EncodedKeySpec(readFromFile(publicKeyFileName));\n        PublicKey publicKey = keyFactory.generatePublic(spec);\n        System.out.println(\"the app public key: \\n\" + publicKey);\n        return publicKey;\n    }\n\n    byte[] readFromFile(String fn) throws Exception {\n        FileInputStream inputStream = new FileInputStream(fn);\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] bytes = new byte[1024];\n        int len;\n        do {\n            len = inputStream.read(bytes);\n            outputStream.write(bytes, 0, len);\n        } while (bytes.length == len);\n        inputStream.close();\n        return outputStream.toByteArray();\n    }\n\n    boolean doVerify(PublicKey publickey, byte[] unsignedData, byte[] signedData, String signAlg) {\n        boolean verifyResult = false;\n        try {\n            Signature signature = Signature.getInstance(signAlg, \"BC\");\n            signature.initVerify(publickey);\n            signature.update(unsignedData);\n            verifyResult = signature.verify(signedData);\n            return verifyResult;\n        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeyException | SignatureException e) {\n            e.printStackTrace();\n        }\n        return verifyResult;\n    }\n\n    void printBytes(byte[] byteArray) {\n        for (int i = 0; i < byteArray.length; i++) {\n            System.out.printf(\"%02X \", byteArray[i]);\n        }\n        System.out.println();\n    }\n}

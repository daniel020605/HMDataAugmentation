WebSocket连接(C/C++)
场景介绍
通过WebSocket模块可以建立服务器与客户端的双向连接。
接口说明
WebSocket常用接口如下表所示，详细的接口说明请参考net_websocket.h。
WebSocket接口开发示例
[h2]开发步骤
使用本文档涉及接口创建并连接到WebSocket服务器时，需先创建Native C++工程，在源文件中将相关接口封装，再在ArkTS层对封装的接口进行调用，使用hilog或者console.log等手段选择打印在控制台或者生成设备日志。
本文以实现建立与WebSocket服务器的连接、发送消息给WebSocket服务器、关闭WebSocket连接为例，给出具体的开发指导。
[h2]添加开发依赖
添加动态链接库
CMakeLists.txt中添加以下lib:
libace_napi.z.so\nlibnet_websocket.so
头文件
#include \"napi/native_api.h\"\n#include \"network/netstack/net_websocket.h\"\n#include \"network/netstack/net_websocket_type.h\"
[h2]构建工程
1、在源文件中编写调用该API的代码，接受ArkTS传递过来的url字符串参数，创建WebSocket对象指针后，检查连接到服务器是否成功。
#include \"napi/native_api.h\"\n#include \"network/netstack/net_websocket.h\"\n#include \"network/netstack/net_websocket_type.h\"\n#include \"hilog/log.h\"\n\n#include <cstring>\n\n#undef LOG_DOMAIN\n#undef LOG_TAG\n#define LOG_DOMAIN 0x3200  // 全局domain宏，标识业务领域\n#define LOG_TAG \"WSDEMO\"   // 全局tag宏，标识模块日志tag\n\n// WebSocket客户端全局变量\nstatic struct WebSocket *client = nullptr;\n\nstatic void onOpen(struct WebSocket *client, WebSocket_OpenResult openResult)\n{\n    (void)client;\n    OH_LOG_INFO(LOG_APP, \"onOpen: code: %{public}u, reason: %{public}s\",\n        openResult.code, openResult.reason);\n}\n\nstatic void onMessage(struct WebSocket *client, char *data, uint32_t length)\n{\n    (void)client;\n    char *tmp = new char[length + 1];\n    for (uint32_t i = 0; i < length; i++) {\n        tmp[i] = data[i];\n    }\n    tmp[length] = '\\0';\n    OH_LOG_INFO(LOG_APP, \"onMessage: len: %{public}u, data: %{public}s\",\n        length, tmp);\n}\n\nstatic void onError(struct WebSocket *client, WebSocket_ErrorResult errorResult)\n{\n    (void)client;\n    OH_LOG_INFO(LOG_APP, \"onError: code: %{public}u, message: %{public}s\",\n        errorResult.errorCode, errorResult.errorMessage);\n}\n\nstatic void onClose(struct WebSocket *client, WebSocket_CloseResult closeResult)\n{\n    (void)client;\n    OH_LOG_INFO(LOG_APP, \"onClose: code: %{public}u, reason: %{public}s\",\n        closeResult.code, closeResult.reason);\n}\n\nstatic napi_value ConnectWebsocket(napi_env env, napi_callback_info info)\n{\n    size_t argc = 2;\n    napi_value args[2] = {nullptr};\n    napi_value result;\n    \n    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);\n    \n    size_t length = 0;\n    napi_status status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &length);\n    if (status != napi_ok) {\n        napi_get_boolean(env, false, &result);\n        return result;\n    }\n    \n    if (client != nullptr) {\n        OH_LOG_INFO(LOG_APP, \"there is already one websocket client running.\");\n        napi_get_boolean(env, false, &result);\n        return result;\n    }\n    char *buf = new char[length + 1];\n    std::memset(buf, 0, length + 1);\n    napi_get_value_string_utf8(env, args[0], buf, length + 1, &length);\n    // 创建WebSocket Client对象指针\n    client = OH_WebSocketClient_Constructor(onOpen, onMessage, onError, onClose);\n    if (client == nullptr) {\n        delete[] buf;\n        napi_get_boolean(env, false, &result);\n        return result;\n    }\n    // 连接buf存放的URL对应的WebSocket服务器\n    int connectRet = OH_WebSocketClient_Connect(client, buf, {});\n    \n    delete[] buf;\n    napi_get_boolean(env, connectRet == 0, &result);\n    return result;\n}\n\nstatic napi_value SendMessage(napi_env env, napi_callback_info info)\n{\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n    napi_value result;\n    \n    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);\n    \n    size_t length = 0;\n    napi_status status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &length);\n    if (status != napi_ok) {\n        napi_create_int32(env, -1, &result);\n        return result;\n    }\n    \n    if (client == nullptr) {\n        OH_LOG_INFO(LOG_APP, \"websocket client not connected.\");\n        napi_create_int32(env, WebSocket_ErrCode::WEBSOCKET_CLIENT_NULL, &result);\n        return result;\n    }\n    char *buf = new char[length + 1];\n    std::memset(buf, 0, length + 1);\n    napi_get_value_string_utf8(env, args[0], buf, length + 1, &length);\n    // 发送buf中的消息给服务器\n    int ret = OH_WebSocketClient_Send(client, buf, length);\n    \n    delete[] buf;\n    napi_create_int32(env, ret, &result);\n    return result;\n}\n\nstatic napi_value CloseWebsocket(napi_env env, napi_callback_info info)\n{\n    napi_value result;\n    if (client == nullptr) {\n        OH_LOG_INFO(LOG_APP, \"websocket client not connected.\");\n        napi_create_int32(env, -1, &result);\n        return result;\n    }\n    // 关闭WebSocket连接\n    int ret = OH_WebSocketClient_Close(client, {\n        .code = 0,\n        .reason = \"Actively Close\",\n    });\n    // 释放WebSocket资源并置空\n    OH_WebSocketClient_Destroy(client);\n    client = nullptr;\n    napi_create_int32(env, ret, &result);\n    return result;\n}
简要说明：ConnectWebsocket函数接收一个WebSocket URL，并尝试连接，如果能连接成功，则返回true，否则返回false。在创建WebSocket结构体指针代表WebSocket客户端前，需要定义好该客户端在接收连接开启消息时的回调onOpen、接收到普通消息的回调onMessage、接收到错误消息时的回调onError、接收到关闭消息时的回调onClose。在示例代码中，还调用了OH_WebSocketClient_Send、OH_WebSocketClient_Close等函数向服务器发送消息，主动关闭WebSocket连接。
2、将通过napi封装好的napi_value类型对象初始化导出，通过外部函数接口，将函数暴露给JavaScript使用。示例代码中，ConnectWebsocket函数就会作为外部函数Connect暴露出去；SendMessage函数作为外部函数Send暴露出去；CloseWebsocket函数作为外部函数Close暴露出去。
EXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports) {\n    napi_property_descriptor desc[] = {\n        {\"Connect\", nullptr, ConnectWebsocket, nullptr, nullptr, nullptr, napi_default, nullptr },\n        {\"Send\", nullptr, SendMessage, nullptr, nullptr, nullptr, napi_default, nullptr },\n        {\"Close\", nullptr, CloseWebsocket, nullptr, nullptr, nullptr, napi_default, nullptr},\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END
3、将上一步中初始化成功的对象通过RegisterEntryModule函数，使用napi_module_register函数将模块注册到 Node.js 中。
static napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void*)0),\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void)\n{\n    napi_module_register(&demoModule);\n}
4、在工程的index.d.ts文件中定义函数的类型。比如，Connect函数接受一个string参数作为入参，并返回boolean值指示WebSocket连接是否能成功建立。
export const Connect: (url: string) => boolean;\nexport const Send: (data: string) => number;\nexport const Close: () => number;
5、在index.ets文件中对上述封装好的接口进行调用。
import testWebsocket from 'libentry.so'\n\n@Entry\n@Component\nstruct Index {\n  @State wsUrl: string = ''\n  @State content: string = ''\n  @State connecting: boolean = false\n\n  build() {\n    Navigation() {\n      Column() {\n        Column() {\n          Text(\"WebSocket address: \")\n            .fontColor(Color.Gray)\n            .textAlign(TextAlign.Start)\n            .width('100%')\n          TextInput()\n            .width('100%')\n            .onChange((value) => {\n              this.wsUrl = value\n            })\n        }\n        .margin({\n          bottom: 16\n        })\n        .padding({\n          left: 16,\n          right: 16\n        })\n\n        Column() {\n          Text(\"Content: \")\n            .fontColor(Color.Gray)\n            .textAlign(TextAlign.Start)\n            .width('100%')\n          TextInput()\n            .width('100%')\n            .enabled(this.connecting)\n            .onChange((value) => {\n              this.content = value\n            })\n        }\n        .margin({\n          bottom: 16\n        })\n        .padding({\n          left: 16,\n          right: 16\n        })\n\n        Blank()\n\n        Column({ space: 12 }) {\n          Button('Connect')\n            .enabled(!this.connecting)\n            .onClick(() => {\n              let connRet = testWebsocket.Connect(this.wsUrl)\n              if (connRet) {\n                this.connecting = true;\n              }\n            })\n          Button('Send')\n            .enabled(this.connecting)\n            .onClick(() => {\n              testWebsocket.Send(this.content)\n            })\n          Button('Close')\n            .enabled(this.connecting)\n            .onClick(() => {\n              let closeResult = testWebsocket.Close()\n              if (closeResult != -1) {\n                this.connecting = false\n              }\n            })\n        }\n      }\n    }\n  }\n}
6、配置CMakeLists.txt，本模块需要用到的共享库是libnet_websocket.so，在工程自动生成的CMakeLists.txt中的target_link_libraries中添加此共享库。
注意：如图所示，在add_library中的entry是工程自动生成的modename，若要做修改，需和步骤3中.nm_modname保持一致；
7、调用WebSocket C API接口要求应用拥有ohos.permission.INTERNET权限，在module.json5中的requestPermissions项添加该权限。
经过以上步骤，整个工程的搭建已经完成，接下来就可以连接设备运行工程进行日志查看了。
测试步骤
1、连接设备，使用DevEco Studio打开搭建好的工程。
2、运行工程，设备上会弹出以下图片所示界面：
简要说明：
 在第一行的输入框中，输入ws://或wss://开头的WebSocket URL。 在输入完WebSocket URL，点击Connect按钮后，如果访问成功，会触发onOpen的回调，打印日志。 在Content输入框里输入要发送给服务器的内容，点击Send按钮发送。如果服务器返回消息，会触发onMessage回调，打印日志。 点击Close按钮，WebSocket连接释放，可以重新输入新的WebSocket URL。 

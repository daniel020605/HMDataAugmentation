订阅踩内存事件（ArkTS）
接口说明
API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。
开发步骤
以实现对写数组越界场景生成的踩内存事件订阅为例，说明开发步骤。
 新建Native C++工程，目录结构如下： entry:\n  src:\n    main:\n      cpp:\n        - types:\n            libentry:\n              - index.d.ts\n        - CMakeLists.txt\n        - napi_init.cpp\n      ets:\n        - entryability:\n            - EntryAbility.ets\n        - pages:\n            - Index.ets 编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，导入依赖模块： import { hiAppEvent, hilog } from '@kit.PerformanceAnalysisKit'; 编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ets”文件，在onCreate函数中添加系统事件的订阅，示例代码如下： hiAppEvent.addWatcher({\n  // 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者\n  name: \"watcher\",\n  // 开发者可以订阅感兴趣的系统事件，此处是订阅了踩内存事件\n  appEventFilters: [\n    {\n      domain: hiAppEvent.domain.OS,\n      names: [hiAppEvent.event.ADDRESS_SANITIZER]\n    }\n  ],\n  // 开发者可以自行实现订阅系统事件回调函数，以便对订阅获取到的事件数据进行自定义处理\n  onReceive: (domain: string, appEventGroups: Array<hiAppEvent.AppEventGroup>) => {\n    hilog.info(0x0000, 'testTag', `HiAppEvent onReceive: domain=${domain}`);\n    for (const eventGroup of appEventGroups) {\n      // 开发者可以根据事件集合中的事件名称区分不同的系统事件\n      hilog.info(0x0000, 'testTag', `HiAppEvent eventName=${eventGroup.name}`);\n      for (const eventInfo of eventGroup.appEventInfos) {\n        // 开发者可以对事件集合中的事件数据进行自定义处理，此处是将事件数据打印在日志中\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.domain=${eventInfo.domain}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.name=${eventInfo.name}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.eventType=${eventInfo.eventType}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.time=${eventInfo.params['time']}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.bundle_version=${eventInfo.params['bundle_version']}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.bundle_name=${eventInfo.params['bundle_name']}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.pid=${eventInfo.params['pid']}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.uid=${eventInfo.params['uid']}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.type=${eventInfo.params['type']}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.external_log=${JSON.stringify(eventInfo.params['external_log'])}`);\n        hilog.info(0x0000, 'testTag', `HiAppEvent eventInfo.log_over_limit=${eventInfo.params['log_over_limit']}`);\n      }\n    }\n  }\n}); 编辑“entry > src > main > cpp > types > libentry > index.d.ts”文件，完整示例代码如下： export const test: () => void; 编辑“entry > src > main > cpp > napi_init.cpp”文件，该文件实现地址越界场景，并提供NAPI接口给应用层代码调用，完整示例代码如下： #include \"napi/native_api.h\"\n\nstatic napi_value Test(napi_env env, napi_callback_info info)\n{\n    int a[10];\n    // 构造数组越界写入\n    a[10] = 1;\n    return {};\n}\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        { \"test\", nullptr, Test, nullptr, nullptr, nullptr, napi_default, nullptr }\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void*)0),\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void)\n{\n    napi_module_register(&demoModule);\n} 编辑工程中的“entry > src > main > ets > pages > Index.ets”文件，新增按钮触发踩内存事件： import testNapi from 'libentry.so'\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Row() {\n      Column() {\n        Button(\"address-sanitizer\").onClick(() => {\n          testNapi.test();\n        })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n} 点击DevEco Studio界面中的“entry”，点击“Edit Configurations”，点击“Diagnostics”，勾选“Address Sanitizer”，保存设置。点击DevEco Studio界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“address-sanitizer”，触发一次踩内存事件。应用崩溃后重新进入应用，可以在Log窗口看到对系统事件数据的处理日志： HiAppEvent onReceive: domain=OS\nHiAppEvent eventName=ADDRESS_SANITIZER\nHiAppEvent eventInfo.domain=OS\nHiAppEvent eventInfo.name=ADDRESS_SANITIZER\nHiAppEvent eventInfo.eventType=1\nHiAppEvent eventInfo.time=1713161197957\nHiAppEvent eventInfo.bundle_version=1.0.0\nHiAppEvent eventInfo.bundle_name=com.example.myapplication\nHiAppEvent eventInfo.pid=12889\nHiAppEvent eventInfo.uid=20020140\nHiAppEvent eventInfo.type=stack-buffer-overflow\nHiAppEvent eventInfo.external_log=[\"/data/storage/el2/log/hiappevent/ADDRESS_SANITIZER_1713161197960_12889.log\"]\nHiAppEvent eventInfo.log_over_limit=false 

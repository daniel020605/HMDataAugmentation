makeObserved接口：将非观察数据变为可观察数据
为了将普通不可观察数据变为可观察数据，开发者可以使用makeObserved接口。
makeObserved可以在@Trace无法标记的情况下使用。在阅读本文档前，建议提前阅读：@Trace。
从API version 12开始，开发者可以使用UIUtils中的makeObserved接口将普通不可观察数据变为可观察数据。
概述
 状态管理框架已提供@ObservedV2/@Trace用于观察类属性变化，makeObserved接口提供主要应用于@ObservedV2/@Trace无法涵盖的场景：  class的定义在三方包中：开发者无法手动对class中需要观察的属性加上@Trace标签，可以使用makeObserved使得当前对象可以被观察。 当前类的成员属性不能被修改：因为@Trace观察类属性会动态修改类的属性，这个行为在@Sendable装饰的class中是不被允许的，此时可以使用makeObserved。 interface或者JSON.parse返回的匿名对象：这类场景往往没有明确的class声明，开发者无法使用@Trace标记当前属性可以被观察，此时可以使用makeObserved。  使用makeObserved接口需要导入UIUtils。 import { UIUtils } from '@kit.ArkUI'; 
限制条件
 makeObserved仅支持非空的对象类型传参。  不支持undefined和null：返回自身，不做任何处理。 非Object类型：编译拦截报错。  import { UIUtils } from '@kit.ArkUI';\nlet res1 = UIUtils.makeObserved(2); // 非法类型入参，错误用法，编译报错\nlet res2 = UIUtils.makeObserved(undefined); // 非法类型入参，错误用法，返回自身，res2 === undefined\nlet res3 = UIUtils.makeObserved(null); // 非法类型入参，错误用法，返回自身，res3 === null\n\nclass Info {\n  id: number = 0;\n}\nlet rawInfo: Info = UIUtils.makeObserved(new Info()); // 正确用法 makeObserved不支持传入被@ObservedV2、@Observed装饰的类的实例以及已经被makeObserved封装过的代理数据。为了防止双重代理，makeObserved发现入参为上述情况时则直接返回，不做处理。 import { UIUtils } from '@kit.ArkUI';\n@ObservedV2\nclass Info {\n  @Trace id: number = 0;\n}\n// 错误用法：makeObserved发现传入的实例是@ObservedV2装饰的类的实例，则返回传入对象自身\nlet observedInfo: Info = UIUtils.makeObserved(new Info());\n\nclass Info2 {\n  id: number = 0;\n}\n// 正确用法：传入对象既不是@ObservedV2/@Observed装饰的类的实例，也不是makeObserved封装过的代理数据\n// 返回可观察数据\nlet observedInfo1: Info2 = UIUtils.makeObserved(new Info2());\n// 错误用法：传入对象为makeObserved封装过的代理数据，此次makeObserved不做处理\nlet observedInfo2: Info2 = UIUtils.makeObserved(observedInfo1); makeObserved可以用在@Component装饰的自定义组件中，但不能和状态管理V1的状态变量装饰器配合使用，如果一起使用，则会抛出运行时异常。 // 错误写法，运行时异常\n@State message: Info = UIUtils.makeObserved(new Info(20)); 下面message2的写法不会抛异常，原因是this.message是@State装饰的，其实现等同于@Observed，而UIUtils.makeObserved的入参是@Observed装饰的class，会直接返回自身。因此对于message2来说，他的初始值不是makeObserved的返回值，而是@State装饰的变量。 import { UIUtils } from '@kit.ArkUI';\nclass Person {\n  age: number = 10;\n}\nclass Info {\n  id: number = 0;\n  person: Person = new Person();\n}\n@Entry\n@Component\nstruct Index {\n  @State message: Info = new Info();\n  @State message2: Info = UIUtils.makeObserved(this.message); // 不会抛异常\n  build() {\n    Column() {\n      Text(`${this.message2.person.age}`)\n        .onClick(() => {\n          // UI不会刷新，因为State只能观察到第一层的变化\n          this.message2.person.age++;\n        })\n    }\n  }\n} 
[h2]makeObserved仅对入参生效，不会改变接受返回值的观察能力
 message被@Local装饰，本身具有观察自身赋值的能力。其初始值为makeObserved的返回值，具有深度观察能力。 点击change id可以触发UI刷新。 点击change Info将this.message重新赋值为不可观察数据后，再次点击change id无法触发UI刷新。 再次点击change Info1将this.message重新赋值为可观察数据后，点击change id可以触发UI刷新。 
import { UIUtils } from '@kit.ArkUI';\nclass Info {\n  id: number = 0;\n  constructor(id: number) {\n    this.id = id;\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local message: Info = UIUtils.makeObserved(new Info(20));\n  build() {\n    Column() {\n      Button(`change id`).onClick(() => {\n        this.message.id++;\n      })\n      Button(`change Info ${this.message.id}`).onClick(() => {\n        this.message = new Info(30);\n      })\n      Button(`change Info1 ${this.message.id}`).onClick(() => {\n        this.message = UIUtils.makeObserved(new Info(30));\n      })\n    }\n  }\n}
支持类型和观察变化
[h2]支持类型
 支持未被@Observed或@ObserveV2装饰的类。 支持Array、Map、Set和Date。 支持collections.Array, collections.Set和collections.Map。 JSON.parse返回的Object。 @Sendable装饰的类。 
[h2]观察变化
 makeObserved传入内置类型或collections类型的实例时，可以观测其API带来的变化：     类型 可观测变化的API    Array push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort   collections.Array push、pop、shift、unshift、splice、fill、reverse、sort、shrinkTo、extendTo   Map/collections.Map set、clear、delete   Set/collections.Set add、clear、delete   Date setFullYear、setMonth、setDate、setHours、setMinutes、setSeconds、setMilliseconds、setTime、setUTCFullYear、setUTCMonth、setUTCDate、setUTCHours、setUTCMinutes、setUTCSeconds、setUTCMilliseconds    
使用场景
[h2]makeObserved和@Sendable装饰的class配合使用
@Sendable主要是为了处理应用场景中的并发任务。将makeObserved和@Sendable配合使用是为了满足一般应用开发中，在子线程做大数据处理，在UI线程做ViewModel的显示和观察数据的需求。@Sendable具体内容可参考并发任务文档。
本章节将说明下面的场景：
 makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI刷新。 从子线程中获取一个整体数据，然后对UI线程的可观察数据做整体替换。 从子线程获取的数据重新执行makeObserved，将数据变为可观察数据。 将数据从主线程传递回子线程时，仅传递不可观察的数据。makeObserved的返回值不可直接传给子线程。 
例子如下：
// SendableData.ets\n@Sendable\nexport class SendableData  {\n  name: string = 'Tom';\n  age: number = 20;\n  gender: number = 1;\n  // ....更多其他属性\n  likes: number = 1;\n  follow: boolean = false;\n}
import { taskpool } from '@kit.ArkTS';\nimport { SendableData } from './SendableData';\nimport { UIUtils } from '@kit.ArkUI';\n\n\n@Concurrent\nfunction threadGetData(param: string): SendableData {\n  // 在子线程处理数据\n  let ret = new SendableData();\n  console.info(`Concurrent threadGetData, param ${param}`);\n  ret.name = param + \"-o\";\n  ret.age = Math.floor(Math.random() * 40);\n  ret.likes = Math.floor(Math.random() * 100);\n  return ret;\n}\n\n@Entry\n@ComponentV2\nstruct ObservedSendableTest {\n  // 通过makeObserved给普通对象或是Sendable对象添加可观察能力\n  @Local send: SendableData = UIUtils.makeObserved(new SendableData());\n  build() {\n    Column() {\n      Text(this.send.name)\n      Button(\"change name\").onClick(() => {\n        // ok 可以观察到属性的改变\n        this.send.name += \"0\";\n      })\n\n      Button(\"task\").onClick(() => {\n        // 将待执行的函数放入taskpool内部任务队列等待，等待分发到工作线程执行。\n        taskpool.execute(threadGetData, this.send.name).then(val => {\n          // 和@Local一起使用，可以观察this.send的变化\n          this.send = UIUtils.makeObserved(val as SendableData);\n        })\n      })\n    }\n  }\n}
需要注意：数据的构建和处理可以在子线程中完成，但有观察能力的数据不能传给子线程，只有在主线程里才可以操作可观察的数据。所以上述例子中只是将this.send的属性name传给子线程操作。
[h2]makeObserved和collections.Array/Set/Map配合使用
collections提供ArkTS容器集，可用于并发场景下的高性能数据传递。详情见@arkts.collections文档。
makeObserved可以在ArkUI中导入可观察的colletions容器，但makeObserved不能和状态管理V1的状态变量装饰器如@State和@Prop等配合使用，否则会抛出运行时异常。
collections.Array
collections.Array可以触发UI刷新的API有：
 改变数组长度：push、pop、shift、unshift、splice、shrinkTo、extendTo 改变数组项本身：sort、fill 
其他API不会改变原始数组，所以不会触发UI刷新。
import { collections } from '@kit.ArkTS';\nimport { UIUtils } from '@kit.ArkUI';\n\n@Sendable\nclass Info {\n  id: number = 0;\n  name: string = 'cc';\n\n  constructor(id: number) {\n    this.id = id;\n  }\n}\n\n\n@Entry\n@ComponentV2\nstruct Index {\n  scroller: Scroller = new Scroller();\n  @Local arrCollect: collections.Array<Info> =\n    UIUtils.makeObserved(new collections.Array<Info>(new Info(1), new Info(2)));\n\n  build() {\n    Column() {\n      // ForEach接口仅支持Array<any>，不支持collections.Array<any>。\n      // 但ForEach的实现用到的Array的API，collections.Array都有提供。所以可以使用as类型断言Array。\n      // 需要注意断言并不会改变原本的数据类型。\n      ForEach(this.arrCollect as object as Array<Info>, (item: Info) => {\n        Text(`${item.id}`).onClick(() => {\n          item.id++;\n        })\n      }, (item: Info, index) => item.id.toString() + index.toString())\n      Divider()\n        .color('blue')\n      if (this.arrCollect.length > 0) {\n        Text(`the first one ${this.arrCollect[this.arrCollect.length - this.arrCollect.length].id}`)\n        Text(`the last one ${this.arrCollect[this.arrCollect.length - 1].id}`)\n      }\n      Divider()\n        .color('blue')\n\n      /****************************改变数据长度的api**************************/\n      Scroll(this.scroller) {\n        Column({space: 10}) {\n          // push: 新增新元素\n          Button('push').onClick(() => {\n            this.arrCollect.push(new Info(30));\n          })\n          // pop: 删除最后一个\n          Button('pop').onClick(() => {\n            this.arrCollect.pop();\n          })\n          // shift: 删除第一个\n          Button('shift').onClick(() => {\n            this.arrCollect.shift();\n          })\n          // unshift: 在数组的开头插入新项\n          Button('unshift').onClick(() => {\n            this.arrCollect.unshift(new Info(50));\n          })\n          // splice: 从数组的指定位置删除元素\n          Button('splice').onClick(() => {\n            this.arrCollect.splice(1);\n          })\n\n          // shrinkTo: 将数组长度缩小到给定的长度\n          Button('shrinkTo').onClick(() => {\n            this.arrCollect.shrinkTo(1);\n          })\n          // extendTo: 将数组长度扩展到给定的长度\n          Button('extendTo').onClick(() => {\n            this.arrCollect.extendTo(6, new Info(20));\n          })\n\n          Divider()\n            .color('blue')\n\n          /****************************************改变数组item本身*****************/\n          // sort：从大到小排序\n          Button('sort').onClick(() => {\n            this.arrCollect.sort((a: Info, b: Info) => b.id - a.id);\n          })\n          // fill: 用值填充指定部分\n          Button('fill').onClick(() => {\n            this.arrCollect.fill(new Info(5), 0, 2);\n          })\n\n          /*****************************不会改变数组本身API***************************/\n          // slice：返回新的数组，根据start end对原数组的拷贝，不会改变原数组，所以直接调用slice不会触发UI刷新\n          // 可以构建用例为返回的浅拷贝的数据赋值给this.arrCollect,需要注意这里依然要调用makeObserved，否则this.arr被普通变量赋值后，会丧失观察能力\n          Button('slice').onClick(() => {\n            this.arrCollect = UIUtils.makeObserved(this.arrCollect.slice(0, 1));\n          })\n          // map：原理同上\n          Button('map').onClick(() => {\n            this.arrCollect = UIUtils.makeObserved(this.arrCollect.map((value) => {\n              value.id += 10;\n              return value;\n            }))\n          })\n          // filter：原理同上\n          Button('filter').onClick(() => {\n            this.arrCollect = UIUtils.makeObserved(this.arrCollect.filter((value: Info) => value.id % 2 === 0));\n          })\n\n          // concat：原理同上\n          Button('concat').onClick(() => {\n            let array1 = new collections.Array(new Info(100))\n            this.arrCollect = UIUtils.makeObserved(this.arrCollect.concat(array1));\n          })\n        }.height('200%')\n      }.height('60%')\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
collections.Map
collections.Map可以触发UI刷新的API有：set、clear、delete。
import { collections } from '@kit.ArkTS';\nimport { UIUtils } from '@kit.ArkUI';\n\n@Sendable\nclass Info {\n  id: number = 0;\n\n  constructor(id: number) {\n    this.id = id;\n  }\n}\n\n\n@Entry\n@ComponentV2\nstruct CollectionMap {\n  mapCollect: collections.Map<string, Info> = UIUtils.makeObserved(new collections.Map<string, Info>([['a', new Info(10)], ['b', new Info(20)]]));\n\n  build() {\n    Column() {\n      // this.mapCollect.keys()返回迭代器。Foreach不支持迭代器，所以要Array.From浅拷贝生成数据。\n      ForEach(Array.from(this.mapCollect.keys()), (item: string) => {\n        Text(`${this.mapCollect.get(item)?.id}`).onClick(() => {\n          let value: Info|undefined = this.mapCollect.get(item);\n          if (value) {\n            value.id++;\n          }\n        })\n      }, (item: string, index) => item + index.toString())\n\n      // set c\n      Button('set c').onClick(() => {\n        this.mapCollect.set('c', new Info(30));\n      })\n      // delete c\n      Button('delete c').onClick(() => {\n        if (this.mapCollect.has('c')) {\n          this.mapCollect.delete('c');\n        }\n      })\n      // clear\n      Button('clear').onClick(() => {\n        this.mapCollect.clear();\n      })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
collections.Set
collections.Set可以触发UI刷新的API有：add、clear、delete。
import { collections } from '@kit.ArkTS';\nimport { UIUtils } from '@kit.ArkUI';\n@Sendable\nclass Info {\n  id: number = 0;\n\n  constructor(id: number) {\n    this.id = id;\n  }\n}\n\n\n@Entry\n@ComponentV2\nstruct Index {\n  set: collections.Set<Info> = UIUtils.makeObserved(new collections.Set<Info>([new Info(10), new Info(20)]));\n\n  build() {\n    Column() {\n      // 因为ForEach不支持迭代器，所以需要使用Array.from浅拷贝生成数组。\n      // 但是浅拷贝生成的新的数组没有观察能力，为了ForEach组件在访问item的时候是可观察的数据，所以需要重新调用makeObserved。\n      ForEach((UIUtils.makeObserved(Array.from(this.set.values()))), (item: Info) => {\n        Text(`${item.id}`).onClick(() => {\n          item.id++;\n        })\n      }, (item: Info, index) => item.id + index.toString())\n\n      // add\n      Button('add').onClick(() => {\n        this.set.add(new Info(30));\n        console.log('size:' + this.set.size);\n      })\n      // delete\n      Button('delete').onClick(() => {\n        let iterator = this.set.keys();\n        this.set.delete(iterator.next().value);\n      })\n      // clear\n      Button('clear').onClick(() => {\n        this.set.clear();\n      })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
[h2]makeObserved的入参为JSON.parse的返回值
JSON.parse返回Object，无法使用@Trace装饰其属性，可以使用makeObserved使其变为可观察数据。
import { JSON } from '@kit.ArkTS';\nimport { UIUtils } from '@kit.ArkUI';\n\nclass Info {\n  id: number = 0;\n\n  constructor(id: number) {\n    this.id = id;\n  }\n}\n\nlet test: Record<string, number> = { \"a\": 123 };\nlet testJsonStr :string = JSON.stringify(test);\nlet test2: Record<string, Info> = { \"a\": new Info(20) };\nlet test2JsonStr: string = JSON.stringify(test2);\n\n@Entry\n@ComponentV2\nstruct Index {\n  message: Record<string, number> = UIUtils.makeObserved<Record<string, number>>(JSON.parse(testJsonStr) as Record<string, number>);\n  message2: Record<string, Info> = UIUtils.makeObserved<Record<string, Info>>(JSON.parse(test2JsonStr) as Record<string, Info>);\n\n  build() {\n    Column() {\n      Text(`${this.message.a}`)\n        .fontSize(50)\n        .onClick(() => {\n          this.message.a++;\n        })\n      Text(`${this.message2.a.id}`)\n        .fontSize(50)\n        .onClick(() => {\n          this.message2.a.id++;\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
[h2]makeObserved和V2装饰器配合使用
makeObserved可以和V2的装饰器一起使用。对于@Monitor和@Computed，因为makeObserved传入@Observed或ObservedV2装饰的类实例会返回其自身，所以@Monitor或者@Computed不能定义在class中，只能定义在自定义组件里。
例子如下：
import { UIUtils } from '@kit.ArkUI';\n\nclass Info {\n  id: number = 0;\n  age: number = 20;\n\n  constructor(id: number) {\n    this.id = id;\n  }\n}\n\n@Entry\n@ComponentV2\nstruct Index {\n  @Local message: Info = UIUtils.makeObserved(new Info(20));\n\n  @Monitor('message.id')\n  onStrChange(monitor: IMonitor) {\n    console.log(`name change from ${monitor.value()?.before} to ${monitor.value()?.now}`);\n  }\n\n  @Computed\n  get ageId() {\n    console.info(\"---------Computed----------\");\n    return this.message.id + ' ' + this.message.age;\n  }\n\n  build() {\n    Column() {\n      Text(`id: ${this.message.id}`)\n        .fontSize(50)\n        .onClick(() => {\n          this.message.id++;\n        })\n\n      Text(`age: ${this.message.age}`)\n        .fontSize(50)\n        .onClick(() => {\n          this.message.age++;\n        })\n\n      Text(`Computed age+id: ${this.ageId}`)\n        .fontSize(50)\n\n      Button('change Info').onClick(() => {\n        this.message = UIUtils.makeObserved(new Info(200));\n      })\n\n      Child({message: this.message})\n    }\n    .height('100%')\n    .width('100%')\n  }\n}\n\n@ComponentV2\nstruct Child {\n  @Param @Require message: Info;\n  build() {\n    Text(`Child id: ${this.message.id}`)\n  }\n}
[h2]makeObserved在@Component内使用
makeObserved不能和V1的状态变量装饰器一起使用，但可以在@Component装饰的自定义组件里使用。
import { UIUtils } from '@kit.ArkUI';\nclass Info {\n  id: number = 0;\n\n  constructor(id: number) {\n    this.id = id;\n  }\n}\n\n\n@Entry\n@Component\nstruct Index {\n  // 如果和@State一起使用会抛出运行时异常\n  message: Info = UIUtils.makeObserved(new Info(20));\n\n  build() {\n    RelativeContainer() {\n      Text(`${this.message.id}`)\n        .onClick(() => {\n          this.message.id++;\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
常见问题
[h2]getTarget后的数据可以正常赋值，但是无法触发UI刷新
getTarget可以获取状态管理框架代理前的原始对象。
makeObserved封装的观察对象，可以通过getTarget获取到其原始对象，对原始对象的赋值不会触发UI刷新。
如下面例子：
 先点击第一个Text组件，通过getTarget获取其原始对象，此时修改原始对象的属性不会触发UI刷新，但数据会正常赋值。 再点击第二个Text组件，此时修改this.observedObj的属性会触发UI刷新，Text显示21。 
import { UIUtils } from '@kit.ArkUI';\nclass Info {\n  id: number = 0;\n}\n\n@Entry\n@Component\nstruct Index {\n  observedObj: Info = UIUtils.makeObserved(new Info());\n  build() {\n    Column() {\n      Text(`${this.observedObj.id}`)\n        .fontSize(50)\n        .onClick(() => {\n          // 通过getTarget获取其原始对象，将this.observedObj赋值为不可观察的数据\n          let rawObj: Info= UIUtils.getTarget(this.observedObj);\n          // 不会触发UI刷新，但数据会正常赋值\n          rawObj.id = 20;\n        })\n\n      Text(`${this.observedObj.id}`)\n        .fontSize(50)\n        .onClick(() => {\n          // 触发UI刷新，Text显示21\n          this.observedObj.id++;\n        })\n    }\n  }\n}

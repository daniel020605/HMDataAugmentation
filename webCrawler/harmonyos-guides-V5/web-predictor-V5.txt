加速Web页面的访问
当Web页面加载缓慢时，可以使用预连接、预加载和预获取post请求的能力加速Web页面的访问。
预解析和预连接
可以通过prepareForPageLoad()来预解析或者预连接将要加载的页面。
在下面的示例中，在Web组件的onAppear中对要加载的页面进行预连接。
// xxx.ets\nimport { webview } from '@kit.ArkWeb';\n\n@Entry\n@Component\nstruct WebComponent {\n  webviewController: webview.WebviewController = new webview.WebviewController();\n\n  build() {\n    Column() {\n      Button('loadData')\n        .onClick(() => {\n          if (this.webviewController.accessBackward()) {\n            this.webviewController.backward();\n          }\n        })\n      Web({ src: 'https://www.example.com/', controller: this.webviewController })\n        .onAppear(() => {\n          // 指定第二个参数为true，代表要进行预连接，如果为false该接口只会对网址进行dns预解析\n          // 第三个参数为要预连接socket的个数。最多允许6个。\n          webview.WebviewController.prepareForPageLoad('https://www.example.com/', true, 2);\n        })\n    }\n  }\n}
也可以通过initializeBrowserEngine()来提前初始化内核，然后在初始化内核后调用
prepareForPageLoad()对即将要加载的页面进行预解析、预连接。这种方式适合提前对首页进行
预解析、预连接。
在下面的示例中，Ability的onCreate中提前初始化Web内核并对首页进行预连接。
// xxx.ets\nimport { webview } from '@kit.ArkWeb';\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {\n    console.log(\"EntryAbility onCreate\");\n    webview.WebviewController.initializeWebEngine();\n    // 预连接时，需要將'https://www.example.com'替换成真实要访问的网站地址。\n    webview.WebviewController.prepareForPageLoad(\"https://www.example.com/\", true, 2);\n    AppStorage.setOrCreate(\"abilityWant\", want);\n    console.log(\"EntryAbility onCreate done\");\n  }\n}
预加载
如果能够预测到Web组件将要加载的页面或者即将要跳转的页面。可以通过prefetchPage()来预加载即将要加载页面。
预加载会提前下载页面所需的资源，包括主资源子资源，但不会执行网页JavaScript代码。预加载是WebviewController的实例方法，需要一个已经关联好Web组件的WebviewController实例。
在下面的示例中，在onPageEnd的时候触发下一个要访问的页面的预加载。
// xxx.ets\nimport { webview } from '@kit.ArkWeb';\n\n@Entry\n@Component\nstruct WebComponent {\n  webviewController: webview.WebviewController = new webview.WebviewController();\n\n  build() {\n    Column() {\n      Web({ src: 'https://www.example.com/', controller: this.webviewController })\n        .onPageEnd(() => {\n          // 预加载https://www.iana.org/help/example-domains。\n          this.webviewController.prefetchPage('https://www.iana.org/help/example-domains');\n        })\n    }\n  }\n}
预获取post请求
可以通过prefetchResource()预获取将要加载页面中的post请求。在页面加载结束时，可以通过clearPrefetchedResource()清除后续不再使用的预获取资源缓存。
以下示例，在Web组件onAppear中，对要加载页面中的post请求进行预获取。在onPageEnd中，可以清除预获取的post请求缓存。
// xxx.ets\nimport { webview } from '@kit.ArkWeb';\n\n@Entry\n@Component\nstruct WebComponent {\n  webviewController: webview.WebviewController = new webview.WebviewController();\n\n  build() {\n    Column() {\n      Web({ src: \"https://www.example.com/\", controller: this.webviewController })\n        .onAppear(() => {\n          // 预获取时，需要將\"https://www.example1.com/post?e=f&g=h\"替换成真实要访问的网站地址。\n          webview.WebviewController.prefetchResource(\n            {\n              url: \"https://www.example1.com/post?e=f&g=h\",\n              method: \"POST\",\n              formData: \"a=x&b=y\",\n            },\n            [{\n              headerKey: \"c\",\n              headerValue: \"z\",\n            },],\n            \"KeyX\", 500);\n        })\n        .onPageEnd(() => {\n          // 清除后续不再使用的预获取资源缓存。\n          webview.WebviewController.clearPrefetchedResource([\"KeyX\",]);\n        })\n    }\n  }\n}
如果能够预测到Web组件将要加载页面或者即将要跳转页面中的post请求。可以通过prefetchResource()预获取即将要加载页面的post请求。
以下示例，在onPageEnd中，触发预获取一个要访问页面的post请求。
// xxx.ets\nimport { webview } from '@kit.ArkWeb';\n\n@Entry\n@Component\nstruct WebComponent {\n  webviewController: webview.WebviewController = new webview.WebviewController();\n\n  build() {\n    Column() {\n      Web({ src: 'https://www.example.com/', controller: this.webviewController })\n        .onPageEnd(() => {\n          // 预获取时，需要將\"https://www.example1.com/post?e=f&g=h\"替换成真实要访问的网站地址。\n          webview.WebviewController.prefetchResource(\n            {\n              url: \"https://www.example1.com/post?e=f&g=h\",\n              method: \"POST\",\n              formData: \"a=x&b=y\",\n            },\n            [{\n              headerKey: \"c\",\n              headerValue: \"z\",\n            },],\n            \"KeyX\", 500);\n        })\n    }\n  }\n}
也可以通过initializeBrowserEngine()提前初始化内核，然后在初始化内核后调用prefetchResource()预获取将要加载页面中的post请求。这种方式适合提前预获取首页的post请求。
以下示例，在Ability的onCreate中，提前初始化Web内核并预获取首页的post请求。
// xxx.ets\nimport { webview } from '@kit.ArkWeb';\nimport { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {\n    console.log(\"EntryAbility onCreate\");\n    webview.WebviewController.initializeWebEngine();\n    // 预获取时，需要將\"https://www.example1.com/post?e=f&g=h\"替换成真实要访问的网站地址。\n    webview.WebviewController.prefetchResource(\n      {\n        url: \"https://www.example1.com/post?e=f&g=h\",\n        method: \"POST\",\n        formData: \"a=x&b=y\",\n      },\n      [{\n        headerKey: \"c\",\n        headerValue: \"z\",\n      },],\n      \"KeyX\", 500);\n    AppStorage.setOrCreate(\"abilityWant\", want);\n    console.log(\"EntryAbility onCreate done\");\n  }\n}
预编译生成编译缓存
可以通过precompileJavaScript()在页面加载前提前生成脚本文件的编译缓存。
推荐配合动态组件使用，使用离线的Web组件用于生成字节码缓存，并在适当的时机加载业务用Web组件使用这些字节码缓存。下方是代码示例：
 首先，在EntryAbility中将UIContext存到localStorage中。 // EntryAbility.ets\nimport { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\n\nconst localStorage: LocalStorage = new LocalStorage('uiContext');\n\nexport default class EntryAbility extends UIAbility {\n  storage: LocalStorage = localStorage;\n\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    windowStage.loadContent('pages/Index', this.storage, (err, data) => {\n      if (err.code) {\n        return;\n      }\n\n      this.storage.setOrCreate<UIContext>(\"uiContext\", windowStage.getMainWindowSync().getUIContext());\n    });\n  }\n} 编写动态组件所需基础代码。 // DynamicComponent.ets\nimport { NodeController, BuilderNode, FrameNode, UIContext } from '@kit.ArkUI';\n\nexport interface BuilderData {\n  url: string;\n  controller: WebviewController;\n}\n\nconst storage = LocalStorage.getShared();\n\nexport class NodeControllerImpl extends NodeController {\n  private rootNode: BuilderNode<BuilderData[]> | null = null;\n  private wrappedBuilder: WrappedBuilder<BuilderData[]> | null = null;\n\n  constructor(wrappedBuilder: WrappedBuilder<BuilderData[]>) {\n    super();\n    this.wrappedBuilder = wrappedBuilder;\n  }\n\n  makeNode(): FrameNode | null {\n    if (this.rootNode != null) {\n      return this.rootNode.getFrameNode();\n    }\n    return null;\n  }\n\n  initWeb(url: string, controller: WebviewController) {\n    if(this.rootNode != null) {\n      return;\n    }\n\n    const uiContext: UIContext = storage.get<UIContext>(\"uiContext\") as UIContext;\n    if (!uiContext) {\n      return;\n    }\n    this.rootNode = new BuilderNode(uiContext);\n    this.rootNode.build(this.wrappedBuilder, { url: url, controller: controller });\n  }\n}\n\nexport const createNode = (wrappedBuilder: WrappedBuilder<BuilderData[]>, data: BuilderData) => {\n  const baseNode = new NodeControllerImpl(wrappedBuilder);\n  baseNode.initWeb(data.url, data.controller);\n  return baseNode;\n} 编写用于生成字节码缓存的组件，本例中的本地Javascript资源内容通过文件读取接口读取rawfile目录下的本地文件。 // PrecompileWebview.ets\nimport { BuilderData } from \"./DynamicComponent\";\nimport { Config, configs } from \"./PrecompileConfig\";\n\n@Builder\nfunction WebBuilder(data: BuilderData) {\n  Web({ src: data.url, controller: data.controller })\n    .onControllerAttached(() => {\n      precompile(data.controller, configs);\n    })\n    .fileAccess(true)\n}\n\nexport const precompileWebview = wrapBuilder<BuilderData[]>(WebBuilder);\n\nexport const precompile = async (controller: WebviewController, configs: Array<Config>) => {\n  for (const config of configs) {\n    let content = await readRawFile(config.localPath);\n\n    try {\n      controller.precompileJavaScript(config.url, content, config.options)\n        .then(errCode => {\n          console.error(\"precompile successfully! \" + errCode);\n        }).catch((errCode: number) => {\n          console.error(\"precompile failed. \" + errCode);\n      });\n    } catch (err) {\n      console.error(\"precompile failed. \" + err.code + \" \" + err.message);\n    }\n  }\n}\n\nasync function readRawFile(path: string) {\n  try {\n    return await getContext().resourceManager.getRawFileContent(path);;\n  } catch (err) {\n    return new Uint8Array(0);\n  }\n} 
JavaScript资源的获取方式也可通过网络请求的方式获取，但此方法获取到的http响应头非标准HTTP响应头格式，需额外将响应头转换成标准HTTP响应头格式后使用。如通过网络请求获取到的响应头是e-tag，则需要将其转换成E-Tag后使用。
 编写业务用组件代码。 // BusinessWebview.ets\nimport { BuilderData } from \"./DynamicComponent\";\n\n@Builder\nfunction WebBuilder(data: BuilderData) {\n  // 此处组件可根据业务需要自行扩展\n  Web({ src: data.url, controller: data.controller })\n    .cacheMode(CacheMode.Default)\n}\n\nexport const businessWebview = wrapBuilder<BuilderData[]>(WebBuilder); 编写资源配置信息。 // PrecompileConfig.ets\nimport { webview } from '@kit.ArkWeb'\n\nexport interface Config {\n  url:  string,\n  localPath: string, // 本地资源路径\n  options: webview.CacheOptions\n}\n\nexport let configs: Array<Config> = [\n  {\n    url: \"https://www.example.com/example.js\",\n    localPath: \"example.js\",\n    options: {\n      responseHeaders: [\n        { headerKey: \"E-Tag\", headerValue: \"aWO42N9P9dG/5xqYQCxsx+vDOoU=\"},\n        { headerKey: \"Last-Modified\", headerValue: \"Wed, 21 Mar 2024 10:38:41 GMT\"}\n      ]\n    }\n  }\n] 在页面中使用。 // Index.ets\nimport { webview } from '@kit.ArkWeb';\nimport { NodeController } from '@kit.ArkUI';\nimport { createNode } from \"./DynamicComponent\"\nimport { precompileWebview } from \"./PrecompileWebview\"\nimport { businessWebview } from \"./BusinessWebview\"\n\n@Entry\n@Component\nstruct Index {\n  @State precompileNode: NodeController | undefined = undefined;\n  precompileController: webview.WebviewController = new webview.WebviewController();\n\n  @State businessNode: NodeController | undefined = undefined;\n  businessController: webview.WebviewController = new webview.WebviewController();\n\n  aboutToAppear(): void {\n    // 初始化用于注入本地资源的Web组件\n    this.precompileNode = createNode(precompileWebview,\n      { url: \"https://www.example.com/empty.html\", controller: this.precompileController});\n  }\n\n  build() {\n    Column() {\n      // 在适当的时机加载业务用Web组件，本例以Button点击触发为例\n      Button(\"加载页面\")\n        .onClick(() => {\n          this.businessNode = createNode(businessWebview, {\n            url:  \"https://www.example.com/business.html\",\n            controller: this.businessController\n          });\n        })\n      // 用于业务的Web组件\n      NodeContainer(this.businessNode);\n    }\n  }\n} 
当需要更新本地已经生成的编译字节码时，修改cacheOptions参数中responseHeaders中的E-Tag或Last-Modified响应头对应的值，再次调用接口即可。
离线资源免拦截注入
可以通过injectOfflineResources()在页面加载前提前将图片、样式表或脚本资源注入到应用的内存缓存中。
推荐配合动态组件使用，使用离线的Web组件用于将资源注入到内核的内存缓存中，并在适当的时机加载业务用Web组件使用这些资源。下方是代码示例：
 首先，在EntryAbility中将UIContext存到localStorage中。 // EntryAbility.ets\nimport { UIAbility } from '@kit.AbilityKit';\nimport { window } from '@kit.ArkUI';\n\nconst localStorage: LocalStorage = new LocalStorage('uiContext');\n\nexport default class EntryAbility extends UIAbility {\n  storage: LocalStorage = localStorage;\n\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    windowStage.loadContent('pages/Index', this.storage, (err, data) => {\n      if (err.code) {\n        return;\n      }\n\n      this.storage.setOrCreate<UIContext>(\"uiContext\", windowStage.getMainWindowSync().getUIContext());\n    });\n  }\n} 编写动态组件所需基础代码。 // DynamicComponent.ets\nimport { NodeController, BuilderNode, FrameNode, UIContext } from '@kit.ArkUI';\n\nexport interface BuilderData {\n  url: string;\n  controller: WebviewController;\n}\n\nconst storage = LocalStorage.getShared();\n\nexport class NodeControllerImpl extends NodeController {\n  private rootNode: BuilderNode<BuilderData[]> | null = null;\n  private wrappedBuilder: WrappedBuilder<BuilderData[]> | null = null;\n\n  constructor(wrappedBuilder: WrappedBuilder<BuilderData[]>) {\n    super();\n    this.wrappedBuilder = wrappedBuilder;\n  }\n\n  makeNode(): FrameNode | null {\n    if (this.rootNode != null) {\n      return this.rootNode.getFrameNode();\n    }\n    return null;\n  }\n\n  initWeb(url: string, controller: WebviewController) {\n    if(this.rootNode != null) {\n      return;\n    }\n\n    const uiContext: UIContext = storage.get<UIContext>(\"uiContext\") as UIContext;\n    if (!uiContext) {\n      return;\n    }\n    this.rootNode = new BuilderNode(uiContext);\n    this.rootNode.build(this.wrappedBuilder, { url: url, controller: controller });\n  }\n}\n\nexport const createNode = (wrappedBuilder: WrappedBuilder<BuilderData[]>, data: BuilderData) => {\n  const baseNode = new NodeControllerImpl(wrappedBuilder);\n  baseNode.initWeb(data.url, data.controller);\n  return baseNode;\n} 编写用于注入资源的组件代码，本例中的本地资源内容通过文件读取接口读取rawfile目录下的本地文件。 // InjectWebview.ets\nimport { webview } from '@kit.ArkWeb';\nimport { resourceConfigs } from \"./Resource\";\nimport { BuilderData } from \"./DynamicComponent\";\n\n@Builder\nfunction WebBuilder(data: BuilderData) {\n  Web({ src: data.url, controller: data.controller })\n    .onControllerAttached(async () => {\n      try {\n        data.controller.injectOfflineResources(await getData ());\n      } catch (err) {\n        console.error(\"error: \" + err.code + \" \" + err.message);\n      }\n    })\n    .fileAccess(true)\n}\n\nexport const injectWebview = wrapBuilder<BuilderData[]>(WebBuilder);\n\nexport async function getData() {\n  const resourceMapArr: Array<webview.OfflineResourceMap> = [];\n\n  // 读取配置，从rawfile目录中读取文件内容\n  for (let config of resourceConfigs) {\n    let buf: Uint8Array = new Uint8Array(0);\n    if (config.localPath) {\n      buf = await readRawFile(config.localPath);\n    }\n\n    resourceMapArr.push({\n      urlList: config.urlList,\n      resource: buf,\n      responseHeaders: config.responseHeaders,\n      type: config.type,\n    })\n  }\n\n  return resourceMapArr;\n}\n\nexport async function readRawFile(url: string) {\n  try {\n    return await getContext().resourceManager.getRawFileContent(url);\n  } catch (err) {\n    return new Uint8Array(0);\n  }\n} 编写业务用组件代码。 // BusinessWebview.ets\nimport { BuilderData } from \"./DynamicComponent\";\n\n@Builder\nfunction WebBuilder(data: BuilderData) {\n  // 此处组件可根据业务需要自行扩展\n  Web({ src: data.url, controller: data.controller })\n    .cacheMode(CacheMode.Default)\n}\n\nexport const businessWebview = wrapBuilder<BuilderData[]>(WebBuilder); 编写资源配置信息。 // Resource.ets\nimport { webview } from '@kit.ArkWeb';\n\nexport interface ResourceConfig {\n  urlList: Array<string>,\n  type: webview.OfflineResourceType,\n  responseHeaders: Array<Header>,\n  localPath: string, // 本地资源存放在rawfile目录下的路径\n}\n\nexport const resourceConfigs: Array<ResourceConfig> = [\n  {\n    localPath: \"example.png\",\n    urlList: [\n      \"https://www.example.com/\",\n      \"https://www.example.com/path1/example.png\",\n      \"https://www.example.com/path2/example.png\",\n    ],\n    type: webview.OfflineResourceType.IMAGE,\n    responseHeaders: [\n      { headerKey: \"Cache-Control\", headerValue: \"max-age=1000\" },\n      { headerKey: \"Content-Type\", headerValue: \"image/png\" },\n    ]\n  },\n  {\n    localPath: \"example.js\",\n    urlList: [ // 仅提供一个url，这个url既作为资源的源，也作为资源的网络请求地址\n      \"https://www.example.com/example.js\",\n    ],\n    type: webview.OfflineResourceType.CLASSIC_JS,\n    responseHeaders: [\n      // 以<script crossorigin=\"anoymous\" />方式使用，提供额外的响应头\n      { headerKey: \"Cross-Origin\", headerValue:\"anonymous\" }\n    ]\n  },\n]; 在页面中使用。 // Index.ets\nimport { webview } from '@kit.ArkWeb';\nimport { NodeController } from '@kit.ArkUI';\nimport { createNode } from \"./DynamicComponent\"\nimport { injectWebview } from \"./InjectWebview\"\nimport { businessWebview } from \"./BusinessWebview\"\n\n@Entry\n@Component\nstruct Index {\n  @State injectNode: NodeController | undefined = undefined;\n  injectController: webview.WebviewController = new webview.WebviewController();\n\n  @State businessNode: NodeController | undefined = undefined;\n  businessController: webview.WebviewController = new webview.WebviewController();\n\n  aboutToAppear(): void {\n    // 初始化用于注入本地资源的Web组件, 提供一个空的html页面作为url即可\n    this.injectNode = createNode(injectWebview,\n        { url: \"https://www.example.com/empty.html\", controller: this.injectController});\n  }\n\n  build() {\n    Column() {\n      // 在适当的时机加载业务用Web组件，本例以Button点击触发为例\n      Button(\"加载页面\")\n        .onClick(() => {\n          this.businessNode = createNode(businessWebview, {\n            url: \"https://www.example.com/business.html\",\n            controller: this.businessController\n          });\n        })\n      // 用于业务的Web组件\n      NodeContainer(this.businessNode);\n    }\n  }\n} 加载的HTML网页示例。 <!DOCTYPE html>\n<html lang=\"en\">\n<head></head>\n<body>\n  <img src=\"https://www.example.com/path1/request.png\" />\n  <img src=\"https://www.example.com/path2/request.png\" />\n  <script src=\"https://www.example.com/example.js\" crossorigin=\"anonymous\"></script>\n</body>\n</html> 

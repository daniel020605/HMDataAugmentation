根据卡片状态刷新不同内容
相同的卡片可以添加到桌面上实现不同的功能，比如添加两张桌面的卡片，一张显示杭州的天气，一张显示北京的天气，设置每天早上7点触发定时刷新，卡片需要感知当前的配置是杭州还是北京，然后将对应城市的天气信息刷新到卡片上，以下示例介绍了如何根据卡片的状态动态选择需要刷新的内容。
 卡片配置文件：配置每30分钟自动刷新。 {\n  \"forms\": [\n    {\n      \"name\": \"WidgetUpdateByStatus\",\n      \"description\": \"$string:UpdateByStatusFormAbility_desc\",\n      \"src\": \"./ets/widgetupdatebystatus/pages/WidgetUpdateByStatusCard.ets\",\n      \"uiSyntax\": \"arkts\",\n      \"window\": {\n        \"designWidth\": 720,\n        \"autoDesignWidth\": true\n      },\n      \"colorMode\": \"auto\",\n      \"isDefault\": true,\n      \"updateEnabled\": true,\n      \"scheduledUpdateTime\": \"10:30\",\n      \"updateDuration\": 1,\n      \"defaultDimension\": \"2*2\",\n      \"supportDimensions\": [\n        \"2*2\"\n      ]\n    }\n  ]\n} 卡片页面：卡片具备不同的状态选择，在不同的状态下需要刷新不同的内容，因此在状态发生变化时通过postCardAction通知EntryFormAbility。 let storageUpdateByStatus = new LocalStorage();\n\n@Entry(storageUpdateByStatus)\n@Component\nstruct WidgetUpdateByStatusCard {\n  @LocalStorageProp('textA') textA: Resource = $r('app.string.to_be_refreshed');\n  @LocalStorageProp('textB') textB: Resource = $r('app.string.to_be_refreshed');\n  @State selectA: boolean = false;\n  @State selectB: boolean = false;\n\n  build() {\n    Column() {\n      Column() {\n        Row() {\n          Checkbox({ name: 'checkbox1', group: 'checkboxGroup' })\n            .padding(0)\n            .select(false)\n            .margin({ left: 26 })\n            .onChange((value: boolean) => {\n              this.selectA = value;\n              postCardAction(this, {\n                action: 'message',\n                params: {\n                  selectA: JSON.stringify(value)\n                }\n              });\n            })\n          Text($r('app.string.status_a'))\n            .fontColor('#000000')\n            .opacity(0.9)\n            .fontSize(14)\n            .margin({ left: 8 })\n        }\n        .width('100%')\n        .padding(0)\n        .justifyContent(FlexAlign.Start)\n\n        Row() {\n          Checkbox({ name: 'checkbox2', group: 'checkboxGroup' })\n            .padding(0)\n            .select(false)\n            .margin({ left: 26 })\n            .onChange((value: boolean) => {\n              this.selectB = value;\n              postCardAction(this, {\n                action: 'message',\n                params: {\n                  selectB: JSON.stringify(value)\n                }\n              });\n            })\n          Text($r('app.string.status_b'))\n            .fontColor('#000000')\n            .opacity(0.9)\n            .fontSize(14)\n            .margin({ left: 8 })\n        }\n        .width('100%')\n        .position({ y: 32 })\n        .padding(0)\n        .justifyContent(FlexAlign.Start)\n      }\n      .position({ y: 12 })\n\n      Column() {\n        Row() { // 选中状态A才会进行刷新的内容\n          Text($r('app.string.status_a'))\n            .fontColor('#000000')\n            .opacity(0.4)\n            .fontSize(12)\n\n          Text(this.textA)\n            .fontColor('#000000')\n            .opacity(0.4)\n            .fontSize(12)\n        }\n        .margin({ top: '12px', left: 26, right: '26px' })\n\n        Row() { // 选中状态B才会进行刷新的内容\n          Text($r('app.string.status_b'))\n            .fontColor('#000000')\n            .opacity(0.4)\n            .fontSize(12)\n          Text(this.textB)\n            .fontColor('#000000')\n            .opacity(0.4)\n            .fontSize(12)\n        }.margin({ top: '12px', bottom: '21px', left: 26, right: '26px' })\n      }\n      .margin({ top: 80 })\n      .width('100%')\n      .alignItems(HorizontalAlign.Start)\n    }.width('100%').height('100%')\n    .backgroundImage($r('app.media.CardUpdateByStatus'))\n    .backgroundImageSize(ImageSize.Cover)\n  }\n} EntryFormAbility：将卡片的状态存储在本地数据库中，在刷新事件回调触发时，通过formId获取当前卡片的状态，然后根据卡片的状态选择不同的刷新内容。 import { Want } from '@kit.AbilityKit';\nimport { preferences } from '@kit.ArkData';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { formBindingData, FormExtensionAbility, formInfo, formProvider } from '@kit.FormKit';\nimport { hilog } from '@kit.PerformanceAnalysisKit';\n\nconst TAG: string = 'UpdateByStatusFormAbility';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class UpdateByStatusFormAbility extends FormExtensionAbility {\n  onAddForm(want: Want): formBindingData.FormBindingData {\n    let formId: string = '';\n    let isTempCard: boolean;\n    if (want.parameters) {\n      formId = want.parameters[formInfo.FormParam.IDENTITY_KEY].toString();\n      isTempCard = want.parameters[formInfo.FormParam.TEMPORARY_KEY] as boolean;\n      if (isTempCard === false) { // 如果为常态卡片，直接进行信息持久化\n        hilog.info(DOMAIN_NUMBER, TAG, 'Not temp card, init db for:' + formId);\n        let promise: Promise<preferences.Preferences> = preferences.getPreferences(this.context, 'myStore');\n        promise.then(async (storeDB: preferences.Preferences) => {\n          hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences.');\n          await storeDB.put('A' + formId, 'false');\n          await storeDB.put('B' + formId, 'false');\n          await storeDB.flush();\n        }).catch((err: BusinessError) => {\n          hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);\n        });\n      }\n  }\n    let formData: Record<string, Object | string> = {};\n    return formBindingData.createFormBindingData(formData);\n  }\n\n  onRemoveForm(formId: string): void {\n    hilog.info(DOMAIN_NUMBER, TAG, 'onRemoveForm, formId:' + formId);\n    let promise = preferences.getPreferences(this.context, 'myStore');\n    promise.then(async (storeDB) => {\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences.');\n      await storeDB.delete('A' + formId);\n      await storeDB.delete('B' + formId);\n    }).catch((err: BusinessError) => {\n    hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);\n    });\n  }\n\n  // 如果在添加时为临时卡片，则建议转为常态卡片时进行信息持久化\n  onCastToNormalForm(formId: string): void {\n    hilog.info(DOMAIN_NUMBER, TAG, 'onCastToNormalForm, formId:' + formId);\n    let promise: Promise<preferences.Preferences> = preferences.getPreferences(this.context, 'myStore');\n    promise.then(async (storeDB: preferences.Preferences) => {\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences.');\n      await storeDB.put('A' + formId, 'false');\n      await storeDB.put('B' + formId, 'false');\n      await storeDB.flush();\n    }).catch((err: BusinessError) => {\n    hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);\n    });\n  }\n\n  onUpdateForm(formId: string): void {\n    let promise: Promise<preferences.Preferences> = preferences.getPreferences(this.context, 'myStore');\n    promise.then(async (storeDB: preferences.Preferences) => {\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences from onUpdateForm.');\n      let stateA = await storeDB.get('A' + formId, 'false');\n      let stateB = await storeDB.get('B' + formId, 'false');\n      // A状态选中则更新textA\n      if (stateA === 'true') {\n        let param: Record<string, string> = {\n          'textA': 'AAA'\n        };\n        let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(param);\n        await formProvider.updateForm(formId, formInfo);\n      }\n      // B状态选中则更新textB\n      if (stateB === 'true') {\n        let param: Record<string, string> = {\n          'textB': 'BBB'\n        };\n        let formInfo: formBindingData.FormBindingData = formBindingData.createFormBindingData(param);\n      await formProvider.updateForm(formId, formInfo);\n      }\n      hilog.info(DOMAIN_NUMBER, TAG, `Update form success stateA:${stateA} stateB:${stateB}.`);\n    }).catch((err: BusinessError) => {\n      hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);\n    });\n  }\n\n  onFormEvent(formId: string, message: string): void {\n    // 存放卡片状态\n    hilog.info(DOMAIN_NUMBER, TAG, 'onFormEvent formId:' + formId + 'msg:' + message);\n    let promise: Promise<preferences.Preferences> = preferences.getPreferences(this.context, 'myStore');\n    promise.then(async (storeDB: preferences.Preferences) => {\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded to get preferences.');\n      let msg: Record<string, string> = JSON.parse(message);\n      if (msg.selectA !== undefined) {\n        hilog.info(DOMAIN_NUMBER, TAG, 'onFormEvent selectA info:' + msg.selectA);\n        await storeDB.put('A' + formId, msg.selectA);\n      }\n      if (msg.selectB !== undefined) {\n        hilog.info(DOMAIN_NUMBER, TAG, 'onFormEvent selectB info:' + msg.selectB);\n        await storeDB.put('B' + formId, msg.selectB);\n      }\n      await storeDB.flush();\n    }).catch((err: BusinessError) => {\n      hilog.info(DOMAIN_NUMBER, TAG, `Failed to get preferences. ${JSON.stringify(err)}`);\n    });\n  }\n} 
通过本地数据库进行卡片信息的持久化时，建议先在onAddForm生命周期中通过TEMPORARY_KEY判断当前添加的卡片是否为常态卡片：如果是常态卡片，则直接进行卡片信息持久化；如果为临时卡片，则可以在卡片转为常态卡片(onCastToNormalForm)时进行持久化；同时需要在卡片销毁(onRemoveForm)时删除当前卡片存储的持久化信息，避免反复添加删除卡片导致数据库文件持续变大。

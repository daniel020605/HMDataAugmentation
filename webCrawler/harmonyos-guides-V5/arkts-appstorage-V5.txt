AppStorage：应用全局的UI状态存储
AppStorage是应用全局的UI状态存储，是和应用的进程绑定的，由UI框架在应用程序启动时创建，为应用程序UI状态属性提供中央存储。
和AppStorage不同的是，LocalStorage是页面级的，通常应用于页面内的数据共享。而AppStorage是应用级的全局状态共享，还相当于整个应用的“中枢”，持久化数据PersistentStorage和环境变量Environment都是通过AppStorage中转，才可以和UI交互。
本文仅介绍AppStorage使用场景和相关的装饰器：@StorageProp和@StorageLink。
AppStorage是应用全局的UI状态存储，不同于@State等装饰器仅能在组件树上传递，AppStorage的目的是为了给开发者提供更大范围的跨ability基本的数据共享。在阅读本文档前，建议开发者对状态管理框架中AppStorage的定位有一个宏观了解。建议提前阅读：状态管理概述。
AppStorage还提供了API接口，可以让开发者通过接口在自定义组件外手动触发AppStorage对应key的增删改查，建议配合AppStorage API文档阅读。
概述
AppStorage是在应用启动的时候会被创建的单例。它的目的是为了提供应用状态数据的中心存储，这些状态数据在应用级别都是可访问的。AppStorage将在应用运行过程保留其属性。属性通过唯一的键字符串值访问。
AppStorage可以和UI组件同步，且可以在应用业务逻辑中被访问。
AppStorage支持应用的主线程内多个UIAbility实例间的状态共享。
AppStorage中的属性可以被双向同步，数据可以是存在于本地或远程设备上，并具有不同的功能，比如数据持久化（详见PersistentStorage）。这些数据是通过业务逻辑中实现，与UI解耦，如果希望这些数据在UI中使用，需要用到@StorageProp和@StorageLink。
@StorageProp
在上文中已经提到，如果要建立AppStorage和自定义组件的联系，需要使用@StorageProp和@StorageLink装饰器。使用@StorageProp(key)/@StorageLink(key)装饰组件内的变量，key标识了AppStorage的属性。
当自定义组件初始化的时候，会使用AppStorage中对应key的属性值将@StorageProp(key)/@StorageLink(key)装饰的变量初始化。由于应用逻辑的差异，无法确认是否在组件初始化之前向AppStorage实例中存入了对应的属性，所以AppStorage不一定存在key对应的属性，因此@StorageProp(key)/@StorageLink(key)装饰的变量进行本地初始化是必要的。
@StorageProp(key)是和AppStorage中key对应的属性建立单向数据同步，允许本地改变，但是对于@StorageProp，本地的修改永远不会同步回AppStorage中，相反，如果AppStorage给定key的属性发生改变，改变会被同步给@StorageProp，并覆盖掉本地的修改。
从API version 11开始，该装饰器支持在元服务中使用。
[h2]装饰器使用规则说明
Object、class、string、number、boolean、enum类型，以及这些类型的数组。
API12及以上支持Map、Set、Date类型。嵌套类型的场景请参考观察变化和行为表现。
类型必须被指定，建议和AppStorage中对应属性类型相同，否则会发生类型隐式转换，从而导致应用行为异常。
不支持any，API12及以上支持undefined和null类型。
API12及以上支持上述支持类型的联合类型，比如string | number, string | undefined 或者 ClassA | null，示例见AppStorage支持联合类型。
注意
当使用undefined和null的时候，建议显式指定类型，遵循TypeScript类型校验，比如：@StorageProp(\"AA\") a: number | null = null是推荐的，不推荐@StorageProp(\"AA\") a: number = null。
单向同步：从AppStorage的对应属性到组件的状态变量。
组件本地的修改是允许的，但是AppStorage中给定的属性一旦发生变化，将覆盖本地的修改。
[h2]变量的传递/访问规则说明
图1 @StorageProp初始化规则图示
[h2]观察变化和行为表现
观察变化
 当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。 当装饰的数据类型为class或者Object时，可以观察到对象整体赋值和对象属性变化（详见从ui内部使用appstorage和localstorage）。 当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。 当装饰的对象是Date时，可以观察到Date整体的赋值，同时可通过调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 更新Date的属性。详见装饰Date类型变量。 当装饰的变量是Map时，可以观察到Map整体的赋值，同时可通过调用Map的接口set, clear, delete 更新Map的值。详见装饰Map类型变量。 当装饰的变量是Set时，可以观察到Set整体的赋值，同时可通过调用Set的接口add, clear, delete 更新Set的值。详见装饰Set类型变量。 
框架行为
 当@StorageProp(key)装饰的数值改变被观察到时，修改不会被同步回AppStorage对应key的属性中。 当前@StorageProp(key)单向绑定的数据会被修改，即仅限于当前组件的私有成员变量改变，其他绑定该key的数据不会同步改变。 当@StorageProp(key)装饰的数据本身是状态变量，它的改变虽然不会同步回AppStorage中，但是会引起所属的自定义组件重新渲染。 当AppStorage中key对应的属性发生改变时，会同步给所有@StorageProp(key)装饰的数据，@StorageProp(key)本地的修改将被覆盖。 
@StorageLink
从API version 11开始，该装饰器支持在元服务中使用。
@StorageLink(key)是和AppStorage中key对应的属性建立双向数据同步：
 本地修改发生，该修改会被写回AppStorage中。 AppStorage中的修改发生后，该修改会被同步到所有绑定AppStorage对应key的属性上，包括单向（@StorageProp和通过Prop创建的单向绑定变量）、双向（@StorageLink和通过Link创建的双向绑定变量）变量和其他实例（比如PersistentStorage）。 
[h2]装饰器使用规则说明
Object、class、string、number、boolean、enum类型，以及这些类型的数组。
API12及以上支持Map、Set、Date类型。嵌套类型的场景请参考观察变化和行为表现。
类型必须被指定，建议和AppStorage中对应属性类型相同，否则会发生类型隐式转换，从而导致应用行为异常。
不支持any，API12及以上支持undefined和null类型。
API12及以上支持上述支持类型的联合类型，比如string | number, string | undefined 或者 ClassA | null，示例见AppStorage支持联合类型。
注意
当使用undefined和null的时候，建议显式指定类型，遵循TypeScript类型校验，比如：@StorageLink(\"AA\") a: number | null = null是推荐的，不推荐@StorageLink(\"AA\") a: number = null。
[h2]变量的传递/访问规则说明
图2 @StorageLink初始化规则图示
[h2]观察变化和行为表现
观察变化
 当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。 当装饰的数据类型为class或者Object时，可以观察到对象整体赋值和对象属性变化（详见从ui内部使用appstorage和localstorage）。 当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。 当装饰的对象是Date时，可以观察到Date整体的赋值，同时可通过调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 更新Date的属性。详见装饰Date类型变量。 当装饰的变量是Map时，可以观察到Map整体的赋值，同时可通过调用Map的接口set, clear, delete 更新Map的值。详见装饰Map类型变量。 当装饰的变量是Set时，可以观察到Set整体的赋值，同时可通过调用Set的接口add, clear, delete 更新Set的值。详见装饰Set类型变量。 
框架行为
 当@StorageLink(key)装饰的数值改变被观察到时，修改将被同步回AppStorage对应属性键值key的属性中。 AppStorage中属性键值key对应的数据一旦改变，属性键值key绑定的所有的数据（包括双向@StorageLink和单向@StorageProp）都将同步修改。 当@StorageLink(key)装饰的数据本身是状态变量，它的改变不仅仅会同步回AppStorage中，还会引起所属的自定义组件的重新渲染。 
限制条件
 @StorageProp/@StorageLink的参数必须为string类型，否则编译期会报错。 AppStorage.setOrCreate('PropA', 47);\n\n// 错误写法，编译报错\n@StorageProp() storageProp: number = 1;\n@StorageLink() storageLink: number = 2;\n\n// 正确写法\n@StorageProp('PropA') storageProp: number = 1;\n@StorageLink('PropA') storageLink: number = 2; @StorageProp与@StorageLink不支持装饰Function类型的变量，框架会抛出运行时错误。 AppStorage与PersistentStorage以及Environment配合使用时，需要注意以下几点： （1） 在AppStorage中创建属性后，调用PersistentStorage.persistProp()接口时，会使用在AppStorage中已经存在的值，并覆盖PersistentStorage中的同名属性，所以建议要使用相反的调用顺序，反例可见在PersistentStorage之前访问AppStorage中的属性。 （2） 如果在AppStorage中已经创建属性后，再调用Environment.envProp()创建同名的属性，会调用失败。因为AppStorage已经有同名属性，Environment环境变量不会再写入AppStorage中，所以建议AppStorage中属性不要使用Environment预置环境变量名。 （3） 状态装饰器装饰的变量，改变会引起UI的渲染更新，如果改变的变量不是用于UI更新，只是用于消息传递，推荐使用 emitter方式。例子可见不建议借助@StorageLink的双向同步机制实现事件通知。 
使用场景
[h2]从应用逻辑使用AppStorage和LocalStorage
AppStorage是单例，它的所有API都是静态的，使用方法类似于LocalStorage中对应的非静态方法。
AppStorage.setOrCreate('PropA', 47);\n\nlet storage: LocalStorage = new LocalStorage();\nstorage.setOrCreate('PropA',17);\nlet propA: number | undefined = AppStorage.get('PropA') // propA in AppStorage == 47, propA in LocalStorage == 17\nlet link1: SubscribedAbstractProperty<number> = AppStorage.link('PropA'); // link1.get() == 47\nlet link2: SubscribedAbstractProperty<number> = AppStorage.link('PropA'); // link2.get() == 47\nlet prop: SubscribedAbstractProperty<number> = AppStorage.prop('PropA'); // prop.get() == 47\n\nlink1.set(48); // 双向同步: link1.get() == link2.get() == prop.get() == 48\nprop.set(1); // 单向同步: prop.get() == 1; 但 link1.get() == link2.get() == 48\nlink1.set(49); // 双向同步: link1.get() == link2.get() == prop.get() == 49\n\nstorage.get<number>('PropA') // == 17\nstorage.set('PropA', 101);\nstorage.get<number>('PropA') // == 101\n\nAppStorage.get<number>('PropA') // == 49\nlink1.get() // == 49\nlink2.get() // == 49\nprop.get() // == 49
[h2]从UI内部使用AppStorage和LocalStorage
@StorageLink变量装饰器与AppStorage配合使用，正如@LocalStorageLink与LocalStorage配合使用一样。此装饰器使用AppStorage中的属性创建双向数据同步。
class Data {\n  code: number;\n\n  constructor(code: number) {\n    this.code = code;\n  }\n}\n\nAppStorage.setOrCreate('PropA', 47);\nAppStorage.setOrCreate('PropB', new Data(50));\nlet storage = new LocalStorage();\nstorage.setOrCreate('LinkA', 48);\nstorage.setOrCreate('LinkB', new Data(100));\n\n@Entry(storage)\n@Component\nstruct Index {\n  @StorageLink('PropA') storageLink: number = 1;\n  @LocalStorageLink('LinkA') localStorageLink: number = 1;\n  @StorageLink('PropB') storageLinkObject: Data = new Data(1);\n  @LocalStorageLink('LinkB') localStorageLinkObject: Data = new Data(1);\n\n  build() {\n    Column({ space: 20 }) {\n      Text(`From AppStorage ${this.storageLink}`)\n        .onClick(() => {\n          this.storageLink += 1;\n        })\n\n      Text(`From LocalStorage ${this.localStorageLink}`)\n        .onClick(() => {\n          this.localStorageLink += 1;\n        })\n\n      Text(`From AppStorage ${this.storageLinkObject.code}`)\n        .onClick(() => {\n          this.storageLinkObject.code += 1;\n        })\n\n      Text(`From LocalStorage ${this.localStorageLinkObject.code}`)\n        .onClick(() => {\n          this.localStorageLinkObject.code += 1;\n        })\n    }\n  }\n}
[h2]不建议借助@StorageLink的双向同步机制实现事件通知
不建议开发者使用@StorageLink和AppStorage的双向同步的机制来实现事件通知，因为AppStorage中的变量可能绑定在多个不同页面的组件中，但事件通知则不一定需要通知到所有的这些组件。并且，当这些@StorageLink装饰的变量在UI中使用时，会触发UI刷新，带来不必要的性能影响。
示例代码中，TapImage中的点击事件，会触发AppStorage中tapIndex对应属性的改变。因为@StorageLink是双向同步，修改会同步回AppStorage中，所以，所有绑定AppStorage的tapIndex自定义组件里都能感知到tapIndex的变化。使用@Watch监听到tapIndex的变化后，修改状态变量tapColor从而触发UI刷新（此处tapIndex并未直接绑定在UI上，因此tapIndex的变化不会直接触发UI刷新）。
使用该机制来实现事件通知需要确保AppStorage中的变量尽量不要直接绑定在UI上，且需要控制@Watch函数的复杂度（如果@Watch函数执行时间长，会影响UI刷新效率）。
// xxx.ets\nclass ViewData {\n  title: string;\n  uri: Resource;\n  color: Color = Color.Black;\n\n  constructor(title: string, uri: Resource) {\n    this.title = title;\n    this.uri = uri\n  }\n}\n\n@Entry\n@Component\nstruct Gallery {\n  // 此处'app.media.icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。\n  dataList: Array<ViewData> = [new ViewData('flower', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon'))]\n  scroller: Scroller = new Scroller()\n\n  build() {\n    Column() {\n      Grid(this.scroller) {\n        ForEach(this.dataList, (item: ViewData, index?: number) => {\n          GridItem() {\n            TapImage({\n              uri: item.uri,\n              index: index\n            })\n          }.aspectRatio(1)\n\n        }, (item: ViewData, index?: number) => {\n          return JSON.stringify(item) + index;\n        })\n      }.columnsTemplate('1fr 1fr')\n    }\n\n  }\n}\n\n@Component\nexport struct TapImage {\n  @StorageLink('tapIndex') @Watch('onTapIndexChange') tapIndex: number = -1;\n  @State tapColor: Color = Color.Black;\n  private index: number = 0;\n  private uri: Resource = {\n    id: 0,\n    type: 0,\n    moduleName: \"\",\n    bundleName: \"\"\n  };\n\n  // 判断是否被选中\n  onTapIndexChange() {\n    if (this.tapIndex >= 0 && this.index === this.tapIndex) {\n      console.info(`tapindex: ${this.tapIndex}, index: ${this.index}, red`)\n      this.tapColor = Color.Red;\n    } else {\n      console.info(`tapindex: ${this.tapIndex}, index: ${this.index}, black`)\n      this.tapColor = Color.Black;\n    }\n  }\n\n  build() {\n    Column() {\n      Image(this.uri)\n        .objectFit(ImageFit.Cover)\n        .onClick(() => {\n          this.tapIndex = this.index;\n        })\n        .border({ width: 5, style: BorderStyle.Dotted, color: this.tapColor })\n    }\n\n  }\n}
相比借助@StorageLink的双向同步机制实现事件通知，开发者可以使用emit订阅某个事件并接收事件回调的方式来减少开销，增强代码的可读性。
emit接口不支持在Previewer预览器中使用。
// xxx.ets\nimport { emitter } from '@kit.BasicServicesKit';\n\nlet NextID: number = 0;\n\nclass ViewData {\n  title: string;\n  uri: Resource;\n  color: Color = Color.Black;\n  id: number;\n\n  constructor(title: string, uri: Resource) {\n    this.title = title;\n    this.uri = uri\n    this.id = NextID++;\n  }\n}\n\n@Entry\n@Component\nstruct Gallery {\n  // 此处'app.media.icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。\n  dataList: Array<ViewData> = [new ViewData('flower', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon'))]\n  scroller: Scroller = new Scroller()\n  private preIndex: number = -1\n\n  build() {\n    Column() {\n      Grid(this.scroller) {\n        ForEach(this.dataList, (item: ViewData) => {\n          GridItem() {\n            TapImage({\n              uri: item.uri,\n              index: item.id\n            })\n          }.aspectRatio(1)\n          .onClick(() => {\n            if (this.preIndex === item.id) {\n              return\n            }\n            let innerEvent: emitter.InnerEvent = { eventId: item.id }\n            // 选中态：黑变红\n            let eventData: emitter.EventData = {\n              data: {\n                \"colorTag\": 1\n              }\n            }\n            emitter.emit(innerEvent, eventData)\n\n            if (this.preIndex != -1) {\n              console.info(`preIndex: ${this.preIndex}, index: ${item.id}, black`)\n              let innerEvent: emitter.InnerEvent = { eventId: this.preIndex }\n              // 取消选中态：红变黑\n              let eventData: emitter.EventData = {\n                data: {\n                  \"colorTag\": 0\n                }\n              }\n              emitter.emit(innerEvent, eventData)\n            }\n            this.preIndex = item.id\n          })\n        }, (item: ViewData) => JSON.stringify(item))\n      }.columnsTemplate('1fr 1fr')\n    }\n\n  }\n}\n\n@Component\nexport struct TapImage {\n  @State tapColor: Color = Color.Black;\n  private index: number = 0;\n  private uri: Resource = {\n    id: 0,\n    type: 0,\n    moduleName: \"\",\n    bundleName: \"\"\n  };\n\n  onTapIndexChange(colorTag: emitter.EventData) {\n    if (colorTag.data != null) {\n      this.tapColor = colorTag.data.colorTag ? Color.Red : Color.Black\n    }\n  }\n\n  aboutToAppear() {\n    //定义事件ID\n    let innerEvent: emitter.InnerEvent = { eventId: this.index }\n    emitter.on(innerEvent, data => {\n    this.onTapIndexChange(data)\n    })\n  }\n\n  build() {\n    Column() {\n      Image(this.uri)\n        .objectFit(ImageFit.Cover)\n        .border({ width: 5, style: BorderStyle.Dotted, color: this.tapColor })\n    }\n  }\n}
以上通知事件逻辑简单，也可以简化成三元表达式。
// xxx.ets\nclass ViewData {\n  title: string;\n  uri: Resource;\n  color: Color = Color.Black;\n\n  constructor(title: string, uri: Resource) {\n    this.title = title;\n    this.uri = uri\n  }\n}\n\n@Entry\n@Component\nstruct Gallery {\n  // 此处'app.media.icon'仅作示例，请开发者自行替换，否则imageSource创建失败会导致后续无法正常执行。\n  dataList: Array<ViewData> = [new ViewData('flower', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon'))]\n  scroller: Scroller = new Scroller()\n\n  build() {\n    Column() {\n      Grid(this.scroller) {\n        ForEach(this.dataList, (item: ViewData, index?: number) => {\n          GridItem() {\n            TapImage({\n              uri: item.uri,\n              index: index\n            })\n          }.aspectRatio(1)\n\n        }, (item: ViewData, index?: number) => {\n          return JSON.stringify(item) + index;\n        })\n      }.columnsTemplate('1fr 1fr')\n    }\n\n  }\n}\n\n@Component\nexport struct TapImage {\n  @StorageLink('tapIndex') tapIndex: number = -1;\n  private index: number = 0;\n  private uri: Resource = {\n    id: 0,\n    type: 0,\n    moduleName: \"\",\n    bundleName: \"\"\n  };\n\n  build() {\n    Column() {\n      Image(this.uri)\n        .objectFit(ImageFit.Cover)\n        .onClick(() => {\n          this.tapIndex = this.index;\n        })\n        .border({\n          width: 5,\n          style: BorderStyle.Dotted,\n          color: (this.tapIndex >= 0 && this.index === this.tapIndex) ? Color.Red : Color.Black\n        })\n    }\n  }\n}
[h2]AppStorage支持联合类型
在下面的示例中，变量A的类型为number | null，变量B的类型为number | undefined。Text组件初始化分别显示为null和undefined，点击切换为数字，再次点击切换回null和undefined。
@Component\nstruct StorLink {\n  @StorageLink(\"LinkA\") LinkA: number | null = null;\n  @StorageLink(\"LinkB\") LinkB: number | undefined = undefined;\n\n  build() {\n    Column() {\n      Text(\"@StorageLink接口初始化，@StorageLink取值\")\n      Text(this.LinkA + \"\").fontSize(20).onClick(() => {\n        this.LinkA ? this.LinkA = null : this.LinkA = 1;\n      })\n      Text(this.LinkB + \"\").fontSize(20).onClick(() => {\n        this.LinkB ? this.LinkB = undefined : this.LinkB = 1;\n      })\n    }\n    .borderWidth(3).borderColor(Color.Red)\n\n  }\n}\n\n@Component\nstruct StorProp {\n  @StorageProp(\"PropA\") PropA: number | null = null;\n  @StorageProp(\"PropB\") PropB: number | undefined = undefined;\n\n  build() {\n    Column() {\n      Text(\"@StorageProp接口初始化，@StorageProp取值\")\n      Text(this.PropA + \"\").fontSize(20).onClick(() => {\n        this.PropA ? this.PropA = null : this.PropA = 1;\n      })\n      Text(this.PropB + \"\").fontSize(20).onClick(() => {\n        this.PropB ? this.PropB = undefined : this.PropB = 1;\n      })\n    }\n    .borderWidth(3).borderColor(Color.Blue)\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Row() {\n      Column() {\n        StorLink()\n        StorProp()\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]装饰Date类型变量
从API version 12开始，AppStorage支持Date类型。
在下面的示例中，@StorageLink装饰的selectedDate类型为Date，点击Button改变selectedDate的值，视图会随之刷新。
@Entry\n@Component\nstruct DateSample {\n  @StorageLink(\"date\") selectedDate: Date = new Date('2021-08-08');\n\n  build() {\n    Column() {\n      Button('set selectedDate to 2023-07-08')\n        .margin(10)\n        .onClick(() => {\n          AppStorage.setOrCreate(\"date\", new Date('2023-07-08'));\n        })\n      Button('increase the year by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setFullYear(this.selectedDate.getFullYear() + 1);\n        })\n      Button('increase the month by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setMonth(this.selectedDate.getMonth() + 1);\n        })\n      Button('increase the day by 1')\n        .margin(10)\n        .onClick(() => {\n          this.selectedDate.setDate(this.selectedDate.getDate() + 1);\n        })\n      DatePicker({\n        start: new Date('1970-1-1'),\n        end: new Date('2100-1-1'),\n        selected: $$this.selectedDate\n      })\n    }.width('100%')\n  }\n}
[h2]装饰Map类型变量
从API version 12开始，AppStorage支持Map类型。
在下面的示例中，@StorageLink装饰的message类型为Map<number, string>，点击Button改变message的值，视图会随之刷新。
@Entry\n@Component\nstruct MapSample {\n  @StorageLink(\"map\") message: Map<number, string> = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.message.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`).fontSize(30)\n          Text(`${item[1]}`).fontSize(30)\n          Divider()\n        })\n        Button('init map').onClick(() => {\n          this.message = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]]);\n        })\n        Button('set new one').onClick(() => {\n          this.message.set(4, \"d\");\n        })\n        Button('clear').onClick(() => {\n          this.message.clear();\n        })\n        Button('replace the existing one').onClick(() => {\n          this.message.set(0, \"aa\");\n        })\n        Button('delete the existing one').onClick(() => {\n          AppStorage.get<Map<number, string>>(\"map\")?.delete(0);\n        })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]装饰Set类型变量
从API version 12开始，AppStorage支持Set类型。
在下面的示例中，@StorageLink装饰的memberSet类型为Set<number>，点击Button改变memberSet的值，视图会随之刷新。
@Entry\n@Component\nstruct SetSample {\n  @StorageLink(\"set\") memberSet: Set<number> = new Set([0, 1, 2, 3, 4]);\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.memberSet.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`)\n            .fontSize(30)\n          Divider()\n        })\n        Button('init set')\n          .onClick(() => {\n            this.memberSet = new Set([0, 1, 2, 3, 4]);\n          })\n        Button('set new one')\n          .onClick(() => {\n            AppStorage.get<Set<number>>(\"set\")?.add(5);\n          })\n        Button('clear')\n          .onClick(() => {\n            this.memberSet.clear();\n          })\n        Button('delete the first one')\n          .onClick(() => {\n            this.memberSet.delete(0);\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
常见问题
[h2]@StorageProp本地更改值后，无法通过AppStorage接口更新
AppStorage.setOrCreate('PropA', false);\n\n@Entry\n@Component\nstruct Index {\n  @StorageProp('PropA') @Watch('onChange') propA: boolean = false;\n\n  onChange() {\n    console.log(`propA change`);\n  }\n\n  aboutToAppear(): void {\n    this.propA = true;\n  }\n\n  build() {\n    Column() {\n      Text(`${this.propA}`)\n      Button('change')\n        .onClick(() => {\n          AppStorage.setOrCreate('PropA', false);\n          console.log(`PropA: ${this.propA}`);\n        })\n    }\n  }\n}
上述示例，在点击事件之前，PropA的值已经在本地被更改为true，而AppStorage中存的值仍为false。当点击事件通过setOrCreate接口尝试更新PropA的值为false时，由于AppStorage中的值为false，两者相等，不会触发更新同步，因此@StorageProp的值仍为true。
如果想要实现二者同步，有两种方式：
（1）将@StorageProp更改为@StorageLink。
（2）本地更改值的方式变为使用AppStorage.setOrCreate('PropA', true)的方式。

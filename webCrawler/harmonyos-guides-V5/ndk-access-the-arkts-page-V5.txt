接入ArkTS页面
占位组件
使用NDK接口构建UI界面时，需要在ArkTS页面创建用于挂载NDK接口创建组件的占位组件。占位组件类型为ContentSlot，ContentSlot能够绑定一个NodeContent对象，该对象可通过Node-API传递到Native侧挂载显示Native组件。
 占位组件和其他ArkTS内置组件使用方法相同。详细代码请参考示例。 import { NodeContent } from '@kit.ArkUI';\nimport nativeNode from 'libentry.so';\n\n@Entry\n@Component\nstruct Index {\n  // 初始化NodeContent对象。\n  private rootSlot = new NodeContent();\n  @State @Watch('changeNativeFlag') showNative: boolean = false;\n\n  changeNativeFlag(): void {\n    if (this.showNative) {\n      // 传递NodeContent对象用于Native创建组件的挂载显示\n      nativeNode.createNativeRoot(this.rootSlot)\n    } else {\n      // 销毁NativeModule组件\n      nativeNode.destroyNativeRoot()\n    }\n  }\n\n  build() {\n    Column() {\n      Button(this.showNative ? \"HideNativeUI\" : \"ShowNativeUI\").onClick(() => {\n        this.showNative = !this.showNative\n      })\n      Row() {\n        // 将NodeContent和ContentSlot占位组件绑定。\n        ContentSlot(this.rootSlot)\n      }.layoutWeight(1)\n    }\n    .width('100%')\n    .height('100%')\n  }\n} 占位组件可以通过相关接口在Native侧转化为挂载对象。 ArkUI_NodeContentHandle contentHandle;\nOH_ArkUI_GetNodeContentFromNapiValue(env, args[0], &contentHandle); 挂载对象提供了相关挂载和卸载组件接口。 OH_ArkUI_NodeContent_AddNode(handle_, myNativeNode);\nOH_ArkUI_NodeContent_RemoveNode(handle_, myNativeNode); 
NDK组件模块
NDK提供的UI组件能力如组件创建、树操作、属性设置、事件注册等是通过函数指针结构体(如ArkUI_NativeNodeAPI_1）进行暴露，该函数指针结构体可以通过模块查询接口获取。
ArkUI_NativeNodeAPI_1* arkUINativeNodeApi = nullptr;\nOH_ArkUI_GetModuleInterface(ARKUI_NATIVE_NODE, ArkUI_NativeNodeAPI_1, arkUINativeNodeApi);
在获取到函数指针结构体后，可以使用该结构体内的函数实现相关UI组件操作。
 组件创建和销毁。 auto listNode = arkUINativeNodeApi->createNode(ARKUI_NODE_LIST);\narkUINativeNodeApi->disposeNode(listNode); 获取NDK接口支持的组件范围可以通过查询ArkUI_NodeType枚举值。 组件树操作。 auto parent = arkUINativeNodeApi->createNode(ARKUI_NODE_STACK);\nauto child = arkUINativeNodeApi->createNode(ARKUI_NODE_STACK);\narkUINativeNodeApi->addChild(parent, child);\narkUINativeNodeApi->removeChild(parent, child); 属性设置。 auto stack = arkUINativeNodeApi->createNode(ARKUI_NODE_STACK);\nArkUI_NumberValue value[] = {{.f32 = 100}};\nArkUI_AttributeItem item = {value, 1};\narkUINativeNodeApi->setAttribute(stack, NODE_WIDTH, &item);\nArkUI_NumberValue value[] = {{.u32 = 0xff112233}};\nArkUI_AttributeItem item = {value, 1};\narkUINativeNodeApi->setAttribute(stack, NODE_BACKGROUND_COLOR, &item); 获取NDK接口支持的属性范围可以通过查询ArkUI_NodeAttributeType枚举值。 事件注册。 auto stack = arkUINativeNodeApi->createNode(ARKUI_NODE_STACK);\narkUINativeNodeApi->addNodeEventReceiver(stack, [](ArkUI_NodeEvent* event){\n    // process event\n});\narkUINativeNodeApi->registerNodeEvent(stack, NODE_ON_CLICK, 0, nullptr); 获取NDK接口支持的事件范围可以通过查询ArkUI_NodeEventType枚举值。 
示例
下面的示例展示了如何使用ContentSlot挂载Native侧的文本列表。
图1 Native文本列表
 在ArkTS页面上声明用于Native页面挂载的占位组件，并在页面创建时通知Native侧创建文本列表。 import nativeNode from 'libentry.so';\nimport { NodeContent } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct Index {\n  // 初始化NodeContent对象。\n  private rootSlot = new NodeContent();\n  @State @Watch('changeNativeFlag') showNative: boolean = false;\n\n  changeNativeFlag(): void {\n    if (this.showNative) {\n      // 传递NodeContent对象用于Native创建组件的挂载显示\n      nativeNode.createNativeRoot(this.rootSlot)\n    } else {\n      // 销毁NativeModule组件\n      nativeNode.destroyNativeRoot()\n    }\n  }\n\n  build() {\n    Column() {\n      Button(this.showNative ? \"HideNativeUI\" : \"ShowNativeUI\").onClick(() => {\n        this.showNative = !this.showNative\n      })\n      Row() {\n        // 将NodeContent和ContentSlot占位组件绑定。\n        ContentSlot(this.rootSlot)\n      }.layoutWeight(1)\n    }\n    .width('100%')\n    .height('100%')\n  }\n} 使用Native模板创建工程，并在Native侧提供Node-API的桥接方法，实现ArkTS侧的NativeNode模块接口。 接口声明。 // entry/src/main/cpp/types/libentry/Index.d.ts\n\nexport const createNativeRoot: (content: Object) => void;\nexport const destroyNativeRoot: () => void; Native实现。 // entry/src/main/cpp/napi_init.cpp\n#include \"napi/native_api.h\"\n#include \"NativeEntry.h\"\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports) {\n    // 绑定Native侧的创建组件和销毁组件。\n    napi_property_descriptor desc[] = {\n        {\"createNativeRoot\", nullptr, NativeModule::CreateNativeRoot, nullptr, nullptr, nullptr, napi_default, nullptr},\n        {\"destroyNativeRoot\", nullptr, NativeModule::DestroyNativeRoot, nullptr, nullptr, nullptr, napi_default, nullptr}};\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void *)0),\n    .reserved = {0},\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void) { napi_module_register(&demoModule); } 在NativeEntry.h文件中创建Native界面。 // NativeEntry.h\n\n#ifndef MYAPPLICATION_NATIVEENTRY_H\n#define MYAPPLICATION_NATIVEENTRY_H\n\n#include <ArkUIBaseNode.h>\n#include <arkui/native_type.h>\n#include <js_native_api_types.h>\n#include <memory.h>\n\nnamespace NativeModule {\n\nnapi_value CreateNativeRoot(napi_env env, napi_callback_info info);\n\nnapi_value DestroyNativeRoot(napi_env env, napi_callback_info info);\n\n// 管理Native组件的生命周期和内存。\nclass NativeEntry {\npublic:\n    static NativeEntry *GetInstance() {\n        static NativeEntry nativeEntry;\n        return &nativeEntry;\n    }\n\n    void SetContentHandle(ArkUI_NodeContentHandle handle) {\n        handle_ = handle;\n    }\n\n    void SetRootNode(const std::shared_ptr<ArkUIBaseNode> &baseNode) {\n        root_ = baseNode;\n        // 添加Native组件到NodeContent上用于挂载显示。\n        OH_ArkUI_NodeContent_AddNode(handle_, root_->GetHandle());\n    }\n    void DisposeRootNode() {\n        // 从NodeContent上卸载组件并销毁Native组件。\n        OH_ArkUI_NodeContent_RemoveNode(handle_, root_->GetHandle());\n        root_.reset();\n    }\n\nprivate:\n    std::shared_ptr<ArkUIBaseNode> root_;\n    ArkUI_NodeContentHandle handle_;\n};\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_NATIVEENTRY_H 对应实现文件。 // NativeEntry.cpp\n\n#include <arkui/native_node_napi.h>\n#include <hilog/log.h>\n#include <js_native_api.h>\n#include \"NativeEntry.h\"\n\nnamespace NativeModule {\n\nnapi_value CreateNativeRoot(napi_env env, napi_callback_info info) {\n    size_t argc = 1;\n    napi_value args[1] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n    // 获取NodeContent\n    ArkUI_NodeContentHandle contentHandle;\n    OH_ArkUI_GetNodeContentFromNapiValue(env, args[0], &contentHandle);\n    NativeEntry::GetInstance()->SetContentHandle(contentHandle);\n\n    // 创建文本列表\n    auto list = CreateTextListExample();\n\n    // 保持Native侧对象到管理类中，维护生命周期。\n    NativeEntry::GetInstance()->SetRootNode(list);\n    return nullptr;\n}\n\nnapi_value DestroyNativeRoot(napi_env env, napi_callback_info info) {\n    // 从管理类中释放Native侧对象。\n    NativeEntry::GetInstance()->DisposeRootNode();\n    return nullptr;\n}\n\n} // namespace NativeModule 使用NDK 提供的C接口需要在CMakeLists.txt 中增加libace_ndk.z.so 的引用，如下所示，其中entry为工程导出的动态库名称，如当前示例使用的是默认的名称 libentry.so。 target_link_libraries(entry PUBLIC libace_napi.z.so libace_ndk.z.so) 由于NDK接口提供的是C接口，为了使用面向对象的方式简化编程和工程管理，这里建议使用C++进行二次封装，下面示例代码展示了示例界面中所需的列表，文本组件封装类。 1）获取ArkUI在NDK接口的入口模块ArkUI_NativeNodeAPI_1，该结构体模块提供了一系列组件创建、树构建、属性设置和事件注册等函数指针。 // NativeModule.h\n// 提供获取ArkUI在Native侧模块的封装接口\n\n#ifndef MYAPPLICATION_NATIVEMODULE_H\n#define MYAPPLICATION_NATIVEMODULE_H\n\n#include <arkui/native_node.h>\n#include <functional>\n#include <cassert>\n\n#include <arkui/native_interface.h>\n\nnamespace NativeModule {\n\nclass NativeModuleInstance {\npublic:\n    static NativeModuleInstance *GetInstance() {\n        static NativeModuleInstance instance;\n        return &instance;\n    }\n\n    NativeModuleInstance() {\n        // 获取NDK接口的函数指针结构体对象，用于后续操作。\n        OH_ArkUI_GetModuleInterface(ARKUI_NATIVE_NODE, ArkUI_NativeNodeAPI_1, arkUINativeNodeApi_);\n        assert(arkUINativeNodeApi_);\n    }\n    // 暴露给其他模块使用。\n    ArkUI_NativeNodeAPI_1 *GetNativeNodeAPI() { return arkUINativeNodeApi_; }\n\nprivate:\n    ArkUI_NativeNodeAPI_1 *arkUINativeNodeApi_ = nullptr;\n};\n\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_NATIVEMODULE_H 2）提供列表，文本组件的基类对象，用于封装通用属性和事件。 // ArkUIBaseNode.h\n// 提供组件树操作的基类。\n\n#ifndef MYAPPLICATION_ARKUIBASENODE_H\n#define MYAPPLICATION_ARKUIBASENODE_H\n\n#include <arkui/native_type.h>\n#include <list>\n#include <memory>\n\n#include \"NativeModule.h\"\n\nnamespace NativeModule {\n\nclass ArkUIBaseNode {\npublic:\n    explicit ArkUIBaseNode(ArkUI_NodeHandle handle)\n        : handle_(handle), nativeModule_(NativeModuleInstance::GetInstance()->GetNativeNodeAPI()) {}\n\n    virtual ~ArkUIBaseNode() {\n        // 封装析构函数，实现子节点移除功能。\n        if (!children_.empty()) {\n            for (const auto& child : children_) {\n                nativeModule_->removeChild(handle_, child->GetHandle());\n            }\n            children_.clear();\n        }\n        // 封装析构函数，统一回收节点资源。 \n        nativeModule_->disposeNode(handle_);\n    }\n\n    void AddChild(const std::shared_ptr<ArkUIBaseNode> &child) {\n        children_.emplace_back(child);\n        OnAddChild(child);\n    }\n\n    void RemoveChild(const std::shared_ptr<ArkUIBaseNode> &child) {\n        children_.remove(child);\n        OnRemoveChild(child);\n    }\n\n    void InsertChild(const std::shared_ptr<ArkUIBaseNode> &child, int32_t index) {\n        if (index >= children_.size()) {\n            AddChild(child);\n        } else {\n            auto iter = children_.begin();\n            std::advance(iter, index);\n            children_.insert(iter, child);\n            OnInsertChild(child, index);\n        }\n    }\n\n    ArkUI_NodeHandle GetHandle() const { return handle_; }\n\nprotected:\n    // 针对父容器子类需要重载下面的函数，实现组件挂载和卸载。\n    virtual void OnAddChild(const std::shared_ptr<ArkUIBaseNode> &child) {}\n    virtual void OnRemoveChild(const std::shared_ptr<ArkUIBaseNode> &child) {}\n    virtual void OnInsertChild(const std::shared_ptr<ArkUIBaseNode> &child, int32_t index) {}\n\n    ArkUI_NodeHandle handle_;\n    ArkUI_NativeNodeAPI_1 *nativeModule_ = nullptr;\n\nprivate:\n    std::list<std::shared_ptr<ArkUIBaseNode>> children_;\n};\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUIBASENODE_H // ArkUINode.h\n// 提供通用属性和事件的封装。\n\n#ifndef MYAPPLICATION_ARKUINODE_H\n#define MYAPPLICATION_ARKUINODE_H\n\n#include \"ArkUIBaseNode.h\"\n#include \"NativeModule.h\"\n#include <arkui/native_node.h>\n#include <arkui/native_type.h>\n\nnamespace NativeModule {\n\nclass ArkUINode : public ArkUIBaseNode {\npublic:\n    explicit ArkUINode(ArkUI_NodeHandle handle) : ArkUIBaseNode(handle) {}\n\n    ~ArkUINode() override {}\n\n    // NDK相关通用属性调用封装\n    void SetWidth(float width) {\n        assert(handle_);\n        ArkUI_NumberValue value[] = {{.f32 = width}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_WIDTH, &item);\n    }\n    void SetPercentWidth(float percent) {\n        assert(handle_);\n        ArkUI_NumberValue value[] = {{.f32 = percent}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_WIDTH_PERCENT, &item);\n    }\n    void SetHeight(float height) {\n        assert(handle_);\n        ArkUI_NumberValue value[] = {{.f32 = height}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_HEIGHT, &item);\n    }\n    void SetPercentHeight(float percent) {\n        assert(handle_);\n        ArkUI_NumberValue value[] = {{.f32 = percent}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_HEIGHT_PERCENT, &item);\n    }\n    void SetBackgroundColor(uint32_t color) {\n        assert(handle_);\n        ArkUI_NumberValue value[] = {{.u32 = color}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_BACKGROUND_COLOR, &item);\n    }\n\nprotected:\n    // 组件树操作的实现类对接。\n    void OnAddChild(const std::shared_ptr<ArkUIBaseNode> &child) override {\n        nativeModule_->addChild(handle_, child->GetHandle());\n    }\n    void OnRemoveChild(const std::shared_ptr<ArkUIBaseNode> &child) override {\n        nativeModule_->removeChild(handle_, child->GetHandle());\n    }\n    void OnInsertChild(const std::shared_ptr<ArkUIBaseNode> &child, int32_t index) override {\n        nativeModule_->insertChildAt(handle_, child->GetHandle(), index);\n    }\n};\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUINODE_H 3）实现列表组件。 // ArkUIListNode.h\n// 提供列表组件的封装。\n\n#ifndef MYAPPLICATION_ARKUILISTNODE_H\n#define MYAPPLICATION_ARKUILISTNODE_H\n\n#include \"ArkUINode.h\"\n\nnamespace NativeModule {\nclass ArkUIListNode : public ArkUINode {\npublic:\n    ArkUIListNode()\n        : ArkUINode((NativeModuleInstance::GetInstance()->GetNativeNodeAPI())->createNode(ARKUI_NODE_LIST)) {} // 创建ArkUI的列表组件。\n\n    ~ArkUIListNode() override {} \n    // List组件的属性NDK接口封装。\n    void SetScrollBarState(bool isShow) {\n        assert(handle_);\n        ArkUI_ScrollBarDisplayMode displayMode =\n            isShow ? ARKUI_SCROLL_BAR_DISPLAY_MODE_ON : ARKUI_SCROLL_BAR_DISPLAY_MODE_OFF;\n        ArkUI_NumberValue value[] = {{.i32 = displayMode}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_SCROLL_BAR_DISPLAY_MODE, &item);\n    }\n};\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUILISTNODE_H 4）实现列表项组件。 // ArkUIListItemNode.h\n// 提供列表项的封装类。\n\n#ifndef MYAPPLICATION_ARKUISTACKNODE_H\n#define MYAPPLICATION_ARKUISTACKNODE_H\n\n#include \"ArkUINode.h\"\n\nnamespace NativeModule {\nclass ArkUIListItemNode : public ArkUINode {\npublic:\n    ArkUIListItemNode()\n        : ArkUINode((NativeModuleInstance::GetInstance()->GetNativeNodeAPI())->createNode(ARKUI_NODE_LIST_ITEM)) {}\n};\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUISTACKNODE_H 5）实现文本组件。 // ArkUITextNode.h\n// 实现文本组件的封装类。\n\n#ifndef MYAPPLICATION_ARKUITEXTNODE_H\n#define MYAPPLICATION_ARKUITEXTNODE_H\n\n#include \"ArkUINode.h\"\n\n#include <string>\n\nnamespace NativeModule {\nclass ArkUITextNode : public ArkUINode {\npublic:\n    ArkUITextNode()\n        : ArkUINode((NativeModuleInstance::GetInstance()->GetNativeNodeAPI())->createNode(ARKUI_NODE_TEXT)) {}\n    // 文本属性NDK接口封装。\n    void SetFontSize(float fontSize) {\n        assert(handle_);\n        ArkUI_NumberValue value[] = {{.f32 = fontSize}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_FONT_SIZE, &item);\n    }\n    void SetFontColor(uint32_t color) {\n        assert(handle_);\n        ArkUI_NumberValue value[] = {{.u32 = color}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_FONT_COLOR, &item);\n    }\n    void SetTextContent(const std::string &content) {\n        assert(handle_);\n        ArkUI_AttributeItem item = {nullptr, 0, content.c_str()};\n        nativeModule_->setAttribute(handle_, NODE_TEXT_CONTENT, &item);\n    }\n    void SetTextAlign(ArkUI_TextAlignment align) {\n        assert(handle_);\n        ArkUI_NumberValue value[] = {{.i32 = align}};\n        ArkUI_AttributeItem item = {value, 1};\n        nativeModule_->setAttribute(handle_, NODE_TEXT_ALIGN, &item);\n    }\n};\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_ARKUITEXTNODE_H 完善步骤3的CreateTextListExample函数，实现Native文本列表的创建和挂载显示。 // NormalTextListExample.h\n// 自定义NDK接口入口函数。\n\n#ifndef MYAPPLICATION_NORMALTEXTLISTEXAMPLE_H\n#define MYAPPLICATION_NORMALTEXTLISTEXAMPLE_H\n\n#include \"ArkUIBaseNode.h\"\n#include \"ArkUIListItemNode.h\"\n#include \"ArkUIListNode.h\"\n#include \"ArkUITextNode.h\"\n#include <hilog/log.h>\n\nnamespace NativeModule {\n\nstd::shared_ptr<ArkUIBaseNode> CreateTextListExample() {\n    // 创建组件并挂载\n    // 1：使用智能指针创建List组件。\n    auto list = std::make_shared<ArkUIListNode>();\n    list->SetPercentWidth(1);\n    list->SetPercentHeight(1);\n    list->SetScrollBarState(true);\n    // 2：创建ListItem子组件并挂载到List上。\n    for (int32_t i = 0; i < 30; ++i) {\n        auto listItem = std::make_shared<ArkUIListItemNode>();\n        auto textNode = std::make_shared<ArkUITextNode>();\n        textNode->SetTextContent(std::to_string(i));\n        textNode->SetFontSize(16);\n        textNode->SetFontColor(0xFFff00ff);\n        textNode->SetPercentWidth(1);\n        textNode->SetWidth(300);\n        textNode->SetHeight(100);\n        textNode->SetBackgroundColor(0xFFfffacd);\n        textNode->SetTextAlign(ARKUI_TEXT_ALIGNMENT_CENTER);\n        listItem->InsertChild(textNode, i);\n        list->AddChild(listItem);\n    }\n    return list;\n}\n} // namespace NativeModule\n\n#endif // MYAPPLICATION_NORMALTEXTLISTEXAMPLE_H 

空域AI超分
XEngine Kit提供空域AI超分能力，基于单帧图像使用AI推理生成滤波参数进行超采样，通过GPU、NPU协同工作，实现比空域GPU超分更好的画质，建议超分倍率在1.5倍以下时使用。
接口说明
以下接口为GLES空域AI超分设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
接口名
描述
const GLubyte * HMS_XEG_GetString (GLenum name)
XEngine GLES扩展特性查询接口。
GL_APICALL void GL_APIENTRY HMS_XEG_NeuralUpscaleParameter (GLenum pname, GLvoid * param)
设置空域AI超分输入参数。
GL_APICALL void GL_APIENTRY HMS_XEG_RenderNeuralUpscale (GLuint inputTexture)
执行空域AI超分渲染命令。
开发步骤
本章以GLES图像API集成为例，说明XEngine集成操作过程。
[h2]配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
 头文件引用#include <cstring>\n#include <cstdlib>\n#include <EGL/egl.h>\n#include <EGL/eglext.h>\n#include <GLES2/gl2.h>\n#include <GLES2/gl2ext.h>\n#include <xengine/xeg_gles_extension.h>\n#include <xengine/xeg_gles_neural_upscale.h>\n#include <native_buffer/native_buffer.h>\n#include <native_window/external_window.h> 编写CMakeLists.txt               CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-GLES）。        find_library(\n    # Sets the name of the path variable.\n    native-buffer-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    native_buffer\n)\nfind_library(\n    # Sets the name of the path variable.\n    native-window-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    native_window\n)\nfind_library(\n    # Sets the name of the path variable.\n    xengine-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    xengine\n)\nfind_library(\n    # Sets the name of the path variable.\n    EGL-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    EGL\n)\nfind_library(\n    # Sets the name of the path variable.\n    GLES-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    GLESv3\n)\n\ntarget_link_libraries(nativerender PUBLIC\n${EGL-lib} ${GLES-lib} ${xengine-lib} ${native-window-lib} ${native-buffer-lib})  
[h2]集成XEngine空域AI超分（GLES）
Native层实现使用GLES和XEngine图形API搭建图像渲染管线并集成空域AI超分，渲染结果通过XComponent组件显示到屏幕。
本节阐述GLES图形API的空域AI超分的使用，详细代码请参见Demo（GPU加速引擎-GLES）。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
 调用HMS_XEG_GetString接口，获取XEngine支持的扩展信息，只有在支持XEG_NEURAL_UPSCALE_EXTENSION_NAME扩展时才可以使用空域AI超分的相关接口。// 查询XEngine支持的GLES扩展信息\nconst char* extensions = (const char*)HMS_XEG_GetString(XEG_EXTENSIONS);\n// 检查是否支持空域AI超分\nif (!strstr(extensions, XEG_NEURAL_UPSCALE_EXTENSION_NAME)) {\n    exit(1); // return error\n}  创建输入纹理，并关联一个OH_NativeBuffer。// 渲染宽高和送显宽高均为用户自定义参数，这里以将800*600的分辨率进行1.5倍超分到1200*900的分辨率为例\nuint32_t renderWidth = 800;\nuint32_t renderHeight = 600;\nuint32_t displayWidth = 1200;\nuint32_t displayHeight = 900;\n// 获取函数指针\nPFNEGLCREATEIMAGEKHRPROC fp_eglCreateImageKHR = reinterpret_cast<PFNEGLCREATEIMAGEKHRPROC>(eglGetProcAddress(\"eglCreateImageKHR\"));\nPFNEGLDESTROYIMAGEKHRPROC fp_eglDestroyImageKHR = reinterpret_cast<PFNEGLDESTROYIMAGEKHRPROC>(eglGetProcAddress(\"eglDestroyImageKHR\"));\nPFNGLEGLIMAGETARGETTEXTURE2DOESPROC fp_glEGLImageTargetTexture2DOES = reinterpret_cast<PFNGLEGLIMAGETARGETTEXTURE2DOESPROC>(eglGetProcAddress(\"glEGLImageTargetTexture2DOES\"));\n// 创建OH_NativeBuffer\nOH_NativeBuffer_Config config = {};\nconfig.width = renderWidth;\nconfig.height = renderHeight;\nconfig.usage = NATIVEBUFFER_USAGE_CPU_READ | NATIVEBUFFER_USAGE_CPU_READ_OFTEN | NATIVEBUFFER_USAGE_HW_TEXTURE | NATIVEBUFFER_USAGE_HW_RENDER| NATIVEBUFFER_USAGE_ALIGNMENT_512;\nconfig.format = NATIVEBUFFER_PIXEL_FMT_RGBA_8888;\nOH_NativeBuffer* bufferHandle = OH_NativeBuffer_Alloc(&config);\nif (bufferHandle == nullptr) {\n    // 创建失败，用户可自定义错误处理\n}\nOHNativeWindowBuffer *nativeWindowBuffer = OH_NativeWindow_CreateNativeWindowBufferFromNativeBuffer(bufferHandle);\nEGLImageKHR eglImage = fp_eglCreateImageKHR(eglGetCurrentDisplay(), EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_OHOS, static_cast<EGLClientBuffer>(nativeWindowBuffer), nullptr);\n// 创建超分输入纹理\nGLuint textureID; \nglGenTextures(1, &textureID);\nglBindTexture(GL_TEXTURE_2D, textureID);\n// 设置纹理环绕和过滤参数\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n// 关联超分输入纹理和eglImage\nfp_glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, eglImage);  在超分输入纹理上进行渲染。GLuint fboID = 0;\nglGenFramebuffers(1, &fboID);\nglBindFramebuffer(GL_FRAMEBUFFER, fboID);\nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureID, 0);\nif (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {\n    // 创建framebuffer失败，用户可自定义错误处理\n}\nglViewport(0, 0, renderWidth, renderHeight);  调用HMS_XEG_NeuralUpscaleParameter接口，设置空域AI超分的输入参数。// sharpness为用户自定义超分锐化参数，此处以参数为0.3f为例\nfloat sharpness = 0.3f;\nHMS_XEG_NeuralUpscaleParameter(XEG_NEURAL_UPSCALE_SHARPNESS, &sharpness);\n// inputScissor为超分输入纹理的裁剪窗口参数\nGLuint inputScissor[4] = {0, 0, renderWidth, renderHeight};\nHMS_XEG_NeuralUpscaleParameter(XEG_NEURAL_UPSCALE_SCISSOR, inputScissor);\n// 设置超分输入纹理对应的OH_NativeBuffer句柄\nHMS_XEG_NeuralUpscaleParameter(XEG_NEURAL_UPSCALE_INPUT_HANDLE, bufferHandle);  调用HMS_XEG_RenderNeuralUpscale接口执行空域AI超分。// 绑定绘制超分结果的帧缓冲，此处使用默认帧缓冲，也可使用用户自定义帧缓冲\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\nglViewport(0, 0, displayWidth, displayHeight);\n// 执行空域AI超分\nHMS_XEG_RenderNeuralUpscale(textureID);  不需要进行超分渲染时，销毁相关资源。glDeleteFramebuffers(1, &fboID);\nglDeleteTextures(1, &textureID);\nif (eglImage != nullptr) {\n   fp_eglDestroyImageKHR(eglGetCurrentDisplay(), eglImage);\n}\nif (nativeWindowBuffer != nullptr) {\n   OH_NativeWindow_DestroyNativeWindowBuffer(nativeWindowBuffer);\n}\nif (bufferHandle != nullptr) {\n   OH_NativeBuffer_Unreference(bufferHandle);\n}  

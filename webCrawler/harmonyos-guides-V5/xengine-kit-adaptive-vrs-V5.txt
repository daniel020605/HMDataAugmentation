自适应VRS
XEngine Kit提供自适应VRS功能，其通过合理分配画面的计算资源，视觉无损降低渲染频次，使不同的渲染图像使用不同的渲染速率，能够有效提高渲染性能。
接口说明
以下接口为自适应VRS设置接口，如要使用更丰富的设置和查询接口，具体API说明详见接口文档。
接口名
描述
const GLubyte * HMS_XEG_GetString (GLenum name)
XEngine GLES扩展特性查询接口。
GL_APICALL void GL_APIENTRY HMS_XEG_AdaptiveVRSParameter (GLenum pname, GLvoid * param)
设置自适应VRS的参数。
GL_APICALL void GL_APIENTRY HMS_XEG_DispatchAdaptiveVRS (GLfloat * reprojectionMatrix, GLuint inputColorImage, GLuint inputDepthImage, GLuint shadingRateImage)
计算着色率图像。
GL_APICALL void GL_APIENTRY HMS_XEG_ApplyAdaptiveVRS (GLuint shadingRateImage)
将着色率图像应用到渲染目标中。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_EnumerateDeviceExtensionProperties (VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, XEG_ExtensionProperties * pProperties)
XEngine Vulkan扩展特性查询接口。
VKAPI_ATTR VkResult VKAPI_CALL HMS_XEG_CreateAdaptiveVRS (VkDevice device, XEG_AdaptiveVRSCreateInfo * pXegAdaptiveVRSCreateInfo, XEG_AdaptiveVRS * pXegAdaptiveVRS)
创建XEG_AdaptiveVRS对象。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_CmdDispatchAdaptiveVRS (VkCommandBuffer cmdBuffer, XEG_AdaptiveVRS xegAdaptiveVRS, XEG_AdaptiveVRSDescription * pXegAdaptiveVRSDescription)
执行计算自适应可变着色率命令。
VKAPI_ATTR void VKAPI_CALL HMS_XEG_DestroyAdaptiveVRS (XEG_AdaptiveVRS xegAdaptiveVRS)
销毁XEG_AdaptiveVRS对象。
开发步骤
本章以GLES/Vulkan图像API集成为例，说明XEngine集成操作过程。
[h2]配置项目
编译HAP时，Native层so编译需要依赖NDK中的libxengine.so。
 头文件引用按需引用XEngine的头文件，如使用GLES自适应VRS功能。 #include <cstring>\n#include <cstdlib>\n#include <xengine/xeg_gles_extension.h>\n#include <xengine/xeg_gles_adaptive_vrs.h> 按需引用XEngine的头文件，如使用Vulkan自适应VRS功能。 #include <string>\n#include <vector>\n#include <algorithm>\n#include <xengine/xeg_vulkan_extension.h>\n#include <xengine/xeg_vulkan_adaptive_vrs.h> 编写CMakeLists.txt按需引用XEngine的CMakeLists，如使用GLES自适应VRS功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-GLES）。 find_library( \n    # Sets the name of the path variable.\n    xengine-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    xengine\n)\nfind_library(\n    # Sets the name of the path variable.\n    EGL-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    EGL\n)\nfind_library(\n    # Sets the name of the path variable.\n    GLES-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    GLESv3\n)\n\ntarget_link_libraries(nativerender PUBLIC\n${EGL-lib} ${GLES-lib} ${xengine-lib}) 按需引用XEngine的CMakeLists，如使用Vulkan自适应VRS功能，CMakeLists.txt部分示例代码如下，完整示例代码请参见Demo（GPU加速引擎-Vulkan）。 find_library(\n    # Sets the name of the path variable.\n    xengine-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    xengine\n)\nfind_library(\n    # Sets the name of the path variable.\n    EGL-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    EGL\n)\nfind_library(\n    # Sets the name of the path variable.\n    Vulkan-lib\n    # Specifies the name of the NDK library that you want CMake to locate.\n    vulkan\n)\n\ntarget_link_libraries(nativerender PUBLIC\n${EGL-lib} ${Vulkan-lib} ${xengine-lib}) 
[h2]集成自适应VRS功能（GLES）
自适应VRS功能GLES版本的着色率纹理创建和绑定由特性提供的接口实现。
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
 调用HMS_XEG_GetString接口，获取XEngine支持的扩展信息，只有在支持XEG_ADAPTIVE_VRS_EXTENSION_NAME扩展时才可以使用自适应VRS的相关接口。// 查询XEngine支持的GLES扩展信息\nconst char* extensions = (const char*)HMS_XEG_GetString(XEG_EXTENSIONS);\n// 查询是否支持自适应VRS\nif (!strstr(extensions, XEG_ADAPTIVE_VRS_EXTENSION_NAME)) {\n    exit(1); // return error\n}  
 调用HMS_XEG_AdaptiveVRSParameter接口，对自适应VRS的参数赋值。// renderWidth与renderHeight分别为用户自定义的渲染宽度与渲染高度，此处以800*600分辨率为例\nuint32_t renderWidth = 800;\nuint32_t renderHeight = 600;\n// inputSize为上一帧渲染管线最终渲染的图像尺寸，用户可自定义\nGLsizei inputSize[2] = {static_cast<GLsizei>(renderWidth), static_cast<GLsizei>(renderHeight)};\nHMS_XEG_AdaptiveVRSParameter(XEG_ADAPTIVE_VRS_INPUT_SIZE, inputSize);\n// inputRegion为上一帧渲染管线最终渲染的图像区域，用户可自定义\nGLuint inputRegion[4] = {0, 0, renderWidth, renderHeight};\nHMS_XEG_AdaptiveVRSParameter(XEG_ADAPTIVE_VRS_INPUT_REGION, inputRegion);\n// texelSizes为渲染的分片大小，用户可自定义，当前支持[8, 8]和[16, 16]两种规格\nGLsizei texelSizes[2] = {8, 8};\nHMS_XEG_AdaptiveVRSParameter(XEG_ADAPTIVE_VRS_TEXEL_SIZE, texelSizes);\n// sensitivity为控制生成着色率图像的阈值，用户可自定义，建议取值范围为[0, 1]\nGLfloat sensitivity = 0.15;\nHMS_XEG_AdaptiveVRSParameter(XEG_ADAPTIVE_VRS_ERROR_SENSITIVITY, &sensitivity);\n// flip为判断是否执行图像上下翻转，为true表示不进行图像上下翻转，false则表示进行图像上下翻转，此处以false为例\nGLboolean flip = false;\nHMS_XEG_AdaptiveVRSParameter(XEG_ADAPTIVE_VRS_FLIP, &flip);  调用HMS_XEG_DispatchAdaptiveVRS接口计算着色率图像。// inputColorImage为用户自定义上一帧渲染管线最终渲染结果颜色附件纹理 \nGLuint inputColorImage; \n// inputDepthImage为用户自定义当前帧渲染管线最终渲染结果深度附件纹理\nGLuint inputDepthImage;\n// outputShadingRateImage为用户可自定义生成着色率图像信息的纹理\nGLuint outputShadingRateImage;\n// reprojectionMatrix为用户根据投影矩阵和观察矩阵计算得来的重投影矩阵\nfloat *reprojectionMatrix = nullptr; \nHMS_XEG_DispatchAdaptiveVRS(reprojectionMatrix, inputColorImage, inputDepthImage, outputShadingRateImage);  
 调用HMS_XEG_ApplyAdaptiveVRS接口，将着色率图像应用到渲染目标中。HMS_XEG_ApplyAdaptiveVRS(outputShadingRateImage);  
[h2]集成自适应VRS功能（Vulkan）
在调用XEngine Kit能力前，需要先通过Syscap查询您的目标设备是否支持SystemCapability.Graphic.XEngine系统能力。
 调用HMS_XEG_EnumerateDeviceExtensionProperties接口，获取XEngine支持的扩展信息，只有在支持XEG_ADAPTIVE_VRS_EXTENSION_NAME扩展时才可以使用自适应VRS的相关接口。// physicalDevice为Vulkan物理设备，用户需进行初始化\nVkPhysicalDevice physicalDevice;\n// 查询XEngine支持的Vulkan扩展列表\nstd::vector<std::string> supportedExtensions;\nuint32_t pPropertyCount;\nHMS_XEG_EnumerateDeviceExtensionProperties(physicalDevice, &pPropertyCount, nullptr);\nif (pPropertyCount > 0) {\n    std::vector<XEG_ExtensionProperties> pProperties(pPropertyCount);\n    if (HMS_XEG_EnumerateDeviceExtensionProperties(physicalDevice, &pPropertyCount, &pProperties.front()) == VK_SUCCESS) {\n        for (auto ext : pProperties) {\n\t    supportedExtensions.push_back(ext.extensionName);\n        }\n    }\n}\n// 查询是否支持自适应VRS\nif (std::find(supportedExtensions.begin(), supportedExtensions.end(), XEG_ADAPTIVE_VRS_EXTENSION_NAME) == supportedExtensions.end()) {\n\texit(1); // return error\n}  声明实例句柄。XEG_AdaptiveVRS xeg_adaptiveVRS;  调用HMS_XEG_CreateAdaptiveVRS接口，定义并创建实例。// m_renderWidth与m_renderHeight分别为纹理采样宽高\nint m_renderWidth;\nint m_renderHeight;\n// VRS_TILE_SIZE为自适应VRS的渲染的分片大小\nint VRS_TILE_SIZE;\n// Vulkan逻辑设备，用户需进行初始化\nVkDevice device;\n// XEG_AdaptiveVRSCreateInfo为自适应VRS实例句柄对象的参数信息\nXEG_AdaptiveVRSCreateInfo xeg_createInfo;\n// XEG_AdaptiveVRSDescription为下发绘制着色率纹理命令所需参数信息\nXEG_AdaptiveVRSDescription xeg_description;\n// VkExtent2D inputSize为上一帧渲染管线最终渲染的图像尺寸，用户可自定义\nVkExtent2D inputSize;\ninputSize.width = m_renderWidth;\ninputSize.height = m_renderHeight;\n// VkRect2D为Vulkan指定的二维区域结构\n// inputRegion为自适应VRS输入纹理区域，用户可自定义\nVkRect2D inputRegion {};\n// inputRegion.extent.width与inputRegion.extent.height分别为纹理采样宽高\ninputRegion.extent.width = m_renderWidth;\ninputRegion.extent.height = m_renderHeight;\n// inputRegion.offset.x和inputRegion.offset.y为原点偏移量\ninputRegion.offset.x = 0;\ninputRegion.offset.y = 0;\n// xeg_createInfo.inputSize为上一帧渲染管线最终渲染的图像尺寸\nxeg_createInfo.inputSize = inputSize;\n// xeg_createInfo.inputRegion为上一帧渲染管线最终渲染的图像区域\nxeg_createInfo.inputRegion = inputRegion;\n// xeg_createInfo.adaptiveTileSize为自适应VRS的渲染的分片大小\nxeg_createInfo.adaptiveTileSize = VRS_TILE_SIZE;\n// xeg_createInfo.errorSensitivity为控制最终生成着色率纹理结果的阈值，此处以阈值为0.5为例\nxeg_createInfo.errorSensitivity = 0.5;\n// xeg_createInfo.flip为判断是否执行图像上下翻转，为true表示进行图像上下翻转，false则表示不进行图像上下翻转，此处以false为例\nxeg_createInfo.flip = false;\nHMS_XEG_CreateAdaptiveVRS(device, &xeg_createInfo, &xeg_adaptiveVRS);  
 调用HMS_XEG_CmdDispatchAdaptiveVRS接口，下发自适应VRS命令，生成perImage着色率纹理。// inputColorImageView为用户自定义的上一帧渲染管线最终渲染结果颜色附件纹理\nVkImageView inputColorImageView = VK_NULL_HANDLE;\n// inputColorImageView为用户自定义的前帧渲染管线最终渲染结果深度附件纹理\nVkImageView inputDepthImageView = VK_NULL_HANDLE;\n// outputShadingRateImage为用户自定义的生成着色率图信息的纹理\nVkImageView outputShadingRateImage = VK_NULL_HANDLE;\n// cmdBuff为命令缓冲区，用户需进行初始化\nVkCommandBuffer commandBuffer = VK_NULL_HANDLE ;\nxeg_description.inputColorImage = inputColorImageView; \nxeg_description.inputDepthImage = inputDepthImageView;\nxeg_description.outputShadingRateImage = outputShadingRateImage;\n // xeg_description.reprojectionMatrix为使用投影矩阵和观察矩阵计算而来的重投影矩阵\nxeg_description.reprojectionMatrix = nullptr; \nHMS_XEG_CmdDispatchAdaptiveVRS(commandBuffer, xeg_adaptiveVRS, &xeg_description);  
 调用HMS_XEG_DestroyAdaptiveVRS接口，卸载VRS实例，清理VRS相关资源。HMS_XEG_DestroyAdaptiveVRS(xeg_adaptiveVRS);  

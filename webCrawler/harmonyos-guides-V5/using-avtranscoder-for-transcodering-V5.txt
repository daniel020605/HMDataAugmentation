使用AVTranscoder实现视频转码(ArkTS)
使用AVTranscoder可以实现视频转码功能，从API 12开始，转码功能可在手机、平板、2in1设备上作为系统提供的基础能力使用。可以通过调用canIUse接口来判断当前设备是否支持AVTranscoder，canIUse(\"SystemCapability.Multimedia.Media.AVTranscoder\")返回值为true，表示可以使用转码能力。
本开发指导将以“开始转码-暂停转码-恢复转码-转码完成”的一次流程为示例，向开发者讲解AVTranscoder视频转码相关功能。
开发步骤及注意事项
详细的API说明请参考AVTranscoder API参考。
 创建AVTranscoder实例。 import { media } from '@kit.MediaKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet avTranscoder: media.AVTranscoder;\nmedia.createAVTranscoder().then((transcoder: media.AVTranscoder) => {\n  avTranscoder = transcoder;\n  // 需要在avTranscoder完成赋值后，再进行其他操作。\n}, (error: BusinessError) => {\n  console.error(`createAVTranscoder failed`);\n}); 设置业务需要的监听事件，监听状态变化及错误上报。     事件类型 说明    complete 必要事件，监听AVTranscoder的转码完成   error 必要事件，监听AVTranscoder的错误信息    import { BusinessError } from '@kit.BasicServicesKit';\n\n// 转码完成回调函数\navTranscoder.on('complete', () => {\n  console.log(`transcoder is completed`);\n  // 用户可以在此监听转码完成事件\n});\n\n// 错误上报回调函数\navTranscoder.on('error', (err: BusinessError) => {\n  console.error(`avTranscoder failed, code is ${err.code}, message is ${err.message}`);\n}); 设置源视频文件fd：设置属性fdSrc。     下面代码示例中的fdSrc仅作示意使用，开发者需根据实际情况，确认资源有效性并设置：  如果使用本地资源转码，必须确认资源文件可用，并使用应用沙箱路径访问对应资源，参考获取应用文件路径。应用沙箱的介绍及如何向应用沙箱推送文件，请参考文件管理。 如果使用ResourceManager.getRawFd()打开HAP资源文件描述符，使用方法可参考ResourceManager API参考。    import resourceManager from '@ohos.resourceManager';\nimport { common } from '@kit.AbilityKit';\n\nlet context = getContext(this) as common.UIAbilityContext;\nlet fileDescriptor = await context.resourceManager.getRawFd('H264_AAC.mp4');\n// 设置转码的源文件属性fdSrc\nthis.avTranscoder.fdSrc = fileDescriptor; 设置目标视频文件fd：设置属性fdDst。     转码输出文件fd（即示例里fdDst），形式为number。需要调用基础文件操作接口（Core File Kit的ohos.file.fs）实现应用文件访问能力，获取方式参考应用文件访问与管理。   // 设置转码的目标文件属性fdDst\nthis.avTranscoder.fdDst = 55; // 参考应用文件访问与管理中的开发示例获取创建的视频文件fd填入此处 配置视频转码参数，调用prepare()接口。     写入配置参数时需要注意，prepare()接口的入参avConfig中仅设置转码相关的配置参数。   import { media } from '@kit.MediaKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nlet avConfig: media.AVTranscoderConfig = {\n  audioBitrate: 100000, // 音频比特率\n  audioCodec: media.CodecMimeType.AUDIO_AAC, // 音频编码格式\n  fileFormat: media.ContainerFormatType.CFT_MPEG_4, // 封装格式\n  videoBitrate: 2000000, // 视频比特率\n  videoCodec: media.CodecMimeType.VIDEO_AVC, // 视频编码格式\n  videoFrameWidth: 640, // 视频分辨率的宽为640\n  videoFrameHeight: 480, // 视频分辨率的高为480\n};\navTranscoder.prepare(avConfig).then(() => {\n  console.log('Invoke prepare succeeded.');\n}, (err: BusinessError) => {\n  console.error(`Invoke prepare failed, code is ${err.code}, message is ${err.message}`);\n}); 开始转码，调用start()接口。 // 开始转码\navTranscoder.start(); 暂停转码，调用pause()接口。 // 暂停转码\navTranscoder.pause(); 恢复转码，调用resume()接口。 // 恢复转码\navTranscoder.resume(); 取消转码，调用cancel()接口。 // 取消转码\navTranscoder.cancel(); 销毁实例，调用release()接口，退出转码。 // 销毁实例\navTranscoder.release(); 
完整示例
参考以下示例，完成“开始转码-暂停转码-恢复转码-转码完成”的完整流程。
import { media } from '@kit.MediaKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\nimport { common } from '@kit.AbilityKit';\n\nexport class AVTranscoderDemo {\n  private avTranscoder: media.AVTranscoder | undefined = undefined;\n  private avConfig: media.AVTranscoderConfig = {\n    audioBitrate: 100000, // 音频比特率\n    audioCodec: media.CodecMimeType.AUDIO_AAC, // 音频编码格式\n    fileFormat: media.ContainerFormatType.CFT_MPEG_4, // 封装格式\n    videoBitrate: 200000, // 视频比特率\n    videoCodec: media.CodecMimeType.VIDEO_AVC, // 视频编码格式\n    videoFrameWidth: 640, // 视频分辨率的宽\n    videoFrameHeight: 480, // 视频分辨率的高\n  };\n\n  // 注册avTranscoder回调函数\n  setAVTranscoderCallback() {\n    if (canIUse(\"SystemCapability.Multimedia.Media.AVTranscoder\")) {\n      if (this.avTranscoder != undefined) {\n        // 转码完成回调函数\n        this.avTranscoder.on('complete', async () => {\n          console.log(`AVTranscoder is completed`);\n          await this.releaseTranscoderingProcess();\n        });\n        // 错误上报回调函数\n        this.avTranscoder.on('error', (err: BusinessError) => {\n          console.error(`AVTranscoder failed, code is ${err.code}, message is ${err.message}`);\n        });\n      }\n    }\n  }\n\n  // 开始转码对应的流程\n  async startTranscoderingProcess() {\n    if (canIUse(\"SystemCapability.Multimedia.Media.AVTranscoder\")) {\n      if (this.avTranscoder != undefined) {\n        await this.avTranscoder.release();\n        this.avTranscoder = undefined;\n      }\n      // 1.创建转码实例\n      this.avTranscoder = await media.createAVTranscoder();\n      this.setAVTranscoderCallback();\n      // 2.获取转码源文件fd和目标文件fd赋予avTranscoder；参考FilePicker文档\n      let context = getContext(this) as common.UIAbilityContext;\n      let fileDescriptor = await context.resourceManager.getRawFd('H264_AAC.mp4');\n      this.avTranscoder.fdSrc = fileDescriptor;\n      this.avTranscoder.fdDst = 55;\n      // 3.配置转码参数完成准备工作\n      await this.avTranscoder.prepare(this.avConfig);\n      // 4.开始转码\n      await this.avTranscoder.start();\n    }\n  }\n\n  // 暂停转码对应的流程\n  async pauseTranscoderingProcess() {\n    if (canIUse(\"SystemCapability.Multimedia.Media.AVTranscoder\")) {\n      if (this.avTranscoder != undefined) { // 仅在调用start返回后调用pause为合理调用\n        await this.avTranscoder.pause();\n      }\n    }\n  }\n\n  // 恢复对应的转码流程\n  async resumeTranscoderingProcess() {\n    if (canIUse(\"SystemCapability.Multimedia.Media.AVTranscoder\")) {\n      if (this.avTranscoder != undefined) { // 仅在调用pause返回后调用resume为合理调用\n        await this.avTranscoder.resume();\n      }\n    }\n  }\n\n  // 释放转码流程\n  async releaseTranscoderingProcess() {\n    if (canIUse(\"SystemCapability.Multimedia.Media.AVTranscoder\")) {\n      if (this.avTranscoder != undefined) {\n        // 1.释放转码实例\n        await this.avTranscoder.release();\n        this.avTranscoder = undefined;\n        // 2.关闭转码目标文件fd\n      }\n    }\n  }\n\n  // 一个完整的【开始转码-暂停转码-恢复转码-转码完成】示例\n  async avTranscoderDemo() {\n    await this.startTranscoderingProcess(); // 开始转码\n    await this.pauseTranscoderingProcess(); //暂停转码\n    await this.resumeTranscoderingProcess(); // 恢复转码\n    await this.releaseTranscoderingProcess(); // 释放转码\n  }\n}

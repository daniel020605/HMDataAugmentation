授权持久化(C/C++)
场景介绍
应用通过Picker获取临时授权，临时授权在应用退出后或者设备重启后会清除，如果应用重启或者设备重启后需要直接访问之前已访问过的文件，则对文件进行持久化授权。FileShare提供了支持基于URI的文件及目录授于持久化权限、权限激活、权限查询等方法。
接口说明
接口的详细介绍请参见API参考。
约束与限制
 使用文件分享的相关接口，需确认设备具有以下系统能力：SystemCapability.FileManagement.AppFileService.FolderAuthorization。 在调用文件分享的相关接口前，需要申请权限：\"ohos.permission.FILE_ACCESS_PERSIST\"，申请方式请参考访问控制-申请应用权限。 
开发步骤
以下步骤描述了如何使用FileShare提供的Native API接口。
添加动态链接库
CMakeLists.txt中添加以下lib。
target_link_libraries(sample PUBLIC libohfileshare.so)
头文件
#include <filemanagement/fileshare/oh_file_share.h>\n#include <iostream>
 创建FileShare_PolicyInfo实例,调用OH_FileShare_PersistPermission接口，设置URI的持久化授权，接口入参policyNum最大上限为500。static const uint32_t POLICY_NUM = 2;\nchar strTestPath1[] = \"file://com.example.fileshare/data/storage/el2/base/files/test1.txt\";\nchar strTestPath2[] = \"file://com.example.fileshare/data/storage/el2/base/files/test2.txt\";\nFileShare_PolicyInfo policy[POLICY_NUM] = {\n    {strTestPath1, static_cast<unsigned int>(strlen(strTestPath1)), FileShare_OperationMode::READ_MODE},\n    {strTestPath2, static_cast<unsigned int>(strlen(strTestPath2)), FileShare_OperationMode::WRITE_MODE}};\nFileShare_PolicyErrorResult* result = nullptr;\nuint32_t resultNum = 0;\nauto ret = OH_FileShare_PersistPermission(policy, POLICY_NUM, &result, &resultNum);\nif (ret != ERR_OK) {\n    if (ret == ERR_EPERM && result != nullptr) {\n        for(uint32_t i = 0; i < resultNum; i++) {\n            std::cout << \"error uri: \" <<  result[i].uri << std::endl;\n            std::cout << \"error code: \" <<  result[i].code << std::endl;\n            std::cout << \"error message: \" << result[i].message << std::endl;\n        }\n    }\n}\nOH_FileShare_ReleasePolicyErrorResult(result, resultNum); 调用OH_FileShare_ActivatePermission接口，激活启用已授权过的URI，接口入参policyNum最大上限为500。auto ret = OH_FileShare_ActivatePermission(policy, POLICY_NUM, &result, &resultNum);\nif (ret != ERR_OK) {\n    if (ret == ERR_EPERM && result != nullptr) {\n        for(uint32_t i = 0; i < resultNum; i++) {\n            std::cout << \"error uri: \" <<  result[i].uri << std::endl;\n            std::cout << \"error code: \" <<  result[i].code << std::endl;\n            std::cout << \"error message: \" << result[i].message << std::endl;\n        }\n    }\n}\nOH_FileShare_ReleasePolicyErrorResult(result, resultNum); 调用OH_FileShare_DeactivatePermission接口，停止已启用授权过URI的访问权限，接口入参policyNum最大上限为500。auto ret = OH_FileShare_DeactivatePermission(policy, POLICY_NUM, &result, &resultNum);\nif (ret != ERR_OK) {\n    if (ret == ERR_EPERM && result != nullptr) {\n        for(uint32_t i = 0; i < resultNum; i++) {\n            std::cout << \"error uri: \" <<  result[i].uri << std::endl;\n            std::cout << \"error code: \" <<  result[i].code << std::endl;\n            std::cout << \"error message: \" << result[i].message << std::endl;\n        }\n    }\n}\nOH_FileShare_ReleasePolicyErrorResult(result, resultNum); 调用OH_FileShare_RevokePermission接口，撤销已经授权的URI持久化权限，接口入参policyNum最大上限为500。auto ret = OH_FileShare_RevokePermission(policy, POLICY_NUM, &result, &resultNum);\nif (ret != ERR_OK) {\n    if (ret == ERR_EPERM && result != nullptr) {\n        for(uint32_t i = 0; i < resultNum; i++) {\n            std::cout << \"error uri: \" <<  result[i].uri << std::endl;\n            std::cout << \"error code: \" <<  result[i].code << std::endl;\n            std::cout << \"error message: \" << result[i].message << std::endl;\n        }\n    }\n}\nOH_FileShare_ReleasePolicyErrorResult(result, resultNum); 调用OH_FileShare_CheckPersistentPermission接口，检查URI持久化权限，接口入参policyNum最大上限为500。bool *result = nullptr;\nauto ret = OH_FileShare_CheckPersistentPermission(policy, POLICY_NUM, &result, &resultNum);\nif (result != nullptr && resultNum > 0) {\n    for(uint32_t i = 0; i < resultNum && resultNum <= POLICY_NUM; i++) {\n        std::cout << \"uri: \" <<  policy[i].uri << std::endl;\n        std::cout << \"result: \" <<  result[i] << std::endl;\n    }\n}\nstd::cout << \"retCode: \" <<  ret << std::endl;\nfree(result); 

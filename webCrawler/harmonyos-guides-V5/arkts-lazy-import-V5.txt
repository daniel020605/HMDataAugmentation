延迟加载（lazy import）
随着应用程序功能的不断扩展，冷启动所需的时间显著增长，主要是由于在启动初期加载了大量模块，其中存在大量未被实际执行的冗余文件。这种情形不仅拖延了应用的初始化过程，还造成了资源的无效占用，亟需采取措施精简加载流程，剔除非必需的文件执行，以优化冷启动性能，确保用户体验的流畅性。
延迟加载特性在API12版本开始支持。 开发者如需在API12上使用lazy import语法，需在工程中配置\"compatibleSdkVersionStage\": \"beta3\"，否则将无法通过编译。参考DevEco Studio build-profile.json5配置文件说明。 
功能特性
延迟加载特性可使待加载文件在冷启动阶段不被加载，直至应用程序实际运行过程中需要用到这些组件时，才按需同步加载相关文件，从而缩短应用冷启动耗时。
使用方式
开发者可以利用诸如Trace工具或日志记录等手段，来识别冷启动期间未被实际调用的文件，分析方法可参考延迟加载lazy-import使用指导。通过对这些数据的分析，开发者能够精准地定位出启动阶段不必预先加载的文件列表。针对这些文件的调用点，可以直接增加lazy标识。但需要注意的是，后续执行的加载是同步加载，有可能会阻塞任务执行（如点击任务，触发了延迟加载，那么运行时会去执行冷启动未加载的文件，从而增加耗时），因此是否使用lazy需要开发者自行评估。
不推荐开发者盲目增加lazy，同样会增大编译及运行时的识别开销。
场景行为解析
使用lazy-import延迟加载。     // main.ets   \n    import lazy { a } from \"./mod1\";    // \"mod1\" 未执行\n    import { c } from \"./mod2\";         // \"mod2\" 执行\n    \n    // ...\n    \n    console.info(\"main executed\");\n    while (false) {\n        let xx = a;\n    }\n    \n    // mod1.ets\n    export let a = \"mod1 executed\"\n    console.info(a);\n    \n    // mod2.ets\n    export let c = \"mod2 executed\"\n    console.info(c);   执行结果为：     mod2 executed\n    main executed 同时对同一模块引用lazy-import与原生import。     // main.ets   \n    import lazy { a } from \"./mod1\";    // \"mod1\" 未执行\n    import { c } from \"./mod2\";         // \"mod2\" 执行\n    import { b } from \"./mod1\";         // \"mod1\" 执行\n    \n    // ...\n    \n    console.info(\"main executed\");\n    while (false) {\n        let xx = a;\n    }\n    \n    // mod1.ets\n    export let a = \"mod1 a executed\"\n    console.info(a);\n    \n    export let b = \"mod1 b executed\"\n    console.info(b);\n    \n    // mod2.ets\n    export let c = \"mod2 c executed\"\n    console.info(c);   执行结果为：     mod2 c executed\n    mod1 a executed\n    mod1 b executed\n    main executed   如果在main.ets内删除lazy关键字，执行顺序为：     mod1 a executed\n    mod1 b executed\n    mod2 c executed\n    main executed 
语法规格
lazy-import支持如下指令实现：
延迟加载共享模块或依赖路径内包含共享模块。  延迟加载对于共享模块依旧生效，使用限制参考共享模块开发指导。 
[h2]错误示例
以下写法将引起编译报错。
    export lazy var v;                  // 编译器提示报错：应用编译报错\n    export lazy default function f(){}; // 编译器提示报错：应用编译报错\n    export lazy default function(){};   // 编译器提示报错：应用编译报错\n    export lazy default 42;             // 编译器提示报错：应用编译报错\n    export lazy { x };                    // 编译器提示报错：应用编译报错\n    export lazy { x as v };               // 编译器提示报错：应用编译报错\n    export lazy { x } from \"mod\";         // 编译器提示报错：应用编译报错\n    export lazy { x as v } from \"mod\";    // 编译器提示报错：应用编译报错\n    export lazy * from \"mod\";           // 编译器提示报错：应用编译报错\n    \n    import lazy v from \"mod\";           // 编译器提示报错：应用编译报错\n    import lazy * as ns from \"mod\";     // 编译器提示报错：应用编译报错
与type关键词同时使用将会导致报错。
    import lazy type { obj } from \"./mod\";    // 不支持，编译器、应用编译报错\n    import type lazy { obj } from \"./mod\";    // 不支持，编译器、应用编译报错
[h2]不推荐用法
在同一ets文件中，期待延迟加载的依赖模块标记不完全。   标记不完全将导致延迟加载失效，并且增加识别延迟加载的开销。     // main.ets   \n    import lazy { a } from \"./mod1\";    // 从\"mod1\"内获取a对象，标记为延迟加载\n    import { c } from \"./mod2\";\n    import { b } from \"./mod1\";         // 再次获取\"mod1\"内属性，未标记lazy，\"mod1\"默认执行\n    \n    // ... 在同一ets文件中，未使用懒加载变量并再次导出，不支持延迟加载变量被re-export导出。   这种方式导出的变量c未在B.ets中使用，文件B.ets不触发执行。在文件A.ets中使用变量c时，该变量未初始化，抛js异常。     // A.ets\n    import { c } from \"./B\";\n    console.info(c);\n\n    // B.ets\n    import lazy { c } from \"./C\";    // 从\"C\"内获取c对象，标记为延迟加载\n    export { c }\n\n    // C.ets\n    let c = \"c\";\n    export { c }   执行结果:     ReferenceError: c is not initaliized\n         at func_main_0 (A.ets:2:13)     // A_ns.ets\n    import * as ns from \"./B\";\n    console.info(ns.c);\n\n    // B.ets\n    import lazy { c } from \"./C\";    // 从\"C\"内获取c对象，标记为延迟加载\n    export { c }\n\n    // C.ets\n    let c = \"c\";\n    export { c }   执行结果: ReferenceError: module environment is undefined\n    at func_main_0 (A_ns.js:2:13) 暂不支持lazy-import延迟加载kit。 开发者需要评估使用延迟加载存在的影响。 不依赖该模块的执行的side-effect(如初始化全局变量，挂载globalThis等)。可参考：模块加载副作用及优化。使用导出对象时，触发延迟加载的耗时导致对应特性的功能劣化。使用lazy特性导致模块未执行而导致的bug。 

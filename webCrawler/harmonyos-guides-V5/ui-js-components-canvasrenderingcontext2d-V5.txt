CanvasRenderingContext2D对象
使用CanvasRenderingContext2D在Canvas画布组件上进行绘制，绘制对象可以是图形、文本、线段、图片等。具体请参考CanvasRenderingContext2D对象。
画线段
使用moveTo和lineTo画出一条线段，当使用closePath方法时会结束当前路径形成一个封闭图形 。设置quadraticCurveTo（二次贝赛尔曲线）或bezierCurveTo（三次贝赛尔曲线）的值组成图形。
<!-- xxx.hml -->\n<div class=\"container\">\n  <canvas ref=\"canvas1\"></canvas>\n  <select @change=\"change\">\n    <option value=\"value1\"> line </option>\n    <option value=\"value2\"> quadratic </option>\n    <option value=\"value3\"> bezier </option>\n    <option value=\"value4\"> arc/ellipse </option>\n    <option value=\"value5\"> lineJoin/miterLimit </option>\n  </select>\n</div>
/* xxx.css */\n.container{\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  background-color: #F1F3F5;\n}\ncanvas{\n  width: 600px;\n  height: 500px;\n  background-color: #fdfdfd;\n  border: 5px solid red;\n}\nselect{\n  margin-top: 50px;\n  width: 250px;\n  height: 100px;\n  background-color: white;\n}
// xxx.js\nexport default {\n  data:{\n    el: null,\n    ctx: null,\n  },\n  onShow(){\n    this.el = this.$refs.canvas1;\n    this.ctx = this.el.getContext(\"2d\",{antialias: true});\n    // 清除画布上的内容\n    this.ctx.clearRect(0, 0, 600, 500);\n    // 创建一个新的绘制路径\n    this.ctx.beginPath();\n    // 线端点以方形结束\n    this.ctx.lineCap = 'butt';\n    // 描边的宽度\n    this.ctx.lineWidth = 15;\n    // 创建一个新的绘制路径\n    this.ctx.beginPath();\n    // 路径从当前点移动到指定点\n    this.ctx.moveTo(200, 100);\n    // 从当前点到指定点进行路径连接\n    this.ctx.lineTo(400, 100);\n    // 边框绘制\n    this.ctx.stroke();\n    this.ctx.beginPath();\n    // 线端点以圆形结束\n    this.ctx.lineCap = 'round';\n    this.ctx.moveTo(200, 200);\n    this.ctx.lineTo(400, 200);\n    this.ctx.stroke();\n    // 线端点以方形结束\n    this.ctx.beginPath();\n    this.ctx.lineCap = 'square';\n    this.ctx.moveTo(200, 300);\n    this.ctx.lineTo(400, 300);\n    this.ctx.stroke();\n  },\n  change(e){\n    if(e.newValue == 'value1'){\n      this.el = this.$refs.canvas1;\n      this.ctx = this.el.getContext(\"2d\",{antialias: true});\n      this.ctx.clearRect(0, 0, 600, 500);\n      // 上\n      this.ctx.beginPath();\n      this.ctx.lineCap = 'butt';\n      this.ctx.moveTo(200, 100);\n      this.ctx.lineTo(400, 100);\n      this.ctx.stroke();\n      // 中\n      this.ctx.beginPath();\n      this.ctx.lineCap = 'round';\n      this.ctx.moveTo(200, 200);\n      this.ctx.lineTo(400, 200);\n      this.ctx.stroke();\n      // 下\n      this.ctx.beginPath();\n      this.ctx.lineCap = 'square';\n      this.ctx.moveTo(200, 300);\n      this.ctx.lineTo(400, 300);\n      this.ctx.stroke();\n    }else if(e.newValue == 'value2'){\n      this.ctx.clearRect(0, 0, 600, 500);\n      // 上\n      this.ctx.beginPath();\n      this.ctx.moveTo(100, 150);\n      // 二次贝赛尔曲线的路径\n      this.ctx.quadraticCurveTo(300, 50, 500, 150);\n      this.ctx.stroke();\n      // 左\n      this.ctx.beginPath();\n      this.ctx.moveTo(200, 150);\n      this.ctx.quadraticCurveTo(250, 250, 250, 400);\n      this.ctx.stroke();\n      // 右\n      this.ctx.beginPath();\n      this.ctx.moveTo(400, 150);\n      this.ctx.quadraticCurveTo(350, 250, 350, 400);\n      this.ctx.stroke();\n    }else if(e.newValue == 'value3'){\n      this.ctx.clearRect(0, 0, 600, 500);\n      // 下\n      this.ctx.beginPath();\n      this.ctx.moveTo(100, 200);\n      // 三次贝赛尔曲线的路径\n      this.ctx.bezierCurveTo(150, 100, 200, 100,250, 200);\n      this.ctx.stroke();\n      // 左\n      this.ctx.beginPath();\n      this.ctx.moveTo(350, 200);\n      this.ctx.bezierCurveTo(400, 100, 450, 100,500, 200);\n      this.ctx.stroke();\n      // 右\n      this.ctx.beginPath();\n      this.ctx.moveTo(200, 350);\n      this.ctx.bezierCurveTo(250, 500, 350, 500, 400, 350);\n      this.ctx.stroke();\n    }else if(e.newValue == 'value4'){\n      this.ctx.clearRect(0, 0, 600, 500);\n      this.ctx.beginPath();\n      this.ctx.moveTo(100, 200);\n      // 弧线\n      this.ctx.arcTo(150, 300, 350, 300, 150);\n      this.ctx.stroke();\n      this.ctx.beginPath();\n      // 椭圆\n      this.ctx.ellipse(400, 250, 50, 100, Math.PI * 0.25, Math.PI * 0.5 , Math.PI , 1);\n      this.ctx.stroke();\n    }else if(e.newValue == 'value5'){\n      this.ctx.clearRect(0, 0, 600, 500);\n      // 左上\n      this.ctx.beginPath();\n      // 在线段相连处绘制一个扇形\n      this.ctx.lineJoin = 'round';\n      this.ctx.moveTo(100, 100);\n      this.ctx.lineTo(200, 200);\n      this.ctx.lineTo(100, 250);\n      this.ctx.stroke();\n      // 左下\n      this.ctx.beginPath();\n      // 在线段相连处使用三角形为底填充\n      this.ctx.lineJoin = 'bevel';\n      this.ctx.moveTo(100, 300);\n      this.ctx.lineTo(200, 400);\n      this.ctx.lineTo(100, 450);\n      this.ctx.stroke();\n      // 右上\n      this.ctx.beginPath();\n      //线条相交处内角和外角的距离\n      this.ctx.lineJoin = 'miter';\n      this.ctx.miterLimit = 3;\n      this.ctx.moveTo(400, 100);\n      this.ctx.lineTo(450, 200);\n      this.ctx.lineTo(400, 250);\n      // 结束当前路径形成一个封闭路径\n      this.ctx.closePath();\n      this.ctx.stroke();\n      // 右下\n      this.ctx.beginPath();\n      this.ctx.lineJoin = 'miter';\n      this.ctx.miterLimit = 10;\n      this.ctx.moveTo(400, 300);\n      this.ctx.lineTo(450, 400);\n      this.ctx.lineTo(400, 450);\n      this.ctx.closePath();\n      this.ctx.stroke();\n    }\n  },\n}
画边框
全局定义画布（el）及画笔（ctx），初始化创建一个边框宽度为5的长方形。对边框的宽度（lineWidth）、颜色（strokeStyle）、虚化程度（setLineDash）进行改变，选用select组件添加change事件，下拉选择时触发change事件后画出改变后的图形。
<!-- xxx.hml -->\n<div class=\"container\">\n  <canvas ref=\"canvas1\"></canvas>\n  <select @change=\"change\">\n    <option value=\"value1\">strokeRect</option>\n    <option value=\"value2\">arc</option>\n    <option value=\"value3\">lineDashRect</option>\n    <option value=\"value4\">fillRect</option>\n  </select>\n</div>
/* xxx.css */\n.container{\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  background-color: #F1F3F5;\n}\ncanvas{\n  width: 600px;\n  height: 500px;\n  background-color: #fdfdfd;\n  border: 5px solid red;\n}\nselect{\n  margin-top: 50px;\n  width: 250px;\n  height: 100px;\n  background-color: white;\n}
// xxx.js\nexport default {\n  data:{\n    el: null,\n    ctx: null,\n  },\n  onShow(){\n    this.el = this.$refs.canvas1;\n    this.ctx = this.el.getContext(\"2d\",{antialias: true});\n    this.ctx.lineWidth = 5;\n    this.ctx.strokeRect(200, 150, 200, 200);\n  },\n  change(e){\n    if(e.newValue == 'value1'){\n      // 清除画布上的内容\n      this.ctx.clearRect(0,0,600,500);\n      // 边框宽度\n      this.ctx.lineWidth = 5;\n      // 边框颜色\n      this.ctx.strokeStyle = '#110000';\n      // 边框的虚化程度\n      this.ctx.setLineDash([0,0]);\n      // 画具有边框的矩形\n      this.ctx.strokeRect(200, 150, 200, 200);\n    }else if (e.newValue == 'value2'){\n      this.ctx.clearRect(0,0,600,500);\n      this.ctx.lineWidth = 30;\n      this.ctx.strokeStyle = '#0000ff';\n      this.ctx.setLineDash([0,0]);\n      // 画圆\n      this.ctx.arc(300, 250, 150,0,6.28);\n      //进行边框绘制\n      this.ctx.stroke();\n    }else if (e.newValue == 'value3'){\n      this.ctx.clearRect(0,0,600,500);\n      this.ctx.lineWidth = 5;\n      this.ctx.setLineDash([5,5]);\n      this.ctx.strokeRect(200, 150, 200, 200);\n    }else if (e.newValue == 'value4'){\n      this.ctx.clearRect(0,0,600,500);\n      // 画一个有填充颜色的矩形\n      this.ctx.fillStyle = '#0000ff';\n      this.ctx.fillRect(200, 150, 200, 200);\n    }\n  },\n}
填充渐变色
添加createLinearGradient和createRadialGradient属性创建渐变容器，接着用addColorStop方法添加多个色块组成渐变色，再设置fillStyle为gradient将渐变色填充到矩形中，最后设置阴影的模糊级别（shadowBlur）、阴影颜色（shadowColor）及阴影偏移量（shadowOffset）。
<!-- xxx.hml -->\n<div class=\"container\">\n  <canvas ref=\"canvas1\"></canvas>\n  <select @change=\"change\">\n    <option value=\"value1\">LinearGradient</option>\n    <option value=\"value2\">RadialGradient</option>\n    <option value=\"value3\">shadowBlur</option>\n    <option value=\"value4\">shadowOffset</option>\n  </select>\n</div>
/* xxx.css */\n.container{\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  background-color: #F1F3F5;\n}\ncanvas{\n  width: 600px;\n  height: 500px;\n  background-color: #fdfdfd;\n  border: 5px solid red;\n}\nselect{\n  margin-top: 50px;\n  width: 250px;\n  height: 100px;\n  background-color: white;\n}
// xxx.js\nexport default {\n  data:{\n    el: null,\n    ctx: null,\n  },\n  onShow(){\n    this.el = this.$refs.canvas1;\n    this.ctx = this.el.getContext(\"2d\",{antialias: true});\n    // 创建一个线性渐变色\n    let gradient = this.ctx.createLinearGradient(100,100, 400,300);\n    // 添加渐变颜色\n    gradient.addColorStop(0.0, 'red');\n    gradient.addColorStop(0.7, 'white');\n    gradient.addColorStop(1.0, 'green');\n    // 填充颜色为渐变色\n    this.ctx.fillStyle = gradient;\n    this.ctx.fillRect(100, 100, 400, 300);\n  },\n  change(e){\n    if(e.newValue == 'value1'){\n      // 清除画布上的内容\n      this.ctx.clearRect(0,0,600,500);\n      let gradient = this.ctx.createLinearGradient(100,100, 400,300);\n      gradient.addColorStop(0.0, 'red');\n      gradient.addColorStop(0.7, 'white');\n      gradient.addColorStop(1.0, 'green');\n      this.ctx.fillStyle = gradient;\n      // 设置绘制阴影时的模糊级别\n      this.ctx.shadowBlur = 0;\n      // 绘制阴影时和原有对象的垂直偏移值\n      this.ctx.shadowOffsetY = 0;\n      // 绘制阴影时和原有对象的水平偏移值\n      this.ctx.shadowOffsetX = 0;\n      this.ctx.fillRect(100, 100, 400, 300);\n    }else if(e.newValue == 'value2'){\n      this.ctx.clearRect(0,0,600,500);\n      // 创建一个径向渐变色\n      let gradient = this.ctx.createRadialGradient(300,250,20,300,250,100);\n      gradient.addColorStop(0.0, 'red');\n      gradient.addColorStop(0.7, 'white');\n      gradient.addColorStop(1.0, 'green');\n      this.ctx.shadowBlur = 0;\n      this.ctx.shadowOffsetY = 0;\n      this.ctx.shadowOffsetX = 0;\n      this.ctx.fillStyle = gradient;\n      this.ctx.fillRect(100, 100, 400, 300);\n    }else if(e.newValue == 'value3'){\n      this.ctx.clearRect(0,0,600,500);\n      let gradient = this.ctx.createLinearGradient(100,100, 400,400);             \n      gradient.addColorStop(0.0, 'red');    \n      gradient.addColorStop(0.5, 'white');    \n      gradient.addColorStop(1, '#17ea35');\n      // 设置绘制阴影时的模糊级别\n      this.ctx.shadowBlur = 30;\n      // 绘制阴影时的阴影颜色\n      this.ctx.shadowColor = 'rgb(229, 16, 16)';\n      this.ctx.fillStyle = gradient;\n      this.ctx.fillRect(100, 100, 400, 300);\n    }else if(e.newValue == 'value4'){\n      this.ctx.clearRect(0,0,600,500);\n      this.ctx.clearRect(0,0,600,500);\n      let gradient = this.ctx.createRadialGradient(300,250,20,300,250,200);      \n      gradient.addColorStop(0.0, 'red');     \n      gradient.addColorStop(0.5, 'white');     \n      gradient.addColorStop(1, '#17ea35');\n      // 设置绘制阴影时的模糊级别\n      this.ctx.shadowBlur = 30;     \n      this.ctx.shadowOffsetY = 30;\n      // 绘制阴影时的阴影颜色\n      this.ctx.shadowColor = 'rgb(23, 1, 1)';\n      this.ctx.fillStyle = gradient;\n      this.ctx.fillRect(100, 100, 400, 300);\n    }\n  },\n}
填充文字
先创建文本，再用fillText方法把文字写在画布上。通过globalAlpha属性改变基线透明度，使基线不会挡住文字，再设置textAlign和textBaseline属性确定文字基于基线的位置。
<!-- xxx.hml -->\n<div class=\"container\">\n  <canvas ref=\"canvas1\"></canvas>\n  <select @change=\"change\">\n    <option value=\"value1\">text</option>\n    <option value=\"value2\">textBaseline</option>\n    <option value=\"value3\">textAlign</option>\n  </select>\n</div>
/* xxx.css */\n.container{\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  background-color: #F1F3F5;\n}\ncanvas{\n  width: 600px;\n  height: 500px;\n  background-color: #fdfdfd;\n  border: 5px solid red;\n}\nselect{\n  margin-top: 50px;\n  width: 250px;\n  height: 100px;\n  background-color: white;\n}
// xxx.js\nexport default {\n  data:{\n    el: null,\n    ctx: null,\n  },\n  onShow(){\n    this.el = this.$refs.canvas1;\n    this.ctx = this.el.getContext(\"2d\",{antialias: true});\n    // 创建文本\n    let text = \"Hello World\";\n    // 设置字体\n    this.ctx.font = '30px';\n    this.ctx.fillText(\"with:\"+this.ctx.measureText(text).width, 200, 300);\n    // 填充字体文本\n    this.ctx.fillText(text, 200, 250);\n  },\n  change(e){\n    if(e.newValue == 'value1'){\n      // 清除画布上的内容\n      this.ctx.clearRect(0,0,600,500);\n      // 开始新的路径\n      this.ctx.beginPath();\n      // 初始化textAlign值\n      this.ctx.textAlign = 'left';\n      // 初始化textBaseline\n      this.ctx.textBaseline = 'alphabetic';\n      // 设置字体\n      this.ctx.font = '30px';\n      let text = \"Hello World\";\n      // 获取字体width\n      this.ctx.fillText(\"with:\"+this.ctx.measureText(text).width, 200, 300);\n      // 填充字体文本\n      this.ctx.fillText(text, 200, 250);\n    }else if(e.newValue == 'value2'){\n      this.ctx.clearRect(0,0,600,500);\n      this.ctx.beginPath();\n      // 设置透明度\n      this.ctx.globalAlpha = 0.1;\n      // 设置线宽度\n      this.ctx.lineWidth = 10;\n      // 设置线段颜色\n      this.ctx.strokeStyle = '#0000ff';\n      // 从当前点移动到指定点\n      this.ctx.moveTo(0, 240);\n      // 当前点到指定点进行路径连接\n      this.ctx.lineTo(600, 240);\n      this.ctx.stroke();\n      this.ctx.font = '35px';\n      this.ctx.globalAlpha = 1;\n      // 初始化textAlign值\n      this.ctx.textAlign = 'left';\n      // 设置textBaseline\n      this.ctx.textBaseline = 'top';\n      this.ctx.fillText('Top', 50, 240);\n      this.ctx.textBaseline = 'bottom';\n      this.ctx.fillText('Bottom', 200, 240);\n      this.ctx.textBaseline = 'middle';\n      this.ctx.fillText('Middle', 400, 240);\n    }else if(e.newValue == 'value3'){\n      // 清除画布上的内容\n      this.ctx.clearRect(0,0,600,500);\n      this.ctx.beginPath();\n      this.ctx.globalAlpha = 0.1;\n      this.ctx.lineWidth = 10;\n      this.ctx.strokeStyle = '#0000ff';\n      this.ctx.moveTo(300, 0);\n      this.ctx.lineTo(300, 500);\n      this.ctx.stroke();\n      this.ctx.font = '35px';\n      this.ctx.globalAlpha = 1;\n      // 初始化 textBaseline\n      this.ctx.textBaseline = 'alphabetic';\n      // 设置textAlign\n      this.ctx.textAlign = 'left';\n      this.ctx.fillText('textAlign=left',300, 100);\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText('textAlign=center',300, 250);\n      this.ctx.textAlign = 'right';\n      this.ctx.fillText('textAlign=right',300, 400);\n    }\n  }\n}
ltr布局模式下start和left一致，rtl布局模式下start和right一致。
添加图片
创建图片对象后使用drawImage属性画出图片，给图片设置一些动画样式如scale（缩放）、translate（平移）或rotate（旋转）。
<!-- xxx.hml -->\n<div class=\"container\">\n  <div class=\"content\">\n    <canvas ref=\"canvas0\"></canvas>\n    <text onclick=\"change\">change</text>\n    <canvas ref=\"canvas1\"></canvas>\n    <text onclick=\"rotate\">rotate</text>\n    <canvas ref=\"canvas2\"></canvas>\n    <text onclick=\"scale\">scale</text>\n    <canvas ref=\"canvas3\"></canvas>\n    <text onclick=\"translate\" style=\"width: 300px;\">translate</text>\n    <canvas ref=\"canvas4\"></canvas>\n    <text onclick=\"transform\" style=\"width: 300px;\">transform</text>\n    <canvas ref=\"canvas5\"></canvas>\n    <text onclick=\"setTransform\" style=\"width: 300px;\">setTransform</text>\n    <canvas ref=\"canvas6\"></canvas>\n  </div>\n</div>
/* xxx.css */\n.container{\n  width: 100%;\n  flex-direction: column;\n  background-color: #F1F3F5;\n  align-items: center;\n}\ncanvas{\n  width: 600px;\n  height: 300px;\n  margin-bottom: 100px;\n  background-color: #fdfdfd;\n  border: 5px solid red;\n}\n.content{\n  width: 80%;\n  margin-top: 50px;\n  margin-bottom: 50px;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-around;\n}\ntext{\n  font-size: 35px;\n  width: 200px;\n  height: 80px;\n  color: white;\n  border-radius: 20px;\n  text-align: center;\n  background-color: #6060e7;\n  margin-bottom: 30px;\n}
// xxx.js\nimport promptAction from '@ohos.promptAction';\nexport default {\n  data:{\n    compositeOperation: 'source-over'\n  },\n  onShow(){\n    let ctx = this.$refs.canvas0.getContext(\"2d\");\n    // 创建图片对象\n    let img = new Image();\n    // 设置图片路径\n    img.src = 'common/images/2.png';\n    // 设置图片宽度\n    img.width= 150;\n    // 设置图片高度\n    img.height=150;\n    // 图片平铺容器\n    var pat = ctx.createPattern(img, 'repeat');ctx.fillStyle = pat;\n    ctx.fillRect(0, 0, 600, 300);\n  },\n  change(){\n    // 创建画布后得到画笔\n    let ctx = this.$refs.canvas1.getContext(\"2d\");\n    ctx.clearRect(0,0,600,1000);\n    if(this.compositeOperation == \"source-over\"){\n      this.compositeOperation = \"destination-over\";\n    }else{\n      this.compositeOperation = \"source-over\";\n    }\n    ctx.globalCompositeOperation = this.compositeOperation;\n    let img = new Image();\n    img.src = 'common/images/2.png';\n    // 图片成功获取触发方法\n    img.onload = function() {\n      ctx.drawImage(img, 150, 20, 200, 200);\n    };\n    let img1 = new Image();\n    img1.src = 'common/images/3.png';\n    img1.onload = function() {\n      // 画上图片\n      ctx.drawImage(img1, 250, 80, 200, 200);\n    };\n    // 图片获取失败触发方法\n    img1.onerror = function() {\n      promptAction.showToast({message:\"error\",duration:2000})\n    };\n  },\n  rotate(){\n    let ctx = this.$refs.canvas2.getContext(\"2d\");\n    ctx.clearRect(0,0,600,300);\n    // 旋转\n    ctx.rotate(10 * Math.PI / 180);\n    let img = new Image();\n    img.src = 'common/images/2.png';\n    img.onload = function() {\n      ctx.drawImage(img, 300, 0, 100, 100);\n    };\n  },\n  scale(){\n    let ctx = this.$refs.canvas3.getContext(\"2d\");\n    ctx.clearRect(0,0,600,200);\n    // 缩放\n    ctx.scale(1.3,1.2);\n    let img = new Image();\n    img.src = 'common/images/2.png';\n    img.onload = function() {\n      ctx.drawImage(img, 0, 0, 50, 50);\n    };\n  },\n  translate(){\n    let ctx = this.$refs.canvas4.getContext(\"2d\");\n    ctx.clearRect(0,0,600,300);\n    ctx.translate(10,0);\n    let img = new Image();\n    img.src = 'common/images/2.png';\n    img.onload = function() {\n      ctx.drawImage(img, 0, 50, 300, 200);\n    };\n  },\n  transform(){\n    let ctx = this.$refs.canvas5.getContext(\"2d\");\n    ctx.clearRect(0,0,600,300);\n    ctx.transform(1.1, 0.1, 0.1, 1, 10, 0);\n    let img = new Image();\n    img.src = 'common/images/2.png';\n    img.onload = function() {\n      ctx.drawImage(img, 0, 50, 100, 100);\n     };\n  },\n  setTransform(){\n    let ctx = this.$refs.canvas6.getContext(\"2d\");\n    ctx.clearRect(0,0,600,300);\n    ctx.setTransform(1.1, 0.1, 0.1, 1, 10, 0);\n    let img = new Image();\n    img.src = 'common/images/2.png';\n    img.onload = function() {\n      ctx.drawImage(img, 0, 50, 100, 100);\n    };\n  },\n}
 setTransform方法使用的参数和transform()方法相同，但setTransform()方法会重置现有的变换矩阵并创建新的变换矩阵。 变换后的坐标计算方式（x和y为变换前坐标，x'和y'为变换后坐标）： x' = scaleX * x + skewY * y + translateX y' = skewX * x + scaleY * y + translateY 
添加方法
save方法可对画笔样式进行存储，restore可对存储的画笔进行恢复。如下面的示例，先设置画笔为红色，在保存画笔后对画布进行清除并改变画笔为蓝色，当我们直接使用画笔时会画出一个蓝色矩形，对存储的画笔进行恢复后就可画出红色矩形。
<!-- xxx.hml -->\n<div class=\"container\">\n  <div class=\"content\">\n    <canvas ref=\"canvas\"></canvas>\n  </div>\n  <div class=\"content\">\n    <text onclick=\"save\">save</text>\n    <text onclick=\"clear\">clear</text>\n    <text onclick=\"restore\">restore</text>\n  </div>\n</div>
/* xxx.css */\n.container{\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  background-color: #F1F3F5;\n  align-items: center;\n}\ncanvas{\n  margin-top: 300px;\n  width: 600px;\n  height: 500px;\n  background-color: #fdfdfd;\n  border: 5px solid red;\n}\n.content{\n  width: 80%;\n  margin-top: 50px;\n  margin-bottom: 50px;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-around;\n}\ntext{\n  width: 150px;\n  height: 80px;\n  color: white;\n  border-radius: 20px;\n  text-align: center;\n  background-color: #6060e7;\n  margin-bottom: 30px;\n}
// xxx.js\nimport promptAction from '@ohos.promptAction';\nexport default {\n  data:{\n    ctx: '',\n  },\n  onShow(){\n    this.ctx = this.$refs.canvas.getContext(\"2d\");\n    this.ctx.fillStyle = \"red\"\n    this.ctx.fillRect(200, 150, 200, 200);\n  },\n  save(){\n    // 画笔储存\n    this.ctx.save();\n    promptAction.showToast({message:\"save succeed\"});\n  },\n  clear(){ \n    this.ctx.clearRect(0,0,600,500);\n    // 该变画笔颜色\n    this.ctx.fillStyle = \"#2133d2\";\n  },\n  restore(){\n    this.ctx.beginPath();\n    // 画笔恢复\n    this.ctx.restore();    \n    this.ctx.fillRect(200, 150, 200, 200);\n  },\n}

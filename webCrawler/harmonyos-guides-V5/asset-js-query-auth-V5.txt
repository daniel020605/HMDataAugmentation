查询需要用户认证的关键资产(ArkTS)
接口介绍
可通过API文档查看此功能的相关接口：
在查询需要用户认证的关键资产时，关键资产属性的内容（AssetMap）参数如下表所示：
下表中名称包含“DATA_LABEL”的关键资产属性，用于存储业务自定义信息，其内容不会被加密，请勿存放个人数据。
 preQuery参数列表     属性名称（Tag） 属性内容（Value） 是否必选 说明    ALIAS 类型为Uint8Array，长度为1-256字节。 可选 关键资产别名，每条关键资产的唯一索引。   ACCESSIBILITY 类型为number，取值范围详见Accessibility。 可选 基于锁屏状态的访问控制。   REQUIRE_PASSWORD_SET 类型为bool。 可选 是否仅在设置了锁屏密码的情况下，可访问关键资产。   AUTH_TYPE 类型为number，取值范围详见AuthType。 可选 访问关键资产所需的用户认证类型。   AUTH_VALIDITY_PERIOD 类型为number，取值范围：1-600，单位为秒。 可选 用户认证的有效期。   SYNC_TYPE 类型为number，取值范围详见SyncType。 可选 关键资产支持的同步类型。   IS_PERSISTENT 类型为bool。 可选 在应用卸载时是否需要保留关键资产。   DATA_LABEL_CRITICAL_1 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_CRITICAL_2 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_CRITICAL_3 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_CRITICAL_4 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_1 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_2 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_3 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_4 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_LOCAL_112+ 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。   DATA_LABEL_NORMAL_LOCAL_212+ 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。   DATA_LABEL_NORMAL_LOCAL_312+ 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。   DATA_LABEL_NORMAL_LOCAL_412+ 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。    query参数列表     属性名称（Tag） 属性内容（Value） 是否必选 说明    ALIAS 类型为Uint8Array，长度为1-256字节。 必选 关键资产别名，每条关键资产的唯一索引。   AUTH_CHALLENGE 类型为Uint8Array，长度为32字节。 必选 用户认证的挑战值。   AUTH_TOKEN 类型为Uint8Array，长度为148字节。 必选 用户认证通过的授权令牌。   RETURN_TYPE 类型为number，asset.ReturnType.ALL。 必选 关键资产查询返回的结果类型。   ACCESSIBILITY 类型为number，取值范围详见Accessibility。 可选 基于锁屏状态的访问控制。   REQUIRE_PASSWORD_SET 类型为bool。 可选 是否仅在设置了锁屏密码的情况下，可访问关键资产。   AUTH_TYPE 类型为number，取值范围详见AuthType。 可选 访问关键资产所需的用户认证类型。   SYNC_TYPE 类型为number，取值范围详见SyncType。 可选 关键资产支持的同步类型。   IS_PERSISTENT 类型为bool。 可选 在应用卸载时是否需要保留关键资产。   DATA_LABEL_CRITICAL_1 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_CRITICAL_2 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_CRITICAL_3 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_CRITICAL_4 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且有完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_1 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_2 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_3 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_4 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属信息，内容由业务自定义且无完整性保护。 说明： API12前长度为1-512字节。   DATA_LABEL_NORMAL_LOCAL_112+ 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。   DATA_LABEL_NORMAL_LOCAL_212+ 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。   DATA_LABEL_NORMAL_LOCAL_312+ 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。   DATA_LABEL_NORMAL_LOCAL_412+ 类型为Uint8Array，长度为1-2048字节。 可选 关键资产附属的本地信息，内容由业务自定义且无完整性保护，该项信息不会进行同步。    postQuery参数列表     属性名称（Tag） 属性内容（Value） 是否必选 说明    AUTH_CHALLENGE 类型为Uint8Array，长度为32字节。 必选 用户认证的挑战值。    
代码示例
本模块提供了异步和同步两套接口，以下为异步接口的使用示例，同步接口详见API文档。
查询别名是demo_alias且需要用户认证的关键资产。
import { asset } from '@kit.AssetStoreKit';\nimport { util } from '@kit.ArkTS';\nimport userAuth from '@ohos.userIAM.userAuth';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nfunction stringToArray(str: string): Uint8Array {\n  let textEncoder = new util.TextEncoder();\n  return textEncoder.encodeInto(str);\n}\n\nfunction arrayToString(arr: Uint8Array): string {\n  let textDecoder = util.TextDecoder.create(\"utf-8\", { ignoreBOM: true });\n  let str = textDecoder.decodeToString(arr, { stream: false })\n  return str;\n}\n\nasync function userAuthenticate(challenge: Uint8Array): Promise<Uint8Array> {\n  return new Promise((resolve, reject) => {\n    const authParam: userAuth.AuthParam = {\n      challenge: challenge,\n      authType: [userAuth.UserAuthType.PIN],\n      authTrustLevel: userAuth.AuthTrustLevel.ATL1,\n    };\n    const widgetParam: userAuth.WidgetParam = { title: '请输入锁屏密码' };\n    try {\n      let userAuthInstance = userAuth.getUserAuthInstance(authParam, widgetParam);\n      userAuthInstance.on('result', {\n        onResult(result) {\n          if (result.result == userAuth.UserAuthResultCode.SUCCESS) {\n            console.info(`User identity authentication succeeded.`);\n            resolve(result.token);\n          } else {\n            console.error(`User identity authentication failed.`);\n            reject();\n          }\n        }\n      });\n      userAuthInstance.start();\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(`User identity authentication failed. Code is ${err.code}, message is ${err.message}`);\n      reject();\n    }\n  })\n}\n\nfunction preQueryAsset(): Promise<Uint8Array> {\n  return new Promise((resolve, reject) => {\n    try {\n      let query: asset.AssetMap = new Map();\n      query.set(asset.Tag.ALIAS, stringToArray('demo_alias'));\n      asset.preQuery(query).then((challenge: Uint8Array) => {\n        resolve(challenge);\n      }).catch(() => {\n        reject();\n      })\n    } catch (error) {\n      let err = error as BusinessError;\n      console.error(`Failed to pre-query Asset. Code is ${err.code}, message is ${err.message}`);\n      reject();\n    }\n  });\n}\n\nasync function postQueryAsset(challenge: Uint8Array) {\n  let handle: asset.AssetMap = new Map();\n  handle.set(asset.Tag.AUTH_CHALLENGE, challenge);\n  try {\n    await asset.postQuery(handle);\n    console.info(`Succeeded in post-querying Asset.`);\n  } catch (error) {\n    let err = error as BusinessError;\n    console.error(`Failed to post-query Asset. Code is ${err.code}, message is ${err.message}`);\n  }\n}\n\nasync function queryAsset() {\n  // step1. 调用asset.preQuery获取挑战值\n  preQueryAsset().then(async (challenge: Uint8Array) => {\n    try {\n      // step2. 传入挑战值，拉起用户认证框\n      let authToken: Uint8Array = await userAuthenticate(challenge);\n      // step3 用户认证通过后，传入挑战值和授权令牌，查询关键资产明文\n      let query: asset.AssetMap = new Map();\n      query.set(asset.Tag.ALIAS, stringToArray('demo_alias'));\n      query.set(asset.Tag.RETURN_TYPE, asset.ReturnType.ALL);\n      query.set(asset.Tag.AUTH_CHALLENGE, challenge);\n      query.set(asset.Tag.AUTH_TOKEN, authToken);\n      let res: Array<asset.AssetMap> = await asset.query(query);\n      for (let i = 0; i < res.length; i++) {\n        // parse the secret.\n        let secret: Uint8Array = res[i].get(asset.Tag.SECRET) as Uint8Array;\n        // parse uint8array to string\n        let secretStr: string = arrayToString(secret);\n      }\n      // step4. 关键资产明文查询成功后，需要调用asset.postQuery进行查询的后置处理。\n      postQueryAsset(challenge);\n    } catch (error) {\n      // step5. preQuery成功，后续操作失败，也需要调用asset.postQuery进行查询的后置处理。\n      postQueryAsset(challenge);\n    }\n  }).catch ((err: BusinessError) => {\n    console.error(`Failed to pre-query Asset. Code is ${err.code}, message is ${err.message}`);\n  })\n}

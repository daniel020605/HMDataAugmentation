使用扩展的Node-API接口在异步线程中运行和停止事件循环
场景介绍
开发者在自己创建的ArkTS运行环境中调用异步的ArkTS接口时，可以通过使用Node-API中的扩展接口napi_run_event_loop和napi_stop_event_loop来运行和停止ArkTS实例中的事件循环。
调用异步的ArkTS接口示例
调用的ArkTS接口为异步接口时，需要通过扩展接口napi_run_event_loop将异步线程中的事件循环运行起来，底层事件队列中的异步任务将被处理执行。当前Node-API扩展了两种事件循环模式来运行异步线程的事件循环，分别为napi_event_mode_nowait模式和napi_event_mode_default模式。
如果使用napi_event_mode_nowait模式运行底层事件循环，系统会尝试从底层的事件队列中取出一个任务并处理，完成之后事件循环停止，如果底层的事件队列中没有任务，事件循环会立刻停止，当前的异步线程不会被阻塞；
如果使用napi_event_mode_default模式来运行底层事件循环，系统会阻塞当前的线程，同时会一直尝试从事件队列中获取任务并执行处理这些任务。如果不想当前线程继续被阻塞，可以使用扩展接口napi_stop_event_loop将正在运行的事件循环停止。
[h2]示例代码
模块注册 // hello.cpp\n#include \"napi/native_api.h\"\n#include <napi/common.h>\n#include <pthread.h>\n\nstatic napi_value ResolvedCallback(napi_env env, napi_callback_info info)\n{\n    napi_stop_event_loop(env);\n    return nullptr;\n}\n\nstatic napi_value RejectedCallback(napi_env env, napi_callback_info info)\n{\n    napi_stop_event_loop(env);\n    return nullptr;\n}\n\nstatic void *RunEventLoopFunc(void *arg)\n{\n    // 1. 创建ArkTS实例\n    napi_env env;\n    napi_status ret = napi_create_ark_runtime(&env);\n    if (ret != napi_ok) {\n        return nullptr;\n    }\n\n    // 2. 加载自定义的模块\n    napi_value objectUtils;\n    // 'com.example.myapplication' 为当前应用的bundleName\n    ret = napi_load_module_with_info(env, \"ets/pages/ObjectUtils\", \"com.example.myapplication/entry\", &objectUtils);\n    if (ret != napi_ok) {\n        return nullptr;\n    }\n\n    // 3. 调用异步SetTimeout接口\n    napi_value setTimeout = nullptr;\n    napi_value promise = nullptr;\n\n    napi_get_named_property(env, objectUtils, \"SetTimeout\", &setTimeout);\n    napi_call_function(env, objectUtils, setTimeout, 0, nullptr, &promise);\n\n    napi_value theFunc = nullptr;\n    if (napi_get_named_property(env, promise, \"then\", &theFunc) != napi_ok) {\n        return nullptr;\n    }\n\n    napi_value resolvedCallback = nullptr;\n    napi_value rejectedCallback = nullptr;\n    napi_create_function(env, \"resolvedCallback\", NAPI_AUTO_LENGTH, ResolvedCallback, nullptr, &resolvedCallback);\n    napi_create_function(env, \"rejectedCallback\", NAPI_AUTO_LENGTH, RejectedCallback, nullptr, &rejectedCallback);\n    napi_value argv[2] = {resolvedCallback, rejectedCallback};\n    napi_call_function(env, promise, theFunc, 2, argv, nullptr);\n\n    auto flag = reinterpret_cast<bool *>(arg);\n    if (*flag == true) {\n        napi_run_event_loop(env, napi_event_mode_default);\n    } else {\n        // 非阻塞式的处理任务，有可能队列中还没有任务就已经返回了\n        napi_run_event_loop(env, napi_event_mode_nowait);\n    }\n    return nullptr;\n}\n\nstatic napi_value RunEventLoop(napi_env env, napi_callback_info info)\n{\n    pthread_t tid;\n    size_t argc = 1;\n    napi_value argv[1] = { nullptr };\n    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);\n\n    bool flag = false;\n    napi_get_value_bool(env, argv[0], &flag);\n    // 创建异步线程\n    pthread_create(&tid, nullptr, RunEventLoopFunc, &flag);\n    pthread_join(tid, nullptr);\n\n    return nullptr;\n}\n\n// 注册模块接口\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    napi_property_descriptor desc[] = {\n        { \"runEventLoop\", nullptr, RunEventLoop, nullptr, nullptr, nullptr, napi_default, nullptr }\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module nativeModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = nullptr,\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule()\n{\n    napi_module_register(&nativeModule);\n} 接口声明 // index.d.ts\nexport const runEventLoop: (isDefault: boolean) => object; 编译配置 
CMakeLists.txt文件需要按照如下配置// CMakeLists.txt\n# the minimum version of CMake.\ncmake_minimum_required(VERSION 3.4.1)\nproject(myapplication)\n\nset(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n\nif(DEFINED PACKAGE_FIND_FILE)\n    include(${PACKAGE_FIND_FILE})\nendif()\n\ninclude_directories(${NATIVERENDER_ROOT_PATH}\n                    ${NATIVERENDER_ROOT_PATH}/include)\nadd_library(entry SHARED hello.cpp)\ntarget_link_libraries(entry PUBLIC libace_napi.z.so) 需要在工程的build-profile.json5文件中进行以下配置{\n    \"buildOption\" : {\n        \"arkOptions\" : {\n            \"runtimeOnly\" : {\n                \"sources\": [\n                    \"./src/main/ets/pages/ObjectUtils.ets\"\n                ]\n            }\n        }\n    }\n} 
ArkTS代码示例// index.ets\nimport testNapi from 'libentry.so'\n\ntestNapi.runEventLoop(true); // ets/pages/ObjectUtils.ets\nexport function SetTimeout() : Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.info('set timer delay 1s');\n            // attempt to stop the event loop at napi terminal\n            resolve();\n        }, 1000)\n    })\n} 

@Param：组件外部输入
为了增强子组件接受外部参数输入的能力，开发者可以使用@Param装饰器。
@Param不仅可以接受组件外部输入，还可以接受@Local的同步变化。在阅读本文档前，建议提前阅读：@Local。
从API version 12开始，在@ComponentV2装饰的自定义组件中支持使用@Param装饰器。
概述
@Param表示组件从外部传入的状态，使得父子组件之间的数据能够进行同步：
@Param装饰的变量支持本地初始化，但是不允许在组件内部直接修改变量本身。 被@Param装饰的变量能够在初始化自定义组件时从外部传入，当数据源也是状态变量时，数据源的修改会同步给@Param。 @Param可以接受任意类型的数据源，包括普通变量、状态变量、常量、函数返回值等。 @Param装饰的变量变化时，会刷新该变量关联的组件。 @Param支持观测number、boolean、string、Object、class等基本类型以及Array、Set、Map、Date等内嵌类型。 对于复杂类型如类对象，@Param会接受数据源的引用。在组件内可以修改类对象中的属性，该修改会同步到数据源。 @Param的观测能力仅限于被装饰的变量本身。当装饰简单类型时，对变量的整体改变能够观测到；当装饰对象类型时，仅能观测对象整体的改变；当装饰数组类型时，能观测到数组整体以及数组元素项的改变；当装饰Array、Set、Map、Date等内嵌类型时，可以观测到通过API调用带来的变化。详见观察变化。 @Param支持null、undefined以及联合类型。 
状态管理V1版本接受外部传入的装饰器的局限性
状态管理V1存在多种可接受外部传入的装饰器，常用的有@State、@Prop、@Link、@ObjectLink。这些装饰器使用各有限制，不易区分，当使用不当时，还会导致性能问题。
@Observed\nclass Region {\n  x: number;\n  y: number;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n@Observed\nclass Info {\n  region: Region;\n  constructor(x: number, y: number) {\n    this.region = new Region(x, y);\n  }\n}\n@Entry\n@Component\nstruct Index {\n  @State info: Info = new Info(0, 0);\n  \n  build() {\n    Column() {\n      Button(\"change Info\")\n        .onClick(() => {\n          this.info = new Info(100, 100);\n      })\n      Child({\n        region: this.info.region,\n        regionProp: this.info.region,\n        infoProp: this.info,\n        infoLink: this.info,\n        infoState: this.info\n      })\n    }\n  }\n}\n@Component\nstruct Child {\n  @ObjectLink region: Region;\n  @Prop regionProp: Region;\n  @Prop infoProp: Info;\n  @Link infoLink: Info;\n  @State infoState: Info = new Info(1, 1);\n  build() {\n    Column() {\n      Text(`ObjectLink region: ${this.region.x}-${this.region.y}`)\n      Text(`Prop regionProp: ${this.regionProp.x}-${this.regionProp.y}`)\n    }\n  }\n}
在上面的示例中，@State仅能在初始化时获得info的引用，当改变info之后，无法进行同步。@Prop虽然能够进行单向同步，但是对于较复杂的类型来说，深拷贝性能较差。@Link能够接受传入的引用进行双向同步，但它必须要求数据源也是状态变量，因此无法接受info中的成员属性region。@ObjectLink能够接受类成员属性，但是要求该属性类型必须为@Observed装饰的类。装饰器的不同限制使得父子组件之间传值规则十分复杂，不易使用。因此推出@Param装饰器表示组件从外部传入的状态。
装饰器说明
变量传递
观察变化
使用@Param装饰的变量具有被观测变化的能力。当装饰的变量发生变化时，会触发该变量绑定的UI组件刷新。
当装饰的变量类型为boolean、string、number类型时，可以观察来自数据源同步的变化。 @Entry\n@ComponentV2\nstruct Index {\n  @Local count: number = 0;\n  @Local message: string = \"Hello\";\n  @Local flag: boolean = false;\n  build() {\n    Column() {\n      Text(`Local ${this.count}`)\n      Text(`Local ${this.message}`)\n      Text(`Local ${this.flag}`)\n      Button(\"change Local\")\n        .onClick(()=>{\n          // 对数据源的更改会同步给子组件\n          this.count++;\n          this.message += \" World\";\n          this.flag = !this.flag;\n      })\n      Child({\n        count: this.count,\n        message: this.message,\n        flag: this.flag\n      })\n    }\n  }\n}\n@ComponentV2\nstruct Child {\n  @Require @Param count: number;\n  @Require @Param message: string;\n  @Require @Param flag: boolean;\n  build() {\n    Column() {\n      Text(`Param ${this.count}`)\n      Text(`Param ${this.message}`)\n      Text(`Param ${this.flag}`)\n    }\n  }\n} 当装饰的变量类型为类对象时，仅可以观察到对类对象整体赋值的变化，无法直接观察到对类成员属性赋值的变化，对类成员属性的观察依赖@ObservedV2和@Trace装饰器。 class RawObject {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n@ObservedV2\nclass ObservedObject {\n  @Trace name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local rawObject: RawObject = new RawObject(\"rawObject\");\n  @Local observedObject: ObservedObject = new ObservedObject(\"observedObject\");\n  build() {\n    Column() {\n      Text(`${this.rawObject.name}`)\n      Text(`${this.observedObject.name}`)\n      Button(\"change object\")\n        .onClick(() => {\n          // 对类对象整体的修改均能观察到\n          this.rawObject = new RawObject(\"new rawObject\");\n          this.observedObject = new ObservedObject(\"new observedObject\");\n      })\n      Button(\"change name\")\n        .onClick(() => {\n          // @Local与@Param均不具备观察类对象属性的能力，因此对rawObject.name的修改无法观察到\n          this.rawObject.name = \"new rawObject name\";\n          // 由于ObservedObject的name属性被@Trace装饰，因此对observedObject.name的修改能被观察到\n          this.observedObject.name = \"new observedObject name\";\n      })\n      Child({\n        rawObject: this.rawObject,\n        observedObject: this.observedObject\n      })\n    }\n  }\n}\n@ComponentV2\nstruct Child {\n  @Require @Param rawObject: RawObject;\n  @Require @Param observedObject: ObservedObject;\n  build() {\n    Column() {\n      Text(`${this.rawObject.name}`)\n      Text(`${this.observedObject.name}`)\n    }\n  }\n  \n} 当装饰的变量类型为简单类型的数组时，可以观察到数组整体或数组项的变化。 @Entry\n@ComponentV2\nstruct Index {\n  @Local numArr: number[] = [1,2,3,4,5];\n  @Local dimensionTwo: number[][] = [[1,2,3],[4,5,6]];\n  \n  build() {\n    Column() {\n      Text(`${this.numArr[0]}`)\n      Text(`${this.numArr[1]}`)\n      Text(`${this.numArr[2]}`)\n      Text(`${this.dimensionTwo[0][0]}`)\n      Text(`${this.dimensionTwo[1][1]}`)\n      Button(\"change array item\")\n        .onClick(() => {\n          this.numArr[0]++;\n          this.numArr[1] += 2;\n          this.dimensionTwo[0][0] = 0;\n          this.dimensionTwo[1][1] = 0;\n        })\n      Button(\"change whole array\")\n        .onClick(() => {\n          this.numArr = [5,4,3,2,1];\n          this.dimensionTwo = [[7,8,9],[0,1,2]];\n        })\n      Child({\n        numArr: this.numArr,\n        dimensionTwo: this.dimensionTwo\n      })\n    }\n  }\n}\n@ComponentV2\nstruct Child {\n  @Require @Param numArr: number[];\n  @Require @Param dimensionTwo: number[][];\n  \n  build() {\n    Column() {\n      Text(`${this.numArr[0]}`)\n      Text(`${this.numArr[1]}`)\n      Text(`${this.numArr[2]}`)\n      Text(`${this.dimensionTwo[0][0]}`)\n      Text(`${this.dimensionTwo[1][1]}`)\n    }\n  }\n} 当装饰的变量是嵌套类或对象数组时，@Param无法观察深层对象属性的变化。对深层对象属性的观测依赖@ObservedV2与@Trace装饰器。 @ObservedV2\nclass Region {\n  @Trace x: number;\n  @Trace y: number;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n@ObservedV2\nclass Info {\n  @Trace region: Region;\n  @Trace name: string;\n  constructor(name: string, x: number, y: number) {\n    this.name = name;\n    this.region = new Region(x, y);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local infoArr: Info[] = [new Info(\"Ocean\", 28, 120), new Info(\"Mountain\", 26, 20)];\n  @Local originInfo: Info = new Info(\"Origin\", 0, 0);\n  build() {\n    Column() {\n      ForEach(this.infoArr, (info: Info) => {\n        Row() {\n          Text(`name: ${info.name}`)\n          Text(`region: ${info.region.x}-${info.region.y}`)\n        }\n      })\n      Row() {\n        Text(`Origin name: ${this.originInfo.name}`)\n        Text(`Origin region: ${this.originInfo.region.x}-${this.originInfo.region.y}`)\n      }\n      Button(\"change infoArr item\")\n        .onClick(() => {\n          // 由于属性name被@Trace装饰，所以能够观察到\n          this.infoArr[0].name = \"Win\";\n        })\n      Button(\"change originInfo\")\n        .onClick(() => {\n          // 由于变量originInfo被@Local装饰，所以能够观察到\n          this.originInfo = new Info(\"Origin\", 100, 100);\n        })\n      Button(\"change originInfo region\")\n        .onClick(() => {\n          // 由于属性x、y被@Trace装饰，所以能够观察到\n          this.originInfo.region.x = 25;\n          this.originInfo.region.y = 25;\n        })\n    }\n  }\n}\n@ComponentV2\nstruct Child {\n  @Param infoArr: Info[] = [];\n  @Param originInfo: Info = new Info(\"O\", 0, 0);\n\n  build() {\n    Column() {\n      ForEach(this.infoArr, (info: Info) => {\n        Row() {\n          Text(`name: ${info.name}`)\n          Text(`region: ${info.region.x}-${info.region.y}`)\n        }\n      })\n      Row() {\n        Text(`Origin name: ${this.originInfo.name}`)\n        Text(`Origin region: ${this.originInfo.region.x}-${this.originInfo.region.y}`)\n      }\n    }\n  }\n} 当装饰的变量类型是内置类型时，可以观察到变量整体赋值以及通过API调用带来的变化。 类型 可观测变化的API   Array push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort  Date setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds  Map set, clear, delete  Set add, clear, delete    
限制条件
@Param装饰器存在以下使用限制：
@Param装饰器只能在@ComponentV2装饰器的自定义组件中使用。 @ComponentV2\nstruct MyComponent {\n  @Param message: string = \"Hello World\"; // 正确用法\n  build() {\n  }\n}\n@Component\nstruct TestComponent {\n  @Param message: string = \"Hello World\"; // 错误用法，编译时报错\n  build() {\n  }\n} @Param装饰的变量表示组件外部输入，需要被初始化。支持使用本地初始值做初始化。当存在外部传入值时，将优先使用外部传入的值初始化。既不使用本地初始值，也不使用外部传入值是不允许的。 @ComponentV2\nstruct ChildComponent {\n  @Param param1: string = \"Initialize local\";\n  @Param param2: string = \"Initialize local and put in\";\n  @Require @Param param3: string;\n  @Param param4: string; // 错误用法，外部未传入初始化且本地也无初始值，编译报错\n  build() {\n    Column() {\n      Text(`${this.param1}`) // 本地初始化，显示Initialize local\n      Text(`${this.param2}`) // 外部传入初始化，显示Put in\n      Text(`${this.param3}`) // 外部传入初始化，显示Put in\n    }\n  }\n}\n@Entry\n@ComponentV2\nstruct MyComponent {\n  @Local message: string = \"Put in\";\n  build() {\n    Column() {\n      ChildComponent({\n        param2: this.message,\n        param3: this.message\n      })\n    }\n  }\n} @Param装饰的变量在子组件中无法进行修改。但当装饰的变量类型为对象时，在子组件中修改对象中属性是允许的。 @ObservedV2\nclass Info {\n  @Trace name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local info: Info = new Info(\"Tom\");\n  build() {\n    Column() {\n      Text(`Parent info.name ${this.info.name}`)\n      Button(\"Parent change info\")\n        .onClick(() => {\n          // 父组件更改@Local变量，会同步子组件对应@Param变量\n          this.info = new Info(\"Lucy\");\n      })\n      Child({ info: this.info })\n    }\n  }\n}\n@ComponentV2\nstruct Child {\n  @Require @Param info: Info;\n  build() {\n    Column() {\n      Text(`info.name: ${this.info.name}`)\n      Button(\"change info\")\n        .onClick(() => {\n          // 错误用法，不允许在子组件更改@Param变量，编译时报错\n          this.info = new Info(\"Jack\");\n        })\n      Button(\"Child change info.name\")\n        .onClick(() => {\n          // 允许在子组件中更改对象中属性，该修改会同步到父组件数据源上，当属性被@Trace装饰时，可观测到对应UI刷新\n          this.info.name = \"Jack\";\n        })\n    }\n  }\n} 
使用场景
[h2]从父组件到子组件变量传递与同步
@Param能够接受父组件@Local或@Param传递的数据并与之变化同步。
@ObservedV2\nclass Region {\n  @Trace x: number;\n  @Trace y: number;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n@ObservedV2\nclass Info {\n  @Trace name: string;\n  @Trace age: number;\n  @Trace region: Region;\n  constructor(name: string, age: number, x: number, y: number) {\n    this.name = name;\n    this.age = age;\n    this.region = new Region(x, y);\n  }\n}\n@Entry\n@ComponentV2\nstruct Index {\n  @Local infoList: Info[] = [new Info(\"Alice\", 8, 0, 0), new Info(\"Barry\", 10, 1, 20), new Info(\"Cindy\", 18, 24, 40)];\n  build() {\n    Column() {\n      ForEach(this.infoList, (info: Info) => {\n        MiddleComponent({ info: info })\n      })\n      Button(\"change\")\n        .onClick(() => {\n          this.infoList[0] = new Info(\"Atom\", 40, 27, 90);\n          this.infoList[1].name = \"Bob\";\n          this.infoList[2].region = new Region(7, 9);\n        })\n    }\n  }\n}\n@ComponentV2\nstruct MiddleComponent {\n  @Require @Param info: Info;\n  build() {\n    Column() {\n      Text(`name: ${this.info.name}`)\n      Text(`age: ${this.info.age}`)\n      SubComponent({ region: this.info.region })\n    }\n  }\n}\n@ComponentV2\nstruct SubComponent {\n  @Require @Param region: Region;\n  build() {\n    Column() {\n      Text(`region: ${this.region.x}-${this.region.y}`)\n    }\n  }\n}
[h2]装饰Date类型变量
@Param装饰Date类型变量，可以观察到数据源对Date整体的赋值，以及调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 带来的变化。
@ComponentV2\nstruct DateComponent {\n  @Param selectedDate: Date = new Date('2024-01-01');\n\n  build() {\n    Column() {\n      DatePicker({\n        start: new Date('1970-1-1'),\n        end: new Date('2100-1-1'),\n        selected: this.selectedDate\n      })\n    }\n  }\n}\n\n@Entry\n@ComponentV2\nstruct ParentComponent {\n  @Local parentSelectedDate: Date = new Date('2021-08-08');\n\n  build() {\n    Column() {\n      Button('parent update the new date')\n        .margin(10)\n        .onClick(() => {\n          this.parentSelectedDate = new Date('2023-07-07')\n        })\n      Button('increase the year by 1')\n        .margin(10)\n        .onClick(() => {\n        this.parentSelectedDate.setFullYear(this.parentSelectedDate.getFullYear() + 1)\n        })\n      Button('increase the month by 1')\n        .margin(10)\n        .onClick(() => {\n        this.parentSelectedDate.setMonth(this.parentSelectedDate.getMonth() + 1)\n        })\n      Button('parent increase the day by 1')\n        .margin(10)\n        .onClick(() => {\n   this.parentSelectedDate.setDate(this.parentSelectedDate.getDate() + 1)\n        })\n      DateComponent({ selectedDate: this.parentSelectedDate })\n    }\n  }\n}
[h2]装饰Map类型变量
@Param装饰Map类型变量，可以观察到数据源对Map整体的赋值，以及调用Map的接口 set、clear、delete带来的变化。
@ComponentV2\nstruct Child {\n  @Param value: Map<number, string> = new Map()\n\n  build() {\n    Column() {\n      ForEach(Array.from(this.value.entries()), (item: [number, string]) => {\n        Text(`${item[0]}`).fontSize(30)\n        Text(`${item[1]}`).fontSize(30)\n        Divider()\n      })\n    }\n  }\n}\n@Entry\n@ComponentV2\nstruct MapSample2 {\n  @Local message: Map<number, string> = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]])\n\n  build() {\n    Row() {\n      Column() {\n        Child({ value: this.message })\n        Button('init map').onClick(() => {\n          this.message = new Map([[0, \"a\"], [1, \"b\"], [3, \"c\"]])\n        })\n        Button('set new one').onClick(() => {\n          this.message.set(4, \"d\")\n        })\n        Button('clear').onClick(() => {\n          this.message.clear()\n        })\n        Button('replace the first one').onClick(() => {\n          this.message.set(0, \"aa\")\n        })\n        Button('delete the first one').onClick(() => {\n          this.message.delete(0)\n        })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]装饰Set类型变量
@Param装饰Set类型变量，可以观察到数据源对Set整体的赋值，以及调用Set的接口 add、clear、delete带来的变化。
@ComponentV2\nstruct Child {\n  @Param message: Set<number> = new Set()\n\n  build() {\n    Column() {\n      ForEach(Array.from(this.message.entries()), (item: [number, string]) => {\n        Text(`${item[0]}`).fontSize(30)\n        Divider()\n      })\n    }\n    .width('100%')\n  }\n}\n@Entry\n@ComponentV2\nstruct SetSample11 {\n  @Local message: Set<number> = new Set([0, 1, 2, 3, 4])\n\n  build() {\n    Row() {\n      Column() {\n        Child({ message: this.message })\n        Button('init set').onClick(() => {\n          this.message = new Set([0, 1, 2, 3, 4])\n        })\n        Button('set new one').onClick(() => {\n          this.message.add(5)\n        })\n        Button('clear').onClick(() => {\n          this.message.clear()\n        })\n        Button('delete the first one').onClick(() => {\n          this.message.delete(0)\n        })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]联合类型
@Param支持null、undefined以及联合类型。在下面的示例中，count类型为number | undefined，点击改变count的类型，UI会随之刷新。
@Entry\n@ComponentV2\nstruct Index {\n  @Local count: number | undefined = 0;\n\n  build() {\n    Column() {\n      MyComponent({ count: this.count })\n      Button('change')\n        .onClick(() => {\n          this.count = undefined;\n        })\n    }\n  }\n}\n\n@ComponentV2\nstruct MyComponent {\n  @Param count: number | undefined = 0;\n\n  build() {\n    Column() {\n      Text(`count(${this.count})`)\n    }\n  }\n}

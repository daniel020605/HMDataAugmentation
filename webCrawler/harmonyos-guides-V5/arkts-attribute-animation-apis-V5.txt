实现属性动画
通过可动画属性改变引起UI上产生的连续视觉效果，即为属性动画。属性动画是最基础易懂的动画，ArkUI提供两种属性动画接口animateTo和animation驱动组件属性按照动画曲线等动画参数进行连续的变化，产生属性动画。
闭包内改变属性引起的界面变化。
作用于出现消失转场。
通用函数，对闭包前界面和闭包中的状态变量引起的界面之间的差异做动画。
支持多次调用，支持嵌套。
适用对多个可动画属性配置相同动画参数的动画。
需要嵌套使用动画的场景。
识别组件的可动画属性变化，自动添加动画。
组件的接口调用是从下往上执行，animation只会作用于在其之上的属性调用。
组件可以根据调用顺序对多个属性设置不同的animation。
使用animateTo产生属性动画
animateTo(value: AnimateParam, event: () => void): void
animateTo接口参数中，value指定AnimateParam对象（包括时长、Curve等）event为动画的闭包函数，闭包内变量改变产生的属性动画将遵循相同的动画参数。
直接使用animateTo可能导致实例不明确的问题，建议使用getUIContext获取UIContext实例，并使用animateTo调用绑定实例的animateTo。
import { curves } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct AnimateToDemo {\n  @State animate: boolean = false;\n  // 第一步: 声明相关状态变量\n  @State rotateValue: number = 0; // 组件一旋转角度\n  @State translateX: number = 0; // 组件二偏移量\n  @State opacityValue: number = 1; // 组件二透明度\n\n  // 第二步：将状态变量设置到相关可动画属性接口\n  build() {\n    Row() {\n      // 组件一\n      Column() {\n      }\n      .rotate({ angle: this.rotateValue })\n      .backgroundColor('#317AF7')\n      .justifyContent(FlexAlign.Center)\n      .width(100)\n      .height(100)\n      .borderRadius(30)\n      .onClick(() => {\n        this.getUIContext()?.animateTo({ curve: curves.springMotion() }, () => {\n          this.animate = !this.animate;\n          // 第三步：闭包内通过状态变量改变UI界面\n          // 这里可以写任何能改变UI的逻辑比如数组添加，显隐控制，系统会检测改变后的UI界面与之前的UI界面的差异，对有差异的部分添加动画\n          // 组件一的rotate属性发生变化，所以会给组件一添加rotate旋转动画\n          this.rotateValue = this.animate ? 90 : 0;\n          // 组件二的透明度发生变化，所以会给组件二添加透明度的动画\n          this.opacityValue = this.animate ? 0.6 : 1;\n          // 组件二的translate属性发生变化，所以会给组件二添加translate偏移动画\n          this.translateX = this.animate ? 50 : 0;\n        })\n      })\n\n      // 组件二\n      Column() {\n\n      }\n      .justifyContent(FlexAlign.Center)\n      .width(100)\n      .height(100)\n      .backgroundColor('#D94838')\n      .borderRadius(30)\n      .opacity(this.opacityValue)\n      .translate({ x: this.translateX })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}
使用animation产生属性动画
相比于animateTo接口需要把要执行动画的属性的修改放在闭包中，animation接口无需使用闭包，把animation接口加在要做属性动画的可动画属性后即可。animation只要检测到其绑定的可动画属性发生变化，就会自动添加属性动画，animateTo则必须在动画闭包内改变可动画属性的值从而生成动画。
import { curves } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct AnimationDemo {\n  @State animate: boolean = false;\n  // 第一步: 声明相关状态变量\n  @State rotateValue: number = 0; // 组件一旋转角度\n  @State translateX: number = 0; // 组件二偏移量\n  @State opacityValue: number = 1; // 组件二透明度\n\n  // 第二步：将状态变量设置到相关可动画属性接口\n  build() {\n    Row() {\n      // 组件一\n      Column() {\n      }\n      .opacity(this.opacityValue)\n      .rotate({ angle: this.rotateValue })\n      // 第三步：通过属性动画接口开启属性动画\n      .animation({ curve: curves.springMotion() })\n      .backgroundColor('#317AF7')\n      .justifyContent(FlexAlign.Center)\n      .width(100)\n      .height(100)\n      .borderRadius(30)\n      .onClick(() => {\n        this.animate = !this.animate;\n        // 第四步：闭包内通过状态变量改变UI界面\n        // 这里可以写任何能改变UI的逻辑比如数组添加，显隐控制，系统会检测改变后的UI界面与之前的UI界面的差异，对有差异的部分添加动画\n        // 组件一的rotate属性发生变化，所以会给组件一添加rotate旋转动画\n        this.rotateValue = this.animate ? 90 : 0;\n        // 组件二的translate属性发生变化，所以会给组件二添加translate偏移动画\n        this.translateX = this.animate ? 50 : 0;\n        // 父组件column的opacity属性有变化，会导致其子节点的透明度也变化，所以这里会给column和其子节点的透明度属性都加动画\n        this.opacityValue = this.animate ? 0.6 : 1;\n      })\n\n      // 组件二\n      Column() {\n      }\n      .justifyContent(FlexAlign.Center)\n      .width(100)\n      .height(100)\n      .backgroundColor('#D94838')\n      .borderRadius(30)\n      .opacity(this.opacityValue)\n      .translate({ x: this.translateX })\n      .animation({ curve: curves.springMotion() })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}
 在对组件的位置大小的变化做动画的时候，由于布局属性的改变会触发测量布局，性能开销大。scale属性的改变不会触发测量布局，性能开销小。因此，在组件位置大小持续发生变化的场景，如跟手触发组件大小变化的场景，推荐适用scale。 属性动画应该作用于始终存在的组件，对于将要出现或者将要消失的组件的动画应该使用转场动画。 尽量不要使用动画结束回调。属性动画是对已经发生的状态进行的动画，不需要开发者去处理结束的逻辑。如果要使用结束回调，一定要正确处理连续操作的数据管理。 

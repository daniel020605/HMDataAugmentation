@AnimatableExtend装饰器：定义可动画属性
@AnimatableExtend装饰器用于自定义可动画的属性方法，在这个属性方法中修改组件不可动画的属性。在动画执行过程时，通过逐帧回调函数修改不可动画属性值，让不可动画属性也能实现动画效果。也可通过逐帧回调函数修改可动画属性的值，实现逐帧布局的效果。
可动画属性：如果一个属性方法在animation属性前调用，改变这个属性的值可以使animation属性的动画效果生效，这个属性称为可动画属性。比如height、width、backgroundColor、translate属性，和Text组件的fontSize属性等。 不可动画属性：如果一个属性方法在animation属性前调用，改变这个属性的值不能使animation属性的动画效果生效，这个属性称为不可动画属性。比如Polyline组件的points属性等。 
 该装饰器从API Version 10开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。
从API version 11开始，该装饰器支持在元服务中使用。
装饰器使用说明
[h2]语法
@AnimatableExtend(UIComponentName) function functionName(value: typeName) { \n  .propertyName(value)\n}
@AnimatableExtend仅支持定义在全局，不支持在组件内部定义。@AnimatableExtend定义的函数参数类型必须为number类型或者实现 AnimatableArithmetic<T>接口的自定义类型。@AnimatableExtend定义的函数体内只能调用@AnimatableExtend括号内组件的属性方法。
[h2]AnimatableArithmetic<T>接口说明
该接口定义非number数据类型的动画运算规则。对非number类型的数据（如数组、结构体、颜色等）做动画，需要实现AnimatableArithmetic<T>接口中加法、减法、乘法和判断相等函数，
使得该数据能参与动画的插值运算和识别该数据是否发生改变。即定义它们为实现了AnimatableArithmetic<T>接口的类型。
使用场景
以下示例通过改变Text组件宽度实现逐帧布局的效果。
@AnimatableExtend(Text)\nfunction animatableWidth(width: number) {\n  .width(width)\n}\n\n@Entry\n@Component\nstruct AnimatablePropertyExample {\n  @State textWidth: number = 80;\n\n  build() {\n    Column() {\n      Text(\"AnimatableProperty\")\n        .animatableWidth(this.textWidth)\n        .animation({ duration: 2000, curve: Curve.Ease })\n      Button(\"Play\")\n        .onClick(() => {\n          this.textWidth = this.textWidth == 80 ? 160 : 80;\n        })\n    }.width(\"100%\")\n    .padding(10)\n  }\n}
以下示例实现折线的动画效果。 
class Point {\n  x: number\n  y: number\n\n  constructor(x: number, y: number) {\n    this.x = x\n    this.y = y\n  }\n\n  plus(rhs: Point): Point {\n    return new Point(this.x + rhs.x, this.y + rhs.y)\n  }\n\n  subtract(rhs: Point): Point {\n    return new Point(this.x - rhs.x, this.y - rhs.y)\n  }\n\n  multiply(scale: number): Point {\n    return new Point(this.x * scale, this.y * scale)\n  }\n\n  equals(rhs: Point): boolean {\n    return this.x === rhs.x && this.y === rhs.y\n  }\n}\n\n// PointVector实现了AnimatableArithmetic<T>接口\nclass PointVector extends Array<Point> implements AnimatableArithmetic<PointVector> {\n  constructor(value: Array<Point>) {\n    super();\n    value.forEach(p => this.push(p))\n  }\n\n  plus(rhs: PointVector): PointVector {\n    let result = new PointVector([])\n    const len = Math.min(this.length, rhs.length)\n    for (let i = 0; i < len; i++) {\n      result.push((this as Array<Point>)[i].plus((rhs as Array<Point>)[i]))\n    }\n    return result\n  }\n\n  subtract(rhs: PointVector): PointVector {\n    let result = new PointVector([])\n    const len = Math.min(this.length, rhs.length)\n    for (let i = 0; i < len; i++) {\n      result.push((this as Array<Point>)[i].subtract((rhs as Array<Point>)[i]))\n    }\n    return result\n  }\n\n  multiply(scale: number): PointVector {\n    let result = new PointVector([])\n    for (let i = 0; i < this.length; i++) {\n      result.push((this as Array<Point>)[i].multiply(scale))\n    }\n    return result\n  }\n\n  equals(rhs: PointVector): boolean {\n    if (this.length != rhs.length) {\n      return false\n    }\n    for (let i = 0; i < this.length; i++) {\n      if (!(this as Array<Point>)[i].equals((rhs as Array<Point>)[i])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  get(): Array<Object[]> {\n    let result: Array<Object[]> = []\n    this.forEach(p => result.push([p.x, p.y]))\n    return result\n  }\n}\n\n@AnimatableExtend(Polyline)\nfunction animatablePoints(points: PointVector) {\n  .points(points.get())\n}\n\n@Entry\n@Component\nstruct AnimatablePropertyExample {\n  @State points: PointVector = new PointVector([\n    new Point(50, Math.random() * 200),\n    new Point(100, Math.random() * 200),\n    new Point(150, Math.random() * 200),\n    new Point(200, Math.random() * 200),\n    new Point(250, Math.random() * 200),\n  ])\n\n  build() {\n    Column() {\n      Polyline()\n        .animatablePoints(this.points)\n        .animation({ duration: 1000, curve: Curve.Ease })// 设置动画参数\n        .size({ height: 220, width: 300 })\n        .fill(Color.Green)\n        .stroke(Color.Red)\n        .backgroundColor('#eeaacc')\n      Button(\"Play\")\n        .onClick(() => {\n          // points是实现了可动画协议的数据类型，points在动画过程中可按照定义的运算规则、动画参数从之前的PointVector变为新的PointVector数据，产生每一帧的PointVector数据，进而产生动画\n          this.points = new PointVector([\n            new Point(50, Math.random() * 200),\n            new Point(100, Math.random() * 200),\n            new Point(150, Math.random() * 200),\n            new Point(200, Math.random() * 200),\n            new Point(250, Math.random() * 200),\n          ])\n        })\n    }.width(\"100%\")\n    .padding(10)\n  }\n}

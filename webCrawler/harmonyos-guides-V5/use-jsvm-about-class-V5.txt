使用JSVM进行class相关开发
简介
使用JSVM-API接口进行class相关开发，处理JavaScript中的类，例如定义类、构造实例等。
基本概念
在使用JSVM-API接口进行class相关开发时，需要理解以下基本概念：
类：类是用于创建对象的模板。它提供了一种封装数据和行为的方式，以便于对数据进行处理和操作。类在JavaScript中是建立在原型（prototype）的基础上的，并且还引入了一些类独有的语法和语义。实例：实例是通过类创建具体的对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。
接口说明
使用示例
JSVM-API接口开发流程参考使用JSVM-API实现JS与C/C++语言交互开发流程，本文仅对接口对应C++相关代码进行展示。
[h2]OH_JSVM_NewInstance
通过给定的构造函数，构建一个实例。
cpp部分代码
// hello.cpp\n#include <string.h>\n\nstd::string ToString(JSVM_Env env, JSVM_Value val) {\n    JSVM_Value jsonString;\n    JSVM_CALL(OH_JSVM_JsonStringify(env, val, &jsonString));\n    size_t totalLen = 0;\n    JSVM_CALL(OH_JSVM_GetValueStringUtf8(env, jsonString, nullptr, 0, &totalLen));\n    size_t needLen = totalLen + 1;\n    char* buff = new char[needLen];\n    std::memset(buff, 0, needLen);\n    JSVM_CALL(OH_JSVM_GetValueStringUtf8(env, jsonString, buff, needLen, &totalLen));\n    std::string str(buff);\n    delete[] buff;\n    return str;\n}\n\n// OH_JSVM_NewInstance的样例方法\nstatic JSVM_Value NewInstance(JSVM_Env env, JSVM_CallbackInfo info) {\n    // 获取js侧传入的两个参数\n    size_t argc = 2;\n    JSVM_Value args[2] = {nullptr};\n    JSVM_CALL(OH_JSVM_GetCbInfo(env, info, &argc, args, nullptr, nullptr));\n    JSVM_Value result = nullptr;\n    // 调用OH_JSVM_NewInstance接口，实例化一个对象，将这个对象返回\n    JSVM_CALL(OH_JSVM_NewInstance(env, args[0], 1, &args[1], &result));\n    std::string str = ToString(env, result);\n    OH_LOG_INFO(LOG_APP, \"NewInstance:%{public}s\", str.c_str());\n    return nullptr;\n}\n\n// 通过给定的构造函数，构建一个实例。\n// NewInstance注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = NewInstance},\n};\n\nstatic JSVM_CallbackStruct *method = param;\n\n// NewInstance方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"newInstance\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};
样例JS
const char *srcCallNative = R\"JS(
 function Fruit(name) {
 this.name = name;
 }
 newInstance(Fruit, \"apple\");
)JS\";
执行结果
在LOG中输出下面的结果：
NewInstance:{\"name\":\"apple\"}
[h2]OH_JSVM_GetNewTarget
用于获取函数的元属性new.target值。在JavaScript中，new.target是一个特殊的元属性，用于检测函数或构造函数是否是通过 'new' 运算符被调用的。
[h2]OH_JSVM_DefineClass
用于在JavaScript中定义一个类，并与对应的C类进行封装和交互。它提供了创建类的构造函数、定义属性和方法的能力，以及在C和JavaScript之间进行数据交互的支持
cpp部分代码
// hello.cpp\n#include <string>\n\nJSVM_Value CreateInstance(JSVM_Env env, JSVM_CallbackInfo info) {\n    JSVM_Value newTarget;\n    // 获取构造函数的new.target值\n    JSVM_CALL(OH_JSVM_GetNewTarget(env, info, &newTarget));\n    OH_LOG_INFO(LOG_APP, \"Create Instance\");\n    OH_LOG_INFO(LOG_APP, \"NAPI MyObject::New %{public}s\", newTarget != nullptr ? \"newTarget != nullptr\" : \"newTarget == nullptr\");\n    JSVM_Value jsObject = nullptr;\n    JSVM_CALL(OH_JSVM_CreateObject(env, &jsObject));\n    JSVM_Value jsName = nullptr;\n    JSVM_CALL(OH_JSVM_CreateStringUtf8(env, \"name\", JSVM_AUTO_LENGTH, &jsName));\n    JSVM_Value jsValue = nullptr;\n    JSVM_CALL(OH_JSVM_CreateStringUtf8(env, \"lilei\", JSVM_AUTO_LENGTH, &jsValue));\n    JSVM_CALL(OH_JSVM_SetProperty(env, jsObject, jsName, jsValue));\n    return jsObject;\n}\n\nstd::string ToString(JSVM_Env env, JSVM_Value val) {\n    JSVM_Value jsonString;\n    JSVM_CALL(OH_JSVM_JsonStringify(env, val, &jsonString));\n    size_t totalLen = 0;\n    JSVM_CALL(OH_JSVM_GetValueStringUtf8(env, jsonString, nullptr, 0, &totalLen));\n    size_t needLen = totalLen + 1;\n    char* buff = new char[needLen];\n    std::memset(buff, 0, needLen);\n    JSVM_CALL(OH_JSVM_GetValueStringUtf8(env, jsonString, buff, needLen, &totalLen));\n    std::string str(buff);\n    delete[] buff;\n    return str;\n}\n\n// 封装c++中的自定义数据结构\nJSVM_Value DefineClass(JSVM_Env env, JSVM_CallbackInfo info) {\n    JSVM_CallbackStruct param;\n    param.data = nullptr;\n    param.callback = CreateInstance;\n    JSVM_Value cons;\n    // 用于在JavaScript中定义一个类\n    JSVM_CALL(OH_JSVM_DefineClass(env, \"MyObject\", JSVM_AUTO_LENGTH, &param, 0, nullptr, &cons));\n    JSVM_Value instanceValue = nullptr;\n    // 作为class的构造函数调用\n    JSVM_CALL(OH_JSVM_NewInstance(env, cons, 0, nullptr, &instanceValue));\n    std::string str = ToString(env, instanceValue);\n    OH_LOG_INFO(LOG_APP, \"NewInstance:%{public}s\", str.c_str());\n    \n    // 作为普通的函数调用\n    JSVM_Value global;\n    JSVM_CALL(OH_JSVM_GetGlobal(env, &global));\n    JSVM_Value key;\n    JSVM_CALL(OH_JSVM_CreateStringUtf8(env, \"Constructor\", JSVM_AUTO_LENGTH, &key));\n    JSVM_CALL(OH_JSVM_SetProperty(env, global, key, cons));\n    JSVM_Value result;\n    JSVM_CALL(OH_JSVM_CallFunction(env, global, cons, 0, nullptr, &result));\n    std::string buf = ToString(env, result);\n    OH_LOG_INFO(LOG_APP, \"NewInstance:%{public}s\", buf.c_str());\n    return nullptr;\n}\n\n// 注册DefineClass的方法\nJSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = DefineClass},\n};\n\nstatic JSVM_CallbackStruct *method = param;\n\n// DefineClass方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"defineClass\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};
样例JS
const char *srcCallNative = R\"JS(
 defineClass();
)JS\";
执行结果
在LOG中输出下面的结果：
Create Instance
NAPI MyObject::New newTarget != nullptr
NewInstance:{\"name\":\"lilei\"}
Create Instance
NAPI MyObject::New newTarget == nullptr
NewInstance:{\"name\":\"lilei\"}
[h2]OH_JSVM_Wrap
在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例
[h2]OH_JSVM_Unwrap
解包先前封装在JavaScript对象中的原生实例
[h2]OH_JSVM_RemoveWrap
解包先前封装在JavaScript对象中的原生实例并释放封装
cpp部分代码
// hello.cpp\n#include <string>\n\n// OH_JSVM_GetNewTarget、OH_JSVM_DefineClass、OH_JSVM_Wrap、OH_JSVM_Unwrap、OH_JSVM_RemoveWrap的样例方法\n\n// 自定义类结构体Object\nstruct Object {\n    std::string name;\n    int32_t age;\n};\n\n// 定义一个回调函数\nstatic void DerefItem(JSVM_Env env, void *data, void *hint) {\n    OH_LOG_INFO(LOG_APP, \"JSVM deref_item\");\n    (void)hint;\n}\n\nstatic JSVM_Value WrapObject(JSVM_Env env, JSVM_CallbackInfo info) {\n    OH_LOG_INFO(LOG_APP, \"JSVM wrap\");\n    Object obj;\n    // 设置Object属性\n    obj.name = \"lilei\";\n    obj.age = 18;\n    Object *objPointer = &obj;\n    // 获取回调信息中的参数数量和将要被封装的值\n    size_t argc = 1;\n    JSVM_Value toWrap = nullptr;\n    JSVM_CALL(OH_JSVM_GetCbInfo(env, info, &argc, &toWrap, nullptr, nullptr));\n    // OH_JSVM_Wrap将自定义结构Object进行封装\n    JSVM_CALL(OH_JSVM_Wrap(env, toWrap, reinterpret_cast<void *>(objPointer), DerefItem, NULL, NULL));\n    Object *data;\n    // OH_JSVM_UnWrap解包先前封装在JavaScript对象中的原生实例\n    JSVM_CALL(OH_JSVM_Unwrap(env, toWrap, reinterpret_cast<void **>(&data)));\n    OH_LOG_INFO(LOG_APP, \"JSVM name: %{public}s\", data->name.c_str());\n    OH_LOG_INFO(LOG_APP, \"JSVM age: %{public}d\", data->age);\n    return nullptr;\n}\n\nstatic JSVM_Value RemoveWrap(JSVM_Env env, JSVM_CallbackInfo info) {\n    OH_LOG_INFO(LOG_APP, \"JSVM removeWrap\");\n    Object obj;\n    // 设置Object属性\n    obj.name = \"lilei\";\n    obj.age = 18;\n    Object *objPointer = &obj;\n    // 获取回调信息中的参数数量和将要被封装的值\n    size_t argc = 1;\n    JSVM_Value toWrap = nullptr;\n    JSVM_CALL(OH_JSVM_GetCbInfo(env, info, &argc, &toWrap, nullptr, nullptr));\n    // 将自定义结构Object封装\n    JSVM_CALL(OH_JSVM_Wrap(env, toWrap, reinterpret_cast<void *>(objPointer), DerefItem, NULL, NULL));\n    Object *data;\n    // 解包先前封装的object，并移除封装\n    JSVM_CALL(OH_JSVM_RemoveWrap(env, toWrap, reinterpret_cast<void **>(&objPointer)));\n    // 检查是否已被移除\n    JSVM_Status status = OH_JSVM_Unwrap(env, toWrap, reinterpret_cast<void **>(&data));\n    if (status != JSVM_OK) {\n        OH_LOG_INFO(LOG_APP, \"JSVM OH_JSVM_RemoveWrap success\");\n    }\n    return nullptr;\n}\n\n// WrapObject、RemoveWrap注册回调\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = WrapObject},\n    {.data = nullptr, .callback = RemoveWrap},\n};\nstatic JSVM_CallbackStruct *method = param;\n// WrapObject、RemoveWrap方法别名，供JS调用\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"wrapObject\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n    {\"removeWrap\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};
样例JS
const char *srcCallNative = R\"JS(
 class Obj {};
 wrapObject(new Obj());
 removeWrap(new Obj());
)JS\";
执行结果
在LOG中输出下面的结果：
JSVM wrap
JSVM name: lilei
JSVM age: 18
JSVM removeWrap
JSVM OH_JSVM_RemoveWrap success
JSVM deref_item
[h2]OH_JSVM_DefineClassWithOptions
Note: 传入的父类class必须是通过OH_JSVM_DefineClass系列接口创建出来的，不然会被视为无效参数，返回JSVM_INVALID_ARG错误码。
目前支持以下的DefineClassOptions:
JSVM_DEFINE_CLASS_NORMAL: 按正常模式创建Class。默认缺省状态为JSVM_DEFINE_CLASS_NORMAL状态。JSVM_DEFINE_CLASS_WITH_COUNT: 为所创建的Class预留interfield槽位。JSVM_DEFINE_CLASS_WITH_PROPERTY_HANDLER: 为所创建的Class设置监听拦截属性以及设置作为函数调用时回调函数。
cpp代码
static JSVM_PropertyHandlerConfigurationStruct propertyCfg{\n  nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr\n};\n\nstatic bool g_call_as_function_flag = false;\nstatic bool g_set_named_property_flag = false;\nstatic bool g_call_as_constructor_flag = false;\nstatic bool g_properties_flag = false;\n\nstatic JSVM_Value SetNamedPropertyCbInfo2(JSVM_Env env, JSVM_Value name, JSVM_Value property, JSVM_Value thisArg,\n    JSVM_Value data)\n{\n    g_set_named_property_flag = true;\n    return property;\n}\n\nstatic JSVM_Value Add(JSVM_Env env, JSVM_CallbackInfo info) {\n    g_properties_flag = true;\n    size_t argc = 2;\n    JSVM_Value args[2];\n    OH_JSVM_GetCbInfo(env, info, &argc, args, NULL, NULL);\n    double num1, num2;\n    OH_JSVM_GetValueDouble(env, args[0], &num1);\n    OH_JSVM_GetValueDouble(env, args[1], &num2);\n    JSVM_Value sum = nullptr;\n    OH_JSVM_CreateDouble(env, num1 + num2, &sum);\n    return sum;\n}\n\nstd::string ToString(JSVM_Env jsvm_env, JSVM_Value val)\n{\n    JSVM_Value js_string;\n    OH_JSVM_CoerceToString(jsvm_env, val, &js_string);\n    size_t length = 0;\n    OH_JSVM_GetValueStringUtf8(jsvm_env, js_string, NULL, 0, &length);\n    size_t capacity = length + 1;\n    char *buffer = new char[capacity];\n    size_t copy_length = 0;\n    OH_JSVM_GetValueStringUtf8(jsvm_env, js_string, buffer, capacity, &copy_length);\n    std::string str(buffer);\n    delete[] buffer;\n    return str;\n}\n\nJSVM_Value Run(JSVM_Env env, const char *s)\n{\n    // 1. 将const char*转换成JS_String。\n    JSVM_Value str;\n    JSVM_CALL(OH_JSVM_CreateStringUtf8(env, s, JSVM_AUTO_LENGTH, &str));\n    // 2. 将JS_String转换成JS_Script。\n    JSVM_Script script;\n    OH_JSVM_CompileScript(jsvm_env, str, nullptr, JSVM_AUTO_LENGTH,   false, nullptr, &script);\n    // 3. 执行JS_Script。\n    JSVM_Value result;\n    OH_JSVM_RunScript(jsvm_env, script, &result);\n    return result;\n}\n\nstatic JSVM_Value TestDefineClassWithOptions(JSVM_Env env, JSVM_CallbackInfo info)\n{\n    g_call_as_function_flag = false;\n    g_set_named_property_flag = false;\n    g_call_as_constructor_flag = false;\n    g_properties_flag = false;\n    // 1. Define parent-class.\n    JSVM_Value parentClass = nullptr;\n    JSVM_CallbackStruct parentClassConstructor;\n    parentClassConstructor.data = nullptr;\n    parentClassConstructor.callback = [](JSVM_Env env, JSVM_CallbackInfo info) -> JSVM_Value {\n        JSVM_Value thisVar = nullptr;\n        OH_JSVM_GetCbInfo(env, info, nullptr, nullptr, &thisVar, nullptr);\n        return thisVar;\n    };\n    JSVM_Value fooVal = Str(env, \"bar\");\n    JSVM_PropertyDescriptor des[2];\n    des[0] = {\n        .utf8name = \"foo\",\n        .value = fooVal,\n    };\n    JSVM_CallbackStruct parentProperties[] = {\n        {.callback = Add, .data = nullptr},\n    };\n    des[1] = {\n        .utf8name = \"add\",\n        .method = &parentProperties[0],\n    };\n    JSVM_DefineClassOptions options[1];\n    options[0].id = JSVM_DEFINE_CLASS_WITH_COUNT;\n    options[0].content.num = 3;\n    JSVM_CALL(OH_JSVM_DefineClassWithOptions(env, \"parentClass\", JSVM_AUTO_LENGTH, &parentClassConstructor, 2, des,\n        nullptr, 1, options, &parentClass));\n  \n    // 2. Define sub-class.\n    JSVM_Value subClass = nullptr;\n    JSVM_CallbackStruct subClassConstructor;\n    subClassConstructor.data = nullptr;\n    subClassConstructor.callback = [](JSVM_Env env, JSVM_CallbackInfo info) -> JSVM_Value {\n        JSVM_Value thisVar = nullptr;\n        g_call_as_constructor_flag = true;\n        OH_JSVM_GetCbInfo(env, info, nullptr, nullptr, &thisVar, nullptr);\n        return thisVar;\n    };\n    JSVM_DefineClassOptions subOptions[2];\n    JSVM_CallbackStruct callAsFuncParam;\n    callAsFuncParam.data = nullptr;\n    callAsFuncParam.callback = [](JSVM_Env env, JSVM_CallbackInfo info) -> JSVM_Value {\n        JSVM_Value thisVar = nullptr;\n        g_call_as_function_flag = true;\n        OH_JSVM_GetCbInfo(env, info, nullptr, nullptr, &thisVar, nullptr);\n        return thisVar;\n    };\n    propertyCfg.genericNamedPropertySetterCallback = SetNamedPropertyCbInfo2;\n    JSVM_PropertyHandler propertyHandler = {\n        .propertyHandlerCfg = &propertyCfg,\n        .callAsFunctionCallback = &callAsFuncParam,\n    };\n    subOptions[0].id = JSVM_DEFINE_CLASS_WITH_COUNT;\n    subOptions[0].content.num = 4;\n    subOptions[1].id = JSVM_DEFINE_CLASS_WITH_PROPERTY_HANDLER;\n    subOptions[1].content.ptr = &propertyHandler;\n    JSVM_CALL(OH_JSVM_DefineClassWithOptions(env, \"subClass\", JSVM_AUTO_LENGTH, &subClassConstructor, 0, nullptr,\n        parentClass, 2, subOptions, &subClass));\n    // 3. Verify the validity of 'constructor'.\n    JSVM_Value subInstance;\n    JSVM_CALL(OH_JSVM_NewInstance(env, subClass, 0, nullptr, &subInstance));\n\n    JSVM_Value globalVal;\n    OH_JSVM_GetGlobal(env, &globalVal);\n    OH_JSVM_SetNamedProperty(env, globalVal, \"obj\", subInstance);\n\n    // 4. Verify the validity of 'parentClass'.\n    JSVM_Value subRes = nullptr;\n    JSVM_CALL(OH_JSVM_GetNamedProperty(env, subInstance, \"foo\", &subRes));\n    if (ToString(env, subRes).compare(\"bar\") != 0) {\n        OH_LOG_ERROR(LOG_APP, \"Run OH_JSVM_DefineClassWithOptions: Failed\");\n    }\n    // 5. Verify the validity of 'properties'.\n    Run(env, \"obj.add(3, 4);\");\n    // 6. Verify the validity of 'options'.\n    Run(env, \"obj()\");\n    Run(env, \"obj.x = 123;\");\n    if (g_call_as_function_flag == true &&\n    g_set_named_property_flag == true &&\n    g_call_as_constructor_flag == true &&\n    g_properties_flag == true) {\n        OH_LOG_INFO(LOG_APP, \"Run OH_JSVM_DefineClassWithOptions: Success\");\n    } else {\n        OH_LOG_ERROR(LOG_APP, \"Run OH_JSVM_DefineClassWithOptions: Failed\");\n    }\n    JSVM_Value checked;\n    OH_JSVM_GetBoolean(env, true, &checked);\n    return checked;\n}\n\nstatic JSVM_CallbackStruct param[] = {\n    {.data = nullptr, .callback = TestDefineClassWithOptions},\n};\nstatic JSVM_CallbackStruct *method = param;\n\nstatic JSVM_PropertyDescriptor descriptor[] = {\n    {\"testDefineClassWithOptions\", nullptr, method++, nullptr, nullptr, nullptr, JSVM_DEFAULT},\n};
样例JS
const char *srcCallNative = R\"JS(testDefineClassWithOptions();)JS\";
执行结果
在LOG中输出下面的结果：
Run OH_JSVM_DefineClassWithOptions: Success

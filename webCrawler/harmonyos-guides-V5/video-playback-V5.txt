使用AVPlayer播放视频(ArkTS)
当前提供两种视频播放开发的方案：
 AVPlayer：功能较完善的音视频播放ArkTS/JS API，集成了流媒体和本地资源解析，媒体资源解封装，视频解码和渲染功能，适用于对媒体资源进行端到端播放的场景，可直接播放mp4、mkv等格式的视频文件。 Video组件：封装了视频播放的基础能力，需要设置数据源以及基础信息即可播放视频，但相对扩展能力较弱。Video组件由ArkUI提供能力，相关指导请参考UI开发文档-Video组件。 
本开发指导将介绍如何使用AVPlayer开发视频播放功能，以完整地播放一个视频作为示例，实现端到端播放原始媒体资源。
播放的全流程包含：创建AVPlayer，设置播放资源和窗口，设置播放参数（音量/倍速/缩放模式），播放控制（播放/暂停/跳转/停止），重置，销毁资源。在进行应用开发的过程中，开发者可以通过AVPlayer的state属性主动获取当前状态或使用on('stateChange')方法监听状态变化。如果应用在视频播放器处于错误状态时执行操作，系统可能会抛出异常或生成其他未定义的行为。
图1 播放状态变化示意图
状态的详细说明请参考AVPlayerState。当播放处于prepared / playing / paused / completed状态时，播放引擎处于工作状态，这需要占用系统较多的运行内存。当客户端暂时不使用播放器时，调用reset()或release()回收内存资源，做好资源利用。
开发建议
当前指导仅介绍如何实现媒体资源播放，在应用开发过程中可能会涉及后台播放、播放冲突等情况，请根据实际需要参考以下说明。
 如果要实现后台播放或熄屏播放，需要接入AVSession（媒体会话）和申请长时任务，避免播放被系统强制中断。 应用在播放过程中，若播放的媒体数据涉及音频，根据系统音频管理策略（参考处理音频焦点事件），可能会被其他应用打断，建议应用主动监听音频打断事件，根据其内容提示，做出相应的处理，避免出现应用状态与预期效果不一致的问题。 面对设备同时连接多个音频输出设备的情况，应用可以通过on('audioOutputDeviceChangeWithInfo')监听音频输出设备的变化，从而做出相应处理。 如果需要访问在线媒体资源，需要申请 ohos.permission.INTERNET 权限。 
开发步骤及注意事项
详细的API说明请参考AVPlayer API参考。
 调用createAVPlayer()创建AVPlayer实例，初始化进入idle状态。 设置业务需要的监听事件，搭配全流程场景使用。支持的监听事件包括：     事件类型 说明    stateChange 必要事件，监听播放器的state属性改变。   error 必要事件，监听播放器的错误信息。   durationUpdate 用于进度条，监听进度条长度，刷新资源时长。   timeUpdate 用于进度条，监听进度条当前位置，刷新当前时间。   seekDone 响应API调用，监听seek()请求完成情况。 当使用seek()跳转到指定播放位置后，如果seek操作成功，将上报该事件。   speedDone 响应API调用，监听setSpeed()请求完成情况。 当使用setSpeed()设置播放倍速后，如果setSpeed操作成功，将上报该事件。   volumeChange 响应API调用，监听setVolume()请求完成情况。 当使用setVolume()调节播放音量后，如果setVolume操作成功，将上报该事件。   bitrateDone 响应API调用，用于HLS协议流，监听setBitrate()请求完成情况。 当使用setBitrate()指定播放比特率后，如果setBitrate操作成功，将上报该事件。   availableBitrates 用于HLS协议流，监听HLS资源的可选bitrates，用于setBitrate()。   bufferingUpdate 用于网络播放，监听网络播放缓冲信息。   startRenderFrame 用于视频播放，监听视频播放首帧渲染时间。 当AVPlayer首次起播进入playing状态后，等到首帧视频画面被渲染到显示画面时，将上报该事件。应用通常可以利用此事件上报，进行视频封面移除，达成封面与视频画面的顺利衔接。   videoSizeChange 用于视频播放，监听视频播放的宽高信息，可用于调整窗口大小、比例。   audioInterrupt 监听音频焦点切换信息，搭配属性audioInterruptMode使用。 如果当前设备存在多个媒体正在播放，音频焦点被切换（即播放其他媒体如通话等）时将上报该事件，应用可以及时处理。    设置资源：设置属性url，AVPlayer进入initialized状态。     下面代码示例中的url仅作示意使用，开发者需根据实际情况，确认资源有效性并设置：  如果使用本地资源播放，必须确认资源文件可用，并使用应用沙箱路径访问对应资源，参考获取应用文件路径。应用沙箱的介绍及如何向应用沙箱推送文件，请参考文件管理。 如果使用网络播放路径，需声明权限：ohos.permission.INTERNET。 如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法可参考ResourceManager API参考。 需要使用支持的播放格式与协议。    设置窗口：获取并设置属性SurfaceID，用于设置显示画面。 应用需要从XComponent组件获取surfaceID，获取方式请参考XComponent。 准备播放：调用prepare()，AVPlayer进入prepared状态，此时可以获取duration，设置缩放模式、音量等。 视频播控：播放play()，暂停pause()，跳转seek()，停止stop() 等操作。 （可选）更换资源：调用reset()重置资源，AVPlayer重新进入idle状态，允许更换资源url。 退出播放：调用release()销毁实例，AVPlayer进入released状态，退出播放。 
完整示例
import { media } from '@kit.MediaKit';\nimport { fileIo as fs } from '@kit.CoreFileKit';\nimport { common } from '@kit.AbilityKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport class AVPlayerDemo {\n  private count: number = 0;\n  private surfaceID: string = ''; // surfaceID用于播放画面显示，具体的值需要通过Xcomponent接口获取，相关文档链接见上面Xcomponent创建方法\n  private isSeek: boolean = true; // 用于区分模式是否支持seek操作\n  private fileSize: number = -1;\n  private fd: number = 0;\n\n  constructor(surfaceID: string) {\n    this.surfaceID = surfaceID;\n  }\n  \n  // 注册avplayer回调函数\n  setAVPlayerCallback(avPlayer: media.AVPlayer) {\n    // startRenderFrame首帧渲染回调函数\n    avPlayer.on('startRenderFrame', () => {\n      console.info(`AVPlayer start render frame`);\n    });\n    // seek操作结果回调函数\n    avPlayer.on('seekDone', (seekDoneTime: number) => {\n      console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);\n    });\n    // error回调监听函数,当avPlayer在操作过程中出现错误时调用reset接口触发重置流程\n    avPlayer.on('error', (err: BusinessError) => {\n      console.error(`Invoke avPlayer failed, code is ${err.code}, message is ${err.message}`);\n      avPlayer.reset(); // 调用reset重置资源，触发idle状态\n    });\n    // 状态机变化回调函数\n    avPlayer.on('stateChange', async (state: string, reason: media.StateChangeReason) => {\n      switch (state) {\n        case 'idle': // 成功调用reset接口后触发该状态机上报\n          console.info('AVPlayer state idle called.');\n          avPlayer.release(); // 调用release接口销毁实例对象\n          break;\n        case 'initialized': // avplayer 设置播放源后触发该状态上报\n          console.info('AVPlayer state initialized called.');\n          avPlayer.surfaceId = this.surfaceID; // 设置显示画面，当播放的资源为纯音频时无需设置\n          avPlayer.prepare();\n          break;\n        case 'prepared': // prepare调用成功后上报该状态机\n          console.info('AVPlayer state prepared called.');\n          avPlayer.play(); // 调用播放接口开始播放\n          break;\n        case 'playing': // play成功调用后触发该状态机上报\n          console.info('AVPlayer state playing called.');\n          if (this.count !== 0) {\n            if (this.isSeek) {\n              console.info('AVPlayer start to seek.');\n              avPlayer.seek(avPlayer.duration); //seek到视频末尾\n            } else {\n              // 当播放模式不支持seek操作时继续播放到结尾\n              console.info('AVPlayer wait to play end.');\n            }\n          } else {\n            avPlayer.pause(); // 调用暂停接口暂停播放\n          }\n          this.count++;\n          break;\n        case 'paused': // pause成功调用后触发该状态机上报\n          console.info('AVPlayer state paused called.');\n          avPlayer.play(); // 再次播放接口开始播放\n          break;\n        case 'completed': // 播放结束后触发该状态机上报\n          console.info('AVPlayer state completed called.');\n          avPlayer.stop(); //调用播放结束接口\n          break;\n        case 'stopped': // stop接口成功调用后触发该状态机上报\n          console.info('AVPlayer state stopped called.');\n          avPlayer.reset(); // 调用reset接口初始化avplayer状态\n          break;\n        case 'released':\n          console.info('AVPlayer state released called.');\n          break;\n        default:\n          console.info('AVPlayer state unknown called.');\n          break;\n      }\n    });\n  }\n\n  // 以下demo为使用fs文件系统打开沙箱地址获取媒体文件地址并通过url属性进行播放示例\n  async avPlayerUrlDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    let fdPath = 'fd://';\n    let context = getContext(this) as common.UIAbilityContext;\n    // 通过UIAbilityContext获取沙箱地址filesDir，以Stage模型为例\n    let pathDir = context.filesDir;\n    let path = pathDir + '/H264_AAC.mp4';\n    // 打开相应的资源文件地址获取fd，并为url赋值触发initialized状态机上报\n    let file = await fs.open(path);\n    fdPath = fdPath + '' + file.fd;\n    this.isSeek = true; // 支持seek操作\n    avPlayer.url = fdPath;\n  }\n\n  // 以下demo为使用资源管理接口获取打包在HAP内的媒体资源文件并通过fdSrc属性进行播放示例\n  async avPlayerFdSrcDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    // 通过UIAbilityContext的resourceManager成员的getRawFd接口获取媒体资源播放地址\n    // 返回类型为{fd,offset,length},fd为HAP包fd地址，offset为媒体资源偏移量，length为播放长度\n    let context = getContext(this) as common.UIAbilityContext;\n    let fileDescriptor = await context.resourceManager.getRawFd('H264_AAC.mp4');\n    let avFileDescriptor: media.AVFileDescriptor =\n      { fd: fileDescriptor.fd, offset: fileDescriptor.offset, length: fileDescriptor.length };\n    this.isSeek = true; // 支持seek操作\n    // 为fdSrc赋值触发initialized状态机上报\n    avPlayer.fdSrc = avFileDescriptor;\n  }\n\n  // 以下demo为使用fs文件系统打开沙箱地址获取媒体文件地址并通过dataSrc属性进行播放(seek模式)示例\n  async avPlayerDataSrcSeekDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    // dataSrc播放模式的的播放源地址，当播放为Seek模式时fileSize为播放文件的具体大小，下面会对fileSize赋值\n    let src: media.AVDataSrcDescriptor = {\n      fileSize: -1,\n      callback: (buf: ArrayBuffer, length: number, pos: number | undefined) => {\n        let num = 0;\n        if (buf == undefined || length == undefined || pos == undefined) {\n          return -1;\n        }\n        num = fs.readSync(this.fd, buf, { offset: pos, length: length });\n        if (num > 0 && (this.fileSize >= pos)) {\n          return num;\n        }\n        return -1;\n      }\n    };\n    let context = getContext(this) as common.UIAbilityContext;\n    // 通过UIAbilityContext获取沙箱地址filesDir，以Stage模型为例\n    let pathDir = context.filesDir;\n    let path = pathDir + '/H264_AAC.mp4';\n    await fs.open(path).then((file: fs.File) => {\n      this.fd = file.fd;\n    });\n    // 获取播放文件的大小\n    this.fileSize = fs.statSync(path).size;\n    src.fileSize = this.fileSize;\n    this.isSeek = true; // 支持seek操作\n    avPlayer.dataSrc = src;\n  }\n\n  // 以下demo为使用fs文件系统打开沙箱地址获取媒体文件地址并通过dataSrc属性进行播放(No seek模式)示例\n  async avPlayerDataSrcNoSeekDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    let context = getContext(this) as common.UIAbilityContext;\n    let src: media.AVDataSrcDescriptor = {\n      fileSize: -1,\n      callback: (buf: ArrayBuffer, length: number) => {\n        let num = 0;\n        if (buf == undefined || length == undefined) {\n          return -1;\n        }\n        num = fs.readSync(this.fd, buf);\n        if (num > 0) {\n          return num;\n        }\n        return -1;\n      }\n    };\n    // 通过UIAbilityContext获取沙箱地址filesDir，以Stage模型为例\n    let pathDir = context.filesDir;\n    let path = pathDir + '/H264_AAC.mp4';\n    await fs.open(path).then((file: fs.File) => {\n      this.fd = file.fd;\n    });\n    this.isSeek = false; // 不支持seek操作\n    avPlayer.dataSrc = src;\n  }\n\n  // 以下demo为通过url设置网络地址来实现播放直播码流的demo\n  async avPlayerLiveDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    // 创建状态机变化回调函数\n    this.setAVPlayerCallback(avPlayer);\n    this.isSeek = false; // 不支持seek操作\n    avPlayer.url = 'http://xxx.xxx.xxx.xxx:xx/xx/index.m3u8'; // 播放hls网络直播码流\n  }\n\n  // 以下demo为通过setMediaSource设置自定义头域及媒体播放优选参数实现初始播放参数设置\n  async preDownloadDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    let mediaSource : media.MediaSource = media.createMediaSourceWithUrl(\"http://xxx\",  {\"User-Agent\" : \"User-Agent-Value\"});\n    let playbackStrategy : media.PlaybackStrategy = {preferredWidth: 1, preferredHeight: 2, preferredBufferDuration: 3, preferredHdr: false};\n    // 设置媒体来源和播放策略\n    avPlayer.setMediaSource(mediaSource, playbackStrategy);\n  }\n\n  // 以下demo为通过selectTrack设置音频轨道，通过deselectTrack取消上次设置的音频轨道并恢复到视频默认音频轨道。\n  async multiTrackDemo() {\n    // 创建avPlayer实例对象\n    let avPlayer: media.AVPlayer = await media.createAVPlayer();\n    let audioTrackIndex: Object = 0;\n    avPlayer.getTrackDescription((error: BusinessError, arrList: Array<media.MediaDescription>) => {\n      if (arrList != null) {\n        for (let i = 0; i < arrList.length; i++) {\n          if (i != 0) {\n            // 获取音频轨道列表\n            audioTrackIndex = arrList[i][media.MediaDescriptionKey.MD_KEY_TRACK_INDEX];\n          }\n        }\n      } else {\n        console.error(`audio getTrackDescription fail, error:${error}`);\n      }\n    });\n    // 选择其中一个音频轨道\n    avPlayer.selectTrack(parseInt(audioTrackIndex.toString()));\n    // 取消选择上次选中的音频轨道，并恢复到默认音频轨道。\n    avPlayer.deselectTrack(parseInt(audioTrackIndex.toString()));\n  }\n}

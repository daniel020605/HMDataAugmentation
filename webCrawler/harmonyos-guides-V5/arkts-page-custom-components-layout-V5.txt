自定义组件的自定义布局
如果需要通过测算的方式布局自定义组件内子组件的位置，建议使用以下接口：
 onMeasureSize：组件每次布局时触发，计算子组件的尺寸，其执行时间先于onPlaceChildren。 onPlaceChildren：组件每次布局时触发，设置子组件的起始位置。 
示例：
// xxx.ets\n@Entry\n@Component\nstruct Index {\n  build() {\n    Column() {\n      CustomLayout({ builder: ColumnChildren })\n    }\n  }\n}\n\n// 通过builder的方式传递多个组件，作为自定义组件的一级子组件（即不包含容器组件，如Column）\n@Builder\nfunction ColumnChildren() {\n  ForEach([1, 2, 3], (index: number) => { // 暂不支持lazyForEach的写法\n    Text('S' + index)\n      .fontSize(30)\n      .width(100)\n      .height(100)\n      .borderWidth(2)\n      .offset({ x: 10, y: 20 })\n  })\n}\n\n@Component\nstruct CustomLayout {\n  @Builder\n  doNothingBuilder() {\n  };\n\n  @BuilderParam builder: () => void = this.doNothingBuilder;\n  @State startSize: number = 100;\n  result: SizeResult = {\n    width: 0,\n    height: 0\n  };\n\n  // 第一步：计算各子组件的大小\n  onMeasureSize(selfLayoutInfo: GeometryInfo, children: Array<Measurable>, constraint: ConstraintSizeOptions) {\n    let size = 100;\n    children.forEach((child) => {\n      let result: MeasureResult = child.measure({ minHeight: size, minWidth: size, maxWidth: size, maxHeight: size })\n      size += result.width / 2;\n    })\n    this.result.width = 100;\n    this.result.height = 400;\n    return this.result;\n  }\n  // 第二步：放置各子组件的位置\n  onPlaceChildren(selfLayoutInfo: GeometryInfo, children: Array<Layoutable>, constraint: ConstraintSizeOptions) {\n    let startPos = 300;\n    children.forEach((child) => {\n      let pos = startPos - child.measureResult.height;\n      child.layout({ x: pos, y: pos })\n    })\n  }\n\n  build() {\n    this.builder()\n  }\n}
以上示例中，Index页面包含一个实现了自定义布局的自定义组件，且对应自定义组件的子组件通过index页面内的builder方式传入。
而在自定义组件中，调用了onMeasureSize和onPlaceChildren设置子组件大小和放置位置。例如，在本示例中，在onMeasureSize中初始化组件大小size=100，后续的每一个子组件size会加上上一个子组件大小的一半，实现组件大小递增的效果。而在onPlaceChildren中，定义startPos=300，设置每一个子组件的位置为startPos减去子组件自身的高度，所有子组件右下角一致在顶点位置(300,300)，实现一个从右下角开始展示组件的类Stack组件。

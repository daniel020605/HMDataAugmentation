指定密钥参数生成非对称密钥对
以RSA、ECC、SM2为例，根据指定的密钥参数，生成非对称密钥对（KeyPair），并获取密钥参数属性。
该对象可用于后续的加解密等操作。获取的密钥参数属性可用于存储或运输。
指定密钥参数生成RSA公钥
对应的算法规格请查看非对称密钥生成和转换规格：RSA。
 构造RSACommonParamsSpec对象，用于指定RSA算法中公私钥包含的公共参数（n）。 RSACommonParamsSpec是AsyKeySpec的子类。需要通过参数algName指定算法'RSA'；指定密钥参数类型AsyKeySpecType.COMMON_PARAMS_SPEC，表示是公私钥中包含的公共参数。 使用密钥参数生成密钥时，用到的bigint类型需要以大端模式输入，且必须为正数。 创建RSAPubKeySpec对象，用于指定RSA算法中公钥包含的参数（n, pk）。 RSAPubKeySpec是AsyKeySpec的子类。通过参数algName指定算法'RSA'；指定密钥参数类型AsyKeySpecType.PUBLIC_KEY_SPEC，表示是公钥中包含的参数。 调用cryptoFramework.createAsyKeyGeneratorBySpec，将RSAPubKeySpec对象传入，创建非对称密钥生成器（AsyKeyGeneratorBySpec）。 调用AsyKeyGeneratorBySpec.generatePubKey，获得指定的公钥（PubKey）。 调用PubKey.getAsyKeySpec，获取模数n和公钥pk（即公钥指数e）。 
 以使用callback方式根据密钥参数生成RSA公钥为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\n// RSA公钥密钥参数生成函数\nfunction genRsaPubKeySpec(nIn: bigint, eIn: bigint): cryptoFramework.RSAPubKeySpec {\n  let rsaCommSpec: cryptoFramework.RSACommonParamsSpec = {\n    n: nIn,\n    algName: 'RSA',\n    specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC\n  };\n  let rsaPubKeySpec: cryptoFramework.RSAPubKeySpec = {\n    params: rsaCommSpec,\n    pk: eIn,\n    algName: 'RSA',\n    specType: cryptoFramework.AsyKeySpecType.PUBLIC_KEY_SPEC\n  };\n  return rsaPubKeySpec;\n}\n// 根据密钥参数构造RSA公钥规范对象\nfunction genRsa2048PubKeySpec() {\n  let nIn = BigInt('0x9260d0750ae117eee55c3f3deaba74917521a262ee76007cdf8a56755ad73a1598a1408410a01434c3f5bc54a88b57fa19fc4328daea0750a4c44e88cff3b2382621b80f670464433e4336e6d003e8cd65bff211da144b88291c2259a00a72b711c116ef7686e8fee34e4d933c868187bdc26f7be071493c86f7a5941c3510806ad67b0f94d88f5cf5c02a092821d8626e8932b65c5bd8c92049c210932b7afa7ac59c0e886ae5c1edb00d8ce2c57633db26bd6639bff73cee82be9275c402b4cf2a4388da8cf8c64eefe1c5a0f5ab8057c39fa5c0589c3e253f0960332300f94bea44877b588e1edbde97cf2360727a09b775262d7ee552b3319b9266f05a25');\n  let eIn = BigInt('0x010001');\n  return genRsaPubKeySpec(nIn, eIn);\n}\n// 将RSA公钥规格与预期值进行比较\nfunction compareRsaPubKeyBySpec(rsaKeySpec: cryptoFramework.RSAPubKeySpec, n: bigint | string | number, e: bigint | string | number) {\n  if (typeof n === 'string' || typeof e === 'string') {\n    console.error('type is string');\n    return false;\n  }\n  if (typeof n === 'number' || typeof e === 'number') {\n    console.error('type is number');\n    return false;\n  }\n  if (rsaKeySpec.params.n != n) {\n    return false;\n  }\n  if (rsaKeySpec.pk != e) {\n    return false;\n  }\n  return true;\n}\n// 根据RSA公钥规格生成RSA公钥，获取密钥规格，并与预期值进行比较\nfunction rsaUsePubKeySpecGetCallback() {\n  let rsaPubKeySpec = genRsa2048PubKeySpec();\n  let rsaGeneratorSpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaPubKeySpec);\n  rsaGeneratorSpec.generatePubKey((error, key) => {\n    if (error) {\n      console.error('generate pubKey error' + 'error code: ' + error.code + 'error message' + error.message);\n    }\n    let pubKey = key;\n    let nBN = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_N_BN);\n    let eBN = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_PK_BN);\n    if (compareRsaPubKeyBySpec(rsaPubKeySpec, nBN, eBN) != true) {\n      console.error('error pub key big number');\n    } else {\n      console.info('n, e in the pubKey are same as the spec.');\n    }\n  });\n} 同步返回结果（调用方法generatePubKeySync）： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\n// RSA公钥密钥参数生成函数\nfunction genRsaPubKeySpec(nIn: bigint, eIn: bigint): cryptoFramework.RSAPubKeySpec {\n  let rsaCommSpec: cryptoFramework.RSACommonParamsSpec = {\n    n: nIn,\n    algName: 'RSA',\n    specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC\n  };\n  let rsaPubKeySpec: cryptoFramework.RSAPubKeySpec = {\n    params: rsaCommSpec,\n    pk: eIn,\n    algName: 'RSA',\n    specType: cryptoFramework.AsyKeySpecType.PUBLIC_KEY_SPEC\n  };\n  return rsaPubKeySpec;\n}\n// 根据密钥参数构造RSA公钥规范对象\nfunction genRsa2048PubKeySpec() {\n  let nIn = BigInt('0x9260d0750ae117eee55c3f3deaba74917521a262ee76007cdf8a56755ad73a1598a1408410a01434c3f5bc54a88b57fa19fc4328daea0750a4c44e88cff3b2382621b80f670464433e4336e6d003e8cd65bff211da144b88291c2259a00a72b711c116ef7686e8fee34e4d933c868187bdc26f7be071493c86f7a5941c3510806ad67b0f94d88f5cf5c02a092821d8626e8932b65c5bd8c92049c210932b7afa7ac59c0e886ae5c1edb00d8ce2c57633db26bd6639bff73cee82be9275c402b4cf2a4388da8cf8c64eefe1c5a0f5ab8057c39fa5c0589c3e253f0960332300f94bea44877b588e1edbde97cf2360727a09b775262d7ee552b3319b9266f05a25');\n  let eIn = BigInt('0x010001');\n  return genRsaPubKeySpec(nIn, eIn);\n}\n// 将RSA公钥规格与预期值进行比较\nfunction compareRsaPubKeyBySpec(rsaKeySpec: cryptoFramework.RSAPubKeySpec, n: bigint | string | number, e: bigint | string | number) {\n  if (typeof n === 'string' || typeof e === 'string') {\n    console.error('type is string');\n    return false;\n  }\n  if (typeof n === 'number' || typeof e === 'number') {\n    console.error('type is number');\n    return false;\n  }\n  if (rsaKeySpec.params.n != n) {\n    return false;\n  }\n  if (rsaKeySpec.pk != e) {\n    return false;\n  }\n  return true;\n}\n// 根据RSA公钥规格生成RSA公钥，获取密钥规格，并与预期值进行比较\nfunction rsaUsePubKeySpecGetSync() {\n  let rsaPubKeySpec = genRsa2048PubKeySpec();\n  let rsaGeneratorSpec = cryptoFramework.createAsyKeyGeneratorBySpec(rsaPubKeySpec);\n  try {\n    let pubKey = rsaGeneratorSpec.generatePubKeySync();\n    if (pubKey != null) {\n      let nBN = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_N_BN);\n      let eBN = pubKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_PK_BN);\n      if (compareRsaPubKeyBySpec(rsaPubKeySpec, nBN, eBN) != true) {\n        console.error('error pub key big number');\n      } else {\n        console.info('n, e in the pubKey are same as the spec.');\n      }\n    } else {\n      console.error('get pub key result fail!');\n    }\n  } catch (e) {\n    console.error(`get pub key result fail, ${e.code}, ${e.message}`);\n  }\n} 
指定密钥参数生成ECC密钥对
对应的算法规格请查看非对称密钥生成和转换规格：ECC。
 构造ECCCommonParamsSpec对象，用于指定ECC算法中公私钥包含的公共参数。 ECCCommonParamsSpec是AsyKeySpec的子类。需要通过参数algName指定算法'ECC'；指定密钥参数类型AsyKeySpecType.COMMON_PARAMS_SPEC，表示是公私钥中包含的公共参数。 使用密钥参数生成密钥时，用到的bigint类型需要以大端模式输入，且必须为正数。 调用cryptoFramework.createAsyKeyGeneratorBySpec，将ECCCommonParamsSpec对象传入，创建非对称密钥生成器（AsyKeyGeneratorBySpec）。 调用AsyKeyGeneratorBySpec.generateKeyPair，得到随机生成的密钥对（KeyPair）。 分别传入密钥对中的私钥和公钥，调用PriKey.getAsyKeySpec和PubKey.getAsyKeySpec，获取ECC算法中私钥和公钥的各种密钥参数。 
 以使用Promise方式根据密钥参数生成ECC密钥为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\n// 打印bigint信息\nfunction showBigIntInfo(bnName: string, bnValue: bigint | string | number) {\n  if (typeof bnValue === 'string') {\n    console.error('type is string');\n    return;\n  }\n  if (typeof bnValue === 'number') {\n    console.error('type is number');\n    return;\n  }\n  console.info(bnName + ':');\n  console.info('. Decimal: ' + bnValue.toString());\n  console.info('. Hexadecimal: ' + bnValue.toString(16));\n  console.info('. Length (bits): ' + bnValue.toString(2).length);\n}\n// 根据关键规范构造EccCommonSpec结构体。EccCommonSpec结构体定义了ECC私钥和公钥的公共参数\nfunction genEccCommonSpec(): cryptoFramework.ECCCommonParamsSpec {\n  let fieldFp: cryptoFramework.ECFieldFp = {\n    fieldType: 'Fp',\n    p: BigInt('0xffffffffffffffffffffffffffffffff000000000000000000000001')\n  }\n  let G: cryptoFramework.Point = {\n    x: BigInt('0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21'),\n    y: BigInt('0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34')\n  }\n  let eccCommonSpec: cryptoFramework.ECCCommonParamsSpec = {\n    algName: 'ECC',\n    specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC,\n    field: fieldFp,\n    a: BigInt('0xfffffffffffffffffffffffffffffffefffffffffffffffffffffffe'),\n    b: BigInt('0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4'),\n    g: G,\n    n: BigInt('0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d'),\n    h: 1\n  }\n  return eccCommonSpec;\n}\n// 打印ECC密钥规格\nfunction showEccSpecDetailInfo(key: cryptoFramework.PubKey | cryptoFramework.PriKey, keyType: string) {\n  console.info('show detail of ' + keyType + ':');\n  try {\n    let p = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FP_P_BN);\n    showBigIntInfo('--- p', p); // length is 224, hex : ffffffffffffffffffffffffffffffff000000000000000000000001\n    let a = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_A_BN);\n    showBigIntInfo('--- a', a); // length is 224, hex : fffffffffffffffffffffffffffffffefffffffffffffffffffffffe\n    let b = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_B_BN);\n    showBigIntInfo('--- b', b); // length is 224, hex : b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\n    let gX = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_G_X_BN);\n    showBigIntInfo('--- gX', gX); // length is 224, hex : b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n    let gY = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_G_Y_BN);\n    showBigIntInfo('--- gY', gY); // length is 224, hex : bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\n    let n = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_N_BN);\n    showBigIntInfo('--- n', n); // length is 224, hex : ffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d\n    let h = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_H_NUM);\n    console.warn('--- h: ' + h); // key h: 1\n    let fieldType = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FIELD_TYPE_STR);\n    console.warn('--- field type: ' + fieldType); // key field type: Fp\n    let fieldSize = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FIELD_SIZE_NUM);\n    console.warn('--- field size: ' + fieldSize); // key field size: 224\n    let curveName = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_CURVE_NAME_STR);\n    console.warn('--- curve name: ' + curveName); // key curve name: NID_secp224r1\n    if (keyType == 'priKey') {\n      let sk = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_SK_BN);\n      showBigIntInfo('--- sk', sk);\n    } else if (keyType == 'pubKey') {\n      let pkX = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_X_BN);\n      showBigIntInfo('--- pkX', pkX);\n      let pkY = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_Y_BN);\n      showBigIntInfo('--- pkY', pkY);\n    }\n  } catch (error) {\n    console.error('getAsyKeySpec error');\n    let e: BusinessError = error as BusinessError;\n    console.error(`getAsyKeySpec failed, ${e.code}, ${e.message}`);\n  }\n}\n// 根据EccCommonSpec实例生成ECC密钥对，获取密钥规格\nfunction testEccUseCommKeySpecGet() {\n  try {\n    let commKeySpec = genEccCommonSpec(); // 使用参数属性，构造ECC公私钥公共密钥参数对象\n    let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(commKeySpec); // 使用密钥参数对象创建生成器\n    let keyPairPromise = generatorBySpec.generateKeyPair(); // Generate an ECC key pair.\n    keyPairPromise.then(keyPair => { // 使用生成器创建ECC密钥对\n      showEccSpecDetailInfo(keyPair.priKey, 'priKey'); // 对私钥获取相关密钥参数属性\n      showEccSpecDetailInfo(keyPair.pubKey, 'pubKey'); // 对公钥获取相关密钥参数属性\n    }).catch((error: BusinessError) => {\n      // 逻辑错误等异步异常在此捕获\n      console.error('generateComm error');\n      console.error('error code: ' + error.code + ', message is: ' + error.message);\n    })\n  } catch (error) {\n    // 参数错误等同步异常在此捕获\n    console.error('testEccUseCommSpec error');\n    let e: BusinessError = error as BusinessError;\n    console.error(`ecc comm spec failed, ${e.code}, ${e.message}`);\n  }\n} 同步返回结果（调用方法generateKeyPairSync）： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\n\nfunction showBigIntInfo(bnName: string, bnValue: bigint | string | number) {\n  if (typeof bnValue === 'string') {\n    console.error('type is string');\n    return;\n  }\n  if (typeof bnValue === 'number') {\n    console.error('type is number');\n    return;\n  }\n  console.info(bnName + ':');\n  console.info('. Decimal: ' + bnValue.toString());\n  console.info('. Hexadecimal: ' + bnValue.toString(16));\n  console.info('. Length (bits): ' + bnValue.toString(2).length);\n}\n// 根据关键规范构造EccCommonSpec结构体。EccCommonSpec结构体定义了ECC私钥和公钥的公共参数\nfunction genEccCommonSpec(): cryptoFramework.ECCCommonParamsSpec {\n  let fieldFp: cryptoFramework.ECFieldFp = {\n    fieldType: 'Fp',\n    p: BigInt('0xffffffffffffffffffffffffffffffff000000000000000000000001')\n  }\n  let G: cryptoFramework.Point = {\n    x: BigInt('0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21'),\n    y: BigInt('0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34')\n  }\n  let eccCommonSpec: cryptoFramework.ECCCommonParamsSpec = {\n    algName: 'ECC',\n    specType: cryptoFramework.AsyKeySpecType.COMMON_PARAMS_SPEC,\n    field: fieldFp,\n    a: BigInt('0xfffffffffffffffffffffffffffffffefffffffffffffffffffffffe'),\n    b: BigInt('0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4'),\n    g: G,\n    n: BigInt('0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d'),\n    h: 1\n  }\n  return eccCommonSpec;\n}\n// 打印ECC密钥规格\nfunction showEccSpecDetailInfo(key: cryptoFramework.PubKey | cryptoFramework.PriKey, keyType: string) {\n  console.info('show detail of ' + keyType + ':');\n  try {\n    let p = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FP_P_BN);\n    showBigIntInfo('--- p', p); // length is 224, hex : ffffffffffffffffffffffffffffffff000000000000000000000001\n    let a = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_A_BN);\n    showBigIntInfo('--- a', a); // length is 224, hex : fffffffffffffffffffffffffffffffefffffffffffffffffffffffe\n    let b = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_B_BN);\n    showBigIntInfo('--- b', b); // length is 224, hex : b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\n    let gX = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_G_X_BN);\n    showBigIntInfo('--- gX', gX); // length is 224, hex : b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n    let gY = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_G_Y_BN);\n    showBigIntInfo('--- gY', gY); // length is 224, hex : bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\n    let n = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_N_BN);\n    showBigIntInfo('--- n', n); // length is 224, hex : ffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d\n    let h = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_H_NUM);\n    console.warn('--- h: ' + h); // key h: 1\n    let fieldType = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FIELD_TYPE_STR);\n    console.warn('--- field type: ' + fieldType); // key field type: Fp\n    let fieldSize = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_FIELD_SIZE_NUM);\n    console.warn('--- field size: ' + fieldSize); // key field size: 224\n    let curveName = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_CURVE_NAME_STR);\n    console.warn('--- curve name: ' + curveName); // key curve name: NID_secp224r1\n    if (keyType == 'priKey') {\n      let sk = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_SK_BN);\n      showBigIntInfo('--- sk', sk);\n    } else if (keyType == 'pubKey') {\n      let pkX = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_X_BN);\n      showBigIntInfo('--- pkX', pkX);\n      let pkY = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_PK_Y_BN);\n      showBigIntInfo('--- pkY', pkY);\n    }\n  } catch (e) {\n    console.error(`getAsyKeySpec failed, ${e.code}, ${e.message}`);\n  }\n}\n// 根据EccCommonSpec实例生成ECC密钥对，获取密钥规格\nfunction testEccUseCommKeySpecGetSync() {\n  try {\n    let commKeySpec = genEccCommonSpec(); // 使用参数属性，构造ECC公私钥公共密钥参数对象\n    let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(commKeySpec); // 使用密钥参数对象创建生成器\n    let keyPair = generatorBySpec.generateKeyPairSync(); // Generate an ECC key pair.\n    if (keyPair != null) {\n      showEccSpecDetailInfo(keyPair.priKey, 'priKey'); // 对私钥获取相关密钥参数属性\n      showEccSpecDetailInfo(keyPair.pubKey, 'pubKey'); // 对公钥获取相关密钥参数属性\n    } else {\n      console.error('get key pair result fail!');\n    }\n  } catch (e) {\n    // 逻辑错误等异常在此捕获\n    console.error(`get key pair result fail, ${e.code}, ${e.message}`);\n  }\n} 
根据椭圆曲线名生成SM2密钥对
对应的算法规格请查看非对称密钥生成和转换规格：SM2。
 构造ECCCommonParamsSpec对象，用于指定非对称公共密钥参数。根据genECCCommonParamsSpec接口传入相应的NID字符串名称生成相应的非对称公共密钥参数。 使用密钥参数生成密钥时，用到的bigint类型需要以大端模式输入，且必须为正数。 创建ECCKeyPairSpec对象，并且algName设置为SM2，用于指定SM2算法中密钥对包含的参数。 调用cryptoFramework.createAsyKeyGeneratorBySpec，将ECCKeyPairSpec对象传入，创建非对称密钥生成器。 调用AsyKeyGeneratorBySpec.generateKeyPair，得到各项数据与密钥参数一致的密钥对（KeyPair）。 调用PriKey.getAsyKeySpec，获取SM2算法中椭圆曲线参数。 
 以使用Promise方式根据椭圆曲线名生成SM2密钥为例： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\n\nfunction genSM2KeyPairSpec() {\n  let sm2CommonParamsSpec = cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2');\n  let sm2KeyPairSpec: cryptoFramework.ECCKeyPairSpec = {\n    algName: \"SM2\",\n    specType: cryptoFramework.AsyKeySpecType.KEY_PAIR_SPEC,\n    params: sm2CommonParamsSpec,\n    sk: BigInt('0x6330B599ECD23ABDC74B9A5B7B5E00E553005F72743101C5FAB83AEB579B7074'),\n    pk: {\n      x: BigInt('0x67F3B850BDC0BA5D3A29D8A0883C4B17612AB84F87F18E28F77D824A115C02C4'),\n      y: BigInt('0xD48966CE754BBBEDD6501A1385E1B205C186E926ADED44287145E8897D4B2071')\n    },\n  };\n  return sm2KeyPairSpec;\n}\n\nasync function sm2Test() {\n  let sm2KeyPairSpec = genSM2KeyPairSpec();\n  let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(sm2KeyPairSpec);\n  let keyPair = await generatorBySpec.generateKeyPair();\n  let sm2CurveName = keyPair.priKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_CURVE_NAME_STR);\n  console.info('ECC_CURVE_NAME_STR: ' + sm2CurveName); // NID_sm2\n} 同步返回结果（调用方法generateKeyPairSync）： import { cryptoFramework } from '@kit.CryptoArchitectureKit';\n\nfunction genSM2KeyPairSpec() {\n  let sm2CommonParamsSpec = cryptoFramework.ECCKeyUtil.genECCCommonParamsSpec('NID_sm2');\n  let sm2KeyPairSpec: cryptoFramework.ECCKeyPairSpec = {\n    algName: \"SM2\",\n    specType: cryptoFramework.AsyKeySpecType.KEY_PAIR_SPEC,\n    params: sm2CommonParamsSpec,\n    sk: BigInt('0x6330B599ECD23ABDC74B9A5B7B5E00E553005F72743101C5FAB83AEB579B7074'),\n    pk: {\n      x: BigInt('0x67F3B850BDC0BA5D3A29D8A0883C4B17612AB84F87F18E28F77D824A115C02C4'),\n      y: BigInt('0xD48966CE754BBBEDD6501A1385E1B205C186E926ADED44287145E8897D4B2071')\n    },\n  };\n  return sm2KeyPairSpec;\n}\nfunction sm2TestSync() {\n  let sm2KeyPairSpec = genSM2KeyPairSpec();\n  let generatorBySpec = cryptoFramework.createAsyKeyGeneratorBySpec(sm2KeyPairSpec);\n  try {\n    let keyPair = generatorBySpec.generateKeyPairSync();\n    if (keyPair != null) {\n      let sm2CurveName = keyPair.priKey.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.ECC_CURVE_NAME_STR);\n      console.info('ECC_CURVE_NAME_STR: ' + sm2CurveName); // NID_sm2\n    } else {\n      console.error('get key pair result fail!');\n    }\n  } catch (e) {\n    console.error(`get key pair result fail, ${e.code}, ${e.message}`);\n  }\n} 

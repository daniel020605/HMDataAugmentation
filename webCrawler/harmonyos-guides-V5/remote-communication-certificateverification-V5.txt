双向证书校验
场景介绍
用于验证服务端和客户端之间的身份和数据完整性，确保通信的安全性。
开发步骤
导入模块。import { rcp } from '@kit.RemoteCommunicationKit';\nimport { fileIo } from '@kit.CoreFileKit';\nimport { BusinessError } from '@kit.BasicServicesKit'; 读取证书。let readSyn = async () => {\n  // 定义文件路径，请根据业务自行定义\n  let pathDir = \"/path/files/\";\n  // 定义文件路径，请根据业务自行定义\n  let filePath = pathDir + \"/client.crt\";\n\n  // 使用 fileIo.open 方法打开文件，返回一个 Promise\n  fileIo.open(filePath, fileIo.OpenMode.READ_WRITE).then((file: fileIo.File) => {\n    // 打印成功打开的文件描述符\n    console.info(`readxx the file is: ${file.fd}`);\n    // 创建一个 4096 字节的缓冲区用于存储读取的数据\n    let buf = new ArrayBuffer(4096);\n    // 使用 fileIo.read 方法读取文件内容，返回一个 Promise\n    fileIo.read(file.fd, buf, (err: BusinessError, readLen: number) => {\n      // 如果读取过程中发生错误\n      if (err) {\n        // 打印错误信息\n        console.error(`readxx failed with error message: Code is ${err.code}, message is ${err.message}`);\n      } else {\n        // 如果读取成功\n        // 打印成功信息\n        console.info(`readxx file data succeed`);\n        // 打印读取的数据\n        console.info(`readxx: ${String.fromCharCode(...new Uint8Array(buf.slice(0, readLen)))}`);\n\n        // 将读取的数据转换为字符串\n        let content = String.fromCharCode(...new Uint8Array(buf.slice(0, readLen)));\n        getCertSyn(content);  \n        // 打印证书内容\n        console.info(`this.cert.data: ${content}`);\n        // 同步关闭文件\n        fileIo.closeSync(file);\n      }\n    });\n  }).catch((err: BusinessError) => {\n    // 如果打开文件过程中发生错误\n    // 打印错误信息\n    console.error(`readxx Open failed errInfo: Code is ${err.code}, message is ${err.message}`);\n  })\n} 发起请求。\"https://www.example.com\"请根据实际情况替换为想要请求的URL地址。let getCertSyn = async (content: string) => {\n  let kHttpServerAddress = \"https://www.example.com/fetch\";\n  try {\n    //创建session\n    const session = rcp.createSession();\n    const request = new rcp.Request(kHttpServerAddress, \"GET\");\n    request.configuration = {\n      security: {\n        certificate: {\n          content: content,\n          type: \"PEM\",\n          key: \" \",\n          keyPassword: \" \"\n        }\n      }\n    }\n    //请求成功处理\n    console.info(`configuration: ${request.configuration}`);\n    const response = await session.fetch(request);\n    console.info(`${kHttpServerAddress} certificate verification succeeded, message is ${response}`);\n  } catch (err) {\n    //请求失败处理\n    console.error(`${kHttpServerAddress} certificate verification failed: Code is ${err.code}, message is ${err.message}`);\n    let e: BusinessError = err as BusinessError;\n    console.error(`TestTag Get push token catch error: Code is ${e.code}, message is ${e.message}`);\n  }\n} 

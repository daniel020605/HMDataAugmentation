@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化
上文所述的装饰器（包括@State、@Prop、@Link、@Provide和@Consume装饰器）仅能观察到第一层的变化，但是在实际应用开发中，应用会根据开发需要，封装自己的数据模型。对于多层嵌套的情况，比如二维数组，或者数组项class，或者class的属性是class，他们的第二层的属性变化是无法观察到的。这就引出了@Observed/@ObjectLink装饰器。
@Observed/@ObjectLink配套使用是用于嵌套场景的观察，主要是为了弥补装饰器仅能观察一层的能力限制，开发者最好对装饰器的基本观察能力有一定的了解，再来对比阅读该文档。建议提前阅读：@State的基本用法。
从API version 9开始，这两个装饰器支持在ArkTS卡片中使用。
从API version 11开始，这两个装饰器支持在元服务中使用。
概述
@ObjectLink和@Observed类装饰器用于在涉及嵌套对象或数组的场景中进行双向数据同步：
 使用new创建被@Observed装饰的类，可以被观察到属性的变化。 子组件中@ObjectLink装饰器装饰的状态变量用于接收@Observed装饰的类的实例，和父组件中对应的状态变量建立双向数据绑定。这个实例可以是数组中的被@Observed装饰的项，或者是class object中的属性，这个属性同样也需要被@Observed装饰。 @Observed用于嵌套类场景中，观察对象类属性变化，要配合自定义组件使用（示例详见嵌套对象），如果要做数据双/单向同步，需要搭配@ObjectLink或者@Prop使用（示例详见@Prop与@ObjectLink的差异）。 
装饰器说明
必须为被@Observed装饰的class实例，必须指定类型。
@ObjectLink不支持简单类型，如果开发者需要使用简单类型，可以使用@Prop。
支持继承Date、Array的class实例，API11及以上支持继承Map、Set的class实例。示例见观察变化。
API11及以上支持@Observed装饰类和undefined或null组成的联合类型，比如ClassA | ClassB, ClassA | undefined 或者 ClassA | null, 示例见@ObjectLink支持联合类型。
@ObjectLink的属性是可以改变的，但是变量的分配是不允许的，也就是说这个装饰器装饰变量是只读的，不能被改变。
@ObjectLink装饰的数据为可读示例。
// 允许@ObjectLink装饰的数据属性赋值\nthis.objLink.a= ...\n// 不允许@ObjectLink装饰的数据自身赋值\nthis.objLink= ...
@ObjectLink装饰的变量不能被赋值，如果要使用赋值操作，请使用@Prop。
 @Prop装饰的变量和数据源的关系是是单向同步，@Prop装饰的变量在本地拷贝了数据源，所以它允许本地更改，如果父组件中的数据源有更新，@Prop装饰的变量本地的修改将被覆盖。 @ObjectLink装饰的变量和数据源的关系是双向同步，@ObjectLink装饰的变量相当于指向数据源的指针。禁止对@ObjectLink装饰的变量赋值，如果一旦发生@ObjectLink装饰的变量的赋值，则同步链将被打断。因为@ObjectLink装饰的变量通过数据源（Object）引用来初始化。对于实现双向数据同步的@ObjectLink，赋值相当于更新父组件中的数组项或者class的属性，TypeScript/JavaScript不能实现，会发生运行时报错。 
变量的传递/访问规则说明
必须指定。
初始化@ObjectLink装饰的变量必须同时满足以下场景：
- 类型必须是@Observed装饰的class。
- 初始化的数值需要是数组项，或者class的属性。
- 同步源的class或者数组必须是@State，@Link，@Provide，@Consume或者@ObjectLink装饰的数据。
同步源是数组项的示例请参考对象数组。初始化的class的示例请参考嵌套对象。
图1 初始化规则图示
观察变化和行为表现
[h2]观察变化
@Observed装饰的类，如果其属性为非简单类型，比如class、Object或者数组，也需要被@Observed装饰，否则将观察不到其属性的变化。
class Child {\n  public num: number;\n\n  constructor(num: number) {\n    this.num = num;\n  }\n}\n\n@Observed\nclass Parent {\n  public child: Child;\n  public count: number;\n\n  constructor(child: Child, count: number) {\n    this.child = child;\n    this.count = count;\n  }\n}
以上示例中，Parent被@Observed装饰，其成员变量的赋值的变化是可以被观察到的，但对于Child，没有被@Observed装饰，其属性的修改不能被观察到。
@ObjectLink parent: Parent;\n\n// 赋值变化可以被观察到\nthis.parent.child = new Child(5);\nthis.parent.count = 5;\n\n// Child没有被@Observed装饰，其属性的变化观察不到\nthis.parent.child.num = 5;
@ObjectLink：@ObjectLink只能接收被@Observed装饰class的实例，推荐设计单独的自定义组件来渲染每一个数组或对象。此时，对象数组或嵌套对象（属性是对象的对象称为嵌套对象）需要两个自定义组件，一个自定义组件呈现外部数组/对象，另一个自定义组件呈现嵌套在数组/对象内的类对象。可以观察到：
 其属性的数值的变化，其中属性是指Object.keys(observedObject)返回的所有属性，示例请参考嵌套对象。 如果数据源是数组，则可以观察到数组item的替换，如果数据源是class，可观察到class的属性的变化，示例请参考对象数组。 
继承Date的class时，可以观察到Date整体的赋值，同时可通过调用Date的接口setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds 更新Date的属性。
@Observed\nclass DateClass extends Date {\n  constructor(args: number | string) {\n    super(args);\n  }\n}\n\n@Observed\nclass NewDate {\n  public data: DateClass;\n\n  constructor(data: DateClass) {\n    this.data = data;\n  }\n}\n\n@Component\nstruct Child {\n  label: string = 'date';\n  @ObjectLink data: DateClass;\n\n  build() {\n    Column() {\n      Button(`child increase the day by 1`)\n        .onClick(() => {\n          this.data.setDate(this.data.getDate() + 1);\n        })\n      DatePicker({\n        start: new Date('1970-1-1'),\n        end: new Date('2100-1-1'),\n        selected: this.data\n      })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State newData: NewDate = new NewDate(new DateClass('2023-1-1'));\n\n  build() {\n    Column() {\n      Child({ label: 'date', data: this.newData.data })\n\n      Button(`parent update the new date`)\n        .onClick(() => {\n          this.newData.data = new DateClass('2023-07-07');\n        })\n      Button(`ViewB: this.newData = new NewDate(new DateClass('2023-08-20'))`)\n        .onClick(() => {\n          this.newData = new NewDate(new DateClass('2023-08-20'));\n        })\n    }\n  }\n}
继承Map的class时，可以观察到Map整体的赋值，同时可通过调用Map的接口set, clear, delete 更新Map的值。详见继承Map类。
继承Set的class时，可以观察到Set整体的赋值，同时可通过调用Set的接口add, clear, delete 更新Set的值。详见继承Set类。
[h2]框架行为
 初始渲染： a. @Observed装饰的class的实例会被不透明的代理对象包装，代理了class上的属性的setter和getter方法。 b. 子组件中@ObjectLink装饰的从父组件初始化，接收被@Observed装饰的class的实例，@ObjectLink的包装类会将自己注册给@Observed class。 属性更新：当@Observed装饰的class属性改变时，会执行到代理的setter和getter，然后遍历依赖它的@ObjectLink包装类，通知数据更新。 
限制条件
 使用@Observed装饰class会改变class原始的原型链，@Observed和其他类装饰器装饰同一个class可能会带来问题。 @ObjectLink装饰器不能在@Entry装饰的自定义组件中使用。 @ObjectLink装饰的变量类型需要为显式的被@Observed装饰的类，如果未指定类型，或其不是@Observed装饰的class，编译期会报错。 
@Observed\nclass Info {\n  count: number;\n\n  constructor(count: number) {\n    this.count = count;\n  }\n}\n\nclass Test {\n  msg: number;\n\n  constructor(msg: number) {\n    this.msg = msg;\n  }\n}\n\n// 错误写法，count未指定类型，编译报错\n@ObjectLink count;\n// 错误写法，Test未被@Observed装饰，编译报错\n@ObjectLink test: Test;\n\n// 正确写法\n@ObjectLink count: Info;
 @ObjectLink装饰的变量不能本地初始化，仅能通过构造参数从父组件传入初始值，否则编译期会报错。 
```ts\n@Observed\nclass Info {\n  count: number;\n\n  constructor(count: number) {\n    this.count = count;\n  }\n}\n\n// 错误写法，编译报错\n@ObjectLink count: Info = new Info(10);\n\n// 正确写法\n@ObjectLink count: Info;\n```
 @ObjectLink装饰的变量是只读的，不能被赋值，否则会有运行时报错提示Cannot set property when setter is undefined。如果需要对@ObjectLink装饰的变量进行整体替换，可以在父组件对其进行整体替换。 
【反例】
@Observed\nclass Info {\n  count: number;\n\n  constructor(count: number) {\n    this.count = count;\n  }\n}\n\n@Component\nstruct Child {\n  @ObjectLink num: Info;\n\n  build() {\n    Column() {\n      Text(`num的值: ${this.num.count}`)\n        .onClick(() => {\n          // 错误写法，@ObjectLink装饰的变量不能被赋值\n          this.num = new Info(10);\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State num: Info = new Info(10);\n\n  build() {\n    Column() {\n      Text(`count的值: ${this.num.count}`)\n      Child({num: this.num})\n    }\n  }\n}
【正例】
@Observed\nclass Info {\n  count: number;\n\n  constructor(count: number) {\n    this.count = count;\n  }\n}\n\n@Component\nstruct Child {\n  @ObjectLink num: Info;\n\n  build() {\n    Column() {\n      Text(`num的值: ${this.num.count}`)\n        .onClick(() => {\n          // 正确写法，可以更改@ObjectLink装饰变量的成员属性\n          this.num.count = 20;\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State num: Info = new Info(10);\n\n  build() {\n    Column() {\n      Text(`count的值: ${this.num.count}`)\n      Button('click')\n        .onClick(() => {\n          // 可以在父组件做整体替换\n          this.num = new Info(30);\n        })\n      Child({num: this.num})\n    }\n  }\n}
使用场景
[h2]嵌套对象
NextID是用来在ForEach循环渲染过程中，为每个数组元素生成一个唯一且持久的键值，用于标识对应的组件。
// objectLinkNestedObjects.ets\nlet NextID: number = 1;\n\n@Observed\nclass Bag {\n  public id: number;\n  public size: number;\n\n  constructor(size: number) {\n    this.id = NextID++;\n    this.size = size;\n  }\n}\n\n@Observed\nclass User {\n  public bag: Bag;\n\n  constructor(bag: Bag) {\n    this.bag = bag;\n  }\n}\n\n@Observed\nclass Book {\n  public bookName: BookName;\n\n  constructor(bookName: BookName) {\n    this.bookName = bookName;\n  }\n}\n\n@Observed\nclass BookName extends Bag {\n  public nameSize: number;\n\n  constructor(nameSize: number) {\n    // 调用父类方法对nameSize进行处理\n    super(nameSize);\n    this.nameSize = nameSize;\n  }\n}\n\n@Component\nstruct Son {\n  label: string = 'Son';\n  @ObjectLink bag: Bag;\n\n  build() {\n    Column() {\n      Text(`Son [${this.label}] this.bag.size = ${this.bag.size}`)\n        .fontColor('#ffffffff')\n        .backgroundColor('#ff3d9dba')\n        .width(320)\n        .height(50)\n        .borderRadius(25)\n        .margin(10)\n        .textAlign(TextAlign.Center)\n      Button(`Son: this.bag.size add 1`)\n        .width(320)\n        .backgroundColor('#ff17a98d')\n        .margin(10)\n        .onClick(() => {\n          this.bag.size += 1;\n        })\n    }\n  }\n}\n\n@Component\nstruct Father {\n  label: string = 'Father';\n  @ObjectLink bookName: BookName;\n\n  build() {\n    Row() {\n      Column() {\n        Text(`Father [${this.label}] this.bookName.size = ${this.bookName.size}`)\n          .fontColor('#ffffffff')\n          .backgroundColor('#ff3d9dba')\n          .width(320)\n          .height(50)\n          .borderRadius(25)\n          .margin(10)\n          .textAlign(TextAlign.Center)\n        Button(`Father: this.bookName.size add 1`)\n          .width(320)\n          .backgroundColor('#ff17a98d')\n          .margin(10)\n          .onClick(() => {\n            this.bookName.size += 1;\n            console.log('this.bookName.size:' + this.bookName.size);\n          })\n      }\n      .width(320)\n    }\n  }\n}\n\n@Entry\n@Component\nstruct GrandFather {\n  @State user: User = new User(new Bag(0));\n  @State child: Book = new Book(new BookName(0));\n\n  build() {\n    Column() {\n      Son({ label: 'Son #1', bag: this.user.bag })\n        .width(320)\n      Father({ label: 'Father #3', bookName: this.child.bookName })\n        .width(320)\n      Button(`GrandFather: this.child.bookName.size add 10`)\n        .width(320)\n        .backgroundColor('#ff17a98d')\n        .margin(10)\n        .onClick(() => {\n          this.child.bookName.size += 10;\n          console.log('this.child.bookName.size:' + this.child.bookName.size);\n        })\n      Button(`GrandFather: this.user.bag = new Bag(10)`)\n        .width(320)\n        .backgroundColor('#ff17a98d')\n        .margin(10)\n        .onClick(() => {\n          this.user.bag = new Bag(10);\n        })\n      Button(`GrandFather: this.user = new User(new Bag(20))`)\n        .width(320)\n        .backgroundColor('#ff17a98d')\n        .margin(10)\n        .onClick(() => {\n          this.user = new User(new Bag(20));\n        })\n    }\n  }\n}
被@Observed装饰的BookName类，可以观测到继承基类的属性的变化。
GrandFather中的事件句柄：
 this.user.bag = new Bag(10) 和this.user = new User(new Bag(20))： 对@State装饰的变量user和其属性的修改。 this.child.bookName.size += ... ：该变化属于第二层的变化，@State无法观察到第二层的变化，但是Bag被@Observed装饰，Bag的属性size的变化可以被@ObjectLink观察到。 
Father中的事件句柄：
 this.bookName.size += 1：对@ObjectLink变量size的修改，将触发Text组件的刷新。@ObjectLink和@Prop不同，@ObjectLink不拷贝来自父组件的数据源，而是在本地构建了指向其数据源的引用。 @ObjectLink变量是只读的，this.bookName = new bookName(...)是不允许的，因为一旦赋值操作发生，指向数据源的引用将被重置，同步将被打断。 
[h2]对象数组
对象数组是一种常用的数据结构。以下示例展示了数组对象的用法。
let NextID: number = 1;\n\n@Observed\nclass Info {\n  public id: number;\n  public info: number;\n\n  constructor(info: number) {\n    this.id = NextID++;\n    this.info = info;\n  }\n}\n\n@Component\nstruct Child {\n  // 子组件Child的@ObjectLink的类型是Info\n  @ObjectLink info: Info;\n  label: string = 'ViewChild';\n\n  build() {\n    Row() {\n      Button(`ViewChild [${this.label}] this.info.info = ${this.info ? this.info.info : \"undefined\"}`)\n        .width(320)\n        .margin(10)\n        .onClick(() => {\n          this.info.info += 1;\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  // Parent中有@State装饰的Info[]\n  @State arrA: Info[] = [new Info(0), new Info(0)];\n\n  build() {\n    Column() {\n      ForEach(this.arrA,\n        (item: Info) => {\n          Child({ label: `#${item.id}`, info: item })\n        },\n        (item: Info): string => item.id.toString()\n      )\n      // 使用@State装饰的数组的数组项初始化@ObjectLink，其中数组项是被@Observed装饰的Info的实例\n      Child({ label: `ViewChild this.arrA[first]`, info: this.arrA[0] })\n      Child({ label: `ViewChild this.arrA[last]`, info: this.arrA[this.arrA.length-1] })\n\n      Button(`ViewParent: reset array`)\n        .width(320)\n        .margin(10)\n        .onClick(() => {\n          this.arrA = [new Info(0), new Info(0)];\n        })\n      Button(`ViewParent: push`)\n        .width(320)\n        .margin(10)\n        .onClick(() => {\n          this.arrA.push(new Info(0));\n        })\n      Button(`ViewParent: shift`)\n        .width(320)\n        .margin(10)\n        .onClick(() => {\n          if (this.arrA.length > 0) {\n            this.arrA.shift();\n          } else {\n            console.log(\"length <= 0\");\n          }\n        })\n      Button(`ViewParent: item property in middle`)\n        .width(320)\n        .margin(10)\n        .onClick(() => {\n          this.arrA[Math.floor(this.arrA.length / 2)].info = 10;\n        })\n      Button(`ViewParent: item property in middle`)\n        .width(320)\n        .margin(10)\n        .onClick(() => {\n          this.arrA[Math.floor(this.arrA.length / 2)] = new Info(11);\n        })\n    }\n  }\n}
 this.arrA[Math.floor(this.arrA.length/2)] = new Info(..) ：该状态变量的改变触发2次更新：  ForEach：数组项的赋值导致ForEach的itemGenerator被修改，因此数组项被识别为有更改，ForEach的item builder将执行，创建新的Child组件实例。 Child({ label: ViewChild this.arrA[last], info: this.arrA[this.arrA.length-1] })：上述更改改变了数组中第二个元素，所以绑定this.arrA[1]的Child将被更新。  this.arrA.push(new Info(0)) ： 将触发2次不同效果的更新：  ForEach：新添加的Info对象对于ForEach是未知的itemGenerator，ForEach的item builder将执行，创建新的Child组件实例。 Child({ label: ViewChild this.arrA[last], info: this.arrA[this.arrA.length-1] })：数组的最后一项有更改，因此引起第二个Child的实例的更改。对于Child({ label: ViewChild this.arrA[first], info: this.arrA[0] })，数组的更改并没有触发一个数组项更改的改变，所以第一个Child不会刷新。  this.arrA[Math.floor(this.arrA.length/2)].info：@State无法观察到第二层的变化，但是Info被@Observed装饰，Info的属性的变化将被@ObjectLink观察到。 
[h2]二维数组
使用@Observed观察二维数组的变化。可以声明一个被@Observed装饰的继承Array的子类。
@Observed\nclass ObservedArray<T> extends Array<T> {\n  constructor(args: T[]) {\n    super(...args);\n  }\n}
声明一个继承自Array的类ObservedArray<T>并使用new操作符创建ObservedArray<string>的实例。通过new操作符创建的ObservedArray的实例可以观察到属性变化。
在下面的示例中，展示了如何利用@Observed观察二维数组的变化。
@Observed\nclass ObservedArray<T> extends Array<T> {\n  constructor(args: T[]) {\n    super(...args);\n  }\n}\n\n@Component\nstruct Item {\n  @ObjectLink itemArr: ObservedArray<string>;\n\n  build() {\n    Row() {\n      ForEach(this.itemArr, (item: string, index: number) => {\n        Text(`${index}: ${item}`)\n          .width(100)\n          .height(100)\n      }, (item: string) => item)\n    }\n  }\n}\n\n@Entry\n@Component\nstruct IndexPage {\n  @State arr: Array<ObservedArray<string>> = [new ObservedArray<string>(['apple']), new ObservedArray<string>(['banana']), new ObservedArray<string>(['orange'])];\n\n  build() {\n    Column() {\n      ForEach(this.arr, (itemArr: ObservedArray<string>) => {\n        Item({ itemArr: itemArr })\n      })\n\n      Divider()\n\n      Button('push two-dimensional array item')\n        .margin(10)\n        .onClick(() => {\n          this.arr[0].push('strawberry');\n        })\n\n      Button('push array item')\n        .margin(10)\n        .onClick(() => {\n          this.arr.push(new ObservedArray<string>(['pear']));\n        })\n\n      Button('change two-dimensional array first item')\n        .margin(10)\n        .onClick(() => {\n          this.arr[0][0] = 'APPLE';\n        })\n\n      Button('change array first item')\n        .margin(10)\n        .onClick(() => {\n          this.arr[0] = new ObservedArray<string>(['watermelon']);\n        })\n    }\n  }\n}
[h2]继承Map类
从API version 11开始，@ObjectLink支持@Observed装饰Map类型和继承Map类的类型。
在下面的示例中，myMap类型为MyMap<number, string>，点击Button改变myMap的属性，视图会随之刷新。
@Observed\nclass Info {\n  public info: MyMap<number, string>;\n\n  constructor(info: MyMap<number, string>) {\n    this.info = info;\n  }\n}\n\n\n@Observed\nexport class MyMap<K, V> extends Map<K, V> {\n  public name: string;\n\n  constructor(name?: string, args?: [K, V][]) {\n    super(args);\n    this.name = name ? name : \"My Map\";\n  }\n\n  getName() {\n    return this.name;\n  }\n}\n\n@Entry\n@Component\nstruct MapSampleNested {\n  @State message: Info = new Info(new MyMap(\"myMap\", [[0, \"a\"], [1, \"b\"], [3, \"c\"]]));\n\n  build() {\n    Row() {\n      Column() {\n        MapSampleNestedChild({ myMap: this.message.info })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}\n\n@Component\nstruct MapSampleNestedChild {\n  @ObjectLink myMap: MyMap<number, string>;\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.myMap.entries()), (item: [number, string]) => {\n          Text(`${item[0]}`).fontSize(30)\n          Text(`${item[1]}`).fontSize(30)\n          Divider().strokeWidth(5)\n        })\n\n        Button('set new one')\n          .width(200)\n          .margin(10)\n          .onClick(() => {\n            this.myMap.set(4, \"d\");\n          })\n        Button('clear')\n          .width(200)\n          .margin(10)\n          .onClick(() => {\n            this.myMap.clear();\n          })\n        Button('replace the first one')\n          .width(200)\n          .margin(10)\n          .onClick(() => {\n            this.myMap.set(0, \"aa\");\n          })\n        Button('delete the first one')\n          .width(200)\n          .margin(10)\n          .onClick(() => {\n            this.myMap.delete(0);\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
[h2]继承Set类
从API version 11开始，@ObjectLink支持@Observed装饰Set类型和继承Set类的类型。
在下面的示例中，mySet类型为MySet<number>，点击Button改变mySet的属性，视图会随之刷新。
@Observed\nclass Info {\n  public info: MySet<number>;\n\n  constructor(info: MySet<number>) {\n    this.info = info;\n  }\n}\n\n\n@Observed\nexport class MySet<T> extends Set<T> {\n  public name: string;\n\n  constructor(name?: string, args?: T[]) {\n    super(args);\n    this.name = name ? name : \"My Set\";\n  }\n\n  getName() {\n    return this.name;\n  }\n}\n\n@Entry\n@Component\nstruct SetSampleNested {\n  @State message: Info = new Info(new MySet(\"Set\", [0, 1, 2, 3, 4]));\n\n  build() {\n    Row() {\n      Column() {\n        SetSampleNestedChild({ mySet: this.message.info })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}\n\n@Component\nstruct SetSampleNestedChild {\n  @ObjectLink mySet: MySet<number>;\n\n  build() {\n    Row() {\n      Column() {\n        ForEach(Array.from(this.mySet.entries()), (item: [number, number]) => {\n          Text(`${item}`).fontSize(30)\n          Divider()\n        })\n        Button('set new one')\n          .width(200)\n          .margin(10)\n          .onClick(() => {\n            this.mySet.add(5);\n          })\n        Button('clear')\n          .width(200)\n          .margin(10)\n          .onClick(() => {\n            this.mySet.clear();\n          })\n        Button('delete the first one')\n          .width(200)\n          .margin(10)\n          .onClick(() => {\n            this.mySet.delete(0);\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
ObjectLink支持联合类型
@ObjectLink支持@Observed装饰类和undefined或null组成的联合类型，在下面的示例中，count类型为Source | Data | undefined，点击父组件Parent中的Button改变count的属性或者类型，Child中也会对应刷新。
@Observed\nclass Source {\n  public source: number;\n\n  constructor(source: number) {\n    this.source = source;\n  }\n}\n\n@Observed\nclass Data {\n  public data: number;\n\n  constructor(data: number) {\n    this.data = data;\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State count: Source | Data | undefined = new Source(10);\n\n  build() {\n    Column() {\n      Child({ count: this.count })\n\n      Button('change count property')\n        .margin(10)\n        .onClick(() => {\n          // 判断count的类型，做属性的更新\n          if (this.count instanceof Source) {\n            this.count.source += 1;\n          } else if (this.count instanceof Data) {\n            this.count.data += 1;\n          } else {\n            console.info('count is undefined, cannot change property');\n          }\n        })\n\n      Button('change count to Source')\n        .margin(10)\n        .onClick(() => {\n          // 赋值为Source的实例\n          this.count = new Source(100);\n        })\n\n      Button('change count to Data')\n        .margin(10)\n        .onClick(() => {\n          // 赋值为Data的实例\n          this.count = new Data(100);\n        })\n\n      Button('change count to undefined')\n        .margin(10)\n        .onClick(() => {\n          // 赋值为undefined\n          this.count = undefined;\n        })\n    }.width('100%')\n  }\n}\n\n@Component\nstruct Child {\n  @ObjectLink count: Source | Data | undefined;\n\n  build() {\n    Column() {\n      Text(`count is instanceof ${this.count instanceof Source ? 'Source' :\n        this.count instanceof Data ? 'Data' : 'undefined'}`)\n        .fontSize(30)\n        .margin(10)\n\n      Text(`count's property is  ${this.count instanceof Source ? this.count.source : this.count?.data}`).fontSize(15)\n\n    }.width('100%')\n  }\n}
常见问题
[h2]在子组件中给@ObjectLink装饰的变量赋值
在子组件中给@ObjectLink装饰的变量赋值是不允许的。
【反例】
@Observed\nclass Info {\n  public info: number = 0;\n\n  constructor(info: number) {\n    this.info = info;\n  }\n}\n\n@Component\nstruct ObjectLinkChild {\n  @ObjectLink testNum: Info;\n\n  build() {\n    Text(`ObjectLinkChild testNum ${this.testNum.info}`)\n      .onClick(() => {\n        // ObjectLink不能被赋值\n        this.testNum = new Info(47);\n      })\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State testNum: Info[] = [new Info(1)];\n\n  build() {\n    Column() {\n      Text(`Parent testNum ${this.testNum[0].info}`)\n        .onClick(() => {\n          this.testNum[0].info += 1;\n        })\n\n      ObjectLinkChild({ testNum: this.testNum[0] })\n    }\n  }\n}
点击ObjectLinkChild给@ObjectLink装饰的变量赋值：
this.testNum = new Info(47); 
这是不允许的，对于实现双向数据同步的@ObjectLink，赋值相当于要更新父组件中的数组项或者class的属性，这个对于 TypeScript/JavaScript是不能实现的。框架对于这种行为会发生运行时报错。
【正例】
@Observed\nclass Info {\n  public info: number = 0;\n\n  constructor(info: number) {\n    this.info = info;\n  }\n}\n\n@Component\nstruct ObjectLinkChild {\n  @ObjectLink testNum: Info;\n\n  build() {\n    Text(`ObjectLinkChild testNum ${this.testNum.info}`)\n      .onClick(() => {\n        // 可以对ObjectLink装饰对象的属性赋值\n        this.testNum.info = 47;\n      })\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State testNum: Info[] = [new Info(1)];\n\n  build() {\n    Column() {\n      Text(`Parent testNum ${this.testNum[0].info}`)\n        .onClick(() => {\n          this.testNum[0].info += 1;\n        })\n\n      ObjectLinkChild({ testNum: this.testNum[0] })\n    }\n  }\n}
[h2]基础嵌套对象属性更改失效
在应用开发中，有很多嵌套对象场景，例如，开发者更新了某个属性，但UI没有进行对应的更新。
每个装饰器都有自己可以观察的能力，并不是所有的改变都可以被观察到，只有可以被观察到的变化才会进行UI更新。@Observed装饰器可以观察到嵌套对象的属性变化，其他装饰器仅能观察到第一层的变化。
【反例】
下面的例子中，一些UI组件并不会更新。
class Parent {\n  parentId: number;\n\n  constructor(parentId: number) {\n    this.parentId = parentId;\n  }\n\n  getParentId(): number {\n    return this.parentId;\n  }\n\n  setParentId(parentId: number): void {\n    this.parentId = parentId;\n  }\n}\n\nclass Child {\n  childId: number;\n\n  constructor(childId: number) {\n    this.childId = childId;\n  }\n\n  getChildId(): number {\n    return this.childId;\n  }\n\n  setChildId(childId: number): void {\n    this.childId = childId;\n  }\n}\n\nclass Cousin extends Parent {\n  cousinId: number = 47;\n  child: Child;\n\n  constructor(parentId: number, cousinId: number, childId: number) {\n    super(parentId);\n    this.cousinId = cousinId;\n    this.child = new Child(childId);\n  }\n\n  getCousinId(): number {\n    return this.cousinId;\n  }\n\n  setCousinId(cousinId: number): void {\n    this.cousinId = cousinId;\n  }\n\n  getChild(): number {\n    return this.child.getChildId();\n  }\n\n  setChild(childId: number): void {\n    return this.child.setChildId(childId);\n  }\n}\n\n@Entry\n@Component\nstruct MyView {\n  @State cousin: Cousin = new Cousin(10, 20, 30);\n\n  build() {\n    Column({ space: 10 }) {\n      Text(`parentId: ${this.cousin.parentId}`)\n      Button(\"Change Parent.parent\")\n        .onClick(() => {\n          this.cousin.parentId += 1;\n        })\n\n      Text(`cousinId: ${this.cousin.cousinId}`)\n      Button(\"Change Cousin.cousinId\")\n        .onClick(() => {\n          this.cousin.cousinId += 1;\n        })\n\n      Text(`childId: ${this.cousin.child.childId}`)\n      Button(\"Change Cousin.Child.childId\")\n        .onClick(() => {\n          // 点击时上面的Text组件不会刷新\n          this.cousin.child.childId += 1;\n        })\n    }\n  }\n}
 最后一个Text组件Text('child: ${this.cousin.child.childId}')，当点击该组件时UI不会刷新。 因为，@State cousin : Cousin 只能观察到this.cousin属性的变化，比如this.cousin.parentId, this.cousin.cousinId 和this.cousin.child的变化，但是无法观察嵌套在属性中的属性，即this.cousin.child.childId（属性childId是内嵌在cousin中的对象Child的属性）。 为了观察到嵌套于内部的Child的属性，需要做如下改变：  构造一个子组件，用于单独渲染Child的实例。 该子组件可以使用@ObjectLink child : Child或@Prop child : Child。通常会使用@ObjectLink，除非子组件需要对其Child对象进行本地修改。 嵌套的Child必须用@Observed装饰。当在Cousin中创建Child对象时（本示例中的Cousin(10, 20, 30）)，它将被包装在ES6代理中，当Child属性更改时（this.cousin.child.childId += 1），该代码将修改通知到@ObjectLink变量。  
【正例】
以下示例使用@Observed/@ObjectLink来观察嵌套对象的属性更改。
class Parent {\n  parentId: number;\n\n  constructor(parentId: number) {\n    this.parentId = parentId;\n  }\n\n  getParentId(): number {\n    return this.parentId;\n  }\n\n  setParentId(parentId: number): void {\n    this.parentId = parentId;\n  }\n}\n\n@Observed\nclass Child {\n  childId: number;\n\n  constructor(childId: number) {\n    this.childId = childId;\n  }\n\n  getChildId(): number {\n    return this.childId;\n  }\n\n  setChildId(childId: number): void {\n    this.childId = childId;\n  }\n}\n\nclass Cousin extends Parent {\n  cousinId: number = 47;\n  child: Child;\n\n  constructor(parentId: number, cousinId: number, childId: number) {\n    super(parentId);\n    this.cousinId = cousinId;\n    this.child = new Child(childId);\n  }\n\n  getCousinId(): number {\n    return this.cousinId;\n  }\n\n  setCousinId(cousinId: number): void {\n    this.cousinId = cousinId;\n  }\n\n  getChild(): number {\n    return this.child.getChildId();\n  }\n\n  setChild(childId: number): void {\n    return this.child.setChildId(childId);\n  }\n}\n\n@Component\nstruct ViewChild {\n  @ObjectLink child: Child;\n\n  build() {\n    Column({ space: 10 }) {\n      Text(`childId: ${this.child.getChildId()}`)\n      Button(\"Change childId\")\n        .onClick(() => {\n          this.child.setChildId(this.child.getChildId() + 1);\n        })\n    }\n  }\n}\n\n@Entry\n@Component\nstruct MyView {\n  @State cousin: Cousin = new Cousin(10, 20, 30);\n\n  build() {\n    Column({ space: 10 }) {\n      Text(`parentId: ${this.cousin.parentId}`)\n      Button(\"Change Parent.parentId\")\n        .onClick(() => {\n          this.cousin.parentId += 1;\n        })\n\n      Text(`cousinId: ${this.cousin.cousinId}`)\n      Button(\"Change Cousin.cousinId\")\n        .onClick(() => {\n          this.cousin.cousinId += 1;\n        })\n\n      ViewChild({ child: this.cousin.child }) // Text(`childId: ${this.cousin.child.childId}`)的替代写法\n      Button(\"Change Cousin.Child.childId\")\n        .onClick(() => {\n          this.cousin.child.childId += 1;\n        })\n    }\n  }\n}
[h2]复杂嵌套对象属性更改失效
【反例】
以下示例创建了一个带有@ObjectLink装饰变量的子组件，用于渲染一个含有嵌套属性的ParentCounter，用@Observed装饰嵌套在ParentCounter中的SubCounter。
let nextId = 1;\n@Observed\nclass SubCounter {\n  counter: number;\n  constructor(c: number) {\n    this.counter = c;\n  }\n}\n@Observed\nclass ParentCounter {\n  id: number;\n  counter: number;\n  subCounter: SubCounter;\n  incrCounter() {\n    this.counter++;\n  }\n  incrSubCounter(c: number) {\n    this.subCounter.counter += c;\n  }\n  setSubCounter(c: number): void {\n    this.subCounter.counter = c;\n  }\n  constructor(c: number) {\n    this.id = nextId++;\n    this.counter = c;\n    this.subCounter = new SubCounter(c);\n  }\n}\n@Component\nstruct CounterComp {\n  @ObjectLink value: ParentCounter;\n  build() {\n    Column({ space: 10 }) {\n      Text(`${this.value.counter}`)\n        .fontSize(25)\n        .onClick(() => {\n          this.value.incrCounter();\n        })\n      Text(`${this.value.subCounter.counter}`)\n        .onClick(() => {\n          this.value.incrSubCounter(1);\n        })\n      Divider().height(2)\n    }\n  }\n}\n@Entry\n@Component\nstruct ParentComp {\n  @State counter: ParentCounter[] = [new ParentCounter(1), new ParentCounter(2), new ParentCounter(3)];\n  build() {\n    Row() {\n      Column() {\n        CounterComp({ value: this.counter[0] })\n        CounterComp({ value: this.counter[1] })\n        CounterComp({ value: this.counter[2] })\n        Divider().height(5)\n        ForEach(this.counter,\n          (item: ParentCounter) => {\n            CounterComp({ value: item })\n          },\n          (item: ParentCounter) => item.id.toString()\n        )\n        Divider().height(5)\n        // 第一个点击事件\n        Text('Parent: incr counter[0].counter')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter[0].incrCounter();\n            // 每次触发时自增10\n            this.counter[0].incrSubCounter(10);\n          })\n        // 第二个点击事件\n        Text('Parent: set.counter to 10')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            // 无法将value设置为10，UI不会刷新\n            this.counter[0].setSubCounter(10);\n          })\n        Text('Parent: reset entire counter')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter = [new ParentCounter(1), new ParentCounter(2), new ParentCounter(3)];\n          })\n      }\n    }\n  }\n}
对于Text('Parent: incr counter[0].counter')的onClick事件，this.counter[0].incrSubCounter(10)调用incrSubCounter方法使SubCounter的counter值增加10，UI同步刷新。
但是，在Text('Parent: set.counter to 10')的onClick中调用this.counter[0].setSubCounter(10)，SubCounter的counter值却无法重置为10。
incrSubCounter和setSubCounter都是同一个SubCounter的函数。在第一个点击处理时调用incrSubCounter可以正确更新UI，而第二个点击处理调用setSubCounter时却没有更新UI。实际上incrSubCounter和setSubCounter两个函数都不能触发Text('${this.value.subCounter.counter}')的更新，因为@ObjectLink value : ParentCounter仅能观察其代理ParentCounter的属性，对于this.value.subCounter.counter是SubCounter的属性，无法观察到嵌套类的属性。
但是，第一个click事件调用this.counter[0].incrCounter()将CounterComp自定义组件中@ObjectLink value: ParentCounter标记为已更改。此时触发Text('${this.value.subCounter.counter}')的更新。 如果在第一个点击事件中删除this.counter[0].incrCounter()，也无法更新UI。
【正例】
对于上述问题，为了直接观察SubCounter中的属性，以便this.counter[0].setSubCounter(10)操作有效，可以利用下面的方法：
CounterComp({ value: this.counter[0] }); // ParentComp组件传递 ParentCounter 给 CounterComp 组件\n@ObjectLink value：ParentCounter; // @ObjectLink 接收 ParentCounter\n\nCounterChild({ subValue: this.value.subCounter }); // CounterComp组件 传递 SubCounter 给 CounterChild 组件\n@ObjectLink subValue：SubCounter; // @ObjectLink 接收 SubCounter
该方法使得@ObjectLink分别代理了ParentCounter和SubCounter的属性，这样对于这两个类的属性的变化都可以观察到，即都会对UI视图进行刷新。即使删除了上面所说的this.counter[0].incrCounter()，UI也会进行正确的刷新。
该方法可用于实现“两个层级”的观察，即外部对象和内部嵌套对象的观察。但是该方法只能用于@ObjectLink装饰器，无法作用于@Prop（@Prop通过深拷贝传入对象）。详情参考@Prop与@ObjectLink的差异。
let nextId = 1;\n\n@Observed\nclass SubCounter {\n  counter: number;\n\n  constructor(c: number) {\n    this.counter = c;\n  }\n}\n\n@Observed\nclass ParentCounter {\n  id: number;\n  counter: number;\n  subCounter: SubCounter;\n\n  incrCounter() {\n    this.counter++;\n  }\n\n  incrSubCounter(c: number) {\n    this.subCounter.counter += c;\n  }\n\n  setSubCounter(c: number): void {\n    this.subCounter.counter = c;\n  }\n\n  constructor(c: number) {\n    this.id = nextId++;\n    this.counter = c;\n    this.subCounter = new SubCounter(c);\n  }\n}\n\n@Component\nstruct CounterComp {\n  @ObjectLink value: ParentCounter;\n\n  build() {\n    Column({ space: 10 }) {\n      Text(`${this.value.counter}`)\n        .fontSize(25)\n        .onClick(() => {\n          this.value.incrCounter();\n        })\n      CounterChild({ subValue: this.value.subCounter })\n      Divider().height(2)\n    }\n  }\n}\n\n@Component\nstruct CounterChild {\n  @ObjectLink subValue: SubCounter;\n\n  build() {\n    Text(`${this.subValue.counter}`)\n      .onClick(() => {\n        this.subValue.counter += 1;\n      })\n  }\n}\n\n@Entry\n@Component\nstruct ParentComp {\n  @State counter: ParentCounter[] = [new ParentCounter(1), new ParentCounter(2), new ParentCounter(3)];\n\n  build() {\n    Row() {\n      Column() {\n        CounterComp({ value: this.counter[0] })\n        CounterComp({ value: this.counter[1] })\n        CounterComp({ value: this.counter[2] })\n        Divider().height(5)\n        ForEach(this.counter,\n          (item: ParentCounter) => {\n            CounterComp({ value: item })\n          },\n          (item: ParentCounter) => item.id.toString()\n        )\n        Divider().height(5)\n        Text('Parent: reset entire counter')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter = [new ParentCounter(1), new ParentCounter(2), new ParentCounter(3)];\n          })\n        Text('Parent: incr counter[0].counter')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter[0].incrCounter();\n            this.counter[0].incrSubCounter(10);\n          })\n        Text('Parent: set.counter to 10')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter[0].setSubCounter(10);\n          })\n      }\n    }\n  }\n}
[h2]@Prop与@ObjectLink的差异
在下面的示例代码中，@ObjectLink装饰的变量是对数据源的引用，即this.value.subCounter和this.subValue都是同一个对象的不同引用，所以在点击CounterComp的click handler，改变this.value.subCounter.counter时，this.subValue.counter也会改变，对应的组件Text(this.subValue.counter: ${this.subValue.counter})会刷新。
let nextId = 1;\n\n@Observed\nclass SubCounter {\n  counter: number;\n\n  constructor(c: number) {\n    this.counter = c;\n  }\n}\n\n@Observed\nclass ParentCounter {\n  id: number;\n  counter: number;\n  subCounter: SubCounter;\n\n  incrCounter() {\n    this.counter++;\n  }\n\n  incrSubCounter(c: number) {\n    this.subCounter.counter += c;\n  }\n\n  setSubCounter(c: number): void {\n    this.subCounter.counter = c;\n  }\n\n  constructor(c: number) {\n    this.id = nextId++;\n    this.counter = c;\n    this.subCounter = new SubCounter(c);\n  }\n}\n\n@Component\nstruct CounterComp {\n  @ObjectLink value: ParentCounter;\n\n  build() {\n    Column({ space: 10 }) {\n      CountChild({ subValue: this.value.subCounter })\n      Text(`this.value.counter：increase 7 `)\n        .fontSize(30)\n        .onClick(() => {\n          // 点击后Text(`this.subValue.counter: ${this.subValue.counter}`)会刷新\n          this.value.incrSubCounter(7);\n        })\n      Divider().height(2)\n    }\n  }\n}\n\n@Component\nstruct CountChild {\n  @ObjectLink subValue: SubCounter;\n\n  build() {\n    Text(`this.subValue.counter: ${this.subValue.counter}`)\n      .fontSize(30)\n  }\n}\n\n@Entry\n@Component\nstruct ParentComp {\n  @State counter: ParentCounter[] = [new ParentCounter(1), new ParentCounter(2), new ParentCounter(3)];\n\n  build() {\n    Row() {\n      Column() {\n        CounterComp({ value: this.counter[0] })\n        CounterComp({ value: this.counter[1] })\n        CounterComp({ value: this.counter[2] })\n        Divider().height(5)\n        ForEach(this.counter,\n          (item: ParentCounter) => {\n            CounterComp({ value: item })\n          },\n          (item: ParentCounter) => item.id.toString()\n        )\n        Divider().height(5)\n        Text('Parent: reset entire counter')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter = [new ParentCounter(1), new ParentCounter(2), new ParentCounter(3)];\n          })\n        Text('Parent: incr counter[0].counter')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter[0].incrCounter();\n            this.counter[0].incrSubCounter(10);\n          })\n        Text('Parent: set.counter to 10')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter[0].setSubCounter(10);\n          })\n      }\n    }\n  }\n}
@ObjectLink图示如下：
【反例】
如果用@Prop替代@ObjectLink。点击Text(this.subValue.counter: ${this.subValue.counter})，UI刷新正常。但是点击Text(this.value.counter：increase 7 )，@Prop 对变量做了一个本地拷贝，CounterComp的第一个Text并不会刷新。
this.value.subCounter和this.subValue并不是同一个对象。所以this.value.subCounter的改变，并没有改变this.subValue的拷贝对象，Text(this.subValue.counter: ${this.subValue.counter})不会刷新。
@Component\nstruct CounterComp {\n  @Prop value: ParentCounter = new ParentCounter(0);\n  @Prop subValue: SubCounter = new SubCounter(0);\n  build() {\n    Column({ space: 10 }) {\n      Text(`this.subValue.counter: ${this.subValue.counter}`)\n        .fontSize(20)\n        .onClick(() => {\n          this.subValue.counter += 7;\n        })\n      Text(`this.value.counter：increase 7 `)\n        .fontSize(20)\n        .onClick(() => {\n          this.value.incrSubCounter(7);\n        })\n      Divider().height(2)\n    }\n  }\n}
@Prop拷贝的关系图示如下：
【正例】
可以通过从ParentComp到CounterComp仅拷贝一份@Prop value: ParentCounter，同时必须避免再多拷贝一份SubCounter。
 在CounterComp组件中只使用一个@Prop counter：Counter。 添加另一个子组件SubCounterComp，其中包含@ObjectLink subCounter: SubCounter。此@ObjectLink可确保观察到SubCounter对象属性更改，并且UI更新正常。 @ObjectLink subCounter: SubCounter与CounterComp中的@Prop counter：Counter的this.counter.subCounter共享相同的SubCounter对象。 
let nextId = 1;\n\n@Observed\nclass SubCounter {\n  counter: number;\n  constructor(c: number) {\n    this.counter = c;\n  }\n}\n\n@Observed\nclass ParentCounter {\n  id: number;\n  counter: number;\n  subCounter: SubCounter;\n  incrCounter() {\n    this.counter++;\n  }\n  incrSubCounter(c: number) {\n    this.subCounter.counter += c;\n  }\n  setSubCounter(c: number): void {\n    this.subCounter.counter = c;\n  }\n  constructor(c: number) {\n    this.id = nextId++;\n    this.counter = c;\n    this.subCounter = new SubCounter(c);\n  }\n}\n\n@Component\nstruct SubCounterComp {\n  @ObjectLink subValue: SubCounter;\n  build() {\n    Text(`SubCounterComp: this.subValue.counter: ${this.subValue.counter}`)\n      .onClick(() => {\n        this.subValue.counter = 7;\n      })\n  }\n}\n@Component\nstruct CounterComp {\n  @Prop value: ParentCounter;\n  build() {\n    Column({ space: 10 }) {\n      Text(`this.value.incrCounter(): this.value.counter: ${this.value.counter}`)\n        .fontSize(20)\n        .onClick(() => {\n          this.value.incrCounter();\n        })\n      SubCounterComp({ subValue: this.value.subCounter })\n      Text(`this.value.incrSubCounter()`)\n        .onClick(() => {\n          this.value.incrSubCounter(77);\n        })\n      Divider().height(2)\n    }\n  }\n}\n@Entry\n@Component\nstruct ParentComp {\n  @State counter: ParentCounter[] = [new ParentCounter(1), new ParentCounter(2), new ParentCounter(3)];\n  build() {\n    Row() {\n      Column() {\n        CounterComp({ value: this.counter[0] })\n        CounterComp({ value: this.counter[1] })\n        CounterComp({ value: this.counter[2] })\n        Divider().height(5)\n        ForEach(this.counter,\n          (item: ParentCounter) => {\n            CounterComp({ value: item })\n          },\n          (item: ParentCounter) => item.id.toString()\n        )\n        Divider().height(5)\n        Text('Parent: reset entire counter')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter = [new ParentCounter(1), new ParentCounter(2), new ParentCounter(3)];\n          })\n        Text('Parent: incr counter[0].counter')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter[0].incrCounter();\n            this.counter[0].incrSubCounter(10);\n          })\n        Text('Parent: set.counter to 10')\n          .fontSize(20).height(50)\n          .onClick(() => {\n            this.counter[0].setSubCounter(10);\n          })\n      }\n    }\n  }\n}
拷贝关系图示如下：
[h2]在@Observed装饰类的构造函数中延时更改成员变量
在状态管理中，使用@Observed装饰类后，会给该类使用一层“代理”进行包装。当在组件中改变该类的成员变量时，会被该代理进行拦截，在更改数据源中值的同时，也会将变化通知给绑定的组件，从而实现观测变化与触发刷新。
当开发者在类的构造函数中对成员变量进行赋值或者修改时，此修改不会经过代理（因为是直接对数据源中的值进行修改），也就无法被观测到。所以，如果开发者在类的构造函数中使用定时器修改类中的成员变量，即使该修改成功执行了，也不会触发UI的刷新。
【反例】
@Observed\nclass RenderClass {\n  waitToRender: boolean = false;\n\n  constructor() {\n    setTimeout(() => {\n      this.waitToRender = true;\n      console.log(\"更改waitToRender的值为：\" + this.waitToRender);\n    }, 1000)\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State @Watch('renderClassChange') renderClass: RenderClass = new RenderClass();\n  @State textColor: Color = Color.Black;\n\n  renderClassChange() {\n    console.log(\"renderClass的值被更改为：\" + this.renderClass.waitToRender);\n  }\n\n  build() {\n    Row() {\n      Column() {\n        Text(\"renderClass的值为：\" + this.renderClass.waitToRender)\n          .fontSize(20)\n          .fontColor(this.textColor)\n        Button(\"Show\")\n          .onClick(() => {\n            // 使用其他状态变量强行刷新UI的做法并不推荐，此处仅用来检测waitToRender的值是否更新\n            this.textColor = Color.Red;\n          })\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
上文的示例代码中在RenderClass的构造函数中使用定时器在1秒后修改了waitToRender的值，但是不会触发UI的刷新。此时点击按钮，强行刷新Text组件可以看到waitToRender的值已经被修改成了true。
【正例】
@Observed\nclass RenderClass {\n  waitToRender: boolean = false;\n\n  constructor() {\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  @State @Watch('renderClassChange') renderClass: RenderClass = new RenderClass();\n\n  renderClassChange() {\n    console.log(\"renderClass的值被更改为：\" + this.renderClass.waitToRender);\n  }\n\n  onPageShow() {\n    setTimeout(() => {\n      this.renderClass.waitToRender = true;\n      console.log(\"更改renderClass的值为：\" + this.renderClass.waitToRender);\n    }, 1000)\n  }\n\n  build() {\n    Row() {\n      Column() {\n        Text(\"renderClass的值为：\" + this.renderClass.waitToRender)\n          .fontSize(20)\n      }\n      .width('100%')\n    }\n    .height('100%')\n  }\n}
上文的示例代码将定时器修改移入到组件内，此时界面显示时会先显示“renderClass的值为：false”。待定时器触发时，renderClass的值改变，触发@Watch回调，此时界面刷新显示“renderClass的值为：true”，日志输出“renderClass的值被更改为：true”。
因此，更推荐开发者在组件中对@Observed装饰的类成员变量进行修改实现刷新。
[h2]@ObjectLink数据源更新时机
@Observed\nclass Person {\n  name: string = '';\n  age: number = 0;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\n@Observed\nclass Info {\n  person: Person;\n\n  constructor(person: Person) {\n    this.person = person;\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State @Watch('onChange01') info: Info = new Info(new Person('Bob', 10));\n\n  onChange01() {\n    console.log(':::onChange01:' + this.info.person.name); // 2\n  }\n\n  build() {\n    Column() {\n      Text(this.info.person.name).height(40)\n      Child({\n        per: this.info.person, clickEvent: () => {\n          console.log(':::clickEvent before', this.info.person.name); // 1\n          this.info.person = new Person('Jack', 12);\n          console.log(':::clickEvent after', this.info.person.name); // 3\n        }\n      })\n    }\n  }\n}\n\n@Component\nstruct Child {\n  @ObjectLink @Watch('onChange02') per: Person;\n  clickEvent?: () => void;\n\n  onChange02() {\n    console.log(':::onChange02:' + this.per.name); // 5\n  }\n\n  build() {\n    Column() {\n      Button(this.per.name)\n        .height(40)\n        .onClick(() => {\n          this.onClickType();\n        })\n    }\n  }\n\n  private onClickType() {\n    if (this.clickEvent) {\n      this.clickEvent();\n    }\n    console.log(':::--------此时Child中的this.per.name值仍然是：' + this.per.name); // 4\n  }\n}
@ObjectLink的数据源更新依赖其父组件，当父组件中数据源改变引起父组件刷新时，会重新设置子组件@ObjectLink的数据源。这个过程不是在父组件数据源变化后立刻发生的，而是在父组件实际刷新时才会进行。上述示例中，Parent包含Child，Parent传递箭头函数给Child，在点击时，日志打印顺序是1-2-3-4-5，打印到日志4时，点击事件流程结束，此时仅仅是将子组件Child标记为需要父组件更新的节点，因此日志4打印的this.per.name的值仍为Bob，等到父组件真正更新时，才会更新Child的数据源。
当@ObjectLink @Watch('onChange02') per: Person的@Watch函数执行时，说明@ObjectLink的数据源已被父组件更新，此时日志5打印的值为更新后的Jack。
日志的含义为：
 日志1：对Parent @State @Watch('onChange01') info: Info = new Info(new Person('Bob', 10)) 赋值前。 日志2：对Parent @State @Watch('onChange01') info: Info = new Info(new Person('Bob', 10)) 赋值，执行其@Watch函数，同步执行。 日志3：对Parent @State @Watch('onChange01') info: Info = new Info(new Person('Bob', 10)) 赋值完成。 日志4：onClickType方法内clickEvent执行完，此时只是将子组件Child标记为需要父组件更新的节点，未将最新的值更新给Child @ObjectLink @Watch('onChange02') per: Person，所以日志4打印的this.per.name的值仍然是Bob。 日志5：下一次vsync信号触发Child更新，@ObjectLink @Watch('onChange02') per: Person被更新，触发其@Watch方法，此时@ObjectLink @Watch('onChange02') per: Person为新值Jack。 
@Prop父子同步原理同@ObjectLink一致。
当clickEvent中更改this.info.person.name时，修改会立刻生效，此时日志4打印的值是Jack。
Child({\n  per: this.info.person, clickEvent: () => {\n    console.log(':::clickEvent before', this.info.person.name); // 1\n    this.info.person.name = 'Jack';\n    console.log(':::clickEvent after', this.info.person.name); // 3\n  }\n})
此时Parent中Text组件不会刷新，因为this.info.person.name属于两层嵌套。
[h2]使用a.b(this.object)形式调用，不会触发UI刷新
在build方法内，当@Observed与@ObjectLink联合装饰的变量是Object类型、且通过a.b(this.object)形式调用时，b方法内传入的是this.object的原生对象，修改其属性，无法触发UI刷新。如下例中，通过静态方法或者使用this调用组件内部方法，修改组件中的this.weather.temperature时，UI不会刷新。
【反例】
@Observed\nclass Weather {\n  temperature:number;\n\n  constructor(temperature:number) {\n    this.temperature = temperature;\n  }\n\n  static increaseTemperature(weather:Weather) {\n    weather.temperature++;\n  }\n}\n\nclass Day {\n  weather:Weather;\n  week:string;\n  constructor(weather:Weather, week:string) {\n    this.weather = weather;\n    this.week = week;\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State day1: Day = new Day(new Weather(15), 'Monday');\n\n  build() {\n    Column({ space:10 }) {\n      Child({ weather: this.day1.weather})\n    }\n    .height('100%')\n    .width('100%')\n  }\n}\n\n@Component\nstruct Child {\n  @ObjectLink weather: Weather;\n\n  reduceTemperature (weather:Weather) {\n    weather.temperature--;\n  }\n\n  build() {\n    Column({ space:10 }) {\n      Text(`The temperature of day1 is ${this.weather.temperature} degrees.`)\n        .fontSize(20)\n      Button('increaseTemperature')\n        .onClick(()=>{\n          // 通过静态方法调用，无法触发UI刷新\n          Weather.increaseTemperature(this.weather);\n        })\n      Button('reduceTemperature')\n        .onClick(()=>{\n          // 使用this通过自定义组件内部方法调用，无法触发UI刷新\n          this.reduceTemperature(this.weather);\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}
可以通过如下先赋值、再调用新赋值的变量的方式为this.weather加上Proxy代理，实现UI刷新。
【正例】
@Observed\nclass Weather {\n  temperature:number;\n\n  constructor(temperature:number) {\n    this.temperature = temperature;\n  }\n\n  static increaseTemperature(weather:Weather) {\n    weather.temperature++;\n  }\n}\n\nclass Day {\n  weather:Weather;\n  week:string;\n  constructor(weather:Weather, week:string) {\n    this.weather = weather;\n    this.week = week;\n  }\n}\n\n@Entry\n@Component\nstruct Parent {\n  @State day1: Day = new Day(new Weather(15), 'Monday');\n\n  build() {\n    Column({ space:10 }) {\n      Child({ weather: this.day1.weather})\n    }\n    .height('100%')\n    .width('100%')\n  }\n}\n\n@Component\nstruct Child {\n  @ObjectLink weather: Weather;\n\n  reduceTemperature (weather:Weather) {\n    weather.temperature--;\n  }\n\n  build() {\n    Column({ space:10 }) {\n      Text(`The temperature of day1 is ${this.weather.temperature} degrees.`)\n        .fontSize(20)\n      Button('increaseTemperature')\n        .onClick(()=>{\n          // 通过赋值添加 Proxy 代理\n          let weather1 = this.weather;\n          Weather.increaseTemperature(weather1);\n        })\n      Button('reduceTemperature')\n        .onClick(()=>{\n          // 通过赋值添加 Proxy 代理\n          let weather2 = this.weather;\n          this.reduceTemperature(weather2);\n        })\n    }\n    .height('100%')\n    .width('100%')\n  }\n}

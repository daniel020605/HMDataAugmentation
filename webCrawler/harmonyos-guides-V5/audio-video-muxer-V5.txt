媒体数据封装
开发者可以调用本模块的Native API接口，完成音视频封装，即将音频、视频等编码后的媒体数据，按一定的格式存储到文件里。
当前支持的封装能力请参考AVCodec支持的格式。
如果需要对HDRVivid视频码流进行封装，需要配置MimeType为H265 (OH_AVCODEC_MIMETYPE_VIDEO_HEVC)，本功能从API version 11开始支持。
适用场景
 录像、录音 保存录像、录音文件时，需要先对音视频流进行编码，再封装为文件。 音视频编辑 完成编辑后的音视频，需要封装为文件。 音视频转码 转码后，保存文件时需要封装。 
开发指导
详细的API说明请参考API文档。
如果调用封装模块写本地文件，需要向用户申请授权：ohos.permission.READ_MEDIA, ohos.permission.WRITE_MEDIA。
[h2]在 CMake 脚本中链接动态库
target_link_libraries(sample PUBLIC libnative_media_avmuxer.so)\ntarget_link_libraries(sample PUBLIC libnative_media_core.so)
[h2]开发步骤
参考以下示例代码，完成音视频封装的全流程。以封装mp4格式的音视频文件为例。
不同的封装格式需要配置的key请参考AVCodec支持的格式。
 添加头文件。 #include <multimedia/player_framework/native_avmuxer.h>\n#include <multimedia/player_framework/native_avcodec_base.h>\n#include <multimedia/player_framework/native_avformat.h>\n#include <multimedia/player_framework/native_avbuffer.h>\n#include <fcntl.h> 调用OH_AVMuxer_Create()创建封装器实例对象。 // 设置封装格式为mp4\nOH_AVOutputFormat format = AV_OUTPUT_FORMAT_MPEG_4;\n// 以读写方式创建fd\nint32_t fd = open(\"test.mp4\", O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR);\nOH_AVMuxer *muxer = OH_AVMuxer_Create(fd, format); （可选）调用OH_AVMuxer_SetRotation()设置旋转角度。 // 旋转角度，视频画面需要旋转的时候设置\nOH_AVMuxer_SetRotation(muxer, 0); 添加音频轨。 方法一：用OH_AVFormat_Create创建format int audioTrackId = -1;\nuint8_t *buffer = ...; // 编码config data，如果没有可以不传\nsize_t size = ...;  // 编码config data的长度，根据实际情况配置\nOH_AVFormat *formatAudio = OH_AVFormat_Create(); // 用OH_AVFormat_Create创建format，这里以封装44100Hz采样率、2声道的AAC-LC音频为例。\nOH_AVFormat_SetStringValue(formatAudio, OH_MD_KEY_CODEC_MIME, OH_AVCODEC_MIMETYPE_AUDIO_AAC); // 必填\nOH_AVFormat_SetIntValue(formatAudio, OH_MD_KEY_AUD_SAMPLE_RATE, 44100); // 必填\nOH_AVFormat_SetIntValue(formatAudio, OH_MD_KEY_AUD_CHANNEL_COUNT, 2); // 必填\nOH_AVFormat_SetIntValue(formatAudio, OH_MD_KEY_PROFILE, AAC_PROFILE_LC); // 选填\nOH_AVFormat_SetBuffer(formatAudio, OH_MD_KEY_CODEC_CONFIG, buffer, size); // 选填\n\nint ret = OH_AVMuxer_AddTrack(muxer, &audioTrackId, formatAudio);\nif (ret != AV_ERR_OK || audioTrackId < 0) {\n    // 音频轨添加失败\n}\nOH_AVFormat_Destroy(formatAudio); // 销毁 方法二：用OH_AVFormat_CreateAudioFormat创建format int audioTrackId = -1;\nuint8_t *buffer = ...; // 编码config data，如果没有可以不传\nsize_t size = ...;  // 编码config data的长度，根据实际情况配置\nOH_AVFormat *formatAudio = OH_AVFormat_CreateAudioFormat(OH_AVCODEC_MIMETYPE_AUDIO_AAC, 44100, 2);\nOH_AVFormat_SetIntValue(formatAudio, OH_MD_KEY_PROFILE, AAC_PROFILE_LC); // 选填\nOH_AVFormat_SetBuffer(formatAudio, OH_MD_KEY_CODEC_CONFIG, buffer, size); // 选填\n\nint ret = OH_AVMuxer_AddTrack(muxer, &audioTrackId, formatAudio);\nif (ret != AV_ERR_OK || audioTrackId < 0) {\n    // 音频轨添加失败\n}\nOH_AVFormat_Destroy(formatAudio); // 销毁 添加视频轨。 方法一：用OH_AVFormat_Create创建format int videoTrackId = -1;\nuint8_t *buffer = ...; // 编码config data，如果没有可以不传\nsize_t size = ...;  // 编码config data的长度，根据实际情况配置\nOH_AVFormat *formatVideo = OH_AVFormat_Create();\nOH_AVFormat_SetStringValue(formatVideo, OH_MD_KEY_CODEC_MIME, OH_AVCODEC_MIMETYPE_VIDEO_AVC); // 必填\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_WIDTH, 1280); // 必填\nOH_AVFormat_SetIntValue(formatVideo, OH_MD_KEY_HEIGHT, 720); // 必填\nOH_AVFormat_SetBuffer(formatVideo, OH_MD_KEY_CODEC_CONFIG, buffer, size); // 非必须\n\nint ret = OH_AVMuxer_AddTrack(muxer, &videoTrackId, formatVideo);\nif (ret != AV_ERR_OK || videoTrackId < 0) {\n    // 视频轨添加失败\n}\nOH_AVFormat_Destroy(formatVideo); // 销毁 方法二：用OH_AVFormat_CreateVideoFormat创建format int videoTrackId = -1;\nuint8_t *buffer = ...; // 编码config data，如果没有可以不传\nsize_t size = ...;  // 编码config data的长度，根据实际情况配置\nOH_AVFormat *formatVideo = OH_AVFormat_CreateVideoFormat(OH_AVCODEC_MIMETYPE_VIDEO_AVC, 1280, 720);\nOH_AVFormat_SetBuffer(formatVideo, OH_MD_KEY_CODEC_CONFIG, buffer, size); // 非必须\n\nint ret = OH_AVMuxer_AddTrack(muxer, &videoTrackId, formatVideo);\nif (ret != AV_ERR_OK || videoTrackId < 0) {\n    // 视频轨添加失败\n}\nOH_AVFormat_Destroy(formatVideo); // 销毁 添加封面轨。 方法一：用OH_AVFormat_Create创建format int coverTrackId = -1;\nOH_AVFormat *formatCover = OH_AVFormat_Create();\nOH_AVFormat_SetStringValue(formatCover, OH_MD_KEY_CODEC_MIME, OH_AVCODEC_MIMETYPE_IMAGE_JPG);\nOH_AVFormat_SetIntValue(formatCover, OH_MD_KEY_WIDTH, 1280);\nOH_AVFormat_SetIntValue(formatCover, OH_MD_KEY_HEIGHT, 720);\n\nint ret = OH_AVMuxer_AddTrack(muxer, &coverTrackId, formatCover);\nif (ret != AV_ERR_OK || coverTrackId < 0) {\n    // 添加封面失败\n}\nOH_AVFormat_Destroy(formatCover); // 销毁 方法二：用OH_AVFormat_CreateVideoFormat创建format int coverTrackId = -1;\nOH_AVFormat *formatCover = OH_AVFormat_CreateVideoFormat(OH_AVCODEC_MIMETYPE_IMAGE_JPG, 1280, 720);\n\nint ret = OH_AVMuxer_AddTrack(muxer, &coverTrackId, formatCover);\nif (ret != AV_ERR_OK || coverTrackId < 0) {\n    // 添加封面失败\n}\nOH_AVFormat_Destroy(formatCover); // 销毁 调用OH_AVMuxer_Start()开始封装。 // 调用start，写封装文件头。start后，不能设置媒体参数、不能添加音视频轨\nif (OH_AVMuxer_Start(muxer) != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_AVMuxer_WriteSampleBuffer()，写入封装数据。 封装数据包括视频、音频、封面等数据。 // start后，才能开始写入数据\nint size = ...;\nOH_AVBuffer *sample = OH_AVBuffer_Create(size); // 创建AVBuffer\n// 通过OH_AVBuffer_GetAddr(sample)往sampleBuffer里写入数据参考OH_AVBuffer的使用方法\n// 封装封面，必须一次写完一张图片\n\n// 创建buffer info\nOH_AVCodecBufferAttr info = {0};\ninfo.pts = ...; // 当前数据的开始播放的时间，单位微秒，相对时间\ninfo.size = size; // 当前数据的长度\ninfo.offset = 0; // 偏移，一般为0\ninfo.flags |= AVCODEC_BUFFER_FLAGS_SYNC_FRAME; // 当前数据的标志。具体参考OH_AVCodecBufferFlags\ninfo.flags |= AVCODEC_BUFFER_FLAGS_CODEC_DATA; // 当annex-b格式的avc包含codec config的标志。\nOH_AVBuffer_SetBufferAttr(sample, &info); // 设置buffer的属性。\nint trackId = audioTrackId; // 选择写的音视频轨\n\nint ret = OH_AVMuxer_WriteSampleBuffer(muxer, trackId, sample);\nif (ret != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_AVMuxer_Stop()，停止封装。 // 调用stop，写封装文件尾。stop后不能写入媒体数据\nif (OH_AVMuxer_Stop(muxer) != AV_ERR_OK) {\n    // 异常处理\n} 调用OH_AVMuxer_Destroy()销毁实例，释放资源。 注意不能重复销毁，会导致程序崩溃。 if (OH_AVMuxer_Destroy(muxer) != AV_ERR_OK) {\n    // 异常处理\n}\nmuxer = NULL;\nclose(fd); // 关闭文件描述符 
